<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Timer d'Entraînement Avancé</title>
    <!-- Font Awesome (CDNJS for reliability) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script> <!-- Version Chart.js mise à jour -->
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- Google Identity Services (GIS) - chargé à la fin du body -->
    <style>
        /* --- Variables Globales & Thèmes --- */
        :root {
            /* Thème Sombre (Base) */
            --bg-color-dark: #0D1117; --secondary-bg-color-dark: #161B22; --primary-text-color-dark: #c9d1d9; --secondary-text-color-dark: #8b949e; --border-color-dark: #30363d; --accent-border-color-dark: #58a6ff33; --input-bg-dark: #0d1117;
            /* Couleurs Néon (Thème Sombre) */
            --neon-blue: #58a6ff; --neon-pink: #f778ba; --neon-red: #ff7b72; --neon-yellow: #facc15; --neon-green: #3fb950; --neon-purple: #bc8cff;
            /* Glows (Thème Sombre) */
            --glow-blue: 0 0 12px rgba(88, 166, 255, 0.6); --glow-pink: 0 0 12px rgba(247, 120, 186, 0.6); --glow-red: 0 0 10px rgba(255, 123, 114, 0.6); --glow-yellow: 0 0 10px rgba(250, 204, 21, 0.5); --glow-green: 0 0 10px rgba(63, 185, 80, 0.6); --glow-purple: 0 0 12px rgba(188, 140, 255, 0.6);
            /* Couleurs spécifiques aux états/types */
            --color-exercise: var(--neon-pink); --glow-exercise: var(--glow-pink); --color-exercise-rgb: 247, 120, 186; --icon-exercise: "\f44b"; /* fa-dumbbell */
            --color-break: var(--neon-yellow); --glow-break: var(--glow-yellow); --color-break-rgb: 250, 204, 21; --icon-break: "\f252"; /* fa-hourglass-half */
            --color-prepare: var(--neon-yellow); --glow-prepare: var(--glow-yellow); --color-prepare-rgb: 250, 204, 21; --icon-prepare: "\f110"; /* fa-spinner */
            --color-finished: var(--neon-green); --glow-finished: var(--glow-green); --color-finished-rgb: 63, 185, 80; --icon-finished: "\f058"; /* fa-check-circle */
            --color-paused: var(--neon-purple); --glow-paused: var(--glow-purple); --color-paused-rgb: 188, 140, 255; --icon-paused: "\f28b"; /* fa-pause-circle */
            --color-idle: var(--secondary-text-color-dark); --glow-idle: none; --color-idle-rgb: 139, 148, 158; --icon-idle: "\f144"; /* fa-play-circle */
            /* --- Autres Variables --- */
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --border-radius-lg: 12px; --border-radius-md: 8px; --border-radius-sm: 6px; --transition-speed: 0.25s;
            /* Initialisation Thème Sombre par Défaut */
            --bg-color: var(--bg-color-dark); --secondary-bg-color: var(--secondary-bg-color-dark); --primary-text-color: var(--primary-text-color-dark); --secondary-text-color: var(--secondary-text-color-dark); --border-color: var(--border-color-dark); --accent-border-color: var(--accent-border-color-dark); --input-bg: var(--input-bg-dark);
            /* Variables pour le timer */
            --current-step-color: var(--color-idle); --current-step-glow: var(--glow-idle);
            /* Total progress est une variable pour JS */
            --total-progress-gradient: var(--total-progress-bg, #2a2f36);
            --total-progress-bg: #2a2f36;
            /* Boutons Contrôle Timer */
            --button-reset-color: var(--neon-red); --button-reset-glow: var(--glow-red); --button-next-color: var(--neon-purple); --button-next-glow: var(--glow-purple); --button-end-color: var(--secondary-text-color-dark); --button-end-glow: none; --button-start-color: var(--neon-blue); --button-start-glow: var(--glow-blue); --button-pause-color: var(--color-paused); --button-pause-glow: var(--glow-paused); --button-resume-color: var(--color-paused); --button-resume-glow: var(--glow-paused); --button-done-color: var(--color-exercise); --button-done-glow: var(--glow-exercise);
            /* Boutons Connexion */
            --button-connect-color: var(--neon-green); --button-connect-glow: var(--glow-green); --button-disconnect-color: var(--neon-red); --button-disconnect-glow: var(--glow-red); --link-color: var(--neon-blue);
            /* Variables RGBA */
            --neon-blue-rgb: 88, 166, 255; --neon-pink-rgb: 247, 120, 186; --neon-red-rgb: 255, 123, 114; --neon-yellow-rgb: 250, 204, 21; --neon-green-rgb: 63, 185, 80; --neon-purple-rgb: 188, 140, 255;
            --secondary-text-color-dark-rgb: 139, 148, 158; --bg-color-dark-rgb: 13, 17, 23; --secondary-bg-color-dark-rgb: 22, 27, 34; --primary-text-color-dark-rgb: 201, 209, 217;
            --color-exercise-rgb: 247, 120, 186; --color-break-rgb: 250, 204, 21; --color-prepare-rgb: 250, 204, 21; --color-finished-rgb: 63, 185, 80; --color-paused-rgb: 188, 140, 255; --color-idle-rgb: 139, 148, 158;
        }

        body.light-theme {
            /* Thème Clair */
            --bg-color: #ffffff; --secondary-bg-color: #f6f8fa; --primary-text-color: #24292f; --secondary-text-color: #57606a; --border-color: #d0d7de; --accent-border-color: #0969da33; --input-bg: #f6f8fa;
            /* Couleurs Néon adaptées */
            --neon-blue: #0969da; --neon-pink: #bf3989; --neon-red: #d73a49; --neon-yellow: #dbab09; --neon-green: #2da44e; --neon-purple: #8250df;
            /* Glows (Subtils ou désactivés en clair) */
            --glow-blue: 0 0 8px rgba(9, 105, 218, 0.3); --glow-pink: 0 0 8px rgba(191, 57, 137, 0.3); --glow-red: 0 0 8px rgba(215, 58, 73, 0.3); --glow-yellow: 0 0 8px rgba(219, 171, 9, 0.3); --glow-green: 0 0 8px rgba(45, 164, 78, 0.3); --glow-purple: 0 0 8px rgba(130, 80, 223, 0.3);
            --total-progress-bg: #e1e4e8; --button-end-color: #57606a; --link-color: #0969da;
            /* Adapter les variables RGBA */
            --bg-color-dark-rgb: 255, 255, 255; --secondary-bg-color-dark-rgb: 246, 248, 250; --primary-text-color-dark-rgb: 36, 41, 47; --secondary-text-color-dark-rgb: 87, 96, 106;
            --color-exercise-rgb: 191, 57, 137; --color-break-rgb: 219, 171, 9; --color-prepare-rgb: 219, 171, 9; --color-finished-rgb: 45, 164, 78; --color-paused-rgb: 130, 80, 223; --color-idle-rgb: 87, 96, 106;
        }

        /* --- Styles de Base & Réinitialisation --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family); background-color: var(--bg-color); color: var(--primary-text-color);
            line-height: 1.6; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            display: flex; flex-direction: column; min-height: 100vh;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden; /* Empêche le débordement horizontal */
        }
        .container { max-width: 1100px; margin: 0 auto; padding: 30px 25px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }

        /* --- En-tête --- */
        header {
            padding: 15px 0; border-bottom: 1px solid var(--border-color);
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
            position: sticky; top: 0; z-index: 1000;
            background-color: rgba(var(--bg-color-dark-rgb), 0.8); /* Effet verre dépoli */
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        }
        .header-content { display: flex; justify-content: space-between; align-items: center; max-width: 1100px; margin: 0 auto; padding: 0 25px; flex-wrap: wrap; gap: 15px 20px; }
        header h1 { font-size: 1.5em; color: var(--primary-text-color); margin: 0; font-weight: 700; display: flex; align-items: center; gap: 10px; }
        header h1 i { color: var(--neon-blue); animation: pulse 2s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.1); opacity: 1; } }

        /* --- Navigation Header --- */
        nav ul { list-style: none; display: flex; gap: 25px; flex-wrap: wrap; justify-content: center; align-items: center; }
        nav button {
            background: none; border: none; color: var(--secondary-text-color); font-size: 1em; font-weight: 500; padding: 5px 0;
            cursor: pointer; transition: color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            position: relative; border-bottom: 2px solid transparent;
        }
        nav button:disabled {
             color: rgba(var(--secondary-text-color-dark-rgb), 0.5); cursor: not-allowed; border-bottom-color: transparent !important; box-shadow: none !important; opacity: 0.6; pointer-events: none; /* Ajouté */
        }
        nav button:not(:disabled):hover { color: var(--primary-text-color); }
        nav button.active { color: var(--neon-blue); font-weight: 700; border-bottom-color: var(--neon-blue); box-shadow: 0 5px 15px -5px rgba(var(--neon-blue-rgb), 0.4); }

        /* Styles spécifiques pour boutons Historique et Progression */
        #nav-history { color: var(--secondary-text-color); border-bottom-color: transparent; }
        #nav-history:hover:not(:disabled) { color: var(--neon-pink); }
        #nav-history.active { color: var(--neon-pink); border-bottom-color: var(--neon-pink); box-shadow: 0 5px 15px -5px rgba(var(--neon-pink-rgb), 0.4); }
        #nav-history i { margin-right: 5px; }

        #nav-progress { color: var(--secondary-text-color); border-bottom-color: transparent; }
        #nav-progress:hover:not(:disabled) { color: var(--neon-green); }
        #nav-progress.active { color: var(--neon-green); border-bottom-color: var(--neon-green); box-shadow: 0 5px 15px -5px rgba(var(--neon-green-rgb), 0.4); }
        #nav-progress i { margin-right: 5px; }

        /* --- Actions Header --- */
        .header-actions { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button {
            background: none; border: 1px solid var(--accent-border-color); color: var(--secondary-text-color); padding: 6px 14px;
            border-radius: var(--border-radius-md); font-size: 0.85em; font-weight: 500; cursor: pointer;
            transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 6px;
        }
        .auth-controls button:disabled {
            opacity: 0.5; cursor: not-allowed; pointer-events: none; /* Crucial pour le bouton Drive */ border-color: var(--border-color) !important; color: var(--secondary-text-color) !important; box-shadow: none !important; background-color: transparent !important;
        }
        .auth-controls button:not(:disabled):hover { border-color: var(--primary-text-color); color: var(--primary-text-color); }
        #signin-button { border-color: var(--button-connect-color); color: var(--button-connect-color); }
        #signin-button:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--glow-green); border-color: var(--neon-green); }
        #signout-button { border-color: var(--button-disconnect-color); color: var(--button-disconnect-color); }
        #signout-button:not(:disabled):hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--glow-red); border-color: var(--neon-red); }
        #export-button { border-color: var(--neon-blue); color: var(--neon-blue); }
        #export-button:not(:disabled):hover { background-color: rgba(var(--neon-blue-rgb), 0.1); box-shadow: var(--glow-blue); border-color: var(--neon-blue); }

        #drive-status {
            font-size: 0.8em; color: var(--secondary-text-color); margin-left: 5px; transition: opacity 0.3s, color 0.3s, border-color 0.3s;
            min-width: fit-content; text-align: right; font-style: normal; padding: 4px 8px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5);
            border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); display: none; /* Initialement caché */
        }
        #drive-status.loading { color: var(--neon-yellow); border-color: var(--neon-yellow); animation: blink-border 1.5s infinite ease-in-out; }
        #drive-status.error { color: var(--neon-red); border-color: var(--neon-red); }
        #drive-status.success { color: var(--neon-green); border-color: var(--neon-green); }
        @keyframes blink-border { 50% { border-color: rgba(var(--neon-yellow-rgb), 0.4); } }

        .theme-toggle button { background: none; border: none; color: var(--secondary-text-color); font-size: 1.2em; padding: 5px; cursor: pointer; transition: color var(--transition-speed) ease; }
        .theme-toggle button:hover { color: var(--neon-yellow); }

        /* Logique affichage connexion/déconnexion */
        body.logged-out #signin-button { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-out #drive-status { display: none; }
        body.logged-out .history-actions { display: none !important; } /* Forcé car contrôlé par JS */
        body.logged-out #drive-connection-status-main { display: none; }
        body.logged-out #export-button { display: none; }
        body.logged-out #nav-progress { display: none; } /* Cacher progression si pas loggué */

        body.logged-in #signin-button { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-in #drive-status { display: inline-block; }
        body.logged-in .history-actions { display: flex !important; } /* Forcé car contrôlé par JS */
        body.logged-in #drive-connection-status-main { display: inline-flex; }
        body.logged-in #export-button { display: inline-flex; }
        body.logged-in #nav-progress { display: inline-block; }

        /* --- Contenu Principal --- */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 50px; position: relative; }
        .workout-section { background-color: transparent; padding: 0; border: none; box-shadow: none; width: 100%; max-width: 600px; text-align: center; transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease; margin-bottom: 40px; }
        .history-section { background-color: var(--secondary-bg-color); padding: 35px; border-radius: var(--border-radius-lg); box-shadow: none; border: 1px solid var(--border-color); width: 100%; max-width: 850px; text-align: left; margin-bottom: 40px; transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease, border-color var(--transition-speed) ease, background-color var(--transition-speed) ease; }
        .progress-section { background-color: var(--secondary-bg-color); padding: 35px; border-radius: var(--border-radius-lg); box-shadow: none; border: 1px solid var(--border-color); width: 100%; max-width: 850px; text-align: left; margin-bottom: 40px; transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease, border-color var(--transition-speed) ease, background-color var(--transition-speed) ease; }
        .section-hidden { transform: scale(0.9) translateY(30px); opacity: 0; pointer-events: none; max-height: 0; padding-top: 0 !important; padding-bottom: 0 !important; margin-bottom: 0 !important; border: none !important; overflow: hidden; }

        /* --- Affichage Timer --- */
        .timer-display { margin-bottom: 50px; position: relative; display: flex; justify-content: center; align-items: center; width: 320px; height: 320px; margin-left: auto; margin-right: auto; cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent; }
        .timer-circle-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none; }
        #total-progress-circle, .timer-circle { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 12px solid transparent; background-clip: padding-box; background-origin: border-box; box-sizing: border-box; }
        #total-progress-circle {
            border-color: var(--total-progress-bg);
            background: var(--total-progress-gradient, var(--total-progress-bg)); /* Utilise la variable JS */
            box-shadow: 0 0 25px rgba(var(--neon-blue-rgb), 0.3), 0 0 35px rgba(var(--neon-pink-rgb), 0.2), inset 0 0 20px rgba(var(--bg-color-dark-rgb), 0.5);
            z-index: 1; transition: background 0.3s linear;
        }
        .timer-circle {
            width: calc(100% - 48px); height: calc(100% - 48px); top: 24px; left: 24px;
            border-color: var(--border-color);
            background-image: conic-gradient(var(--current-step-color, var(--color-idle)) 0%, transparent 0%); /* Progression étape actuelle */
            box-shadow: var(--current-step-glow, var(--glow-idle)), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6);
            z-index: 3; transition: background-image 0.15s linear, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            background-size: 100% 100%; background-repeat: no-repeat; background-position: center center;
        }
        .timer-circle::before { /* Cache interne pour masquer la progression */
             content: ''; position: absolute; width: calc(100% - 24px); height: calc(100% - 24px); background-color: var(--bg-color); border-radius: 50%; z-index: 4; transition: background-color var(--transition-speed) ease;
        }
        .time-left { font-size: 5.5em; font-weight: 900; color: var(--primary-text-color); z-index: 5; transition: color var(--transition-speed) ease; font-variant-numeric: tabular-nums; position: relative; text-shadow: 0 0 10px rgba(var(--primary-text-color-dark-rgb), 0.3); }

        .timer-state {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); font-size: 0.9em; letter-spacing: 0.08em;
            color: var(--current-step-color, var(--color-idle));
            font-weight: 500; text-transform: uppercase; opacity: 0; transition: opacity 0.3s ease, color var(--transition-speed) ease;
            background-color: transparent; padding: 0; box-shadow: none; z-index: 6;
            text-shadow: 0 0 8px rgba(var(--bg-color-dark-rgb), 0.7);
        }
        .timer-state.visible { opacity: 0.9; }
        .timer-state.preparing { animation: countdown-pulse 1s infinite; font-size: 1.1em; }
        @keyframes countdown-pulse { 0%, 100% { transform: translateX(-50%) scale(1); opacity: 1; } 50% { transform: translateX(-50%) scale(1.05); opacity: 0.85; } }

        /* --- Rep Adjustment Overlay --- */
        .rep-adjustment-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 10; background-color: rgba(var(--bg-color-dark-rgb), 0.85);
            padding: 20px; border-radius: var(--border-radius-md); border: 1px solid var(--border-color);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3); display: none; flex-direction: column;
            align-items: center; gap: 15px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            width: 280px; /* Fix width */
        }
        .rep-adjustment-overlay.visible { display: flex; animation: fadeInScale 0.3s ease-out forwards; }
        @keyframes fadeInScale { from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        .rep-adjustment-overlay .title { font-size: 1.1em; font-weight: 700; color: var(--primary-text-color); text-align: center; margin-bottom: 5px;}
        .rep-adjustment-controls { display: flex; align-items: center; gap: 15px; }
        .rep-adjustment-btn {
            width: 45px; height: 45px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 1.4em; font-weight: 700; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.9);
            border: 1px solid var(--border-color); color: var(--primary-text-color); cursor: pointer;
            transition: all var(--transition-speed) ease;
        }
        .rep-adjustment-btn.minus { border-color: var(--neon-red); color: var(--neon-red); }
        .rep-adjustment-btn.minus:hover { background-color: rgba(var(--neon-red-rgb), 0.15); box-shadow: var(--glow-red); }
        .rep-adjustment-btn.plus { border-color: var(--neon-green); color: var(--neon-green); }
        .rep-adjustment-btn.plus:hover { background-color: rgba(var(--neon-green-rgb), 0.15); box-shadow: var(--glow-green); }
        .rep-adjustment-btn:active { transform: scale(0.95); }
        .current-reps {
            font-size: 2.2em; font-weight: 900; color: var(--primary-text-color); font-variant-numeric: tabular-nums;
            min-width: 60px; text-align: center;
        }
        .rep-adjustment-next-exercise { font-size: 0.95em; color: var(--color-exercise); font-weight: 500; text-align: center; margin-top: 5px; }

        /* --- Infos Exercice --- */
        .workout-info { margin-bottom: 40px; min-height: 100px; position: relative; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #current-exercise-name-display { display: block; font-size: 1.4em; font-weight: 700; color: var(--primary-text-color); margin-bottom: 8px; padding: 0 10px; min-height: 1.5em; transition: color 0.3s ease; }
        /* Coloration du titre selon l'état via classe body */
        body.state-exercise #current-exercise-name-display { color: var(--color-exercise); }
        body.state-break #current-exercise-name-display { color: var(--color-break); }
        body.state-paused #current-exercise-name-display { color: var(--color-paused); }
        body.state-preparing #current-exercise-name-display { color: var(--color-prepare); }
        body.state-finished #current-exercise-name-display { color: var(--color-finished); }

        #current-exercise-container { display: flex; flex-direction: column; align-items: center; gap: 8px; font-size: 1.1em; color: var(--secondary-text-color); min-height: 3em; width: 100%; }
        #current-exercise-container .exercise-details,
        #current-exercise-container .break-info,
        #current-exercise-container .idle-message {
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px 20px;
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3); padding: 10px 18px; border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color); width: fit-content; max-width: 90%;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        #current-exercise-container .exercise-details span,
        #current-exercise-container .break-info span { display: flex; align-items: center; gap: 6px; font-weight: 500; }
        #current-exercise-container .exercise-details span i { color: var(--color-exercise); width: 16px; text-align: center; } /* Icônes alignées */
        #current-exercise-container .break-info i { color: var(--color-break); width: 16px; text-align: center; }
        #current-exercise-container .exercise-details .details-text { font-size: 0.9em; opacity: 0.8; }
        #current-exercise-container .idle-message { border-style: dashed; opacity: 0.7; }
        #current-exercise-container .idle-message i { color: var(--neon-blue); }

        /* Performances Précédentes */
        .previous-performance {
            margin-top: 10px; padding: 8px 15px; background-color: rgba(var(--neon-blue-rgb), 0.1);
            border: 1px dashed var(--neon-blue); border-radius: var(--border-radius-md); font-size: 0.9em;
            color: var(--neon-blue); display: flex; align-items: center; gap: 10px; max-width: 90%;
            opacity: 0; animation: fadeIn 0.5s 0.2s ease-out forwards; /* Animation d'apparition */
        }
        @keyframes fadeIn { to { opacity: 1; } }
        .previous-performance i { font-size: 1.1em; }
        .previous-performance strong { font-weight: 700; }

        /* --- Progress Tracker --- */
        .progress-tracker { font-size: 0.9em; color: var(--secondary-text-color); margin-top: 30px; opacity: 0.8; font-weight: 500; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 5px 15px; min-height: 1.2em; }
        #drive-connection-status-main { align-items: center; gap: 6px; }
        #drive-connection-status-main i.fa-google-drive { color: var(--neon-green); font-size: 1.1em; transition: color 0.3s ease; }
        #drive-connection-status-main i.fa-google-drive.fa-spin { animation: fa-spin 2s linear infinite; }
        #drive-connection-status-main i.fa-google-drive.error { color: var(--neon-red); animation: none; }
        @keyframes fa-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #progress-text-area { font-weight: 500; }

        /* --- Contrôles Timer --- */
        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 40px; flex-wrap: wrap; }
        .controls button {
            background: transparent; border: 2px solid var(--accent-border-color); color: var(--primary-text-color); min-width: 110px; padding: 10px 20px;
            border-radius: var(--border-radius-lg); font-size: 1.05em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        }
        .controls button i { font-size: 0.9em; transition: transform 0.2s ease; }
        .controls button:disabled {
             border-color: var(--border-color) !important; color: var(--secondary-text-color) !important; opacity: 0.5; cursor: not-allowed; box-shadow: none !important; transform: none !important; background-color: transparent !important; pointer-events: none;
        }
        .controls button:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .controls button:not(:disabled):hover i { transform: scale(1.1); }
        .controls button:not(:disabled):active { transform: scale(0.97); }

        /* Styles spécifiques aux boutons basés sur la classe JS */
        #start-pause-btn.start-btn { border-color: var(--button-start-color); color: var(--button-start-color); }
        #start-pause-btn.start-btn:not(:disabled):hover { box-shadow: var(--glow-blue), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--neon-blue-rgb), 0.08); }
        #start-pause-btn.pause-btn { border-color: var(--button-pause-color); color: var(--button-pause-color); }
        #start-pause-btn.pause-btn:not(:disabled):hover { box-shadow: var(--glow-paused), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--color-paused-rgb), 0.08); }
        #start-pause-btn.resume-btn { border-color: var(--button-resume-color); color: var(--button-resume-color); }
        #start-pause-btn.resume-btn:not(:disabled):hover { box-shadow: var(--glow-paused), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--color-paused-rgb), 0.08); }
        #start-pause-btn.done-btn { border-color: var(--button-done-color); color: var(--button-done-color); }
        #start-pause-btn.done-btn:not(:disabled):hover { box-shadow: var(--glow-exercise), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--color-exercise-rgb), 0.08); }
        #start-pause-btn.finished-btn { border-color: var(--color-finished); color: var(--color-finished); }
        #start-pause-btn.finished-btn:not(:disabled):hover { box-shadow: var(--glow-finished), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--color-finished-rgb), 0.08); }
        #start-pause-btn.preparing-btn { border-color: var(--color-prepare); color: var(--color-prepare); opacity: 0.7; cursor: default; pointer-events: none; } /* Style pour bouton pendant prépa */

        #skip-btn { border-color: var(--button-next-color); color: var(--button-next-color); }
        #skip-btn:not(:disabled):hover { box-shadow: var(--glow-purple), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--neon-purple-rgb), 0.08); }
        #finish-btn { border-color: var(--button-end-color); color: var(--button-end-color); }
        #finish-btn:not(:disabled):hover { background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1); border-color: var(--primary-text-color); color: var(--primary-text-color); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        #reset-btn { border-color: var(--button-reset-color); color: var(--button-reset-color); }
        #reset-btn:not(:disabled):hover { box-shadow: var(--glow-red), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--neon-red-rgb), 0.08); }

        /* --- Section Historique --- */
        .history-section h2 { color: var(--primary-text-color); margin-bottom: 25px; text-align: center; }
        .history-controls { padding-bottom: 20px; margin-bottom: 25px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
        .history-filters { display: flex; gap: 10px; flex-wrap: wrap; }
        .history-filters button { background-color: transparent; border: 1px solid var(--accent-border-color); color: var(--secondary-text-color); opacity: 1; font-size: 0.85em; padding: 6px 12px; border-radius: var(--border-radius-md); cursor: pointer; transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 5px; }
        .history-filters button:not(:disabled):hover { border-color: var(--primary-text-color); color: var(--primary-text-color); background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1); }
        .history-filters button.active { border-color: var(--neon-blue); color: var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); font-weight: 500; box-shadow: var(--glow-blue); }
        .history-actions { display: flex; gap: 15px; align-items: center; color: var(--secondary-text-color); }
        .history-actions i.fab.fa-google-drive { color: var(--neon-green); font-size: 1.1em; }
        #history-drive-status { font-size: 0.8em; padding: 3px 6px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5); border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); transition: color 0.3s ease, border-color 0.3s ease; }
        #history-drive-status.syncing { color: var(--neon-yellow); border-color: var(--neon-yellow); animation: blink-border 1.5s infinite ease-in-out; }
        #history-drive-status.error { color: var(--neon-red); border-color: var(--neon-red); }
        #history-drive-status.success { color: var(--neon-green); border-color: var(--neon-green); }

        .chart-container { height: 350px; margin-bottom: 30px; background-color: transparent; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 15px; box-shadow: none; position: relative; transition: border-color var(--transition-speed) ease; }
        .chart-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-text-color); font-style: italic; text-align: center; padding: 0 10px;}
        #history-chart-canvas { display: block; width: 100% !important; height: 100% !important; }

        .stats-display { margin-bottom: 30px; padding: 20px; background-color: transparent; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); box-shadow: none; transition: border-color var(--transition-speed) ease; }
        .stats-display h3 { color: var(--primary-text-color); margin-bottom: 15px; font-size: 1.15em;}
        .stats-display .content-wrapper p { margin-bottom: 8px; display: flex; align-items: center; gap: 8px;} /* Cibler le contenu généré */
        .stats-display .content-wrapper p i { width: 16px; text-align: center; color: var(--neon-blue); opacity: 0.8;}
        .stats-display .content-wrapper p strong { color: var(--primary-text-color); font-weight: 500; }
        .stats-display .content-wrapper p:last-child { margin-bottom: 0; }
        .stats-display .motivational-message {
            font-style: italic; font-weight: 500; margin-top: 15px !important;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-blue));
            -webkit-background-clip: text; background-clip: text;
            /* Correction: text-fill-color n'est pas standard, utiliser -webkit- prefixe */
            -webkit-text-fill-color: transparent;
            color: transparent; /* Fallback pour navigateurs non-webkit */
        }

        .history-list { list-style: none; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); background-color: transparent; box-shadow: none; max-height: 400px; overflow-y: auto; transition: border-color var(--transition-speed) ease; }
        .history-list li { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s ease, border-color var(--transition-speed) ease; gap: 15px; flex-wrap: wrap; }
        .history-list li:last-child { border-bottom: none; }
        .history-list li:nth-child(even) { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3); }
        .history-list li:hover { background-color: rgba(var(--neon-blue-rgb), 0.08); }
        .history-item-date { color: var(--primary-text-color); font-size: 0.9em; flex-shrink: 0; }
        .history-item-date small { color: var(--secondary-text-color); font-size: 0.9em;}
        .history-item-type { color: var(--neon-pink); background-color: rgba(var(--neon-pink-rgb), 0.1); border-radius: var(--border-radius-sm); padding: 3px 8px; font-size: 0.85em; font-weight: 500; text-align: center; min-width: 50px; flex-shrink: 0; margin: 5px 0; }
        .history-item-duration { color: var(--neon-blue); font-weight: 500; font-variant-numeric: tabular-nums; flex-shrink: 0; margin-left: auto; margin: 5px 0; }
        .history-list .no-history { color: var(--secondary-text-color); text-align: center; padding: 30px 15px; font-style: italic; border: none; background: none !important; }

        /* --- Section Progression --- */
        .progress-section h2 { color: var(--primary-text-color); margin-bottom: 25px; text-align: center; }
        .progress-controls { padding-bottom: 20px; margin-bottom: 25px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }

        .progress-filters { display: flex; gap: 10px; flex-wrap: wrap; }
        .progress-filters .filter-group { display: flex; flex-direction: column; gap: 8px; min-width: 180px; }
        .progress-filters .filter-group label { font-size: 0.85em; color: var(--secondary-text-color); margin-bottom: -2px; }
        .progress-filters select {
            background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); color: var(--primary-text-color);
            border-radius: var(--border-radius-sm); padding: 6px 10px; font-size: 0.9em; cursor: pointer;
            transition: all var(--transition-speed) ease; max-width: 100%; appearance: none; -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23${getComputedStyle(document.documentElement).getPropertyValue('--secondary-text-color').substring(1)}'%3E%3Cpath fill-rule='evenodd' d='M4.22 6.22a.75.75 0 011.06 0L8 8.94l2.72-2.72a.75.75 0 111.06 1.06l-3.25 3.25a.75.75 0 01-1.06 0L4.22 7.28a.75.75 0 010-1.06z' clip-rule='evenodd'/%3E%3C/svg%3E"); /* Chevron */
            background-repeat: no-repeat; background-position: right 8px center; background-size: 16px 16px; padding-right: 30px;
        }
        .progress-filters select:hover { border-color: var(--neon-blue); }
        .progress-filters select:focus { outline: none; border-color: var(--neon-blue); box-shadow: var(--glow-blue); }
        .progress-filters option { background-color: var(--bg-color); color: var(--primary-text-color); }

        .muscle-map-container {
            margin-bottom: 30px; padding: 20px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3);
            border: 1px solid var(--border-color); border-radius: var(--border-radius-md);
            display: flex; flex-direction: column; align-items: center; gap: 15px; transition: border-color var(--transition-speed) ease;
        }
        .muscle-map-container h3 { color: var(--primary-text-color); font-size: 1.15em; margin-bottom: 5px; }
        .muscle-map {
            position: relative; width: 100%; max-width: 600px; height: 400px;
            background-color: rgba(var(--bg-color-dark-rgb), 0.2); border-radius: var(--border-radius-sm);
            display: flex; justify-content: center; align-items: center;
        }
        .muscle-map-placeholder { color: var(--secondary-text-color); font-style: italic; text-align: center; font-size: 0.9em; }

        .exercise-progress-container, .volume-load-container { margin-bottom: 30px; }
        .exercise-progress-container h3, .volume-load-container h3 { color: var(--primary-text-color); font-size: 1.15em; margin-bottom: 15px; }
        .exercise-chart-container, .volume-chart-container {
            height: 350px; background-color: transparent; border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md); padding: 15px; position: relative; transition: border-color var(--transition-speed) ease;
        }
        .exercise-progress-chart, .volume-chart { display: block; width: 100% !important; height: 100% !important; }

        /* --- Résumé Post-Workout (MODAL) --- */
        .post-workout-summary {
            position: fixed; inset: 0; background-color: rgba(var(--bg-color-dark-rgb), 0.85); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            z-index: 2000; display: flex; align-items: center; justify-content: center; padding: 20px; opacity: 0; visibility: hidden; pointer-events: none;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s; /* Transition visibilité après opacité */
        }
        .post-workout-summary.visible { opacity: 1; visibility: visible; pointer-events: auto; transition: opacity 0.3s ease, visibility 0s linear 0s; }
        .post-workout-summary-content {
            background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-lg); box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 100%; max-width: 680px; max-height: 90vh; display: flex; flex-direction: column; overflow: hidden;
            transform: scale(0.95); transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; /* Ajout transition couleur */
        }
        .post-workout-summary.visible .post-workout-summary-content { transform: scale(1); }
        .post-workout-summary h2 { color: var(--primary-text-color); font-size: 1.5em; font-weight: 700; padding: 20px 25px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; text-align: center; background-color: rgba(var(--bg-color-dark-rgb), 0.2); transition: color var(--transition-speed) ease, border-color var(--transition-speed) ease, background-color var(--transition-speed) ease; }
        .summary-items-list { list-style: none; padding: 10px 25px; overflow-y: auto; flex-grow: 1; background: var(--bg-color); border-bottom: 1px solid var(--border-color); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        .summary-item {
            border-bottom: 1px solid var(--border-color); padding: 18px 0; display: grid;
            grid-template-columns: auto 1fr auto; gap: 10px 15px; align-items: center; transition: border-color var(--transition-speed) ease;
        }
        .summary-item:last-child { border-bottom: none; }
        .summary-item h4 { grid-column: 1 / -1; color: var(--primary-text-color); font-size: 1.15em; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; }
        .summary-item h4 i { width: 20px; text-align: center; font-size: 1.1em; transition: color 0.3s ease;}
        .summary-item.item-type-exercise h4 i { color: var(--color-exercise); }
        .summary-item.item-type-break h4 i { color: var(--color-break); }
        .summary-item label {
            grid-column: 2 / 3; color: var(--secondary-text-color); font-size: 0.9em; font-weight: 500; white-space: nowrap; text-align: left; padding-left: 5px;
        }
        .summary-item .input-container { grid-column: 3 / 4; display: flex; align-items: center; gap: 8px; }
        .summary-item input[type="number"], .summary-item input[type="text"], .summary-item textarea {
            background-color: var(--input-bg); border: 1px solid var(--border-color); color: var(--primary-text-color);
            border-radius: var(--border-radius-sm); padding: 8px 12px; font-size: 1em; width: 100%;
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        .summary-item input[type="number"] { width: 70px; text-align: center; flex-shrink: 0; -moz-appearance: textfield; }
        .summary-item input[type="number"]::-webkit-outer-spin-button,
        .summary-item input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .summary-item input:focus, .summary-item textarea:focus { border-color: var(--neon-blue); background-color: var(--bg-color); outline: none; box-shadow: 0 0 0 3px rgba(var(--neon-blue-rgb), 0.3); }
        .summary-item textarea { min-height: 45px; resize: vertical; width: 100%; }
        .summary-item .details-container { grid-column: 1 / -1; margin-top: 5px; }
        .summary-item .details-container label { display: block; text-align: left; margin-bottom: 4px; font-size: 0.9em; color: var(--secondary-text-color); padding-left: 0; }
        .summary-item p { grid-column: 2 / -1; color: var(--primary-text-color); font-weight: 500; padding-left: 5px; }

        /* Boutons +/- dans le résumé */
        .rep-adjust-btn {
            background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); color: var(--primary-text-color);
            border-radius: 50%; width: 28px; height: 28px; font-size: 1em; line-height: 26px; text-align: center;
            cursor: pointer; transition: all var(--transition-speed) ease; flex-shrink: 0;
        }
        .rep-adjust-btn:hover { background-color: var(--accent-border-color); border-color: var(--neon-blue); color: var(--neon-blue); }
        .rep-adjust-btn:active { transform: scale(0.95); }

        .summary-controls {
            padding: 20px 25px; display: flex; justify-content: flex-end; gap: 15px;
            flex-shrink: 0; flex-wrap: wrap; border-top: 1px solid var(--border-color); background-color: rgba(var(--bg-color-dark-rgb), 0.2); transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
        }
        .summary-controls button {
            border: none; color: white; min-width: 160px; padding: 10px 22px; border-radius: var(--border-radius-md);
            font-size: 1em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .summary-controls button:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none; background-color: var(--secondary-text-color) !important; }
        .summary-controls button:not(:disabled):hover { filter: brightness(1.1); box-shadow: 0 4px 10px rgba(0,0,0,0.25); transform: translateY(-1px); }
        .summary-controls button:not(:disabled):active { filter: brightness(0.95); transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }

        #confirm-summary-btn { background-color: var(--neon-green); }
        #discard-summary-btn { background-color: var(--neon-red); }
        #close-summary-btn { background-color: var(--secondary-text-color); display: none; /* Affiché par JS si pas de modifs */ }

        /* --- Animation Fin Workout --- */
        .timer-display.finished-animation .timer-circle { animation: finish-circle-glow 1.5s ease-out forwards; }
        @keyframes finish-circle-glow {
            0% { box-shadow: var(--current-step-glow), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6); border-color: var(--border-color); }
            50% { box-shadow: 0 0 35px 15px rgba(var(--color-finished-rgb), 0.7), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.4); border-color: var(--color-finished); }
            100% { box-shadow: var(--glow-finished), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6); border-color: var(--color-finished); }
        }

        /* --- Zone de Messages Flottante --- */
        .message-area {
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%);
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.9); color: var(--primary-text-color);
            border: 1px solid var(--border-color); padding: 12px 25px; border-radius: var(--border-radius-md);
            z-index: 3000; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease;
            pointer-events: none; font-size: 0.95em; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); max-width: 90%; text-align: center;
        }
        .message-area.visible { opacity: 1; transform: translate(-50%, 0); bottom: 40px; pointer-events: auto; }

        /* --- Pied de Page --- */
        footer {
            color: var(--secondary-text-color); opacity: 0.7; border-top: 1px solid var(--border-color);
            margin-top: 60px; padding: 25px; text-align: center; transition: border-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        footer a { color: var(--link-color); text-decoration: none; transition: color var(--transition-speed) ease; }
        footer a:hover { color: var(--primary-text-color); text-decoration: underline; }
        footer .fab.fa-google-drive { color: #4CAF50; }

        /* --- Styles Responsives --- */
        @media (max-width: 768px) {
            header h1 { font-size: 1.3em; }
            nav ul { gap: 15px; }
            .header-actions { gap: 15px; }
            .timer-display { width: 280px; height: 280px; }
            .timer-circle { width: calc(100% - 40px); height: calc(100% - 40px); top: 20px; left: 20px; border-width: 10px; }
            .timer-circle::before { width: calc(100% - 20px); height: calc(100% - 20px); }
            .time-left { font-size: 4.5em; }
            #total-progress-circle { border-width: 10px; }
            .controls { gap: 15px; }
            .controls button { min-width: 100px; padding: 10px 18px; font-size: 1em; }
            .history-controls { flex-direction: column; align-items: stretch; gap: 15px; }
            .history-actions { justify-content: center; }
            .chart-container { height: 320px; padding: 10px; }
            .stats-display { padding: 15px; }
            .history-list li { padding: 10px; gap: 10px; font-size: 0.95em;}
            .post-workout-summary-content { padding: 0; max-width: 95%; max-height: 85vh; }
            .post-workout-summary h2 { padding: 15px 20px; font-size: 1.3em; }
            .summary-items-list { padding: 10px 20px; }
            .summary-item { grid-template-columns: auto 1fr auto; gap: 8px 10px;}
            .summary-item label { font-size: 0.85em; }
            .summary-item input[type="number"] { width: 60px; padding: 6px 8px; }
            .rep-adjust-btn { width: 24px; height: 24px; font-size: 0.9em; line-height: 22px; }
            .summary-controls { padding: 15px 20px; justify-content: space-around; }
            .summary-controls button { min-width: 130px; padding: 10px 18px; }

            .exercise-chart-container,
            .volume-chart-container,
            .muscle-map { height: 300px; }

            .progress-filters .filter-group { min-width: 160px; }
        }
        @media (max-width: 480px) {
            header { padding: 15px 0;}
            header h1 { font-size: 1.2em; }
            nav ul { gap: 10px; justify-content: center;}
            .header-content { justify-content: center; }
            .header-actions { justify-content: center; }
            .auth-controls { flex-wrap: wrap; justify-content: center; gap: 8px;}
            .timer-display { width: 240px; height: 240px; margin-bottom: 40px; }
            .timer-circle { width: calc(100% - 32px); height: calc(100% - 32px); top: 16px; left: 16px; border-width: 8px; }
            .timer-circle::before { width: calc(100% - 16px); height: calc(100% - 16px); }
            .time-left { font-size: 3.8em; }
            #total-progress-circle { border-width: 8px; }
            .workout-info { min-height: 80px; margin-bottom: 30px; }
            #current-exercise-name-display { font-size: 1.2em; }
            #current-exercise-container { font-size: 1em; }
            #current-exercise-container .exercise-details,
            #current-exercise-container .break-info,
            #current-exercise-container .idle-message { padding: 8px 12px; gap: 8px 15px; max-width: 95%;}
            #current-exercise-container .exercise-details span { flex-basis: 100%; justify-content: center;} /* Détails exo sur lignes séparées */
            #current-exercise-container .exercise-details .details-text { text-align: center; }
            .controls { gap: 10px; margin-top: 30px; flex-direction: column; align-items: stretch; }
            .controls button { width: 100%; min-width: 0; padding: 12px; font-size: 1em; }
            .progress-tracker { margin-top: 25px; font-size: 0.85em;}
            .history-section { padding: 20px; }
            .history-controls { padding-bottom: 15px; margin-bottom: 20px;}
            .history-filters button { font-size: 0.8em; padding: 5px 10px; }
            .chart-container { height: 280px; }
            .stats-display { padding: 12px; font-size: 0.9em;}
            .stats-display .content-wrapper p { gap: 6px;}
            .history-list li { font-size: 0.9em; flex-direction: column; align-items: flex-start; gap: 5px; }
             .history-item-duration { margin-left: 0; }
            .history-item-type { align-self: flex-start; }
            .post-workout-summary-content { max-width: 100%; max-height: 90vh; border-radius: var(--border-radius-md); }
            .post-workout-summary h2 { font-size: 1.2em; padding: 12px 15px;}
            .summary-items-list { padding: 8px 15px; }
            .summary-item { grid-template-columns: auto 1fr; gap: 5px 10px; padding: 12px 0; }
            .summary-item label { grid-column: 1 / 2; text-align: left; }
            .summary-item .input-container { grid-column: 2 / 3; justify-content: flex-start;}
             .summary-item .details-container { grid-column: 1 / -1; }
             .summary-item p { grid-column: 1 / -1; text-align: left; padding-left: 0; }
            .summary-controls { flex-direction: column; gap: 10px; }
            .summary-controls button { width: 100%; }

            .exercise-chart-container,
            .volume-chart-container,
            .muscle-map { height: 250px; }

            .progress-section { padding: 20px; }
            .progress-controls { flex-direction: column; gap: 15px; }
            .progress-filters { flex-direction: column; width: 100%; }
            .progress-filters .filter-group { width: 100%; }
            .progress-filters select { width: 100%; }
        }
    </style>
</head>
<body class="logged-out dark-theme state-idle"> <!-- Classe d'état initiale -->

<header>
    <div class="header-content">
        <h1><i class="fas fa-shield-halved"></i> ArmorWorkout</h1>
        <nav>
            <ul>
                <li><button id="nav-push" data-workout="Push" disabled>Push</button></li>
                <li><button id="nav-pull" data-workout="Pull" disabled>Pull</button></li>
                <li><button id="nav-legs" data-workout="Legs" disabled>Legs</button></li>
                <li><button id="nav-history"><i class="fas fa-history"></i> Historique</button></li>
                <li><button id="nav-progress" disabled><i class="fas fa-chart-line"></i> Progression</button></li>
            </ul>
        </nav>
        <div class="header-actions">
            <div class="auth-controls">
                <!-- ID Client Google remplacé ici -->
                <button id="signin-button"><i class="fab fa-google"></i> Connecter Drive</button>
                <button id="signout-button"><i class="fas fa-sign-out-alt"></i> Déconnecter</button>
                <button id="export-button"><i class="fas fa-file-export"></i> Exporter</button>
            </div>
            <span id="drive-status"></span>
            <div class="theme-toggle">
                <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button>
            </div>
        </div>
    </div>
</header>

<div class="container">
    <main>
        <!-- Section Entraînement -->
        <div class="workout-section" id="workout-section">
            <div class="timer-display" id="timer-display-clickable" aria-label="Affichage du timer - Cliquer pour ajuster les répétitions">
                <div class="timer-circle-container">
                    <div id="total-progress-circle" aria-hidden="true"></div>
                    <div class="timer-circle" id="timer-circle" aria-hidden="true">
                        <span class="time-left" id="time-left">00:00</span>
                    </div>
                </div>
                <div class="timer-state" id="timer-state" aria-live="polite"></div>
                <!-- Overlay Ajustement Répétitions -->
                <div class="rep-adjustment-overlay" id="rep-adjustment-overlay">
                    <div class="title">Ajuster Répétitions</div>
                    <div class="rep-adjustment-next-exercise" id="rep-adjustment-exercise-name">Exercice</div>
                    <div class="rep-adjustment-controls">
                        <button class="rep-adjustment-btn minus" id="rep-adjust-minus" aria-label="Diminuer répétitions">-</button>
                        <span class="current-reps" id="current-reps-display" aria-live="polite">12</span>
                        <button class="rep-adjustment-btn plus" id="rep-adjust-plus" aria-label="Augmenter répétitions">+</button>
                    </div>
                </div>
            </div>
            <div class="workout-info" id="workout-info">
                <div id="current-exercise-name-display">ArmorWorkout</div> <!-- Titre initial -->
                <div id="current-exercise-container" aria-live="polite">
                    <!-- Contenu dynamique ajouté par JS -->
                    <div class="idle-message"><i class="fas fa-info-circle"></i> Connectez-vous à Google Drive pour commencer.</div>
                </div>
            </div>
            <div class="controls">
                <button id="start-pause-btn" disabled><i class="fas fa-play"></i> Démarrer</button>
                <button id="skip-btn" disabled><i class="fas fa-forward-step"></i> Suivant</button>
                <button id="finish-btn" disabled><i class="fas fa-flag-checkered"></i> Finir</button>
                <button id="reset-btn" disabled><i class="fas fa-redo"></i> Reset</button>
            </div>
            <div class="progress-tracker" id="progress-tracker">
                <span id="progress-text-area">Sélectionnez un entraînement</span>
                <span id="drive-connection-status-main" style="display: none;">
                    <i class="fab fa-google-drive"></i>
                    <span id="drive-connection-text">Connecté</span>
                </span>
            </div>
        </div>

        <!-- Section Historique -->
        <div class="history-section section-hidden" id="history-section">
            <h2><i class="fas fa-history"></i> Historique & Statistiques</h2>
            <div class="history-controls">
                <div class="history-filters" role="group" aria-label="Filtres période historique">
                    <button data-period="week" class="active"><i class="fas fa-calendar-week"></i> Semaine</button>
                    <button data-period="month"><i class="fas fa-calendar-alt"></i> Mois</button>
                    <button data-period="year"><i class="fas fa-calendar-check"></i> Année</button>
                    <button data-period="all"><i class="fas fa-infinity"></i> Tout</button>
                </div>
                <div class="history-actions" style="display: none;"> <!-- Affichage géré par body.logged-in -->
                    <i class="fab fa-google-drive" aria-hidden="true"></i>
                    <span id="history-drive-status">Synchro Drive</span>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="history-chart-canvas" role="img" aria-label="Graphique du volume d'entraînement"></canvas>
                <p id="chart-placeholder" class="chart-placeholder" style="display: none;"></p> <!-- Texte si pas de données -->
            </div>
            <div class="stats-display" id="stats-display">
                <h3>Statistiques</h3>
                <div class="content-wrapper" aria-live="polite">
                     <p>Connectez-vous pour voir les statistiques.</p>
                </div>
                <p class="motivational-message"></p>
            </div>
            <ul class="history-list" id="history-list">
                <li class="no-history">Connectez-vous pour voir l'historique.</li>
            </ul>
        </div>

        <!-- Section Progression -->
        <div class="progress-section section-hidden" id="progress-section">
            <h2><i class="fas fa-chart-line"></i> Analyse de Progression</h2>
            <div class="progress-controls">
                <div class="progress-filters">
                    <div class="filter-group">
                        <label for="exercise-select">Exercice</label>
                        <select id="exercise-select" aria-label="Sélectionner un exercice">
                            <option value="all">Tous les exercices</option>
                            <!-- Rempli dynamiquement -->
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="metric-select">Métrique</label>
                        <select id="metric-select" aria-label="Sélectionner une métrique">
                            <option value="weight">Poids/Résistance</option>
                            <option value="reps">Répétitions</option>
                            <option value="volume">Volume (Poids × Reps)</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="period-select">Période</label>
                        <select id="period-select" aria-label="Sélectionner une période">
                            <option value="3months">3 derniers mois</option>
                            <option value="6months">6 derniers mois</option>
                            <option value="all">Tout l'historique</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="exercise-progress-container">
                <h3>Progression par Exercice</h3>
                <div class="exercise-chart-container">
                    <canvas id="exercise-progress-chart" class="exercise-progress-chart" role="img" aria-label="Graphique de progression par exercice"></canvas>
                    <p id="exercise-chart-placeholder" class="chart-placeholder">Sélectionnez un exercice pour voir sa progression.</p>
                </div>
            </div>

            <div class="volume-load-container">
                <h3>Volume d'Entraînement Global</h3>
                <div class="volume-chart-container">
                    <canvas id="volume-chart" class="volume-chart" role="img" aria-label="Graphique du volume d'entraînement global"></canvas>
                    <p id="volume-chart-placeholder" class="chart-placeholder">Chargement des données de volume...</p>
                </div>
            </div>

            <div class="muscle-map-container">
                <h3>Carte des Groupes Musculaires</h3>
                <div class="muscle-map">
                    <p class="muscle-map-placeholder">La visualisation des groupes musculaires sera disponible prochainement.</p>
                </div>
            </div>
        </div>
    </main>
</div>

<footer>
    <p>© 2024 ArmorWorkout. Sauvegarde automatique sur <i class="fab fa-google-drive" aria-hidden="true"></i> Google Drive.</p>
    <p><a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> Voir sur GitHub</a></p>
</footer>

<!-- Zone de Message Flottante -->
<div id="message-area" class="message-area" role="status" aria-live="polite"></div>

<!-- Modal Résumé Post-Workout -->
<div id="post-workout-summary" class="post-workout-summary" role="dialog" aria-modal="true" aria-labelledby="summary-title">
    <div class="post-workout-summary-content">
        <h2 id="summary-title">Résumé de la Séance</h2>
        <ul id="summary-items-list" class="summary-items-list">
            <!-- Contenu généré par JS -->
        </ul>
        <div class="summary-controls">
            <button id="close-summary-btn"><i class="fas fa-times"></i> Fermer</button>
            <button id="discard-summary-btn"><i class="fas fa-trash-alt"></i> Annuler Modifs</button> <!-- Texte clarifié -->
            <button id="confirm-summary-btn"><i class="fas fa-check"></i> Valider & Fermer</button>
        </div>
    </div>
</div>

<!-- Google Identity Services Script - IMPORTANT: Placé à la fin du body -->
<script async defer src="https://accounts.google.com/gsi/client" onload="gisLoadedCallback"></script>

<script>
    // --- CONFIGURATION & CONSTANTES ---
    // IMPORTANT: Remplacez par votre propre ID Client Google Cloud pour l'API Google Drive
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com"; // Utilisation de l'ID fourni
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file'; // Scope nécessaire pour créer/modifier des fichiers
    const HISTORY_FILENAME = "armorworkout_history.json"; // Fichier pour l'historique (format JSON)
    // Noms des fichiers de programme (format JSON attendu pour la simplicité)
    const PROGRAM_FILENAMES = {
        Push: "armorworkout_push_program.json",
        Pull: "armorworkout_pull_program.json",
        Legs: "armorworkout_legs_program.json"
    };
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const PREPARE_DURATION = 3; // Secondes de préparation avant exercice/repos
    const SECONDS_PER_REP = 2.5; // Estimation temps par répétition (pour barre de progression totale)
    const IN_PROGRESS_KEY = 'armorWorkoutStateInProgress'; // Clé localStorage pour sauvegarde état en cours

    // Mappage muscles-exercices (pour analyses futures - non utilisé pour l'instant)
    const MUSCLE_GROUPS = { /* ... (gardé pour référence future) ... */ };

    // --- DONNÉES PAR DÉFAUT (si Drive échoue ou premier usage) ---
    const defaultWorkouts = {
        Push: [ {type:"exercise",name:"Band Standing Chest Press",details:"Élastique 15kg à porte",reps:13,weight:15}, {type:"exercise",name:"Band Bench Press",details:"Élastique 25kg",reps:15,weight:25}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Band Standing Chest Press",details:"Élastique 15kg à porte",reps:13,weight:15}, {type:"exercise",name:"Band Bench Press",details:"Élastique 25kg",reps:15,weight:25}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Band Standing Chest Press",details:"Élastique 15kg à porte",reps:14,weight:15}, {type:"exercise",name:"Band Bench Press",details:"Élastique 25kg",reps:15,weight:25}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Overhead Press",details:"Élastique 15kg",reps:12,weight:15}, {type:"exercise",name:"Triceps Pushdown",details:"Élastique 15kg",reps:15,weight:15}, {type:"break",duration:60,name:"Repos"}, {type:"exercise",name:"Overhead Press",details:"Élastique 15kg",reps:12,weight:15}, {type:"exercise",name:"Triceps Pushdown",details:"Élastique 15kg",reps:15,weight:15} ],
        Pull: [ {type:"exercise",name:"Band Bent-over Row",details:"Élastique 25 kg",reps:12,weight:25}, {type:"exercise",name:"Band Face Pull",details:"Élastique 15 kg",reps:14,weight:15}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Band Bent-over Row",details:"Élastique 25 kg",reps:12,weight:25}, {type:"exercise",name:"Band Face Pull",details:"Élastique 15 kg",reps:14,weight:15}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Band Bent-over Row",details:"Élastique 25 kg",reps:13,weight:25}, {type:"exercise",name:"Band Face Pull",details:"Élastique 15 kg",reps:15,weight:15}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Bicep Curls",details:"Élastique 15 kg",reps:12,weight:15}, {type:"exercise",name:"Lat Pulldown (Band)",details:"Élastique 25 kg",reps:12,weight:25}, {type:"break",duration:60,name:"Repos"}, {type:"exercise",name:"Bicep Curls",details:"Élastique 15 kg",reps:12,weight:15}, {type:"exercise",name:"Lat Pulldown (Band)",details:"Élastique 25 kg",reps:12,weight:25} ],
        Legs: [ {type:"exercise",name:"Front squat",details:"Élastique 15+25 kg + Haltère 5kg",reps:13,weight:45}, {type:"exercise",name:"Fentes Arrière",details:"Élastique 25 kg",reps:10,weight:25}, {type:"break",duration:90,name:"Repos"}, {type:"exercise",name:"Front squat",details:"Élastique 15+25 kg + Haltère 5kg",reps:13,weight:45}, {type:"exercise",name:"Fentes Arrière",details:"Élastique 25 kg",reps:10,weight:25}, {type:"break",duration:90,name:"Repos"}, {type:"exercise",name:"Front squat",details:"Élastique 15+25 kg + Haltère 5kg",reps:14,weight:45}, {type:"exercise",name:"Fentes Arrière",details:"Élastique 25 kg",reps:11,weight:25}, {type:"break",duration:90,name:"Repos"}, {type:"exercise",name:"Romanian Deadlift (Band)",details:"Élastique 25kg",reps:15,weight:25}, {type:"exercise",name:"Calf Raises",details:"Bodyweight or Band",reps:20,weight:10}, {type:"break",duration:60,name:"Repos"}, {type:"exercise",name:"Romanian Deadlift (Band)",details:"Élastique 25kg",reps:15,weight:25}, {type:"exercise",name:"Calf Raises",details:"Bodyweight or Band",reps:20,weight:10} ]
    };

    // --- Éléments DOM (Déclaration Globale pour accès facile) ---
    let timeLeftDisplay, timerCircle, timerStateDisplay, currentExerciseContainer,
        progressTracker, startPauseBtn, skipBtn, finishBtn, resetBtn, navButtons = [],
        navHistoryBtn, navProgressBtn, themeToggleBtn, messageArea, workoutSection, historySection, progressSection,
        historyList, statsDisplay, statsContentWrapper, historyFilterBtns = [], historyChartCanvas,
        signInButton, signOutButton, exportButton, driveStatusElement,
        postWorkoutSummary, summaryTitle, summaryItemsList, confirmSummaryBtn,
        discardSummaryBtn, closeSummaryBtn,
        historyDriveStatus, totalProgressCircle,
        currentExerciseNameDisplay, driveConnectionStatusMain, driveConnectionText,
        timerDisplayElement, chartPlaceholder, progressTextArea, historyActionsContainer,
        exerciseSelect, metricSelect, periodSelect, exerciseProgressChart, volumeChart,
        exerciseChartPlaceholder, volumeChartPlaceholder,
        repAdjustmentOverlay, repAdjustMinusBtn, repAdjustPlusBtn, currentRepsDisplay, repAdjustmentExerciseName;

    // --- Variables d'État (Déclaration Globale) ---
    let currentWorkoutType = null; // 'Push', 'Pull', 'Legs' ou null
    let currentWorkoutPlan = []; // Plan chargé, potentiellement modifié par l'utilisateur
    let originalCompletedWorkoutPlan = []; // Copie du plan tel qu'il était au moment de la fin
    let currentItemIndex = 0; // Index de l'étape actuelle
    let timerInterval = null, prepareCountdownInterval = null; // IDs des intervals
    let totalTime = 0, timeLeft = 0, prepareTimeLeft = 0; // Temps pour l'étape actuelle / préparation
    let totalWorkoutEstimatedSeconds = 0, elapsedWorkoutEstimatedSeconds = 0; // Pour la barre de progression globale
    let isTimerRunning = false, isWorkoutActive = false, workoutFinished = false, wasFinishedState = false;
    let currentState = 'idle'; // 'idle', 'preparing', 'exercise', 'break', 'paused', 'finished'
    let workoutStartTime = null; // Timestamp début séance
    let workoutHistory = []; // Historique chargé depuis Drive/localStorage
    let currentHistoryPeriod = 'week'; // Filtre période historique
    let historyChart = null, exercisePerfChart = null, volumeLoadChart = null; // Instances Chart.js
    let googleAccessToken = null, tokenClient = null; // Tokens & client Google
    let historyFileId = null, programFileIds = { Push: null, Pull: null, Legs: null }; // IDs fichiers Drive
    let programsLoaded = false; // Flag: programmes chargés depuis Drive?
    let loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Programmes chargés (initialisé avec défauts)
    let summaryChangesMade = false; // Flag: modifications dans le résumé post-workout?
    let isSavingDriveData = false; // Flag pour éviter écritures concurrentes
    let currentTheme = 'dark'; // Thème actuel ('dark' ou 'light')
    let messageTimeoutId = null; // ID timeout pour masquer message flottant
    let audioContext = null; // Pour les sons (bips)
    let nextExerciseIndexForAdjustment = -1; // Index de l'exo pour ajustement reps
    let currentRepAdjustment = 0; // Valeur de l'ajustement (+/- reps)
    let isRepAdjustmentVisible = false; // Overlay d'ajustement visible?

    // --- Initialisation Audio & Vibration ---
    let endSound = () => console.log("Beep! (AudioContext non initialisé ou bloqué)"); // Fonction son par défaut

    function initAudioContext() {
        if (audioContext || typeof window === 'undefined' || (!window.AudioContext && !window.webkitAudioContext)) return;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            console.log("AudioContext initialisé.");
            // Déblocage nécessaire sur interaction utilisateur
            const unlock = () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("AudioContext réactivé par interaction utilisateur.");
                        // Retirer les listeners une fois réactivé
                        document.removeEventListener('click', unlock);
                        document.removeEventListener('touchend', unlock);
                    }).catch(e => console.error("Erreur réactivation AudioContext:", e));
                } else {
                    // Déjà actif ou non suspendu, retirer les listeners
                    document.removeEventListener('click', unlock);
                    document.removeEventListener('touchend', unlock);
                }
            };
            document.addEventListener('click', unlock, { once: true }); // Option 'once' pour retirer auto
            document.addEventListener('touchend', unlock, { once: true });
            endSound = () => playActualSound(); // Assigner la vraie fonction une fois initialisé
        } catch (e) {
            console.warn("Échec initialisation AudioContext:", e);
            audioContext = null; // Assurer que audioContext est null si échec
        }
    }

    function playActualSound() {
        if (!audioContext || audioContext.state !== 'running') {
            console.log(`Tentative de son échouée (état: ${audioContext?.state})`);
            return; // Ne rien faire si contexte non prêt
        }
        try {
            const o = audioContext.createOscillator();
            const g = audioContext.createGain();
            o.connect(g);
            g.connect(audioContext.destination);
            o.type = 'triangle'; // Son un peu moins agressif que 'sine'
            o.frequency.setValueAtTime(659.25, audioContext.currentTime); // Note Mi5 (E5)
            g.gain.setValueAtTime(0.15, audioContext.currentTime); // Volume réduit
            g.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.5); // Fondu rapide
            o.start(audioContext.currentTime);
            o.stop(audioContext.currentTime + 0.5);
        } catch(e) {
            console.error("Erreur lecture son:", e);
        }
    }

    const vibrate = (pattern = [100]) => { // Pattern simple par défaut
        if ('vibrate' in navigator) {
            try { navigator.vibrate(pattern); } catch (e) { console.warn("Vibration échouée:", e); }
        }
    };

    // --- Fonctions Google Identity Services (GIS) & Drive API ---

    // Callback appelé par le script GIS une fois chargé
    async function gisLoadedCallback() {
        console.log("GIS Library Loaded");
        if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID.includes("YOUR_CLIENT_ID")) { // Vérification plus générique
            console.error("CRITICAL: GOOGLE_CLIENT_ID n'est pas configuré ! Remplacez la valeur dans le code.");
            showMessage("Erreur critique : ID Client Google manquant. Vérifiez la console.", 10000, true);
            if (driveStatusElement) {
                driveStatusElement.textContent = 'Erreur Config ID';
                driveStatusElement.classList.remove('loading', 'success');
                driveStatusElement.classList.add('error');
                driveStatusElement.style.display = 'inline-block';
            }
            updateAuthUI(false); // Met l'UI en état déconnecté
            signInButton.disabled = true; // Désactive le bouton connexion car inutilisable
            return;
        }
        try {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GOOGLE_DRIVE_SCOPES,
                callback: tokenCallback, // Fonction appelée avec le token (succès ou erreur gérée dedans)
                error_callback: handleTokenError, // Fonction pour erreurs spécifiques GIS
                prompt: '' // Important: Ne pas afficher de pop-up automatiquement au chargement
            });
            console.log("Token Client Google initialisé.");
            // Tenter de restaurer une session silencieusement si possible (non implémenté ici, mais possible)
            // Exemple : google.accounts.id.initialize({...}); google.accounts.id.prompt();
        } catch (error) {
            console.error("Erreur initialisation Google Token Client:", error);
            showMessage("Erreur initialisation services Google.", 5000, true);
            updateAuthUI(false);
            if (driveStatusElement) {
                driveStatusElement.textContent = 'Erreur Init Auth';
                driveStatusElement.classList.remove('loading', 'success');
                driveStatusElement.classList.add('error');
                driveStatusElement.style.display = 'inline-block';
            }
        }
    }

    // Gère les erreurs venant de l'initTokenClient ou requestAccessToken
    function handleTokenError(error) {
        console.error("Erreur Google Token Client:", error);
        let userMessage = `Erreur Auth Google: ${error.type || error.error || 'Inconnue'}`;
        let statusText = 'Erreur Auth';
        if (driveStatusElement) {
            driveStatusElement.classList.remove('loading', 'success');
            driveStatusElement.classList.add('error');
            driveStatusElement.style.display = 'inline-block';
        }

        // Messages plus clairs selon l'erreur
        if (error.error === 'popup_closed_by_user' || error.error === 'user_cancel' || error.type === 'popup_closed') {
            userMessage = "Connexion Google annulée par l'utilisateur.";
            statusText = 'Annulé';
        } else if (error.error === 'popup_failed_to_open' || error.type === 'popup_failed_to_open') {
            userMessage = "La fenêtre pop-up Google a été bloquée par le navigateur.";
            statusText = 'Popup Bloqué';
        } else if (error.error === 'access_denied' || error.type === 'access_denied') {
            userMessage = "Accès à Google Drive refusé.";
            statusText = 'Accès Refusé';
        } else if (error.error === 'token_network_error') {
             userMessage = "Erreur réseau lors de l'authentification Google.";
             statusText = 'Erreur Réseau';
        } else if (error.error === 'invalid_grant') {
             userMessage = "Autorisation Google invalide ou révoquée.";
             statusText = 'Autorisation Invalide';
             // Forcer déconnexion si token invalide
             googleAccessToken = null;
        }

        showMessage(userMessage, 6000, true);
        if (driveStatusElement) driveStatusElement.textContent = statusText;
        updateAuthUI(false); // Assurer que l'UI est en mode déconnecté
    }

    // Callback appelé après que l'utilisateur ait autorisé (ou échoué) via le pop-up
    async function tokenCallback(tokenResponse) {
        if (driveStatusElement) {
            driveStatusElement.classList.remove('loading', 'error', 'success'); // Reset état visuel
            driveStatusElement.style.display = 'inline-block';
        }

        // Vérifier si la réponse contient une erreur (méthode recommandée par Google)
        if (tokenResponse.error) {
            handleTokenError(tokenResponse); // Laisser handleTokenError gérer les détails
            return;
        }

        // Succès: nous avons un token d'accès
        if (tokenResponse && tokenResponse.access_token) {
            console.log("Access Token reçu avec succès.");
            googleAccessToken = tokenResponse.access_token;
            updateAuthUI(true); // Met l'UI en mode connecté

            showMessage("Connecté ! Chargement des données...", 2500);
            if (driveStatusElement) {
                driveStatusElement.textContent = 'Chargement...';
                driveStatusElement.classList.add('loading');
            }

            try {
                // Charger l'historique ET les programmes en parallèle
                await Promise.all([
                    loadHistoryFromDrive(),
                    loadProgramsFromDrive()
                ]);
                console.log("Historique et programmes chargés (ou utilisation des défauts si échec).");

                if (programsLoaded) {
                    showMessage("Données prêtes. Sélectionnez un entraînement.", 3000);
                } else {
                     showMessage("Programmes par défaut chargés. Vérifiez Drive.", 4000);
                }

                if (driveStatusElement) {
                    driveStatusElement.textContent = 'Connecté';
                    driveStatusElement.classList.remove('loading', 'error'); // Assurer que loading/error sont retirés
                    driveStatusElement.classList.add('success');
                }
                // Essayer de restaurer un état en cours (si existait avant déconnexion/rechargement)
                loadInProgressState();
                 // Re-mettre à jour l'UI au cas où loadInProgressState aurait changé l'état
                updateAuthUI(true);
                // Peupler les options et afficher les graphiques maintenant que les données sont là
                populateExerciseSelect();
                displayHistory(currentHistoryPeriod); // Affiche histo + stats + graph histo
                displayExerciseProgress(); // Affiche graph progression exo
                displayVolumeLoad(); // Affiche graph volume global

            } catch (error) {
                console.error("Erreur CRITIQUE pendant le chargement des données Drive:", error);
                showMessage("Erreur majeure lors du chargement des données Drive.", 6000, true);
                if (driveStatusElement) {
                    driveStatusElement.textContent = 'Erreur Données';
                    driveStatusElement.classList.remove('loading', 'success');
                    driveStatusElement.classList.add('error');
                }
                 // L'utilisateur est techniquement connecté, mais les données n'ont pas pu être chargées
                 // Il utilisera les données par défaut ou un historique vide.
                updateAuthUI(true);
            }
        } else {
            // Cas où la réponse n'est pas conforme (ni token, ni erreur explicite)
            handleTokenError({ error: "invalid_response", details: "Réponse inattendue du serveur Google." });
        }
    }

    // Gère le clic sur le bouton "Connecter Drive"
    function handleAuthClick() {
        initAudioContext(); // Tenter init audio au cas où interaction utilisateur
        if (!tokenClient) {
            showMessage("Les services Google ne sont pas encore prêts...", 3000);
            console.warn("Tentative de connexion avant initialisation du tokenClient.");
            // Vérifier si l'ID Client est manquant (cause fréquente)
            if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID.includes("YOUR_CLIENT_ID")) {
                 showMessage("Erreur critique : ID Client Google manquant. Impossible de connecter.", 8000, true);
            }
            return;
        }

        if (driveStatusElement) {
            driveStatusElement.textContent = 'Connexion...';
            driveStatusElement.classList.add('loading');
            driveStatusElement.classList.remove('error', 'success');
            driveStatusElement.style.display = 'inline-block';
        }
        // Demander le token (ouvre le pop-up de connexion/autorisation Google)
        tokenClient.requestAccessToken({ prompt: 'consent' }); // 'consent' force l'écran d'autorisation si nécessaire
    }

    // Gère le clic sur le bouton "Déconnecter"
    function handleSignoutClick(showMessages = true) {
        const token = googleAccessToken;
        if (!token) {
            console.log("Déjà déconnecté.");
            updateAuthUI(false); // Assurer que l'UI est correcte
            return;
        }

        if (showMessages && driveStatusElement) {
            driveStatusElement.textContent = 'Déconnexion...';
            driveStatusElement.classList.add('loading');
            driveStatusElement.style.display = 'inline-block';
        }

        google.accounts.oauth2.revoke(token, () => {
            console.log('Token Google révoqué.');
            googleAccessToken = null;
            // Réinitialiser les IDs de fichiers et les données chargées
            historyFileId = null;
            programFileIds = { Push: null, Pull: null, Legs: null };
            programsLoaded = false;
            workoutHistory = [];
            loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Revenir aux défauts
            clearInProgressState(); // Supprimer état sauvegardé

            // Si un workout était actif, le réinitialiser complètement
            if (isWorkoutActive || currentState !== 'idle') {
                resetCurrentWorkout(); // Ceci appelle updateAuthUI(false) à la fin
            } else {
                 updateAuthUI(false); // Mettre à jour l'UI directement
            }

            if (showMessages) {
                showMessage("Déconnecté de Google Drive.", 3000);
            }
            if (driveStatusElement) {
                driveStatusElement.textContent = ''; // Vider le statut
                driveStatusElement.style.display = 'none'; // Cacher le statut
            }
            // Nettoyer les graphiques et les listes
            displayHistory(currentHistoryPeriod); // Affichera "Connectez-vous"
            clearCharts(); // Fonction pour vider les graphiques
            populateExerciseSelect(); // Videra le sélecteur d'exercices
        });
    }

    // Met à jour l'interface utilisateur en fonction de l'état de connexion
    function updateAuthUI(isLoggedIn) {
        console.log(`Mise à jour UI - Connecté: ${isLoggedIn}, Programmes Chargés: ${programsLoaded}, État Timer: ${currentState}`);
        const body = document.body;
        body.classList.toggle('logged-in', isLoggedIn);
        body.classList.toggle('logged-out', !isLoggedIn);

        // Affichage statut Drive dans le header
        if (driveStatusElement) {
            driveStatusElement.style.display = isLoggedIn ? 'inline-block' : 'none';
            if (!isLoggedIn) driveStatusElement.textContent = '';
            // Sinon, le texte est géré par les fonctions d'auth/chargement
        }

        // Affichage statut Drive dans la zone de progression (sous le timer)
        const driveIconMain = driveConnectionStatusMain?.querySelector('i.fa-google-drive');
        if (driveConnectionStatusMain && driveConnectionText && driveIconMain) {
            driveConnectionStatusMain.style.display = isLoggedIn ? 'inline-flex' : 'none';
            if (isLoggedIn) {
                if (driveStatusElement?.classList.contains('loading')) {
                    driveConnectionText.textContent = "Chargement...";
                    driveIconMain.classList.add('fa-spin');
                    driveIconMain.classList.remove('error');
                } else if (driveStatusElement?.classList.contains('error')) {
                    driveConnectionText.textContent = `Erreur Drive`;
                    driveIconMain.classList.remove('fa-spin');
                    driveIconMain.classList.add('error');
                } else {
                    driveConnectionText.textContent = "Connecté";
                    driveIconMain.classList.remove('fa-spin', 'error');
                }
            } else {
                 driveIconMain.classList.remove('fa-spin', 'error');
            }
        }

        // Statut Drive dans la section historique
        if (historyDriveStatus && historyActionsContainer) {
            historyActionsContainer.style.display = isLoggedIn ? 'flex' : 'none';
            if (isLoggedIn) {
                historyDriveStatus.classList.remove('syncing', 'error', 'success'); // Reset classes
                if (isSavingDriveData) { // Priorité si sauvegarde en cours
                    historyDriveStatus.textContent = 'Synchro...';
                    historyDriveStatus.classList.add('syncing');
                } else if (driveStatusElement?.classList.contains('loading')) {
                    historyDriveStatus.textContent = 'Chargement...';
                    historyDriveStatus.classList.add('syncing');
                } else if (driveStatusElement?.classList.contains('error')) {
                    historyDriveStatus.textContent = 'Erreur Synchro';
                    historyDriveStatus.classList.add('error');
                } else {
                    historyDriveStatus.textContent = 'Synchro OK';
                    historyDriveStatus.classList.add('success');
                }
            }
        }

        // Activation/Désactivation des boutons et navigations
        themeToggleBtn.disabled = false; // Toujours actif
        signInButton.disabled = isLoggedIn; // Désactivé si déjà loggué
        signOutButton.disabled = !isLoggedIn; // Désactivé si pas loggué
        exportButton.disabled = !isLoggedIn; // Désactivé si pas loggué

        const isTimerActive = ['preparing', 'exercise', 'break', 'paused'].includes(currentState);

        navButtons.forEach(btn => {
            // Actif seulement si loggué, programmes chargés, et timer non actif
            btn.disabled = !(isLoggedIn && programsLoaded && !isTimerActive);
        });
        navHistoryBtn.disabled = isTimerActive; // Désactivé pendant entraînement
        navProgressBtn.disabled = !isLoggedIn || isTimerActive; // Désactivé si pas loggué OU pendant entraînement

        // État des boutons de contrôle du timer (géré plus finement par setState)
        // Ici on assure juste l'état initial/final correct
        if (currentState === 'idle') {
            startPauseBtn.disabled = !(isLoggedIn && programsLoaded && !!currentWorkoutType); // Actif si loggué, chargé, et type choisi
            skipBtn.disabled = true;
            finishBtn.disabled = true;
            resetBtn.disabled = !(isLoggedIn && !!currentWorkoutType); // Actif si loggué et type choisi (même si pas démarré)
            startPauseBtn.innerHTML = `<i class="fas fa-play"></i> Démarrer`;
            startPauseBtn.className = 'start-btn'; // Style 'Démarrer'
        } else if (currentState === 'finished') {
             // Les boutons sont gérés par setState pendant la transition vers 'finished' et le modal
        }

        // Mettre à jour les infos affichées (nom exo, historique, etc.)
        updateWorkoutInfo(); // Met à jour infos sous le timer
        displayHistory(currentHistoryPeriod); // Met à jour section historique
        // Les graphiques de progression sont mis à jour via leurs fonctions dédiées après chargement données
    }

    // Trouve ou crée un fichier sur Google Drive
    async function findOrCreateFile(filename, defaultContent = "", mimeType = 'application/json') {
        console.log(`Drive: Recherche/Création de ${filename}`);
        if (!googleAccessToken) {
            console.warn("findOrCreateFile: Pas de token Google.");
            return null;
        }

        const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+trashed=false&spaces=drive&fields=files(id,name)`;

        try {
            const searchRes = await fetch(searchUrl, {
                headers: { 'Authorization': `Bearer ${googleAccessToken}` }
            });

            if (!searchRes.ok) {
                if (searchRes.status === 401 || searchRes.status === 403) {
                    console.warn(`findOrCreateFile(${filename}): Erreur d'autorisation (${searchRes.status}). Déconnexion.`);
                    handleSignoutClick(false); // Déconnexion silencieuse
                    showMessage("Session Google expirée. Reconnectez-vous.", 5000, true);
                    return null;
                }
                throw new Error(`Recherche échouée (${searchRes.status}): ${await searchRes.text()}`);
            }

            const searchData = await searchRes.json();
            if (searchData.files && searchData.files.length > 0) {
                console.log(`Drive: Fichier ${filename} trouvé (ID: ${searchData.files[0].id}).`);
                return searchData.files[0].id; // Fichier trouvé, retourner son ID
            }

            // Fichier non trouvé, le créer
            console.log(`Drive: Fichier ${filename} non trouvé. Création...`);
            const createUrl = `https://www.googleapis.com/drive/v3/files`;
            const metadata = { name: filename, mimeType: mimeType }; // Utiliser le mimeType fourni

            const createRes = await fetch(createUrl, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${googleAccessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(metadata)
            });

            if (!createRes.ok) {
                throw new Error(`Création échouée (${createRes.status}): ${await createRes.text()}`);
            }

            const createData = await createRes.json();
            const newFileId = createData.id;
            console.log(`Drive: Fichier ${filename} créé (ID: ${newFileId}). Écriture du contenu par défaut...`);

            // Écrire le contenu par défaut dans le nouveau fichier
            const writeSuccess = await updateFileContent(newFileId, defaultContent);
            if (writeSuccess) {
                console.log(`Drive: Contenu par défaut écrit avec succès dans ${filename}.`);
                return newFileId;
            } else {
                console.error(`Drive: Échec de l'écriture du contenu par défaut dans ${filename}.`);
                 // Optionnel: tenter de supprimer le fichier vide créé? Pour l'instant on le laisse.
                return null;
            }

        } catch (error) {
            console.error(`Erreur Drive (findOrCreate ${filename}):`, error);
            showMessage(`Erreur Drive (${filename.substring(0, 15)}...): ${error.message}`, 6000, true);
            return null;
        }
    }

    // Lit le contenu d'un fichier sur Google Drive par son ID
    async function readFileContent(fileId) {
        if (!googleAccessToken || !fileId) {
            console.warn("readFileContent: Pas de token ou d'ID de fichier.");
            return null;
        }
        console.log(`Drive: Lecture du fichier ${fileId}`);
        const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;

        try {
            const response = await fetch(url, {
                headers: { 'Authorization': `Bearer ${googleAccessToken}` }
            });

            if (!response.ok) {
                if (response.status === 404) {
                    console.warn(`readFileContent(${fileId}): Fichier non trouvé (404).`);
                    return ""; // Retourner chaîne vide si non trouvé, pour permettre recréation
                }
                if (response.status === 401 || response.status === 403) {
                    console.warn(`readFileContent(${fileId}): Erreur d'autorisation (${response.status}). Déconnexion.`);
                    handleSignoutClick(false);
                    showMessage("Session Google expirée. Reconnectez-vous.", 5000, true);
                    return null;
                }
                throw new Error(`Lecture échouée (${response.status}): ${await response.text()}`);
            }

            const content = await response.text();
            console.log(`Drive: Contenu du fichier ${fileId} lu avec succès.`);
            return content;

        } catch (error) {
            console.error(`Erreur Drive (readFile ${fileId}):`, error);
            showMessage(`Erreur Lecture Drive (${fileId}): ${error.message}`, 6000, true);
            return null;
        }
    }

    // Met à jour le contenu d'un fichier sur Google Drive
    async function updateFileContent(fileId, content) {
        if (!googleAccessToken || !fileId) {
            console.warn("updateFileContent: Pas de token ou d'ID de fichier.");
            return false;
        }
        if (isSavingDriveData) {
            showMessage("Sauvegarde Drive déjà en cours...", 1500);
            console.warn("Tentative d'écriture concurrente sur Drive annulée.");
            return false; // Empêcher écritures concurrentes
        }

        console.log(`Drive: Écriture dans le fichier ${fileId}...`);
        isSavingDriveData = true; // Verrouiller
        if (historyDriveStatus) historyDriveStatus.textContent = 'Synchro...'; historyDriveStatus.className = 'syncing'; // Feedback UI
        updateAuthUI(true); // Mettre à jour potentiellement l'état sync partout

        const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`;
        // Déterminer le type de contenu et le formater
        const isJson = typeof content === 'object';
        const contentToSend = isJson ? JSON.stringify(content, null, 2) : content; // Indenter JSON pour lisibilité
        const contentType = isJson ? 'application/json; charset=UTF-8' : 'text/plain; charset=UTF-8'; // Préciser UTF-8
        let success = false;

        try {
            const response = await fetch(url, {
                method: 'PATCH', // PATCH pour remplacer le contenu
                headers: {
                    'Authorization': `Bearer ${googleAccessToken}`,
                    'Content-Type': contentType
                },
                body: contentToSend
            });

            if (!response.ok) {
                if (response.status === 401 || response.status === 403) {
                    console.warn(`updateFileContent(${fileId}): Erreur d'autorisation (${response.status}). Déconnexion.`);
                    handleSignoutClick(false);
                    showMessage("Session expirée. Sauvegarde échouée.", 6000, true);
                    // Laisser isSavingDriveData = true pour bloquer d'autres tentatives jusqu'à reconnexion? Non, déverrouiller.
                } else {
                    throw new Error(`Écriture échouée (${response.status}): ${await response.text()}`);
                }
            } else {
                console.log(`Drive: Fichier ${fileId} mis à jour avec succès.`);
                success = true;
            }
        } catch (error) {
            console.error(`Erreur Drive (updateFile ${fileId}):`, error);
            showMessage(`Erreur Écriture Drive: ${error.message}`, 6000, true);
            success = false;
            if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Synchro'; historyDriveStatus.className = 'error';
        } finally {
            isSavingDriveData = false; // Déverrouiller
             // Mettre à jour l'UI après la tentative d'écriture
            updateAuthUI(!!googleAccessToken);
            console.log(`Drive: Écriture ${fileId} terminée. Succès: ${success}`);
        }
        return success;
    }

    // --- Fonctions Cœur du Timer ---

    // Formate les secondes en MM:SS
    function formatTime(seconds) {
        const cleanSeconds = Math.max(0, Math.round(seconds)); // Arrondir et assurer >= 0
        const minutes = Math.floor(cleanSeconds / 60);
        const remainingSeconds = cleanSeconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    // Calcule le temps total estimé pour un plan (pour la barre de progression globale)
    function calculateTotalEstimatedTime(plan) {
        let totalSeconds = 0;
        plan.forEach(item => {
            let estimatedDuration = 0;
            if (item.type === 'break') {
                estimatedDuration = item.duration || 0;
            } else if (item.type === 'exercise') {
                // Si durée fixe fournie, l'utiliser, sinon estimer par reps
                estimatedDuration = item.duration || (item.reps || 0) * SECONDS_PER_REP;
            }
            item.estimatedDuration = estimatedDuration; // Stocker pour usage ultérieur
            totalSeconds += estimatedDuration;
        });
        return totalSeconds;
    }

    // Met à jour la barre de progression circulaire globale
    function updateTotalProgressCircle() {
        if (!totalProgressCircle || totalWorkoutEstimatedSeconds <= 0 || !isWorkoutActive) {
            // Si pas de cercle, temps total 0, ou workout inactif, afficher cercle de base
            totalProgressCircle.style.setProperty('--total-progress-gradient', `var(--total-progress-bg)`);
            return;
        }

        // Calculer le temps estimé écoulé des étapes précédentes
        let elapsedSeconds = 0;
        for (let i = 0; i < currentItemIndex; i++) {
            elapsedSeconds += currentWorkoutPlan[i]?.estimatedDuration || 0;
        }

        // Ajouter la progression dans l'étape actuelle (si c'est une pause ou préparation)
        const currentItem = currentWorkoutPlan[currentItemIndex];
        if (currentItem) {
            if (currentState === 'break' && totalTime > 0) {
                const elapsedInBreak = Math.min(totalTime - timeLeft, currentItem.estimatedDuration || totalTime);
                elapsedSeconds += elapsedInBreak;
            } else if (currentState === 'preparing' && PREPARE_DURATION > 0) {
                 const elapsedInPrepare = Math.min(PREPARE_DURATION - prepareTimeLeft, PREPARE_DURATION);
                 // Note: La prépa n'est pas dans currentWorkoutPlan, donc on ne l'ajoute pas à elapsedSeconds basé sur le plan.
                 // On pourrait l'ajouter si on veut que la barre avance pendant la prépa.
            } else if (currentState === 'paused') {
                 // Ajouter le temps écoulé dans l'étape pausée (si c'était une pause)
                 if (currentItem.type === 'break' && totalTime > 0) {
                     const elapsedInBreak = Math.min(totalTime - timeLeft, currentItem.estimatedDuration || totalTime);
                     elapsedSeconds += elapsedInBreak;
                 }
            }
        }

        // Gérer le cas spécial de la fin
        if (currentState === 'finished') {
            elapsedSeconds = totalWorkoutEstimatedSeconds;
        }

        // Calculer le pourcentage et créer le gradient
        const percentage = totalWorkoutEstimatedSeconds > 0
            ? Math.min(100, (elapsedSeconds / totalWorkoutEstimatedSeconds) * 100)
            : 0;

        // Créer un gradient plus subtil/moderne
        const gradient = `conic-gradient(
            var(--neon-blue) ${percentage * 0.6}%,
            var(--neon-pink) ${percentage}%,
            var(--total-progress-bg) ${percentage}%
        )`;
        // Appliquer le style
        totalProgressCircle.style.setProperty('--total-progress-gradient', gradient);
    }

    // Met à jour l'affichage du timer (temps restant, cercle, état)
    function updateTimerDisplay() {
        if (!timeLeftDisplay || !timerCircle || !timerStateDisplay) return;

        let percentage = 0;
        let timeString = "00:00";
        let stepColorVar = '--color-idle';
        let stepGlowVar = '--glow-idle';
        let stateText = '';

        const item = currentWorkoutPlan[currentItemIndex];

        switch(currentState) {
            case 'exercise':
                timeString = "GO!"; // Ou afficher reps? item?.reps ? `${item.reps} Reps` : "GO!";
                stepColorVar = '--color-exercise';
                stepGlowVar = '--glow-exercise';
                stateText = item?.name || 'Exercice';
                percentage = 100; // Cercle plein pendant l'exercice (pas de timer)
                break;
            case 'break':
                if (totalTime > 0) percentage = Math.min(100, ((totalTime - timeLeft) / totalTime) * 100);
                timeString = formatTime(timeLeft);
                stepColorVar = '--color-break';
                stepGlowVar = '--glow-break';
                stateText = 'Repos';
                break;
            case 'paused':
                // Afficher le temps restant si en pause pendant une pause, sinon "PAUSE"
                if (item?.type === 'break' && totalTime > 0) {
                    percentage = Math.min(100, ((totalTime - timeLeft) / totalTime) * 100);
                    timeString = formatTime(timeLeft);
                } else {
                     percentage = item?.type === 'exercise' ? 100 : 0; // Cercle plein si exo pausé
                     timeString = "PAUSE";
                }
                stepColorVar = '--color-paused';
                stepGlowVar = '--glow-paused';
                stateText = 'En Pause';
                break;
            case 'preparing':
                percentage = Math.min(100, ((PREPARE_DURATION - prepareTimeLeft) / PREPARE_DURATION) * 100);
                timeString = formatTime(prepareTimeLeft);
                stepColorVar = '--color-prepare';
                stepGlowVar = '--glow-prepare';
                stateText = 'Préparation';
                break;
            case 'finished':
                percentage = 100;
                timeString = "FINI !";
                stepColorVar = '--color-finished';
                stepGlowVar = '--glow-finished';
                stateText = 'Terminé !';
                break;
            default: // idle
                percentage = 0;
                timeString = formatTime(0);
                stepColorVar = '--color-idle';
                stepGlowVar = '--glow-idle';
                stateText = ''; // Pas d'état affiché quand idle
                break;
        }

        // Appliquer les styles et textes
        timeLeftDisplay.textContent = timeString;
        timerCircle.style.setProperty('--current-step-color', `var(${stepColorVar})`);
        timerCircle.style.setProperty('--current-step-glow', `var(${stepGlowVar})`);
        // Appliquer la progression au cercle intérieur
        timerCircle.style.backgroundImage = `conic-gradient(var(${stepColorVar}) ${percentage}%, transparent ${percentage}%)`;
        // Afficher l'état textuel (Repos, Pause, etc.)
        timerStateDisplay.textContent = stateText;
        timerStateDisplay.style.color = `var(${stepColorVar})`;

        // Mettre à jour la progression globale
        updateTotalProgressCircle();
    }

    // Trouve la dernière performance enregistrée pour un exercice donné
    function findPreviousPerformance(exerciseName) {
        if (!workoutHistory || workoutHistory.length === 0) return null;

        // Parcourir l'historique du plus récent au plus ancien
        for (let i = workoutHistory.length - 1; i >= 0; i--) {
            const entry = workoutHistory[i];
            if (!entry.exercises) continue; // Ignorer si pas de détail d'exercices

            // Chercher l'exercice dans cette séance
            const foundExercise = entry.exercises.find(ex => ex.name === exerciseName);

            if (foundExercise) {
                // Retourner les détails trouvés
                return {
                    reps: foundExercise.actualReps ?? foundExercise.reps, // Utiliser actualReps si dispo
                    weight: foundExercise.actualWeight ?? foundExercise.weight, // Utiliser actualWeight si dispo
                    date: new Date(entry.date) // Convertir la date string en objet Date
                };
            }
        }
        return null; // Pas trouvé dans tout l'historique
    }

    // Met à jour les informations affichées sous le timer (nom exo, détails, progression)
    function updateWorkoutInfo() {
        if (!currentExerciseContainer || !currentExerciseNameDisplay || !progressTracker || !progressTextArea) {
            console.error("updateWorkoutInfo: Éléments DOM manquants.");
            return;
        }

        const item = currentWorkoutPlan[currentItemIndex];
        let infoHtml = ''; // Conteneur pour les détails (reps, poids, etc.)
        let exerciseName = ''; // Nom affiché en grand
        let progressText = ''; // Texte dans la barre de progression
        const body = document.body;

        // Définir le contenu en fonction de l'état actuel
        switch (currentState) {
            case 'idle':
                exerciseName = "ArmorWorkout";
                if (!googleAccessToken) {
                    progressText = "Connectez-vous à Google Drive";
                    infoHtml = `<div class="idle-message"><i class="fas fa-sign-in-alt"></i> ${progressText} pour commencer.</div>`;
                } else if (!programsLoaded) {
                    progressText = "Chargement des programmes...";
                    infoHtml = `<div class="idle-message"><i class="fas fa-spinner fa-spin"></i> ${progressText}</div>`;
                } else if (!currentWorkoutType) {
                    progressText = "Sélectionnez un entraînement (Push/Pull/Legs)";
                    infoHtml = `<div class="idle-message"><i class="fas fa-hand-pointer"></i> ${progressText}</div>`;
                } else {
                    progressText = `Prêt: ${currentWorkoutType}`;
                    infoHtml = `<div class="idle-message"><i class="fas fa-play-circle"></i> Appuyez sur Démarrer pour commencer "${currentWorkoutType}".</div>`;
                }
                break;

            case 'finished':
                const durationSeconds = workoutStartTime ? (Date.now() - workoutStartTime) / 1000 : 0;
                exerciseName = 'Entraînement Terminé !';
                infoHtml = `<div class="exercise-details">
                                <span><i class="fas ${getIconForState('finished')}"></i> Bravo ! Séance finie.</span>
                                ${durationSeconds > 0 ? `<span><i class="fas fa-stopwatch"></i> Durée: <strong>${formatTime(durationSeconds)}</strong></span>` : ''}
                            </div>`;
                progressText = `Fini (${originalCompletedWorkoutPlan.length}/${originalCompletedWorkoutPlan.length})`;
                break;

            case 'preparing':
                const nextItem = currentWorkoutPlan[0]; // Le premier item est celui qui arrive
                exerciseName = `Préparation...`;
                infoHtml = `<div class="break-info" style="border-color: var(--color-prepare);">
                                <i class="fas ${getIconForState('preparing')} fa-spin"></i>
                                <span>Prêt pour <strong>${nextItem?.name || '?'}</strong> dans ${prepareTimeLeft}s...</span>
                            </div>`;
                progressText = `Prépa... (1/${currentWorkoutPlan.length})`;
                break;

            case 'exercise':
            case 'paused': // Afficher les mêmes infos si en pause pendant un exercice
            case 'break': // Afficher les mêmes infos si en pause pendant un repos
                if (!item) { // Sécurité si item est indéfini
                    exerciseName = 'Erreur';
                    infoHtml = '<p>Erreur : Étape inconnue.</p>';
                    progressText = `Étape ?/${currentWorkoutPlan.length}`;
                    break;
                }

                exerciseName = `${item.name || (item.type === 'break' ? 'Repos' : 'Étape inconnue')}`;
                progressText = `Étape ${currentItemIndex + 1}/${currentWorkoutPlan.length}`;

                if (item.type === 'exercise') {
                    const reps = (item.actualReps !== undefined ? item.actualReps : item.reps) ?? '-'; // Afficher reps ajustées si dispo
                    const weight = (item.actualWeight !== undefined ? item.actualWeight : item.weight) ?? '-';
                    const details = item.details || '';

                    infoHtml = `<div class="exercise-details">
                                    <span><i class="fas ${getIconForType('exercise')}"></i> Reps: <strong>${reps}</strong></span>
                                    <span><i class="fas fa-weight-hanging"></i> Poids: <strong>${weight}${weight !== '-' ? ' kg' : ''}</strong></span>
                                    ${details ? `<span class="details-text"><i class="fas fa-info-circle"></i> ${details}</span>` : ''}
                                </div>`;

                    // Afficher la performance précédente si elle existe
                    const prevPerf = findPreviousPerformance(item.name);
                    if (prevPerf) {
                        const dateStr = prevPerf.date.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short' });
                        const prevReps = prevPerf.reps ?? '-';
                        const prevWeight = prevPerf.weight ?? '-';
                        infoHtml += `<div class="previous-performance">
                                        <i class="fas fa-history"></i>
                                        <span>Dernière fois (${dateStr}): <strong>${prevReps} reps</strong> à <strong>${prevWeight}${prevWeight !== '-' ? ' kg' : ''}</strong></span>
                                    </div>`;
                    }

                } else if (item.type === 'break') {
                    infoHtml = `<div class="break-info">
                                    <i class="fas ${getIconForType('break')}"></i>
                                    <span>Pause: ${formatTime(item.duration || 0)}</span>
                                </div>`;

                    // Afficher l'exercice suivant
                    const nextExerciseIndex = currentItemIndex + 1;
                    if (nextExerciseIndex < currentWorkoutPlan.length && currentWorkoutPlan[nextExerciseIndex].type === 'exercise') {
                        const nextEx = currentWorkoutPlan[nextExerciseIndex];
                        const nextReps = nextEx.reps ?? '-';
                        const nextWeight = nextEx.weight ?? '-';
                        infoHtml += `<div class="break-info" style="margin-top: 8px; opacity: 0.8;">
                                        <i class="fas fa-arrow-right"></i>
                                        <span>Suivant: ${nextEx.name || '?'} (${nextReps} reps @ ${nextWeight}${nextWeight !== '-' ? 'kg' : ''})</span>
                                    </div>`;
                    }
                }
                break;

            default: // Cas inattendu
                exerciseName = 'Inconnu';
                infoHtml = '<p>État inconnu.</p>';
                progressText = '';
                break;
        }

        // Appliquer les mises à jour au DOM
        currentExerciseNameDisplay.textContent = exerciseName;
        currentExerciseContainer.innerHTML = infoHtml;
        progressTextArea.textContent = progressText;

        // Mettre à jour la classe d'état sur le body pour CSS conditionnel
        // (déjà fait dans setState, mais on assure ici aussi)
        const stateClassPrefix = 'state-';
        body.className = Array.from(body.classList)
                              .filter(cls => !cls.startsWith(stateClassPrefix))
                              .join(' ') + ` ${stateClassPrefix}${currentState}`;
        body.classList.toggle('workout-active', !['idle', 'finished'].includes(currentState));
    }

    // Icônes FA basées sur l'état ou le type
    function getIconForState(state) {
        switch(state) {
            case 'exercise': return 'fa-dumbbell';
            case 'break': return 'fa-hourglass-half';
            case 'preparing': return 'fa-spinner';
            case 'paused': return 'fa-pause-circle';
            case 'finished': return 'fa-check-circle';
            case 'idle': return 'fa-play-circle';
            default: return 'fa-question-circle';
        }
    }
    function getIconForType(type) {
        return type === 'exercise' ? 'fa-dumbbell' : 'fa-hourglass-half';
    }

    // Définit l'état principal de l'application et met à jour l'UI
    function setState(newState) {
        // Sécurité: vérifier que les éléments DOM cruciaux existent
        if (!startPauseBtn || !skipBtn || !finishBtn || !resetBtn || !timerStateDisplay || !workoutSection || !timerDisplayElement) {
            console.error("setState: Éléments DOM critiques manquants. Impossible de changer d'état.");
            // Tenter une réinitialisation douce si possible? Ou juste logguer.
            return;
        }

        const previousState = currentState;
        // Ne pas changer si le nouvel état est identique à l'ancien
        if (previousState === newState) {
             console.log(`State: Déjà en état '${newState}'.`);
             return;
        }
        currentState = newState;
        console.log(`Changement d'état: ${previousState} -> ${newState}`);

        // Nettoyer les timers précédents
        clearInterval(timerInterval);
        clearInterval(prepareCountdownInterval);

        // Gérer la visibilité et style de l'indicateur d'état textuel
        timerStateDisplay.classList.remove('preparing'); // Retirer animation spécifique si présente
        timerStateDisplay.classList.toggle('visible', newState !== 'idle'); // Visible sauf si idle

        // Retirer animation de fin si présente
        timerDisplayElement.classList.remove('finished-animation');

        // Mettre à jour la classe d'état sur le body
        const stateClassPrefix = 'state-';
        document.body.className = Array.from(document.body.classList)
                                      .filter(cls => !cls.startsWith(stateClassPrefix))
                                      .join(' ') + ` ${stateClassPrefix}${currentState}`;
        document.body.classList.toggle('workout-active', !['idle', 'finished'].includes(newState));

        // Réinitialiser les classes spécifiques des boutons de contrôle
        startPauseBtn.className = ''; // Va être redéfini ci-dessous

        // Désactiver tous les boutons par défaut, puis activer sélectivement
        startPauseBtn.disabled = true;
        skipBtn.disabled = true;
        finishBtn.disabled = true;
        resetBtn.disabled = true;

        // Gérer l'état des boutons de navigation principaux
        const isTimerActive = ['preparing', 'exercise', 'break', 'paused'].includes(newState);
        navButtons.forEach(btn => btn.disabled = !(googleAccessToken && programsLoaded && !isTimerActive));
        navHistoryBtn.disabled = isTimerActive;
        navProgressBtn.disabled = !googleAccessToken || isTimerActive; // Besoin d'être loggué et timer inactif

        // Cacher l'overlay d'ajustement des répétitions
        hideRepAdjustmentOverlay();

        // Logique spécifique à chaque état
        switch (newState) {
            case 'idle':
                isTimerRunning = false;
                isWorkoutActive = false;
                workoutFinished = false;
                timeLeft = 0;
                totalTime = 0;
                // Activer Démarrer si loggué, programmes chargés et type sélectionné
                startPauseBtn.disabled = !(googleAccessToken && programsLoaded && !!currentWorkoutType);
                startPauseBtn.innerHTML = `<i class="fas ${getIconForState('idle')}"></i> Démarrer`;
                startPauseBtn.className = 'start-btn';
                // Activer Reset si loggué et type sélectionné
                resetBtn.disabled = !(googleAccessToken && !!currentWorkoutType);
                break;

            case 'preparing':
                isWorkoutActive = true;
                timerStateDisplay.classList.add('preparing'); // Ajoute animation pulse
                prepareTimeLeft = PREPARE_DURATION;
                startPauseBtn.innerHTML = `<i class="fas ${getIconForState('preparing')} fa-spin"></i> Prêt...`;
                startPauseBtn.className = 'preparing-btn'; // Style spécial (non cliquable)
                startPauseBtn.disabled = true; // Non interactif pendant prépa
                resetBtn.disabled = !googleAccessToken; // Reset possible si loggué
                startPrepareCountdown(); // Lance le décompte
                if (!workoutStartTime) workoutStartTime = Date.now(); // Marquer début si pas déjà fait
                break;

            case 'exercise':
                isWorkoutActive = true;
                isTimerRunning = false; // Pas de timer pour l'exercice lui-même
                timeLeft = 0; // Pas de temps restant pour exo (basé sur reps/manuel)
                totalTime = 0;
                if (googleAccessToken) {
                    startPauseBtn.disabled = false; // Activer bouton "Fait"
                    startPauseBtn.innerHTML = `<i class="fas ${getIconForType('exercise')}"></i> Fait`;
                    startPauseBtn.className = 'done-btn';
                    skipBtn.disabled = false; // Activer Suivant
                    finishBtn.disabled = false; // Activer Finir
                    resetBtn.disabled = false; // Activer Reset
                }
                findNextExerciseForAdjustment(); // Préparer index pour overlay
                break;

            case 'break':
                isWorkoutActive = true;
                isTimerRunning = true; // Timer actif pour le repos
                if (googleAccessToken) {
                    startPauseBtn.disabled = false; // Activer bouton Pause
                    startPauseBtn.innerHTML = `<i class="fas ${getIconForState('paused')}"></i> Pause`;
                    startPauseBtn.className = 'pause-btn';
                    skipBtn.disabled = false; // Activer Suivant (pour passer le repos)
                    finishBtn.disabled = false; // Activer Finir
                    resetBtn.disabled = false; // Activer Reset
                }
                startBreakTimer(); // Lance le timer de repos
                findNextExerciseForAdjustment(); // Préparer index pour overlay (pour après la pause)
                break;

            case 'paused':
                isWorkoutActive = true;
                isTimerRunning = false; // Timer arrêté
                if (googleAccessToken) {
                    startPauseBtn.disabled = false; // Activer bouton Reprendre
                    startPauseBtn.innerHTML = `<i class="fas fa-play"></i> Reprendre`;
                    startPauseBtn.className = 'resume-btn';
                    skipBtn.disabled = false; // Activer Suivant
                    finishBtn.disabled = false; // Activer Finir
                    resetBtn.disabled = false; // Activer Reset
                }
                break;

            case 'finished':
                isWorkoutActive = false;
                isTimerRunning = false;
                workoutFinished = true;
                wasFinishedState = true; // Marqueur pour savoir qu'on est passé par 'finished'
                timeLeft = 0;
                totalTime = 0;
                elapsedWorkoutEstimatedSeconds = totalWorkoutEstimatedSeconds; // Marquer comme 100% complété
                startPauseBtn.disabled = true; // Désactiver pdt affichage résumé
                startPauseBtn.innerHTML = `<i class="fas ${getIconForState('finished')}"></i> Terminé`;
                startPauseBtn.className = 'finished-btn';
                resetBtn.disabled = !googleAccessToken; // Activer Reset si loggué
                showMessage('Entraînement terminé ! 💪', 3000);
                vibrate([150, 50, 150]); // Vibration de succès
                endSound(); // Son de fin
                // Sauvegarder une copie profonde du plan tel qu'il était à la fin
                originalCompletedWorkoutPlan = JSON.parse(JSON.stringify(currentWorkoutPlan));
                saveWorkoutToHistory(); // Sauvegarde dans l'historique local et Drive
                clearInProgressState(); // Nettoyer sauvegarde état en cours
                timerDisplayElement.classList.add('finished-animation'); // Animation visuelle
                setTimeout(populateAndShowSummary, 500); // Afficher le résumé après une courte pause
                break;

            default:
                console.error("État inconnu rencontré:", newState);
                currentState = 'idle'; // Revenir à l'état idle par sécurité
                updateAuthUI(!!googleAccessToken); // Mettre à jour UI pour idle
                break;
        }

        // Mettre à jour les affichages après chaque changement d'état
        updateTimerDisplay();
        updateWorkoutInfo();
    }

    // Lance le décompte de préparation
    function startPrepareCountdown() {
        if (prepareCountdownInterval) clearInterval(prepareCountdownInterval);
        prepareTimeLeft = PREPARE_DURATION;
        updateTimerDisplay(); // Afficher temps initial
        updateWorkoutInfo(); // Afficher infos prépa
        timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`; // Texte spécifique

        prepareCountdownInterval = setInterval(() => {
            prepareTimeLeft--;
            updateTimerDisplay();
            updateWorkoutInfo();
            timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`;

            if (prepareTimeLeft <= 0) {
                clearInterval(prepareCountdownInterval);
                endSound(); // Son début d'étape
                vibrate(); // Vibration début d'étape
                const firstItem = currentWorkoutPlan[0];
                if (!firstItem) { // Sécurité: si plan vide
                    resetCurrentWorkout();
                    return;
                }
                // Passer à l'état de la première étape (exo ou break)
                const nextState = firstItem.type === 'exercise' ? 'exercise' : 'break';
                setState(nextState);
                if (nextState === 'break') { // Si première étape est un break, initialiser son timer
                    totalTime = firstItem.duration || 0;
                    timeLeft = totalTime;
                }
                saveInProgressState(); // Sauvegarder l'état au début de la première étape
            }
        }, 1000);
    }

    // Lance le timer pour une pause
    function startBreakTimer() {
        if (timerInterval) clearInterval(timerInterval);
        updateTimerDisplay(); // Afficher temps initial de pause

        timerInterval = setInterval(() => {
            if (timeLeft > 0) {
                timeLeft--;
                updateTimerDisplay();
                saveInProgressState(); // Sauvegarder progression pendant la pause
            } else {
                clearInterval(timerInterval);
                handleItemCompletion(true); // Gérer fin de pause naturelle
            }
        }, 1000);
    }

    // Gère la fin d'une étape (exercice 'Fait', fin de pause, skip)
    function handleItemCompletion(naturalEnd = false) {
        // Ne rien faire si pas dans un état actif approprié
        if (!['exercise', 'break', 'paused'].includes(currentState)) return;

        const completedItemIndex = currentItemIndex;
        const completedItem = currentWorkoutPlan[completedItemIndex];

        // Ajouter la durée estimée de l'étape terminée au total écoulé (pour barre globale)
        if (completedItem?.estimatedDuration) {
            elapsedWorkoutEstimatedSeconds += completedItem.estimatedDuration;
        }

        // Si c'était un exercice et qu'un ajustement de reps a été fait via l'overlay
        if (completedItem?.type === 'exercise' && currentRepAdjustment !== 0) {
            const baseReps = completedItem.reps || 0;
            // Stocker les reps réellement effectuées (base + ajustement)
            // Utiliser ?? pour garder la valeur si 0 est valide
            completedItem.actualReps = Math.max(0, baseReps + currentRepAdjustment);
            console.log(`Reps ajustées pour ${completedItem.name}: ${baseReps} + (${currentRepAdjustment}) = ${completedItem.actualReps}`);
            currentRepAdjustment = 0; // Réinitialiser l'ajustement après application
        }

        // Son/Vibration si fin naturelle d'une pause
        if (naturalEnd && currentState === 'break') {
            endSound();
            vibrate();
        }

        // Passer à l'étape suivante
        currentItemIndex++;
        saveInProgressState(); // Sauvegarder avant de changer d'état

        // Vérifier si c'était la dernière étape
        if (currentItemIndex >= currentWorkoutPlan.length) {
            setState('finished'); // Terminer l'entraînement
        } else {
            // Passer à l'étape suivante
            const nextItem = currentWorkoutPlan[currentItemIndex];
            if (!nextItem) { // Sécurité: si l'étape suivante est invalide
                setState('finished');
                return;
            }
            // Définir le nouvel état (exercice ou pause)
            const nextState = nextItem.type === 'exercise' ? 'exercise' : 'break';
            setState(nextState);
            // Si la nouvelle étape est une pause, initialiser son timer
            if (nextState === 'break') {
                totalTime = nextItem.duration || 0;
                timeLeft = totalTime;
            }
        }
    }

    // Termine prématurément l'entraînement
    function forceFinishWorkout() {
        if (!isWorkoutActive || workoutFinished || currentState === 'preparing') return;
        // Confirmation utilisateur
        if (confirm("Êtes-vous sûr de vouloir terminer l'entraînement maintenant ?")) {
            clearInterval(timerInterval);
            clearInterval(prepareCountdownInterval);
            setState('finished'); // Passer à l'état final
            showMessage("Entraînement terminé manuellement.", 2500);
        }
    }

    // Charge un type d'entraînement (Push/Pull/Legs)
    function loadWorkout(type) {
        if (!googleAccessToken) { showMessage("Connectez-vous pour charger un entraînement.", 3000, true); return; }
        if (!programsLoaded) { showMessage("Programmes non disponibles. Vérifiez la connexion Drive.", 3000, true); return; }

        // Si un autre workout est actif, demander confirmation
        if (isWorkoutActive && currentWorkoutType !== type) {
            if (!confirm(`Un entraînement "${currentWorkoutType}" est en cours. Voulez-vous l'arrêter et charger "${type}" ?`)) {
                setActiveWorkoutNav(currentWorkoutType); // Rétablir bouton actif
                return; // Annuler le chargement
            }
            resetCurrentWorkout(); // Arrêter et réinitialiser l'ancien workout
        } else if (currentState === 'finished' && currentWorkoutType !== type) {
            // Si fini, mais on charge un autre type, reset d'abord
            resetCurrentWorkout();
        } else if (currentWorkoutType === type && (isWorkoutActive || currentState === 'idle' || currentState === 'finished')) {
             // Si on reclique sur le même type déjà chargé/actif/fini
            showMessage(`"${type}" est déjà ${currentState === 'idle' ? 'sélectionné' : (currentState === 'finished' ? 'terminé' : 'en cours')}. Utilisez Reset pour recommencer.`, 3000);
            showSection('workout'); // Assurer que la section timer est visible
            setActiveWorkoutNav(type); // Assurer que le bouton est actif
            return;
        }

        // Vérifier si le programme existe dans les données chargées/par défaut
        if (!loadedWorkouts[type] || !Array.isArray(loadedWorkouts[type])) {
            showMessage(`Erreur: Programme "${type}" invalide ou non trouvé.`, 4000, true);
            console.error(`Tentative de chargement d'un programme invalide pour "${type}". Données:`, loadedWorkouts[type]);
            currentWorkoutType = null; // Désélectionner
            setActiveWorkoutNav(null);
            return;
        }
        if (loadedWorkouts[type].length === 0) {
            showMessage(`Attention: Le programme "${type}" est vide.`, 4000);
            // Permettre de charger mais avertir
        }

        console.log(`Chargement du programme: ${type}`);
        currentWorkoutType = type;
        // Créer une copie profonde pour éviter de modifier l'original chargé
        currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[type]));

        // Calculer le temps estimé et réinitialiser les compteurs
        totalWorkoutEstimatedSeconds = calculateTotalEstimatedTime(currentWorkoutPlan);
        elapsedWorkoutEstimatedSeconds = 0;
        currentItemIndex = 0;
        workoutStartTime = null;
        isTimerRunning = false;
        isWorkoutActive = false;
        workoutFinished = false;
        currentRepAdjustment = 0; // Reset ajustement reps

        // Mettre à jour l'UI
        setActiveWorkoutNav(type);
        showSection('workout'); // Afficher section timer
        closeSummary(false); // Fermer résumé si ouvert
        setState('idle'); // Mettre en état prêt à démarrer
        showMessage(`Programme "${type}" chargé. Prêt à démarrer !`, 2500);
    }

    // Réinitialise complètement l'entraînement en cours ou sélectionné
    function resetCurrentWorkout() {
        console.log("Réinitialisation de l'entraînement...");
        clearInterval(timerInterval);
        clearInterval(prepareCountdownInterval);

        const typeReset = currentWorkoutType; // Garder trace du type qui a été reset

        // Réinitialiser toutes les variables d'état liées à l'entraînement
        currentWorkoutType = null;
        currentWorkoutPlan = [];
        originalCompletedWorkoutPlan = [];
        currentItemIndex = 0;
        workoutStartTime = null;
        isTimerRunning = false;
        isWorkoutActive = false;
        workoutFinished = false;
        wasFinishedState = false;
        timeLeft = 0;
        totalTime = 0;
        prepareTimeLeft = 0;
        totalWorkoutEstimatedSeconds = 0;
        elapsedWorkoutEstimatedSeconds = 0;
        currentRepAdjustment = 0;

        clearInProgressState(); // Supprimer la sauvegarde locale de l'état
        closeSummary(false); // Fermer le modal de résumé s'il est ouvert
        timerDisplayElement.classList.remove('finished-animation'); // Retirer l'animation de fin
        setActiveWorkoutNav(null); // Désactiver tous les boutons de nav workout
        showSection('workout'); // Assurer que la section timer est visible
        setState('idle'); // Revenir à l'état initial

        if (typeReset) {
            showMessage(`Entraînement "${typeReset}" réinitialisé.`, 2000);
        }
    }

    // Affiche un message flottant en bas de l'écran
    function showMessage(msg, duration = 3000, isError = false) {
        if (!messageArea) return;
        messageArea.textContent = msg;
        messageArea.style.backgroundColor = isError ? 'var(--neon-red)' : 'rgba(var(--secondary-bg-color-dark-rgb), 0.9)';
        messageArea.style.color = isError ? '#fff' : 'var(--primary-text-color)';
        messageArea.style.borderColor = isError ? 'var(--neon-red)' : 'var(--border-color)';
        messageArea.classList.add('visible');

        // Annuler le timeout précédent s'il existe
        if (messageTimeoutId) clearTimeout(messageTimeoutId);

        // Cacher le message après la durée spécifiée
        messageTimeoutId = setTimeout(() => {
            messageArea.classList.remove('visible');
        }, duration);
    }

    // --- Gestion Thème ---
    function applyTheme(theme) {
        const body = document.body;
        currentTheme = theme;
        body.classList.remove('light-theme', 'dark-theme');
        body.classList.add(theme + '-theme');
        if (themeToggleBtn) {
            themeToggleBtn.innerHTML = theme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            themeToggleBtn.setAttribute('aria-label', theme === 'dark' ? 'Passer au thème clair' : 'Passer au thème sombre');
        }
        try {
            localStorage.setItem('theme', theme);
            console.log(`Thème appliqué et sauvegardé: ${theme}`);
        } catch (e) {
            console.warn("Impossible de sauvegarder le thème dans localStorage:", e);
        }
        // Mettre à jour les couleurs des graphiques si initialisés
        updateChartColors();
    }

    function toggleTheme() {
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        applyTheme(newTheme);
    }

    function loadSavedTheme() {
        let savedTheme = 'dark'; // Défaut
        try {
            savedTheme = localStorage.getItem('theme') || 'dark';
        } catch (e) {
            console.warn("Impossible de lire le thème depuis localStorage:", e);
        }
        applyTheme(savedTheme);
    }

    // --- Navigation & Affichage Sections ---
    function showSection(sectionId) {
        const sections = [workoutSection, historySection, progressSection];
        const navLinks = {
            'workout-section': [...navButtons], // Associe aux boutons Push/Pull/Legs
            'history-section': [navHistoryBtn],
            'progress-section': [navProgressBtn]
        };

        // Masquer toutes les sections et désactiver tous les liens de nav associés
        sections.forEach(section => section.classList.add('section-hidden'));
        Object.values(navLinks).flat().forEach(btn => btn?.classList.remove('active'));

        // Afficher la section demandée
        const sectionToShow = document.getElementById(sectionId);
        if (sectionToShow) {
            sectionToShow.classList.remove('section-hidden');
            console.log(`Affichage section: ${sectionId}`);

            // Activer le lien de navigation correspondant
            const linksToActivate = navLinks[sectionId];
            if (linksToActivate) {
                // Si c'est la section workout, activer le bouton du type actuel
                if (sectionId === 'workout-section' && currentWorkoutType) {
                    const activeWorkoutBtn = document.getElementById(`nav-${currentWorkoutType.toLowerCase()}`);
                    activeWorkoutBtn?.classList.add('active');
                } else {
                    // Sinon, activer le bouton direct (Historique/Progression)
                    linksToActivate.forEach(btn => btn?.classList.add('active'));
                }
            }
        } else {
             console.error(`Section introuvable: ${sectionId}`);
        }
    }

    // Met en évidence le bouton de navigation pour le workout actif/sélectionné
    function setActiveWorkoutNav(type) {
        navButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.workout === type);
        });
        // Si un type est sélectionné, on montre la section workout
        if (type) {
            showSection('workout-section');
        }
    }

    // --- Gestion Historique & Statistiques ---

    // Fonction principale pour afficher l'historique et les stats
    function displayHistory(period = 'week') {
        if (!historyList || !statsDisplay || !historyChartCanvas) return;
        if (!googleAccessToken) {
            historyList.innerHTML = '<li class="no-history">Connectez-vous pour voir l\'historique.</li>';
            statsContentWrapper.innerHTML = '<p>Connectez-vous pour voir les statistiques.</p>';
            clearCharts(); // Vide le graphique historique
            setChartPlaceholder(historyChartCanvas.id, "Connectez-vous pour voir le graphique.");
            return;
        }

        console.log(`Affichage historique pour période: ${period}`);
        currentHistoryPeriod = period;

        // Mettre à jour le bouton de filtre actif
        historyFilterBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.period === period));

        // Filtrer l'historique
        const filteredHistory = filterHistoryByPeriod(workoutHistory, period);

        // Afficher la liste
        renderHistoryList(filteredHistory);

        // Calculer et afficher les statistiques
        calculateAndDisplayStats(filteredHistory);

        // Mettre à jour le graphique
        renderHistoryChart(filteredHistory);
    }

    // Filtre l'historique en fonction de la période sélectionnée
    function filterHistoryByPeriod(history, period) {
        const now = new Date();
        let startDate = new Date();

        switch (period) {
            case 'week':
                startDate.setDate(now.getDate() - 7);
                break;
            case 'month':
                startDate.setMonth(now.getMonth() - 1);
                break;
            case 'year':
                startDate.setFullYear(now.getFullYear() - 1);
                break;
            case 'all':
                // Pas de filtre de date pour 'tout'
                return history;
            default:
                startDate.setDate(now.getDate() - 7); // Semaine par défaut
        }
        startDate.setHours(0, 0, 0, 0); // Début du jour pour la comparaison

        return history.filter(entry => new Date(entry.date) >= startDate);
    }

    // Remplit la liste <ul> avec les éléments d'historique filtrés
    function renderHistoryList(filteredHistory) {
        if (filteredHistory.length === 0) {
            historyList.innerHTML = '<li class="no-history">Aucun entraînement enregistré pour cette période.</li>';
            return;
        }

        historyList.innerHTML = filteredHistory
            // Trier du plus récent au plus ancien
            .sort((a, b) => new Date(b.date) - new Date(a.date))
            .map(entry => {
                const date = new Date(entry.date);
                const formattedDate = date.toLocaleDateString('fr-FR', { weekday: 'short', day: '2-digit', month: 'short' });
                const formattedTime = date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                const durationSeconds = entry.durationSeconds || 0;
                const formattedDuration = durationSeconds > 0 ? formatTime(durationSeconds) : 'N/A';
                const type = entry.type || 'Inconnu';

                // Calculer volume total pour l'entrée si possible
                let totalVolume = 0;
                if (entry.exercises && Array.isArray(entry.exercises)) {
                    totalVolume = entry.exercises.reduce((sum, ex) => {
                        const reps = ex.actualReps ?? ex.reps ?? 0;
                        const weight = ex.actualWeight ?? ex.weight ?? 0;
                        return sum + (reps * weight);
                    }, 0);
                }

                return `
                    <li>
                        <span class="history-item-date">
                            ${formattedDate} <small>(${formattedTime})</small>
                        </span>
                        <span class="history-item-type">${type}</span>
                        ${totalVolume > 0 ? `<span class="history-item-volume" style="color: var(--neon-green); font-size:0.9em;">${totalVolume.toFixed(0)} kg vol.</span>` : ''}
                        <span class="history-item-duration">${formattedDuration}</span>
                    </li>
                `;
            }).join('');
    }

    // Calcule et affiche les statistiques (total séances, durée moyenne, etc.)
    function calculateAndDisplayStats(filteredHistory) {
        const numWorkouts = filteredHistory.length;
        let totalDuration = 0;
        let workoutTypes = {}; // Compter les types
        let totalVolume = 0;

        filteredHistory.forEach(entry => {
            totalDuration += entry.durationSeconds || 0;
            const type = entry.type || 'Inconnu';
            workoutTypes[type] = (workoutTypes[type] || 0) + 1;
            // Calculer volume
            if (entry.exercises && Array.isArray(entry.exercises)) {
                totalVolume += entry.exercises.reduce((sum, ex) => {
                    const reps = ex.actualReps ?? ex.reps ?? 0;
                    const weight = ex.actualWeight ?? ex.weight ?? 0;
                    return sum + (reps * weight);
                }, 0);
            }
        });

        const avgDuration = numWorkouts > 0 ? totalDuration / numWorkouts : 0;
        const formattedAvgDuration = formatTime(avgDuration);

        // Créer le HTML pour les statistiques
        let statsHtml = `<p><i class="fas fa-calendar-check"></i> Séances: <strong>${numWorkouts}</strong></p>`;
        if (numWorkouts > 0) {
            statsHtml += `<p><i class="fas fa-stopwatch"></i> Durée totale: <strong>${formatTime(totalDuration)}</strong></p>`;
            statsHtml += `<p><i class="fas fa-clock"></i> Durée moyenne: <strong>${formattedAvgDuration}</strong></p>`;
             statsHtml += `<p><i class="fas fa-weight-hanging"></i> Volume total: <strong>${totalVolume.toFixed(0)} kg</strong></p>`;
            statsHtml += `<p><i class="fas fa-tags"></i> Répartition:</p><ul>`;
            for (const type in workoutTypes) {
                statsHtml += `<li style="margin-left: 25px; font-size: 0.95em;">- ${type}: ${workoutTypes[type]}</li>`;
            }
            statsHtml += `</ul>`;
        } else {
            statsHtml += '<p>Aucune donnée pour calculer les statistiques.</p>';
        }

        statsContentWrapper.innerHTML = statsHtml;

        // Message motivationnel (simple exemple)
        const motivationalMessage = statsDisplay.querySelector('.motivational-message');
        if (motivationalMessage) {
             if (numWorkouts > 5) motivationalMessage.textContent = "Super régularité ! Continuez comme ça ! 💪";
             else if (numWorkouts > 0) motivationalMessage.textContent = "Chaque séance compte ! Bien joué !";
             else motivationalMessage.textContent = "Prêt à commencer votre première séance ?";
        }
    }

    // Met à jour le graphique de l'historique (volume par jour)
    function renderHistoryChart(filteredHistory) {
        if (!historyChartCanvas) return;
        const ctx = historyChartCanvas.getContext('2d');

        if (filteredHistory.length === 0) {
            setChartPlaceholder(historyChartCanvas.id, "Aucune donnée pour afficher le graphique.");
            clearCharts();
            return;
        } else {
             setChartPlaceholder(historyChartCanvas.id, "", false); // Cacher le placeholder
        }

        // Préparer les données pour Chart.js : Volume par jour
        const dataByDate = {};
        filteredHistory.forEach(entry => {
            const date = new Date(entry.date).toISOString().split('T')[0]; // Jour YYYY-MM-DD
            let dailyVolume = 0;
            if (entry.exercises && Array.isArray(entry.exercises)) {
                dailyVolume = entry.exercises.reduce((sum, ex) => {
                    const reps = ex.actualReps ?? ex.reps ?? 0;
                    const weight = ex.actualWeight ?? ex.weight ?? 0;
                    return sum + (reps * weight);
                }, 0);
            }
            dataByDate[date] = (dataByDate[date] || 0) + dailyVolume;
        });

        const labels = Object.keys(dataByDate).sort(); // Trier les dates
        const data = labels.map(date => dataByDate[date]);

        const chartData = {
            labels: labels,
            datasets: [{
                label: 'Volume Total (kg)',
                data: data,
                backgroundColor: 'rgba(var(--neon-blue-rgb), 0.5)',
                borderColor: `rgb(${getComputedStyle(document.documentElement).getPropertyValue('--neon-blue-rgb')})`,
                borderWidth: 2,
                tension: 0.3, // Courbe légèrement lissée
                fill: true // Remplir sous la courbe
            }]
        };

        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Volume (kg)' },
                    ticks: { color: `var(--secondary-text-color)` },
                    grid: { color: `var(--accent-border-color)` }
                },
                x: {
                    title: { display: true, text: 'Date' },
                    ticks: { color: `var(--secondary-text-color)` },
                    grid: { display: false } // Masquer grille verticale
                }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: `rgba(var(--bg-color-dark-rgb), 0.8)`,
                    titleColor: `var(--primary-text-color)`,
                    bodyColor: `var(--primary-text-color)`,
                    callbacks: {
                        label: function(context) {
                            return ` Volume: ${context.parsed.y.toFixed(0)} kg`;
                        }
                    }
                }
            }
        };

        // Créer ou mettre à jour le graphique
        if (historyChart) {
            historyChart.data = chartData;
            historyChart.options = chartOptions; // Appliquer options pour thème
            historyChart.update();
        } else {
            historyChart = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: chartOptions
            });
        }
    }

    // Met à jour les couleurs des graphiques (appelé lors du changement de thème)
    function updateChartColors() {
        const textColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-text-color');
        const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-border-color');
        const primaryColor = `rgb(${getComputedStyle(document.documentElement).getPropertyValue('--neon-blue-rgb')})`;
        const secondaryColor = `rgb(${getComputedStyle(document.documentElement).getPropertyValue('--neon-pink-rgb')})`;
        const bgColorTooltip = `rgba(${getComputedStyle(document.documentElement).getPropertyValue('--bg-color-dark-rgb')}, 0.8)`;
        const textColorTooltip = getComputedStyle(document.documentElement).getPropertyValue('--primary-text-color');

        [historyChart, exercisePerfChart, volumeLoadChart].forEach(chart => {
            if (chart) {
                chart.options.scales.x.ticks.color = textColor;
                chart.options.scales.x.grid.color = borderColor;
                chart.options.scales.y.ticks.color = textColor;
                chart.options.scales.y.grid.color = borderColor;
                chart.options.plugins.tooltip.backgroundColor = bgColorTooltip;
                chart.options.plugins.tooltip.titleColor = textColorTooltip;
                chart.options.plugins.tooltip.bodyColor = textColorTooltip;
                // Mettre à jour couleurs spécifiques datasets si nécessaire
                 if (chart.data.datasets[0]) {
                    chart.data.datasets[0].borderColor = primaryColor;
                    chart.data.datasets[0].backgroundColor = primaryColor.replace(')', ', 0.5)').replace('rgb', 'rgba');
                 }
                 if (chart.data.datasets[1]) { // Pour graph exo avec poids/reps
                    chart.data.datasets[1].borderColor = secondaryColor;
                     chart.data.datasets[1].backgroundColor = secondaryColor.replace(')', ', 0.5)').replace('rgb', 'rgba');
                 }
                chart.update('none'); // 'none' pour éviter ré-animation
            }
        });
    }

    // Efface les instances de graphiques
    function clearCharts() {
        [historyChart, exercisePerfChart, volumeLoadChart].forEach((chart, index) => {
            if (chart) {
                chart.destroy();
                if (index === 0) historyChart = null;
                else if (index === 1) exercisePerfChart = null;
                else if (index === 2) volumeLoadChart = null;
            }
        });
    }

    // Gère l'affichage d'un message si le canvas est vide
    function setChartPlaceholder(canvasId, message, show = true) {
        const placeholderId = canvasId.replace('-canvas', '') + '-placeholder'; // Convention de nommage
        const placeholder = document.getElementById(placeholderId);
        const canvas = document.getElementById(canvasId);
        if (placeholder && canvas) {
            placeholder.textContent = message;
            placeholder.style.display = show ? 'block' : 'none';
            canvas.style.opacity = show ? '0.3' : '1'; // Estomper canvas si placeholder visible
        }
    }

    // --- Gestion Progression ---

    // Peuple le sélecteur d'exercices basé sur l'historique
    function populateExerciseSelect() {
        if (!exerciseSelect || !workoutHistory) return;

        const uniqueExercises = new Set();
        workoutHistory.forEach(entry => {
            entry.exercises?.forEach(ex => uniqueExercises.add(ex.name));
        });

        const sortedExercises = Array.from(uniqueExercises).sort();

        // Vider les anciennes options (sauf la première "Tous")
        exerciseSelect.innerHTML = '<option value="all">Tous les exercices</option>';

        sortedExercises.forEach(exName => {
            const option = document.createElement('option');
            option.value = exName;
            option.textContent = exName;
            exerciseSelect.appendChild(option);
        });
         // Déclencher affichage initial après peuplement
         displayExerciseProgress();
         displayVolumeLoad();
    }

    // Affiche le graphique de progression pour l'exercice/métrique/période sélectionné
    function displayExerciseProgress() {
        if (!exerciseProgressChart || !googleAccessToken) {
             setChartPlaceholder(exerciseProgressChart.canvas.id, "Connectez-vous pour voir la progression.");
             clearCharts();
             return;
        }

        const selectedExercise = exerciseSelect.value;
        const selectedMetric = metricSelect.value;
        const selectedPeriod = periodSelect.value;

        const filteredHistory = filterHistoryByPeriod(workoutHistory, selectedPeriod);

        if (selectedExercise === 'all') {
             setChartPlaceholder(exerciseProgressChart.canvas.id, "Sélectionnez un exercice spécifique pour voir sa progression.");
             if (exercisePerfChart) { exercisePerfChart.destroy(); exercisePerfChart = null; } // Détruire ancien graph
             return;
        }
         if (filteredHistory.length === 0) {
             setChartPlaceholder(exerciseProgressChart.canvas.id, "Aucune donnée pour cet exercice et cette période.");
             if (exercisePerfChart) { exercisePerfChart.destroy(); exercisePerfChart = null; }
             return;
         } else {
              setChartPlaceholder(exerciseProgressChart.canvas.id, "", false);
         }


        // Extraire les données pour l'exercice sélectionné
        const exerciseData = [];
        filteredHistory.forEach(entry => {
            entry.exercises?.forEach(ex => {
                if (ex.name === selectedExercise) {
                    exerciseData.push({
                        date: new Date(entry.date),
                        reps: ex.actualReps ?? ex.reps ?? 0,
                        weight: ex.actualWeight ?? ex.weight ?? 0,
                        volume: (ex.actualReps ?? ex.reps ?? 0) * (ex.actualWeight ?? ex.weight ?? 0)
                    });
                }
            });
        });

         // Trier par date
        exerciseData.sort((a, b) => a.date - b.date);

        if (exerciseData.length === 0) {
             setChartPlaceholder(exerciseProgressChart.canvas.id, "Aucune donnée trouvée pour cet exercice dans la période sélectionnée.");
              if (exercisePerfChart) { exercisePerfChart.destroy(); exercisePerfChart = null; }
             return;
         } else {
             setChartPlaceholder(exerciseProgressChart.canvas.id, "", false);
         }


        const labels = exerciseData.map(d => d.date.toLocaleDateString('fr-CA')); // YYYY-MM-DD
        let datasets = [];

        if (selectedMetric === 'weight' || selectedMetric === 'reps' || selectedMetric === 'volume') {
             datasets.push({
                label: selectedMetric === 'weight' ? 'Poids (kg)' : (selectedMetric === 'reps' ? 'Répétitions' : 'Volume (kg)'),
                data: exerciseData.map(d => d[selectedMetric]),
                borderColor: `rgb(${getComputedStyle(document.documentElement).getPropertyValue('--neon-blue-rgb')})`,
                backgroundColor: `rgba(${getComputedStyle(document.documentElement).getPropertyValue('--neon-blue-rgb')}, 0.5)`,
                tension: 0.1,
                fill: false,
                yAxisID: 'yMetric' // Associer à l'axe Y principal
            });
        }
        // Optionnel: Ajouter une deuxième métrique sur un axe Y différent?
        // Exemple: afficher poids et reps ensemble
        /* if (selectedMetric === 'weight') { // Si on regarde le poids, on peut ajouter les reps
             datasets.push({
                label: 'Répétitions',
                data: exerciseData.map(d => d.reps),
                borderColor: `rgb(${getComputedStyle(document.documentElement).getPropertyValue('--neon-pink-rgb')})`,
                backgroundColor: `rgba(${getComputedStyle(document.documentElement).getPropertyValue('--neon-pink-rgb')}, 0.5)`,
                tension: 0.1,
                fill: false,
                yAxisID: 'yReps' // Axe Y secondaire
            });
        } */

        const chartData = { labels, datasets };
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: 'index', intersect: false }, // Tooltip sur index X
            scales: {
                x: { ticks: { color: `var(--secondary-text-color)` }, grid: { display: false } },
                yMetric: { // Axe Y principal pour la métrique choisie
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: { display: true, text: selectedMetric === 'weight' ? 'Poids (kg)' : (selectedMetric === 'reps' ? 'Répétitions' : 'Volume (kg)') },
                    ticks: { color: `var(--secondary-text-color)` },
                    grid: { color: `var(--accent-border-color)` }
                },
                /* yReps: { // Axe Y secondaire (si activé)
                    type: 'linear',
                    display: selectedMetric === 'weight', // Afficher seulement si métrique principale est poids
                    position: 'right',
                    title: { display: true, text: 'Répétitions' },
                    ticks: { color: `var(--secondary-text-color)` },
                    grid: { drawOnChartArea: false } // Ne pas dessiner grille pour axe secondaire
                } */
            },
            plugins: {
                 legend: { display: datasets.length > 1 }, // Afficher légende si plusieurs datasets
                 tooltip: { /* ... options tooltip ... */ }
            }
        };

        const ctx = exerciseProgressChart.getContext('2d');
        if (exercisePerfChart) {
            exercisePerfChart.data = chartData;
            exercisePerfChart.options = chartOptions;
            exercisePerfChart.update();
        } else {
            exercisePerfChart = new Chart(ctx, { type: 'line', data: chartData, options: chartOptions });
        }
    }

    // Affiche le graphique du volume d'entraînement global
    function displayVolumeLoad() {
         if (!volumeChart || !googleAccessToken) {
             setChartPlaceholder(volumeChart.canvas.id, "Connectez-vous pour voir le volume.");
             clearCharts();
             return;
         }

         const selectedPeriod = periodSelect.value; // Utiliser même période que pour exo
         const filteredHistory = filterHistoryByPeriod(workoutHistory, selectedPeriod);

          if (filteredHistory.length === 0) {
             setChartPlaceholder(volumeChart.canvas.id, "Aucune donnée pour afficher le volume global.");
              if (volumeLoadChart) { volumeLoadChart.destroy(); volumeLoadChart = null; }
             return;
         } else {
              setChartPlaceholder(volumeChart.canvas.id, "", false);
         }

        // Agréger le volume par date (similaire à renderHistoryChart)
        const volumeByDate = {};
        filteredHistory.forEach(entry => {
            const date = new Date(entry.date).toISOString().split('T')[0];
            let dailyVolume = 0;
            entry.exercises?.forEach(ex => {
                dailyVolume += (ex.actualReps ?? ex.reps ?? 0) * (ex.actualWeight ?? ex.weight ?? 0);
            });
            volumeByDate[date] = (volumeByDate[date] || 0) + dailyVolume;
        });

        const labels = Object.keys(volumeByDate).sort();
        const data = labels.map(date => volumeByDate[date]);

        const chartData = {
            labels: labels,
            datasets: [{
                label: 'Volume Total Quotidien (kg)',
                data: data,
                backgroundColor: `rgba(${getComputedStyle(document.documentElement).getPropertyValue('--neon-green-rgb')}, 0.6)`, // Couleur verte
                borderColor: `rgb(${getComputedStyle(document.documentElement).getPropertyValue('--neon-green-rgb')})`,
                borderWidth: 1,
                barPercentage: 0.8, // Largeur barres
                categoryPercentage: 0.7
            }]
        };

        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, title: { display: true, text: 'Volume (kg)' }, ticks: { color: `var(--secondary-text-color)` }, grid: { color: `var(--accent-border-color)` } },
                x: { title: { display: true, text: 'Date' }, ticks: { color: `var(--secondary-text-color)` }, grid: { display: false } }
            },
            plugins: { legend: { display: false }, tooltip: { /* ... options ... */ } }
        };

        const ctx = volumeChart.getContext('2d');
        if (volumeLoadChart) {
            volumeLoadChart.data = chartData;
             volumeLoadChart.options = chartOptions;
            volumeLoadChart.update();
        } else {
            volumeLoadChart = new Chart(ctx, { type: 'bar', data: chartData, options: chartOptions });
        }
    }

    // --- Résumé Post-Workout (Modal) ---

    // Peuple et affiche le modal de résumé après la fin de l'entraînement
    function populateAndShowSummary() {
        if (!postWorkoutSummary || !summaryItemsList || !confirmSummaryBtn || !discardSummaryBtn || !closeSummaryBtn) {
             console.error("Éléments du modal de résumé manquants.");
             return;
        }

        // Utiliser la copie originale du plan terminé pour peupler le résumé
        const planToSummarize = originalCompletedWorkoutPlan;
        summaryTitle.textContent = `Résumé: ${currentWorkoutType || 'Séance'} (${planToSummarize.length} étapes)`;
        summaryItemsList.innerHTML = ''; // Vider la liste précédente

        summaryChangesMade = false; // Réinitialiser flag de modif

        planToSummarize.forEach((item, index) => {
            const li = document.createElement('li');
            li.classList.add('summary-item', `item-type-${item.type}`);
            li.dataset.index = index;

            let contentHtml = `<h4><i class="fas ${getIconForType(item.type)}"></i> ${item.name || 'Étape'}</h4>`;

            if (item.type === 'exercise') {
                const initialReps = item.reps ?? 0;
                const actualReps = item.actualReps ?? initialReps; // Utiliser actual si défini, sinon initial
                const initialWeight = item.weight ?? 0;
                const actualWeight = item.actualWeight ?? initialWeight; // Pareil pour poids

                contentHtml += `
                    <label for="reps-${index}">Reps Effectuées:</label>
                    <div class="input-container">
                        <button class="rep-adjust-btn" data-action="decrease" data-target="reps-${index}" aria-label="Diminuer répétitions">-</button>
                        <input type="number" id="reps-${index}" value="${actualReps}" min="0" step="1" data-initial="${initialReps}">
                        <button class="rep-adjust-btn" data-action="increase" data-target="reps-${index}" aria-label="Augmenter répétitions">+</button>
                    </div>

                    <label for="weight-${index}">Poids (kg):</label>
                    <div class="input-container">
                         <button class="rep-adjust-btn" data-action="decrease" data-target="weight-${index}" data-step="2.5" aria-label="Diminuer poids">-</button>
                         <input type="number" id="weight-${index}" value="${actualWeight}" min="0" step="2.5" data-initial="${initialWeight}">
                         <button class="rep-adjust-btn" data-action="increase" data-target="weight-${index}" data-step="2.5" aria-label="Augmenter poids">+</button>
                    </div>

                    <div class="details-container">
                        <label for="notes-${index}">Notes:</label>
                        <textarea id="notes-${index}" placeholder="Ajouter des notes sur cet exercice..." rows="1">${item.notes || ''}</textarea>
                    </div>
                `;
            } else if (item.type === 'break') {
                contentHtml += `<p><i class="fas fa-clock"></i> Durée: ${formatTime(item.duration || 0)}</p>`;
                 // Option pour ajouter note à une pause? Moins courant.
                 contentHtml += `
                    <div class="details-container">
                         <label for="notes-${index}">Notes (Pause):</label>
                         <textarea id="notes-${index}" placeholder="Notes sur la pause..." rows="1">${item.notes || ''}</textarea>
                    </div>`;
            }

            li.innerHTML = contentHtml;
            summaryItemsList.appendChild(li);
        });

        // Ajouter les écouteurs pour les boutons +/- et inputs
        summaryItemsList.querySelectorAll('input[type="number"], textarea').forEach(input => {
            input.addEventListener('change', handleSummaryInputChange);
            input.addEventListener('input', handleSummaryInputChange); // Pour textarea
        });
        summaryItemsList.querySelectorAll('.rep-adjust-btn').forEach(button => {
            button.addEventListener('click', handleSummaryAdjustClick);
        });

        // Gérer affichage boutons selon modifications
        updateConfirmDiscardButtons();

        // Afficher le modal
        postWorkoutSummary.classList.add('visible');
    }

    // Gère le clic sur les boutons +/- dans le résumé
    function handleSummaryAdjustClick(event) {
        const button = event.currentTarget;
        const action = button.dataset.action;
        const targetId = button.dataset.target;
        const step = parseFloat(button.dataset.step || '1'); // Step de 1 par défaut, ajustable (ex: pour poids)
        const input = document.getElementById(targetId);

        if (!input) return;

        let currentValue = parseFloat(input.value) || 0;
        if (action === 'increase') {
            currentValue += step;
        } else if (action === 'decrease') {
            currentValue -= step;
        }
        currentValue = Math.max(0, currentValue); // Empêcher négatif

        // Arrondir si step décimal (pour éviter imprécisions flottantes)
         if (step % 1 !== 0) {
            const decimalPlaces = step.toString().split('.')[1]?.length || 0;
            input.value = currentValue.toFixed(decimalPlaces);
         } else {
             input.value = currentValue;
         }


        // Déclencher l'événement change manuellement pour enregistrer la modif
        input.dispatchEvent(new Event('change'));
    }

    // Gère la modification d'un input/textarea dans le résumé
    function handleSummaryInputChange(event) {
        summaryChangesMade = true;
        updateConfirmDiscardButtons();
        // Optionnel: Ajouter une classe 'modified' à l'input/li
        event.target.closest('.summary-item')?.classList.add('modified');
    }

    // Met à jour l'état des boutons Confirmer/Annuler Modifs
    function updateConfirmDiscardButtons() {
        discardSummaryBtn.style.display = summaryChangesMade ? 'inline-flex' : 'none';
        closeSummaryBtn.style.display = summaryChangesMade ? 'none' : 'inline-flex';
        confirmSummaryBtn.textContent = summaryChangesMade ? 'Valider Modifs' : 'Fermer';
        confirmSummaryBtn.innerHTML = summaryChangesMade
            ? `<i class="fas fa-save"></i> Valider Modifs`
            : `<i class="fas fa-check"></i> Fermer`;
    }

    // Confirme les modifications du résumé et ferme le modal
    function confirmSummary() {
        if (summaryChangesMade) {
            console.log("Validation des modifications du résumé...");
            // Parcourir les items du résumé et mettre à jour `originalCompletedWorkoutPlan`
            summaryItemsList.querySelectorAll('.summary-item').forEach(li => {
                const index = parseInt(li.dataset.index);
                const item = originalCompletedWorkoutPlan[index];
                if (!item) return;

                const repsInput = li.querySelector(`#reps-${index}`);
                const weightInput = li.querySelector(`#weight-${index}`);
                const notesInput = li.querySelector(`#notes-${index}`);

                if (repsInput) item.actualReps = parseInt(repsInput.value);
                if (weightInput) item.actualWeight = parseFloat(weightInput.value);
                if (notesInput) item.notes = notesInput.value.trim();
            });

            // Mettre à jour l'entrée d'historique correspondante (la dernière ajoutée)
            if (workoutHistory.length > 0) {
                const lastEntry = workoutHistory[workoutHistory.length - 1];
                // S'assurer que la dernière entrée correspond bien à la séance terminée
                // (comparaison simple par date/heure pourrait être fragile, mais ok ici)
                 if (Math.abs(new Date(lastEntry.date) - workoutStartTime) < 5000) { // Tolérance 5s
                     lastEntry.exercises = originalCompletedWorkoutPlan; // Remplacer avec les données modifiées
                     console.log("Entrée d'historique mise à jour avec les modifications.");
                     // Sauvegarder l'historique mis à jour sur Drive
                     saveHistoryToDrive();
                 } else {
                      console.warn("Impossible de trouver l'entrée d'historique correspondante pour la mise à jour.");
                 }
            }
            showMessage("Modifications enregistrées.", 2000);
        } else {
            console.log("Fermeture du résumé (pas de modifications).");
        }
        closeSummary();
    }

    // Annule les modifications faites dans le résumé et ferme
    function discardSummary() {
        if (summaryChangesMade) {
            if (confirm("Annuler les modifications non enregistrées dans le résumé ?")) {
                console.log("Modifications du résumé annulées.");
                summaryChangesMade = false; // Reset flag
                closeSummary();
            }
        } else {
             closeSummary(); // Fermer normalement si pas de modifs
        }
    }

    // Ferme le modal de résumé
    function closeSummary(updateUI = true) {
        postWorkoutSummary.classList.remove('visible');
        summaryChangesMade = false; // Reset flag
        if (updateUI) {
            // Réactiver les boutons de contrôle si nécessaire (après fermeture)
            // L'état devrait être 'finished' ou 'idle' si on a reset entre temps
            setState(currentState); // Redéclenche la logique d'activation/désactivation des boutons
        }
    }


    // --- Sauvegarde & Chargement (Drive & LocalStorage) ---

    // Sauvegarde l'historique complet sur Google Drive
    async function saveHistoryToDrive() {
        if (!googleAccessToken) return; // Ne rien faire si pas connecté
        if (isSavingDriveData) { console.log("Sauvegarde Drive déjà en cours..."); return; }

        console.log("Tentative de sauvegarde de l'historique sur Drive...");
        // Assurer que l'ID du fichier historique est connu
        if (!historyFileId) {
            historyFileId = await findOrCreateFile(HISTORY_FILENAME, JSON.stringify([])); // Crée avec tableau vide si inexistant
        }

        if (historyFileId) {
            await updateFileContent(historyFileId, workoutHistory);
        } else {
            console.error("Impossible d'obtenir l'ID du fichier historique pour la sauvegarde.");
            showMessage("Erreur: Fichier historique Drive inaccessible.", 5000, true);
        }
    }

    // Charge l'historique depuis Google Drive
    async function loadHistoryFromDrive() {
        if (!googleAccessToken) return; // Ne rien faire si pas connecté

        console.log("Chargement de l'historique depuis Drive...");
        historyFileId = await findOrCreateFile(HISTORY_FILENAME, JSON.stringify([])); // Trouve ou crée

        if (historyFileId) {
            const content = await readFileContent(historyFileId);
            if (content !== null) { // Vérifier si lecture réussie (null si erreur)
                try {
                    workoutHistory = JSON.parse(content || "[]"); // Parser le JSON, ou tableau vide si vide/erreur
                    console.log(`Historique chargé depuis Drive (${workoutHistory.length} entrées).`);
                    // Sauvegarde locale (fallback ou offline?) - Optionnel
                    // localStorage.setItem('workoutHistory', JSON.stringify(workoutHistory));
                } catch (e) {
                    console.error("Erreur parsing JSON historique depuis Drive:", e);
                    showMessage("Erreur: Format historique Drive invalide. Utilisation d'un historique vide.", 5000, true);
                    workoutHistory = []; // Réinitialiser si invalide
                    // Optionnel: tenter de sauvegarder un tableau vide pour corriger?
                    // await updateFileContent(historyFileId, []);
                }
            } else {
                 console.warn("Lecture du fichier historique Drive échouée. Utilisation d'un historique vide.");
                 workoutHistory = [];
            }
        } else {
            console.error("Impossible d'obtenir l'ID du fichier historique pour le chargement.");
            showMessage("Erreur: Fichier historique Drive inaccessible.", 5000, true);
            workoutHistory = []; // Utiliser historique vide si fichier inaccessible
        }
        // Mettre à jour l'affichage après chargement
        displayHistory(currentHistoryPeriod);
    }

    // Sauvegarde les programmes sur Drive (appelé si on modifie les programmes via UI future)
    async function saveProgramsToDrive() {
         if (!googleAccessToken || !programsLoaded) return; // Besoin d'être connecté et programmes chargés
         if (isSavingDriveData) { console.log("Sauvegarde Drive déjà en cours..."); return; }

         console.log("Sauvegarde des programmes sur Drive...");
         let allSaved = true;

         for (const type of PROGRAM_TYPES) {
             if (!programFileIds[type]) { // Trouver/Créer ID si inconnu
                 const defaultProgContent = defaultWorkouts[type] ? JSON.stringify(defaultWorkouts[type], null, 2) : '[]';
                 programFileIds[type] = await findOrCreateFile(PROGRAM_FILENAMES[type], defaultProgContent);
             }

             if (programFileIds[type]) {
                 // Sauvegarder le contenu ACTUEL de loadedWorkouts[type]
                 const success = await updateFileContent(programFileIds[type], loadedWorkouts[type] || []);
                 if (!success) allSaved = false;
             } else {
                 console.error(`Impossible d'obtenir l'ID pour le programme ${type}.`);
                 allSaved = false;
             }
         }

         if (allSaved) {
             showMessage("Programmes sauvegardés sur Drive.", 2500);
         } else {
             showMessage("Erreur lors de la sauvegarde de certains programmes sur Drive.", 5000, true);
         }
    }

    // Charge les programmes (Push/Pull/Legs) depuis Drive
    async function loadProgramsFromDrive() {
        if (!googleAccessToken) return;

        console.log("Chargement des programmes depuis Drive...");
        programsLoaded = false; // Marquer comme non chargé initialement
        let allLoadedSuccessfully = true;
        loadedWorkouts = {}; // Vider avant de charger

        for (const type of PROGRAM_TYPES) {
            programFileIds[type] = await findOrCreateFile(PROGRAM_FILENAMES[type], JSON.stringify(defaultWorkouts[type] || [], null, 2)); // Trouve ou crée avec défaut

            if (programFileIds[type]) {
                const content = await readFileContent(programFileIds[type]);
                if (content !== null) {
                    try {
                        loadedWorkouts[type] = JSON.parse(content || '[]');
                         console.log(`Programme ${type} chargé (${loadedWorkouts[type].length} étapes).`);
                    } catch (e) {
                        console.error(`Erreur parsing JSON programme ${type}:`, e);
                        showMessage(`Erreur format programme ${type}. Utilisation du défaut.`, 4000, true);
                        loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type] || [])); // Revenir au défaut si erreur
                        allLoadedSuccessfully = false;
                         // Optionnel: Sauvegarder le défaut pour corriger le fichier Drive?
                         // await updateFileContent(programFileIds[type], defaultWorkouts[type] || []);
                    }
                } else {
                     console.warn(`Lecture programme ${type} échouée. Utilisation du défaut.`);
                     loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type] || [])); // Défaut si lecture échoue
                     allLoadedSuccessfully = false;
                }
            } else {
                console.error(`Impossible d'obtenir l'ID pour le programme ${type}. Utilisation du défaut.`);
                loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type] || [])); // Défaut si fichier inaccessible
                allLoadedSuccessfully = false;
            }
        }

        programsLoaded = true; // Marquer comme chargés (même si certains sont par défaut)
        console.log("Fin du chargement des programmes.", loadedWorkouts);
        updateAuthUI(true); // Mettre à jour l'état des boutons de navigation workout
        return allLoadedSuccessfully; // Retourne succès global
    }

    // Sauvegarde l'état actuel de l'entraînement dans localStorage
    function saveInProgressState() {
        if (!isWorkoutActive || currentState === 'preparing') return; // Ne pas sauvegarder si pas actif ou pendant prépa
        if (typeof localStorage === 'undefined') return; // Vérifier support localStorage

        const stateToSave = {
            currentWorkoutType,
            currentItemIndex,
            timeLeft: currentState === 'break' || currentState === 'paused' ? timeLeft : 0, // Sauver temps restant seulement si pause/break
            currentState,
            workoutStartTime,
            currentWorkoutPlan, // Sauver le plan potentiellement modifié
            totalWorkoutEstimatedSeconds,
            elapsedWorkoutEstimatedSeconds,
            timestamp: Date.now()
        };
        try {
            localStorage.setItem(IN_PROGRESS_KEY, JSON.stringify(stateToSave));
             console.log("État en cours sauvegardé localement.");
        } catch (e) {
            console.warn("Échec sauvegarde état en cours dans localStorage:", e);
             // Peut arriver si quota dépassé
             // Option: essayer de nettoyer d'anciennes données?
        }
    }

    // Charge et restaure un état d'entraînement depuis localStorage
    function loadInProgressState() {
        if (typeof localStorage === 'undefined') return;
        if (!googleAccessToken) return; // Ne restaurer que si connecté

        try {
            const savedStateJSON = localStorage.getItem(IN_PROGRESS_KEY);
            if (!savedStateJSON) return; // Pas d'état sauvegardé

            const savedState = JSON.parse(savedStateJSON);

            // Vérifier si la sauvegarde est raisonnablement récente (ex: moins de 24h)
            const maxAge = 24 * 60 * 60 * 1000; // 24 heures
            if (Date.now() - savedState.timestamp > maxAge) {
                console.log("État sauvegardé trop ancien, ignoré.");
                clearInProgressState();
                return;
            }

            // Demander confirmation à l'utilisateur pour reprendre
            if (confirm(`Un entraînement "${savedState.currentWorkoutType}" était en cours. Voulez-vous le reprendre ?`)) {
                console.log("Reprise de l'entraînement sauvegardé...");

                // Restaurer les variables d'état
                currentWorkoutType = savedState.currentWorkoutType;
                currentItemIndex = savedState.currentItemIndex;
                currentState = savedState.currentState; // État au moment de la sauvegarde
                workoutStartTime = savedState.workoutStartTime;
                currentWorkoutPlan = savedState.currentWorkoutPlan; // Restaurer le plan exact
                totalWorkoutEstimatedSeconds = savedState.totalWorkoutEstimatedSeconds;
                elapsedWorkoutEstimatedSeconds = savedState.elapsedWorkoutEstimatedSeconds;

                // Restaurer le temps restant spécifique à l'état
                if (currentState === 'break' || (currentState === 'paused' && currentWorkoutPlan[currentItemIndex]?.type === 'break')) {
                    totalTime = currentWorkoutPlan[currentItemIndex]?.duration || 0;
                    timeLeft = Math.max(0, Math.min(savedState.timeLeft, totalTime)); // Assurer validité
                } else {
                     timeLeft = 0;
                     totalTime = 0;
                }

                // Mettre à jour l'UI et relancer le timer si nécessaire
                setActiveWorkoutNav(currentWorkoutType);
                showSection('workout-section');
                setState(currentState); // Appliquer l'état restauré (ce qui relance le timer si 'break')

                showMessage(`Entraînement "${currentWorkoutType}" repris.`, 3000);

            } else {
                // L'utilisateur refuse de reprendre
                console.log("Reprise annulée par l'utilisateur.");
                clearInProgressState(); // Supprimer l'état sauvegardé
            }

        } catch (e) {
            console.error("Erreur lors du chargement/parsing de l'état sauvegardé:", e);
            clearInProgressState(); // Supprimer état invalide
        }
    }

    // Supprime l'état sauvegardé de localStorage
    function clearInProgressState() {
        if (typeof localStorage === 'undefined') return;
        try {
            localStorage.removeItem(IN_PROGRESS_KEY);
            console.log("État en cours supprimé de localStorage.");
        } catch (e) {
            console.warn("Échec suppression état en cours de localStorage:", e);
        }
    }

    // Ajoute l'entraînement terminé à l'historique (local + sauvegarde Drive)
    function saveWorkoutToHistory() {
        if (!googleAccessToken || !originalCompletedWorkoutPlan || originalCompletedWorkoutPlan.length === 0) {
            console.log("Sauvegarde historique annulée (non connecté ou plan vide).");
            return;
        }

        const endTime = Date.now();
        const durationSeconds = workoutStartTime ? (endTime - workoutStartTime) / 1000 : 0;

        const historyEntry = {
            date: new Date(workoutStartTime || endTime).toISOString(), // Utiliser début si dispo, sinon fin
            type: currentWorkoutType || 'Inconnu',
            durationSeconds: Math.round(durationSeconds),
            // Sauvegarder la copie *originalCompletedWorkoutPlan* qui peut contenir les modifs du résumé
            exercises: originalCompletedWorkoutPlan.map(item => ({ ...item })) // Copie pour éviter refs
        };

        workoutHistory.push(historyEntry);
        console.log("Entraînement ajouté à l'historique local:", historyEntry);

        // Sauvegarder l'historique complet sur Drive (asynchrone)
        saveHistoryToDrive();

        // Mettre à jour l'affichage de l'historique immédiatement
        displayHistory(currentHistoryPeriod);
         // Mettre à jour les graphiques de progression
         populateExerciseSelect(); // M-a-j liste exos si nouveau
         displayExerciseProgress();
         displayVolumeLoad();
    }

    // Exporte l'historique en fichier JSON
    function exportHistory() {
        if (!googleAccessToken) { showMessage("Connectez-vous pour exporter.", 3000, true); return; }
        if (workoutHistory.length === 0) { showMessage("Historique vide, rien à exporter.", 3000); return; }

        try {
            const jsonData = JSON.stringify(workoutHistory, null, 2); // Indenté pour lisibilité
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const dateStr = new Date().toISOString().split('T')[0];
            a.download = `armorworkout_history_${dateStr}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showMessage("Historique exporté avec succès.", 2500);
        } catch (e) {
            console.error("Erreur lors de l'export de l'historique:", e);
            showMessage("Erreur lors de l'exportation.", 4000, true);
        }
    }

    // --- Gestion Overlay Ajustement Répétitions ---

    // Affiche l'overlay pour ajuster les reps du *prochain* exercice (si état = break)
    function showRepAdjustmentOverlay() {
        if (!isWorkoutActive || currentState === 'finished' || currentState === 'preparing') return;
        // Ne montrer que si un exercice suit (ou si on est sur l'exercice lui-même ?)
        // Logique actuelle: montrer pendant pause ou exercice pour ajuster le *prochain*

        const itemForAdjustment = currentWorkoutPlan[nextExerciseIndexForAdjustment];

        if (!itemForAdjustment || itemForAdjustment.type !== 'exercise') {
            // console.log("Pas d'exercice suivant à ajuster.");
            hideRepAdjustmentOverlay(); // Cacher s'il n'y a rien à ajuster
            return;
        }

        // Afficher le nom de l'exercice concerné
        repAdjustmentExerciseName.textContent = itemForAdjustment.name;

        // Afficher les reps prévues + ajustement actuel
        const baseReps = itemForAdjustment.reps || 0;
        currentRepsDisplay.textContent = Math.max(0, baseReps + currentRepAdjustment);

        // Afficher l'overlay
        if (!isRepAdjustmentVisible) {
            repAdjustmentOverlay.classList.add('visible');
            isRepAdjustmentVisible = true;
        }
    }

    // Cache l'overlay d'ajustement
    function hideRepAdjustmentOverlay() {
        if (isRepAdjustmentVisible) {
            repAdjustmentOverlay.classList.remove('visible');
            isRepAdjustmentVisible = false;
        }
        // Ne pas reset currentRepAdjustment ici, car il doit être appliqué à handleItemCompletion
    }

    // Gère le clic sur les boutons +/- de l'overlay
    function handleRepAdjustClick(event) {
        const adjustment = event.target.id === 'rep-adjust-plus' ? 1 : -1;
        currentRepAdjustment += adjustment;

        // Mettre à jour l'affichage dans l'overlay
        const itemForAdjustment = currentWorkoutPlan[nextExerciseIndexForAdjustment];
        if (itemForAdjustment) {
             const baseReps = itemForAdjustment.reps || 0;
             currentRepsDisplay.textContent = Math.max(0, baseReps + currentRepAdjustment);
        }
        console.log(`Ajustement reps: ${currentRepAdjustment}`);
        // Pas besoin de sauvegarder ici, sera appliqué à la fin de l'étape
    }

    // Trouve l'index du prochain exercice pour l'overlay
    function findNextExerciseForAdjustment() {
         nextExerciseIndexForAdjustment = -1;
         if (!currentWorkoutPlan) return;
         // Chercher à partir de l'index actuel + 1
         for (let i = currentItemIndex + 1; i < currentWorkoutPlan.length; i++) {
             if (currentWorkoutPlan[i].type === 'exercise') {
                 nextExerciseIndexForAdjustment = i;
                 return; // Trouvé
             }
         }
         // Si on est sur l'exercice actuel, on peut aussi l'ajuster (pour la prochaine fois?)
         // Pour l'instant, on ajuste seulement le *prochain* exercice pendant la pause.
         // Si on est sur un exercice, nextExerciseIndexForAdjustment reste -1.
    }


    // --- Initialisation Générale ---

    // Récupère les références aux éléments DOM importants
    function initializeDOMReferences() {
        timeLeftDisplay = document.getElementById('time-left');
        timerCircle = document.getElementById('timer-circle');
        timerStateDisplay = document.getElementById('timer-state');
        currentExerciseContainer = document.getElementById('current-exercise-container');
        progressTracker = document.getElementById('progress-tracker');
        startPauseBtn = document.getElementById('start-pause-btn');
        skipBtn = document.getElementById('skip-btn');
        finishBtn = document.getElementById('finish-btn');
        resetBtn = document.getElementById('reset-btn');
        themeToggleBtn = document.getElementById('theme-toggle-btn');
        messageArea = document.getElementById('message-area');
        workoutSection = document.getElementById('workout-section');
        historySection = document.getElementById('history-section');
        progressSection = document.getElementById('progress-section');
        historyList = document.getElementById('history-list');
        statsDisplay = document.getElementById('stats-display');
        statsContentWrapper = statsDisplay?.querySelector('.content-wrapper'); // Cible div interne
        historyFilterBtns = Array.from(document.querySelectorAll('.history-filters button'));
        historyChartCanvas = document.getElementById('history-chart-canvas');
        signInButton = document.getElementById('signin-button');
        signOutButton = document.getElementById('signout-button');
        exportButton = document.getElementById('export-button');
        driveStatusElement = document.getElementById('drive-status');
        postWorkoutSummary = document.getElementById('post-workout-summary');
        summaryTitle = document.getElementById('summary-title');
        summaryItemsList = document.getElementById('summary-items-list');
        confirmSummaryBtn = document.getElementById('confirm-summary-btn');
        discardSummaryBtn = document.getElementById('discard-summary-btn');
        closeSummaryBtn = document.getElementById('close-summary-btn');
        historyDriveStatus = document.getElementById('history-drive-status');
        totalProgressCircle = document.getElementById('total-progress-circle');
        currentExerciseNameDisplay = document.getElementById('current-exercise-name-display');
        driveConnectionStatusMain = document.getElementById('drive-connection-status-main');
        driveConnectionText = document.getElementById('drive-connection-text');
        timerDisplayElement = document.querySelector('.timer-display');
        chartPlaceholder = document.getElementById('chart-placeholder');
        progressTextArea = document.getElementById('progress-text-area');
        historyActionsContainer = document.querySelector('.history-actions');
        exerciseSelect = document.getElementById('exercise-select');
        metricSelect = document.getElementById('metric-select');
        periodSelect = document.getElementById('period-select');
        exerciseProgressChart = document.getElementById('exercise-progress-chart');
        volumeChart = document.getElementById('volume-chart');
        exerciseChartPlaceholder = document.getElementById('exercise-chart-placeholder');
        volumeChartPlaceholder = document.getElementById('volume-chart-placeholder');
        repAdjustmentOverlay = document.getElementById('rep-adjustment-overlay');
        repAdjustMinusBtn = document.getElementById('rep-adjust-minus');
        repAdjustPlusBtn = document.getElementById('rep-adjust-plus');
        currentRepsDisplay = document.getElementById('current-reps-display');
        repAdjustmentExerciseName = document.getElementById('rep-adjustment-exercise-name');
        navHistoryBtn = document.getElementById('nav-history');
        navProgressBtn = document.getElementById('nav-progress');
        navButtons = [ // Boutons Push/Pull/Legs
            document.getElementById('nav-push'),
            document.getElementById('nav-pull'),
            document.getElementById('nav-legs')
        ];
    }

    // Attache les écouteurs d'événements principaux
    function addEventListeners() {
        // Boutons de contrôle du timer
        startPauseBtn?.addEventListener('click', () => {
            initAudioContext(); // Init audio sur première interaction
            if (currentState === 'idle') setState('preparing');
            else if (currentState === 'exercise') handleItemCompletion(false); // Marquer exo comme fait
            else if (currentState === 'break') setState('paused');
            else if (currentState === 'paused') setState(currentWorkoutPlan[currentItemIndex]?.type === 'exercise' ? 'exercise' : 'break'); // Reprendre
        });
        skipBtn?.addEventListener('click', () => { if (isWorkoutActive) handleItemCompletion(false); });
        finishBtn?.addEventListener('click', forceFinishWorkout);
        resetBtn?.addEventListener('click', resetCurrentWorkout);

        // Navigation principale (Sections & Workouts)
        navButtons.forEach(btn => btn?.addEventListener('click', () => loadWorkout(btn.dataset.workout)));
        navHistoryBtn?.addEventListener('click', () => showSection('history-section'));
        navProgressBtn?.addEventListener('click', () => showSection('progress-section'));

        // Filtres Historique
        historyFilterBtns.forEach(btn => btn?.addEventListener('click', () => displayHistory(btn.dataset.period)));

         // Filtres Progression
         exerciseSelect?.addEventListener('change', displayExerciseProgress);
         metricSelect?.addEventListener('change', displayExerciseProgress);
         periodSelect?.addEventListener('change', () => { displayExerciseProgress(); displayVolumeLoad(); }); // Met à jour les deux graphiques

        // Thème & Auth
        themeToggleBtn?.addEventListener('click', toggleTheme);
        signInButton?.addEventListener('click', handleAuthClick);
        signOutButton?.addEventListener('click', handleSignoutClick);
        exportButton?.addEventListener('click', exportHistory);

        // Résumé Post-Workout
        confirmSummaryBtn?.addEventListener('click', confirmSummary);
        discardSummaryBtn?.addEventListener('click', discardSummary);
        closeSummaryBtn?.addEventListener('click', closeSummary);
         // Fermer modal si on clique en dehors du contenu
         postWorkoutSummary?.addEventListener('click', (e) => { if (e.target === postWorkoutSummary) discardSummary(); });


        // Overlay ajustement reps
        timerDisplayElement?.addEventListener('click', () => {
             if (isWorkoutActive && currentState !== 'preparing' && currentState !== 'finished') {
                 // Afficher seulement si un exercice est le prochain ou en cours
                 // Logique actuelle: ajuste le *prochain* exo (index dans nextExerciseIndexForAdjustment)
                 if (nextExerciseIndexForAdjustment !== -1) {
                      showRepAdjustmentOverlay();
                 } else {
                     // Optionnel: montrer pour l'exo actuel?
                     // showMessage("Ajustement disponible pendant les pauses pour l'exercice suivant.", 2000);
                 }
             }
        });
        repAdjustMinusBtn?.addEventListener('click', handleRepAdjustClick);
        repAdjustPlusBtn?.addEventListener('click', handleRepAdjustClick);
         // Fermer overlay si on clique en dehors
         repAdjustmentOverlay?.addEventListener('click', (e) => { if (e.target === repAdjustmentOverlay) hideRepAdjustmentOverlay(); });

         // Fermer overlay si on change d'état (géré dans setState)


        // Gestion changement visibilité page (pour sauvegarde état)
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden' && isWorkoutActive) {
                saveInProgressState();
            }
        });
        // Sauvegarde aussi avant fermeture/rechargement
        window.addEventListener('beforeunload', () => {
             if (isWorkoutActive) saveInProgressState();
        });
    }

    // Point d'entrée principal après chargement du DOM
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Chargé. Initialisation ArmorWorkout...");
        initializeDOMReferences(); // Récupérer références
        addEventListeners(); // Attacher écouteurs
        loadSavedTheme(); // Appliquer thème sauvegardé
        setState('idle'); // Définir état initial
        updateAuthUI(!!googleAccessToken); // Mettre à jour UI initiale (sera déconnecté)

        // Note: Le chargement des données Drive est déclenché par gisLoadedCallback après le chargement du script Google.
        // Afficher messages initiaux dans les sections non-actives
        setChartPlaceholder(historyChartCanvas.id, "Connectez-vous pour voir le graphique.");
        setChartPlaceholder(exerciseProgressChart.canvas.id, "Connectez-vous et sélectionnez un exercice.");
        setChartPlaceholder(volumeChart.canvas.id, "Connectez-vous pour voir le volume.");
    });

</script>

</body>
</html>
