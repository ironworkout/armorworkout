<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Timer d'Entraînement</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- Google Identity Services (GIS) - chargé à la fin -->
    <style>
        /* --- Variables Globales & Thèmes --- */
        :root {
            /* Thème Sombre (Inspiré de l'image) */
            --bg-color-dark: #0D1117;
            --secondary-bg-color-dark: #161B22;
            --primary-text-color-dark: #c9d1d9;
            --secondary-text-color-dark: #8b949e;
            --border-color-dark: #30363d;
            --accent-border-color-dark: #8b949e;
            --neon-blue: #00aeff;
            --neon-pink: #e54ac5;
            --neon-red: #ff4d4d;
            --neon-yellow: #facc15;
            --neon-green: #2ecc71;
            --glow-blue: 0 0 15px rgba(0, 174, 255, 0.5);
            --glow-pink: 0 0 15px rgba(229, 74, 197, 0.5);
            --glow-red: 0 0 10px rgba(255, 77, 77, 0.5);
            --glow-yellow: 0 0 10px rgba(250, 204, 21, 0.4);
            --glow-green: 0 0 10px rgba(46, 204, 113, 0.4);
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius-lg: 12px;
            --border-radius-md: 8px;
            --border-radius-sm: 6px;
            --transition-speed: 0.25s;

            /* Initialisation Thème Sombre par Défaut */
            --bg-color: var(--bg-color-dark);
            --secondary-bg-color: var(--secondary-bg-color-dark);
            --primary-text-color: var(--primary-text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --border-color: var(--border-color-dark);
            --accent-border-color: var(--accent-border-color-dark);

            --current-step-color: var(--neon-blue);
            --current-step-glow: var(--glow-blue);
            --total-progress-gradient: conic-gradient(from 180deg, var(--neon-blue), var(--neon-pink) 60%, var(--neon-blue));
            --total-progress-bg: #2a2f36;

            --button-reset-color: var(--neon-red);
            --button-reset-glow: var(--glow-red);
            --button-next-color: var(--neon-pink);
            --button-next-glow: var(--glow-pink);
            --button-end-color: var(--secondary-text-color-dark);
            --button-end-glow: none;
            --button-start-color: var(--neon-blue);
            --button-start-glow: var(--glow-blue);
            --button-pause-color: var(--neon-yellow);
            --button-pause-glow: var(--glow-yellow);
            --button-connect-color: var(--neon-green);
            --button-connect-glow: var(--glow-green);
            --button-disconnect-color: var(--neon-red);
            --button-disconnect-glow: var(--glow-red);
            --link-color: var(--neon-blue);

            /* --- Variables RGBA Helper --- */
            --neon-blue-rgb: 0, 174, 255;
            --neon-pink-rgb: 229, 74, 197;
            --neon-red-rgb: 255, 77, 77;
            --neon-yellow-rgb: 250, 204, 21;
            --neon-green-rgb: 46, 204, 113;
            --secondary-text-color-dark-rgb: 139, 148, 158;
            --bg-color-dark-rgb: 13, 17, 23;
            --secondary-bg-color-dark-rgb: 22, 27, 34;
            --primary-text-color-dark-rgb: 201, 209, 217;
        }

        body.light-theme {
            /* Styles pour thème clair */
            --bg-color: #ffffff;
            --secondary-bg-color: #f6f8fa;
            --primary-text-color: #24292f;
            --secondary-text-color: #57606a;
            --border-color: #d0d7de;
            --accent-border-color: #8c959f;
            --total-progress-bg: #e1e4e8;
            --button-end-color: #57606a;
            --link-color: #0969da;

            /* Adapter les variables RGBA pour light theme */
            --bg-color-dark-rgb: 255, 255, 255;
            --secondary-bg-color-dark-rgb: 246, 248, 250;
            --primary-text-color-dark-rgb: 36, 41, 47;
            --secondary-text-color-dark-rgb: 87, 96, 106;
        }

        /* --- Styles de Base & Réinitialisation --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
            font-size: 16px;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            line-height: 1.6;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 30px 25px;
            width: 100%;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* --- En-tête --- */
        header {
            padding: 20px 0;
            border-bottom: 1px solid var(--border-color);
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: rgba(var(--bg-color-dark-rgb), 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 25px;
            flex-wrap: wrap;
            gap: 15px 20px;
        }

        header h1 {
            font-size: 1.5em;
            color: var(--primary-text-color);
            margin: 0;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        header h1 i {
            color: var(--neon-blue);
            animation: pulse 2s infinite ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        /* --- Navigation Header --- */
        nav ul {
            list-style: none;
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        nav button {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            font-size: 1em;
            font-weight: 500;
            padding: 5px 0;
            cursor: pointer;
            transition: color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            position: relative;
            border-bottom: 2px solid transparent;
        }

        nav button:disabled {
            color: rgba(var(--primary-text-color-dark-rgb), 0.3);
            cursor: not-allowed;
            border-bottom-color: transparent !important;
            box-shadow: none !important;
            opacity: 0.6; /* Visually indicate disabled */
        }

        nav button:not(:disabled):hover {
            color: var(--primary-text-color);
        }

        nav button.active {
            color: var(--neon-blue);
            font-weight: 700;
            border-bottom-color: var(--neon-blue);
            box-shadow: 0 5px 15px -5px rgba(var(--neon-blue-rgb), 0.4);
        }

        #nav-history {
            color: var(--secondary-text-color);
            border-bottom-color: transparent;
        }
        #nav-history:hover:not(:disabled) { /* Only hover if not disabled */
            color: var(--neon-pink);
        }
        #nav-history.active {
            color: var(--neon-pink);
            border-bottom-color: var(--neon-pink);
            box-shadow: 0 5px 15px -5px rgba(var(--neon-pink-rgb), 0.4);
        }

        #nav-history i {
            margin-right: 5px;
        }

        /* --- Actions Header --- */
        .header-actions {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .auth-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .auth-controls button, #export-programs-btn {
            background: none;
            border: 1px solid var(--accent-border-color);
            color: var(--secondary-text-color);
            padding: 6px 14px;
            border-radius: var(--border-radius-md);
            font-size: 0.85em;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .auth-controls button:disabled, #export-programs-btn:disabled {
             opacity: 0.5;
             cursor: not-allowed;
             pointer-events: none;
        }

        .auth-controls button:not(:disabled):hover, #export-programs-btn:not(:disabled):hover {
            border-color: var(--primary-text-color);
            color: var(--primary-text-color);
        }

        #signin-button {
            border-color: var(--button-connect-color);
            color: var(--button-connect-color);
        }
        #signin-button:not(:disabled):hover {
            background-color: rgba(var(--neon-green-rgb), 0.1);
            box-shadow: var(--glow-green);
            border-color: var(--neon-green);
        }

        #signout-button {
            border-color: var(--button-disconnect-color);
            color: var(--button-disconnect-color);
        }
        #signout-button:not(:disabled):hover {
            background-color: rgba(var(--neon-red-rgb), 0.1);
            box-shadow: var(--glow-red);
            border-color: var(--neon-red);
        }

        #export-programs-btn {
            border-color: var(--neon-pink);
            color: var(--neon-pink);
        }
        #export-programs-btn:not(:disabled):hover {
            background-color: rgba(var(--neon-pink-rgb), 0.1);
            box-shadow: var(--glow-pink);
            border-color: var(--neon-pink);
        }

        #drive-status {
            font-size: 0.8em;
            color: var(--secondary-text-color);
            margin-left: 5px;
            transition: opacity 0.3s, color 0.3s, border-color 0.3s;
            min-width: fit-content;
            text-align: right;
            font-style: normal;
            padding: 4px 8px;
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5);
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--border-color);
            display: none; /* Initialement caché */
        }
        #drive-status.loading { color: var(--neon-yellow); border-color: var(--neon-yellow); }
        #drive-status.error { color: var(--neon-red); border-color: var(--neon-red); }
        #drive-status.success { color: var(--neon-green); border-color: var(--neon-green); }

        .theme-toggle button {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            font-size: 1.2em;
            padding: 5px;
            cursor: pointer;
            transition: color var(--transition-speed) ease;
        }
        .theme-toggle button:hover { color: var(--neon-yellow); }

        /* Logique d'affichage connexion/déconnexion */
        body.logged-out #signin-button { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-out #drive-status { display: none; }
        body.logged-out #export-programs-btn { display: none; }
        body.logged-out .history-actions i.fab.fa-google-drive { display: none; }
        body.logged-out #history-drive-status { display: none; }
        body.logged-out #drive-connection-status-main { display: none; } /* Cache le statut Drive en bas */

        body.logged-in #signin-button { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-in #drive-status { display: inline-block; }
        body.logged-in #export-programs-btn { display: inline-flex; }
        body.logged-in .history-actions i.fab.fa-google-drive { display: inline-block; }
        body.logged-in #history-drive-status { display: inline-block; }
        body.logged-in #drive-connection-status-main { display: flex; } /* Affiche le statut Drive en bas */


        /* --- Contenu Principal --- */
        main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 50px;
            position: relative;
        }

        .workout-section {
            background-color: transparent;
            padding: 0;
            border: none;
            box-shadow: none;
            width: 100%;
            max-width: 600px;
            text-align: center;
            transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease;
            margin-bottom: 40px;
        }

        .history-section {
            background-color: var(--secondary-bg-color);
            padding: 35px;
            border-radius: var(--border-radius-lg);
            box-shadow: none;
            border: 1px solid var(--border-color);
            width: 100%;
            max-width: 850px;
            text-align: left;
            margin-bottom: 40px;
            transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease;
        }

        .section-hidden {
            transform: scale(0.9) translateY(30px);
            opacity: 0;
            pointer-events: none;
            max-height: 0;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
            border: none !important;
            overflow: hidden;
        }

        /* --- Affichage Timer --- */
        .timer-display {
            margin-bottom: 50px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 320px;
            height: 320px;
            margin-left: auto;
            margin-right: auto;
            cursor: pointer; /* Indique qu'on peut cliquer */
            user-select: none; /* Empêche la sélection de texte */
            -webkit-tap-highlight-color: transparent; /* Retire le flash sur mobile */
        }

        .timer-circle-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none; /* Laisse passer les clics vers le parent .timer-display */
        }

        #total-progress-circle,
        .timer-circle {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            border: 12px solid transparent;
            background-clip: padding-box;
            background-origin: border-box;
            box-sizing: border-box;
        }

        #total-progress-circle {
            border-color: var(--total-progress-bg);
            background-image: var(--total-progress-gradient);
            background-size: 100% 100%;
            box-shadow: 0 0 25px rgba(var(--neon-blue-rgb), 0.3), 0 0 35px rgba(var(--neon-pink-rgb), 0.2), inset 0 0 20px rgba(var(--bg-color-dark-rgb), 0.5);
            z-index: 1;
            transition: background 0.5s ease-out;
            background-repeat: no-repeat;
            background-position: center center;
        }

        .timer-circle {
            width: calc(100% - 48px); height: calc(100% - 48px);
            top: 24px; left: 24px;
            border-color: var(--border-color);
            background-image: conic-gradient(var(--current-step-color) 0%, transparent 0%);
            background-size: 100% 100%;
            box-shadow: var(--current-step-glow), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6);
            z-index: 3;
            transition: background-image 0.15s linear, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            background-repeat: no-repeat;
            background-position: center center;
        }

        .timer-circle::before {
            content: '';
            position: absolute;
            width: calc(100% - 24px); height: calc(100% - 24px);
            background-color: var(--bg-color);
            border-radius: 50%;
            z-index: 4;
            transition: background-color var(--transition-speed) ease;
        }

        .time-left {
            font-size: 5.5em;
            font-weight: 900;
            color: var(--primary-text-color);
            z-index: 5;
            transition: color var(--transition-speed) ease;
            font-variant-numeric: tabular-nums;
            position: relative;
            text-shadow: 0 0 10px rgba(var(--primary-text-color-dark-rgb), 0.3);
        }

        .timer-state {
            position: absolute;
            bottom: 15%; left: 50%; transform: translateX(-50%);
            font-size: 0.8em; letter-spacing: 0.1em;
            color: var(--secondary-text-color);
            font-weight: 500; text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.3s ease;
            background-color: transparent; padding: 0; box-shadow: none;
            z-index: 6;
        }
        .timer-state.visible { opacity: 0.8; }
        .timer-state.preparing {
            color: var(--neon-yellow); font-size: 1em;
            animation: countdown-pulse 1s infinite;
        }
        @keyframes countdown-pulse {
            0%, 100% { transform: translateX(-50%) scale(1); opacity: 1; }
            50% { transform: translateX(-50%) scale(1.1); opacity: 0.8; }
        }

        /* --- Infos Exercice --- */
        .workout-info {
            margin-bottom: 40px;
            min-height: 100px;
            position: relative;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #current-exercise-name-display {
            display: block;
            font-size: 1.3em;
            font-weight: 700;
            color: var(--primary-text-color);
            margin-bottom: 5px;
            padding: 0 10px;
            min-height: 1.5em;
        }
        /* Cache le nom quand pas en cours, sauf si on est "idle" mais un workout est sélectionné */
        body:not(.workout-active):not(.workout-selected) #current-exercise-name-display {
            display: none;
        }
        body.workout-selected #current-exercise-name-display {
             /* Si idle mais sélectionné, on pourrait montrer le nom du workout ? Non, gardons le simple */
             display: none; /* Cache quand idle même si sélectionné */
        }
        body.workout-active #current-exercise-name-display {
            display: block; /* Assure l'affichage quand actif */
        }


        #current-exercise-container {
            display: flex; flex-direction: column; align-items: center;
            gap: 5px; font-size: 1.1em; color: var(--secondary-text-color);
            min-height: 3em;
        }
        #current-exercise-container .exercise-details {
            display: flex; align-items: center; gap: 15px;
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3);
            padding: 8px 15px; border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color);
        }
        #current-exercise-container .exercise-details span {
            display: flex; align-items: center; gap: 5px; font-weight: 500;
        }
        #current-exercise-container .exercise-details span i { color: var(--neon-pink); }
        #current-exercise-container .exercise-details .details-text { font-size: 0.9em; opacity: 0.8; }
        #current-exercise-container .break-info {
            display: flex; align-items: center; gap: 8px;
            font-weight: 500; font-size: 1.1em; color: var(--neon-yellow);
        }

        /* Comportement d'affichage des détails */
        body:not(.workout-active) #current-exercise-container .exercise-details,
        body:not(.workout-active) #current-exercise-container .break-info {
            display: none; /* Cache détails/pause si pas actif */
        }
        body.workout-active #current-exercise-container > p {
             display: none; /* Cache le message par défaut quand actif */
        }


        /* --- Progress Tracker (Maintenant utilisé pour l'état général) --- */
        .progress-tracker {
            font-size: 0.9em; color: var(--secondary-text-color); margin-top: 30px;
            opacity: 0.8; font-weight: 500;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            min-height: 1.2em;
        }
        .progress-tracker i.fa-google-drive { color: var(--neon-green); }
        .progress-tracker i.fa-google-drive.fa-spin { animation: fa-spin 2s linear infinite; }
        @keyframes fa-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* --- Contrôles Timer --- */
        .controls {
            display: flex; justify-content: center; gap: 20px;
            margin-top: 40px; flex-wrap: wrap;
        }
        .controls button {
            background: transparent;
            border: 2px solid var(--accent-border-color);
            color: var(--primary-text-color);
            min-width: 120px; padding: 12px 25px;
            border-radius: var(--border-radius-lg);
            font-size: 1.1em; font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        }
        .controls button i { font-size: 0.9em; }

        .controls button:disabled {
            border-color: var(--border-color) !important; /* Force la couleur de bordure disabled */
            color: var(--secondary-text-color) !important; /* Force la couleur de texte disabled */
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none !important; /* Enlève le glow */
            transform: none !important; /* Enlève le hover effect */
            background-color: transparent !important; /* Assure pas de fond */
            pointer-events: none; /* Double sécurité pour l'interaction */
        }

        .controls button:not(:disabled):hover { transform: translateY(-2px); }
        .controls button:not(:disabled):active { transform: scale(0.97); }

        #start-pause-btn { border-color: var(--button-start-color); color: var(--button-start-color); }
        #start-pause-btn:not(:disabled):hover { box-shadow: var(--glow-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); }
        #start-pause-btn.pause-btn { border-color: var(--button-pause-color); color: var(--button-pause-color); }
        #start-pause-btn.pause-btn:not(:disabled):hover { box-shadow: var(--glow-yellow); background-color: rgba(var(--neon-yellow-rgb), 0.1); }

        #skip-btn { border-color: var(--button-next-color); color: var(--button-next-color); }
        #skip-btn:not(:disabled):hover { box-shadow: var(--glow-pink); background-color: rgba(var(--neon-pink-rgb), 0.1); }

        #finish-btn { border-color: var(--button-end-color); color: var(--button-end-color); }
        #finish-btn:not(:disabled):hover { background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1); border-color: var(--primary-text-color); color: var(--primary-text-color); }

        #reset-btn { border-color: var(--button-reset-color); color: var(--button-reset-color); }
        #reset-btn:not(:disabled):hover { box-shadow: var(--glow-red); background-color: rgba(var(--neon-red-rgb), 0.1); }


        /* --- Section Historique --- */
        .history-section h2 { color: var(--primary-text-color); margin-bottom: 25px; text-align: center; }

        .history-controls {
            padding-bottom: 20px; margin-bottom: 25px;
            border-bottom: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center;
            flex-wrap: wrap; gap: 15px;
        }
        .history-filters { display: flex; gap: 10px; flex-wrap: wrap; }
        .history-filters button {
            background-color: transparent; border: 1px solid var(--accent-border-color);
            color: var(--secondary-text-color); opacity: 1; font-size: 0.85em;
            padding: 6px 12px; border-radius: var(--border-radius-md); cursor: pointer;
            transition: all var(--transition-speed) ease;
            display: inline-flex; align-items: center; gap: 5px;
        }
        .history-filters button:not(:disabled):hover {
            border-color: var(--primary-text-color); color: var(--primary-text-color);
            background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1);
        }
        .history-filters button.active {
            border-color: var(--neon-blue); color: var(--neon-blue);
            background-color: rgba(var(--neon-blue-rgb), 0.1);
            font-weight: 500; box-shadow: var(--glow-blue);
        }

        .history-actions { display: flex; gap: 15px; align-items: center; color: var(--secondary-text-color); }
        .history-actions i.fab.fa-google-drive { color: var(--neon-green); }
        #history-drive-status {
            font-size: 0.8em; padding: 3px 6px;
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5);
            border-radius: var(--border-radius-sm); border: 1px solid var(--border-color);
        }

        .chart-container {
            height: 350px; margin-bottom: 30px;
            background-color: transparent; border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md); padding: 15px; box-shadow: none;
        }

        .stats-display {
            margin-bottom: 30px; padding: 20px;
            background-color: transparent; border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md); box-shadow: none;
        }
        .stats-display h3 { color: var(--primary-text-color); margin-bottom: 15px; font-size: 1.15em;}
        .stats-display p { margin-bottom: 8px; display: flex; align-items: center; gap: 8px;}
        .stats-display p i { width: 16px; text-align: center; color: var(--neon-blue); opacity: 0.8;}
        .stats-display p strong { color: var(--primary-text-color); font-weight: 500; }
        .stats-display p:last-child { margin-bottom: 0; }
        .stats-display .motivational-message {
            font-style: italic; font-weight: 500; margin-top: 15px !important;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-blue));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text; text-fill-color: transparent;
        }

        .history-list {
            list-style: none; border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md); background-color: transparent; box-shadow: none;
            max-height: 400px; overflow-y: auto;
        }
        .history-list li {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 15px; border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s ease; gap: 15px;
        }
        .history-list li:last-child { border-bottom: none; }
        .history-list li:nth-child(even) { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3); }
        .history-list li:hover { background-color: rgba(var(--neon-blue-rgb), 0.08); transform: none; }
        .history-item-date { color: var(--primary-text-color); font-size: 0.9em; }
        .history-item-date small { color: var(--secondary-text-color); font-size: 0.9em;}
        .history-item-type {
            color: var(--neon-pink); background-color: rgba(var(--neon-pink-rgb), 0.1);
            border-radius: var(--border-radius-sm); padding: 3px 8px; font-size: 0.85em;
            font-weight: 500; text-align: center; min-width: 50px;
        }
        .history-item-duration { color: var(--neon-blue); font-weight: 500; font-variant-numeric: tabular-nums;}
        .history-list .no-history {
            color: var(--secondary-text-color); text-align: center; padding: 30px 15px;
            font-style: italic; border: none; background: none !important;
        }

        /* --- Résumé Post-Workout (MODAL) --- */
        .post-workout-summary {
            position: fixed; inset: 0;
            background-color: rgba(var(--bg-color-dark-rgb), 0.85);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            z-index: 2000; display: flex; align-items: center; justify-content: center;
            padding: 20px; opacity: 0; visibility: hidden; pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .post-workout-summary.visible { opacity: 1; visibility: visible; pointer-events: auto; }
        .post-workout-summary-content {
            background-color: var(--secondary-bg-color); border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg); box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 100%; max-width: 650px; max-height: 90vh;
            display: flex; flex-direction: column; overflow: hidden;
            transform: scale(0.95); transition: transform 0.3s ease;
        }
        .post-workout-summary.visible .post-workout-summary-content { transform: scale(1); }
        .post-workout-summary h2 {
            color: var(--primary-text-color); font-size: 1.4em;
            padding: 20px 25px; border-bottom: 1px solid var(--border-color);
            flex-shrink: 0; text-align: center;
        }
        .summary-items-list {
            list-style: none; padding: 15px 25px; overflow-y: auto; flex-grow: 1;
            background: var(--bg-color); border-bottom: 1px solid var(--border-color);
        }
        .summary-item {
            border-bottom: 1px solid var(--border-color); padding: 15px 0;
            display: grid; grid-template-columns: auto 1fr; gap: 10px 20px; align-items: start;
        }
        .summary-item:last-child { border-bottom: none; }
        .summary-item h4 {
            grid-column: 1 / -1; color: var(--primary-text-color); font-size: 1.1em;
            margin-bottom: 8px; display: flex; align-items: center; gap: 8px;
        }
        .summary-item h4 i { color: var(--neon-blue); width: 18px; text-align: center;}
        .summary-item .item-type-break h4 { color: var(--neon-yellow); }
        .summary-item .item-type-break h4 i { color: var(--neon-yellow);}
        .summary-item label {
            color: var(--secondary-text-color); font-size: 0.9em; font-weight: 500;
            white-space: nowrap; padding-top: 6px; text-align: right; grid-column: 1 / 2;
        }
        .summary-item > div { grid-column: 2 / 3; }
        .summary-item input[type="number"],
        .summary-item input[type="text"],
        .summary-item textarea {
            background-color: var(--bg-color); border: 1px solid var(--border-color);
            color: var(--primary-text-color); border-radius: var(--border-radius-sm);
            padding: 6px 10px; font-size: 1em; width: 100%;
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
        }
        .summary-item input[type="number"] { width: 80px; }
        .summary-item input:focus, .summary-item textarea:focus {
            border-color: var(--neon-blue); background-color: var(--bg-color); outline: none;
            box-shadow: 0 0 0 2px rgba(var(--neon-blue-rgb), 0.3);
        }
        .summary-item textarea { min-height: 40px; resize: vertical; }
        .summary-item p { color: var(--secondary-text-color); padding-top: 6px; grid-column: 1 / -1; text-align: center; font-style: italic; }

        .summary-controls {
            padding: 20px 25px; display: flex; justify-content: space-between; gap: 15px;
            flex-shrink: 0; flex-wrap: wrap;
        }
        .summary-controls button { /* Hérite de .controls button mais on peut overrider */
            border-width: 2px; padding: 10px 20px; font-size: 1em;
            border-radius: var(--border-radius-md); flex-grow: 1; min-width: 150px;
        }
        .summary-controls .save-summary-btn { border-color: var(--neon-green); color: var(--neon-green); }
        .summary-controls .save-summary-btn:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--glow-green); }
        .summary-controls .cancel-summary-btn { border-color: var(--neon-red); color: var(--neon-red); }
        .summary-controls .cancel-summary-btn:not(:disabled):hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--glow-red); }

        /* --- Animation Fin Workout --- */
        .workout-section.finished-animation {
            animation: finish-glow 1.5s ease-out forwards;
            /* Applique un style temporaire pour rendre l'effet visible sur le container */
            border: 2px solid transparent; /* Bordure temporaire pour que le shadow soit visible */
            border-radius: var(--border-radius-lg);
            padding: 20px; /* Ajoute un peu de padding pour mieux voir l'effet */
            box-shadow: 0 0 0px 0px var(--neon-green); /* Initial state */
        }
        @keyframes finish-glow {
            0% { box-shadow: 0 0 0px 0px rgba(var(--neon-green-rgb), 0); border-color: transparent; }
            50% { box-shadow: 0 0 35px 15px rgba(var(--neon-green-rgb), 0.5); border-color: rgba(var(--neon-green-rgb), 0.6); }
            100% { box-shadow: 0 0 0px 0px rgba(var(--neon-green-rgb), 0); border-color: transparent; }
        }

        /* --- Zone de Messages Flottante --- */
        .message-area {
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%);
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.9);
            color: var(--primary-text-color); border: 1px solid var(--border-color);
            padding: 12px 25px; border-radius: var(--border-radius-md); z-index: 1001;
            opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease;
            pointer-events: none; font-size: 0.95em;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            max-width: 90%; text-align: center;
        }
        .message-area.visible { opacity: 1; transform: translate(-50%, 0); bottom: 40px; pointer-events: auto; }

        /* --- Pied de Page --- */
        footer {
            color: var(--secondary-text-color); opacity: 0.7;
            border-top: 1px solid var(--border-color); margin-top: 60px;
            padding: 25px; text-align: center;
        }
        footer a { color: var(--link-color); text-decoration: none; }
        footer a:hover { color: var(--primary-text-color); text-decoration: underline; }
        footer .fab.fa-google-drive { color: #4CAF50; }

        /* --- Styles Responsives --- */
        @media (max-width: 992px) {
            .header-content { padding: 0 15px; }
            .container { padding: 30px 15px; }
        }

        @media (max-width: 768px) {
            header h1 { font-size: 1.3em; }
            nav ul { gap: 15px; }
            .header-actions { gap: 15px; }
            .timer-display { width: 280px; height: 280px; }
            .timer-circle { width: calc(100% - 40px); height: calc(100% - 40px); top: 20px; left: 20px; border-width: 10px; }
            .timer-circle::before { width: calc(100% - 20px); height: calc(100% - 20px); }
            .time-left { font-size: 4.5em; }
            #total-progress-circle { border-width: 10px; }
            .controls { gap: 15px; }
            .controls button { min-width: 100px; padding: 10px 20px; font-size: 1em; }
            .history-controls { flex-direction: column; align-items: stretch; gap: 15px; }
            .history-actions { justify-content: center; }
            .chart-container { height: 320px; padding: 10px; }
            .stats-display { padding: 15px; }
            .history-list li { padding: 10px; gap: 10px; font-size: 0.95em;}
            .post-workout-summary-content { padding: 0; max-width: 95%; max-height: 85vh; }
            .post-workout-summary h2 { padding: 15px 20px; font-size: 1.3em; }
            .summary-items-list { padding: 10px 20px; }
            .summary-item { grid-template-columns: 60px 1fr; gap: 8px 15px;}
            .summary-item label { font-size: 0.85em; text-align: left; padding-top: 8px;}
            .summary-item input[type="number"] { width: 60px; }
            .summary-controls { padding: 15px 20px; flex-direction: column; }
            .summary-controls button { width: 100%; }
        }

        @media (max-width: 480px) {
            header { padding: 15px 0;}
            header h1 { font-size: 1.2em; }
            nav ul { gap: 10px; }
            .header-actions { justify-content: center; }
            .auth-controls { flex-wrap: wrap; justify-content: center; gap: 8px;}
            .timer-display { width: 240px; height: 240px; margin-bottom: 40px; }
            .timer-circle { width: calc(100% - 32px); height: calc(100% - 32px); top: 16px; left: 16px; border-width: 8px; }
            .timer-circle::before { width: calc(100% - 16px); height: calc(100% - 16px); }
            .time-left { font-size: 3.8em; }
            #total-progress-circle { border-width: 8px; }
            .workout-info { min-height: 80px; }
            #current-exercise-name-display { font-size: 1.2em; }
            #current-exercise-container { font-size: 1em; }
            #current-exercise-container .exercise-details { padding: 6px 10px; gap: 10px;}
            .controls { gap: 10px; margin-top: 30px; }
            .controls button { width: 100%; min-width: 0; padding: 12px; font-size: 1em; }
            .progress-tracker { margin-top: 25px; font-size: 0.85em;}
            .history-section { padding: 20px; }
            .history-controls { padding-bottom: 15px; margin-bottom: 20px;}
            .history-filters button { font-size: 0.8em; padding: 5px 10px; }
            .chart-container { height: 280px; }
            .stats-display { padding: 12px; font-size: 0.9em;}
            .history-list li { font-size: 0.9em;}
            .history-item-type { font-size: 0.8em; padding: 2px 6px;}
            .post-workout-summary-content { max-width: 100%; max-height: 90vh; border-radius: var(--border-radius-md); }
            .post-workout-summary h2 { font-size: 1.2em; padding: 12px 15px;}
            .summary-items-list { padding: 8px 15px; }
            .summary-item { grid-template-columns: 50px 1fr; gap: 5px 10px; padding: 12px 0;}
            .summary-item h4 {font-size: 1em;}
            .summary-item label { font-size: 0.8em; }
            .summary-controls { padding: 12px 15px; }
        }
    </style>
</head>
<body class="logged-out dark-theme"> <!-- Initialement logged-out et thème sombre -->

<header>
    <div class="header-content">
        <h1><i class="fas fa-shield-halved"></i> ArmorWorkout</h1>
        <nav>
            <ul>
                <li><button id="nav-push" data-workout="Push" disabled>Push</button></li>
                <li><button id="nav-pull" data-workout="Pull" disabled>Pull</button></li>
                <li><button id="nav-legs" data-workout="Legs" disabled>Legs</button></li>
                <li><button id="nav-history"><i class="fas fa-history"></i> Historique</button></li>
            </ul>
        </nav>
        <div class="header-actions">
            <div class="auth-controls">
                <button id="signin-button"><i class="fab fa-google"></i> Connecter Drive</button>
                <button id="signout-button"><i class="fas fa-sign-out-alt"></i> Déconnecter</button>
            </div>
            <span id="drive-status"></span>
            <button id="export-programs-btn" disabled><i class="fas fa-upload"></i> Exporter Progs</button>
            <div class="theme-toggle">
                <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button>
            </div>
        </div>
    </div>
</header>

<div class="container">
    <main>
        <!-- Section Entraînement -->
        <div class="workout-section" id="workout-section">

            <div class="timer-display" id="timer-display-clickable"> <!-- ID ajouté pour le clic -->
                <div class="timer-circle-container">
                    <div id="total-progress-circle"></div>
                    <div class="timer-circle" id="timer-circle">
                        <span class="time-left" id="time-left">00:00</span>
                    </div>
                </div>
                <div class="timer-state" id="timer-state"></div>
            </div>

            <div class="workout-info" id="workout-info">
                <div id="current-exercise-name-display"></div>
                <div id="current-exercise-container">
                    <p>Initialisation...</p> <!-- Message par défaut -->
                </div>
            </div>

            <div class="controls">
                <button id="start-pause-btn" disabled><i class="fas fa-play"></i> Démarrer</button>
                <button id="skip-btn" disabled><i class="fas fa-forward-step"></i> Suivant</button>
                <button id="finish-btn" disabled><i class="fas fa-flag-checkered"></i> Finir</button>
                <button id="reset-btn" disabled><i class="fas fa-redo"></i> Reset</button>
            </div>

            <div class="progress-tracker" id="progress-tracker">
                <!-- Statut étape ou connexion Drive affiché ici par JS -->
                <span id="progress-text-area">Sélectionnez un entraînement</span>
                <span id="drive-connection-status-main" style="display: none; margin-left: 10px; padding-left: 10px; border-left: 1px solid var(--border-color); align-items: center; gap: 5px;">
                    <i class="fab fa-google-drive"></i>
                    <span id="drive-connection-text">Connecté à Google Drive</span>
                </span>
            </div>
        </div>

        <!-- Section Historique -->
        <div class="history-section section-hidden" id="history-section">
            <h2><i class="fas fa-chart-line"></i> Historique & Statistiques</h2>
            <div class="history-controls">
                <div class="history-filters">
                    <button data-period="week" class="active"><i class="fas fa-calendar-week"></i> Semaine</button>
                    <button data-period="month"><i class="fas fa-calendar-alt"></i> Mois</button>
                    <button data-period="year"><i class="fas fa-calendar-check"></i> Année</button>
                    <button data-period="all"><i class="fas fa-infinity"></i> Tout</button>
                </div>
                <div class="history-actions" style="display: none;"> <!-- Caché si pas loggé -->
                    <i class="fab fa-google-drive"></i>
                    <span id="history-drive-status">Synchro Drive</span>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="history-chart-canvas"></canvas>
                <p id="chart-placeholder" style="text-align:center; padding-top: 50px; color: var(--secondary-text-color); display: none;"></p> <!-- Pour message si pas de données/pas connecté -->
            </div>
            <div class="stats-display" id="stats-display">
                <h3>Statistiques</h3>
                <p>Connectez-vous.</p>
                <p class="motivational-message"></p> <!-- Placeholder for motivational message -->
            </div>
            <ul class="history-list" id="history-list">
                <li class="no-history">Connectez-vous.</li>
            </ul>
        </div>
    </main>
</div>

<footer>
    <p>© 2024 ArmorWorkout. Intégré avec <i class="fab fa-google-drive"></i> Google Drive.</p>
    <p><a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i> Voir sur GitHub</a></p>
</footer>

<!-- Zone de Message Flottante -->
<div id="message-area" class="message-area"></div>

<!-- Modal Résumé Post-Workout -->
<div id="post-workout-summary" class="post-workout-summary">
    <div class="post-workout-summary-content">
        <h2 id="summary-title">Résumé de la Séance</h2>
        <ul id="summary-items-list" class="summary-items-list">
            <!-- Contenu généré par JS -->
        </ul>
        <div class="summary-controls">
            <button id="save-summary-btn" class="controls button save-summary-btn"><i class="fas fa-save"></i> Sauvegarder & Fermer</button>
            <button id="cancel-summary-btn" class="controls button cancel-summary-btn"><i class="fas fa-times"></i> Fermer sans Sauvegarder</button>
        </div>
    </div>
</div>

<script>
    // --- CONFIGURATION & CONSTANTES ---
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const HISTORY_FILENAME = "armorworkout_history.csv";
    const PROGRAM_FILENAMES = {
        Push: "armorworkout_push_program.csv",
        Pull: "armorworkout_pull_program.csv",
        Legs: "armorworkout_legs_program.csv"
    };
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const PREPARE_DURATION = 3; // Secondes
    const FINISH_ANIMATION_DURATION = 1500; // ms
    const SECONDS_PER_REP = 2.5; // Estimation temps par rep
    const IN_PROGRESS_KEY = 'armorWorkoutStateInProgress'; // Clé localStorage

    // --- DONNÉES PAR DÉFAUT ---
    // Utilisées comme FALLBACK si Drive échoue ou si les fichiers n'existent pas
    const defaultWorkouts = {
        Push: [
            { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 },
            { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
            { type: 'break', duration: 75, name: 'Repos' },
            { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 },
            { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
            { type: 'break', duration: 75, name: 'Repos' },
            { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 14 },
            { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
            { type: 'break', duration: 75, name: 'Repos' },
            { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 },
            { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 },
            { type: 'break', duration: 60, name: 'Repos' },
            { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 },
            { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 },
        ],
        Pull: [
            { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 },
            { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 },
            { type: 'break', duration: 75, name: 'Repos' },
            { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 },
            { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 },
            { type: 'break', duration: 75, name: 'Repos' },
            { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 13 },
            { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 15 },
            { type: 'break', duration: 75, name: 'Repos' },
            { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 },
            { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 },
            { type: 'break', duration: 60, name: 'Repos' },
            { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 },
            { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 },
        ],
        Legs: [
            { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 },
            { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 },
            { type: 'break', duration: 90, name: 'Repos' },
            { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 },
            { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 },
            { type: 'break', duration: 90, name: 'Repos' },
            { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 14 },
            { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 11 },
            { type: 'break', duration: 90, name: 'Repos' },
            { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 },
            { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 },
            { type: 'break', duration: 60, name: 'Repos' },
            { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 },
            { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 },
        ]
    };

    // --- Éléments DOM (Déclaration) ---
    let timeLeftDisplay, timerCircle, timerStateDisplay, currentExerciseContainer,
        progressTracker, startPauseBtn, skipBtn, finishBtn, resetBtn, navButtons,
        navHistoryBtn, themeToggleBtn, messageArea, workoutSection, historySection,
        historyList, statsDisplay, historyFilterBtns, historyChartCanvas,
        signInButton, signOutButton, driveStatusElement, exportProgramsBtn,
        postWorkoutSummary, summaryTitle, summaryItemsList, saveSummaryBtn,
        cancelSummaryBtn, historyDriveStatus, totalProgressCircle,
        currentExerciseNameDisplay, driveConnectionStatusMain, driveConnectionText,
        timerDisplayElement, chartPlaceholder, progressTextArea, historyActionsContainer; // Ajoutés

    // --- Variables d'État ---
    let currentWorkoutType = null;
    let currentWorkoutPlan = [];
    let originalCompletedWorkoutPlan = []; // Pour le résumé
    let currentItemIndex = 0;
    let timerInterval = null;
    let prepareCountdownInterval = null;
    let totalTime = 0; // Durée totale de l'étape courante (pause)
    let timeLeft = 0; // Temps restant pour l'étape courante (pause)
    let prepareTimeLeft = 0; // Temps restant pour la préparation
    let totalWorkoutEstimatedSeconds = 0;
    let elapsedWorkoutEstimatedSeconds = 0;
    let isTimerRunning = false;
    let isWorkoutActive = false;
    let workoutFinished = false;
    let currentState = 'idle'; // idle, preparing, exercise, break, paused, finished
    let workoutStartTime = null;
    let workoutHistory = [];
    let currentHistoryPeriod = 'week';
    let historyChart = null;
    let googleAccessToken = null;
    let tokenClient = null;
    let historyFileId = null;
    let programFileIds = { Push: null, Pull: null, Legs: null };
    let programsLoaded = false;
    let loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Commence avec défauts
    let isSavingSummary = false;
    let currentTheme = 'dark';
    let messageTimeoutId = null;

    // --- Audio & Vibration ---
    let audioContext = null;
    let endSound = () => { console.log("Beep! (AudioContext non initialisé)"); };
    function initAudioContext() {
        if (audioContext) return; // Déjà initialisé
        if (window.AudioContext || window.webkitAudioContext) {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log("AudioContext initialisé.");
                // Débloquer l'audio context sur interaction utilisateur
                const unlockAudio = () => {
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume().then(() => {
                             console.log("AudioContext resumed!");
                             document.removeEventListener('click', unlockAudio); // Nettoyer listener
                             document.removeEventListener('touchstart', unlockAudio);
                        });
                    } else {
                         document.removeEventListener('click', unlockAudio);
                         document.removeEventListener('touchstart', unlockAudio);
                    }
                };
                document.addEventListener('click', unlockAudio);
                document.addEventListener('touchstart', unlockAudio);

                // Définir la fonction de son maintenant que le contexte existe
                endSound = () => {
                    if (!audioContext) return;
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().then(playActualSound).catch(e => console.error("Erreur reprise AudioContext", e));
                    } else {
                        playActualSound();
                    }
                };
            } catch (e) {
                console.warn("Initialisation AudioContext échouée:", e);
                audioContext = null;
                endSound = () => console.log("Beep! (AudioContext indisponible)");
            }
        } else {
             endSound = () => console.log("Beep! (AudioContext indisponible)");
        }
    }
    function playActualSound() {
        if (!audioContext) return;
        try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = 'triangle';
            oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.5);
        } catch(e) {
            console.error("Erreur lecture son:", e);
        }
    }
    const vibrate = (pattern = [100, 50, 100]) => {
        if ('vibrate' in navigator) {
            try { navigator.vibrate(pattern); }
            catch (e) { console.warn("Vibration échouée:", e); }
        }
    };

    // --- Google Identity Services (GIS) & Drive API ---
    function gisLoadedCallback() {
        console.log("GIS Library Loaded Callback Executed");
        if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID === "VOTRE ID CLIENT ICI") {
            console.error("ERREUR CRITIQUE: GOOGLE_CLIENT_ID non configuré !");
            showMessage("Erreur critique : ID Client Google manquant.", 10000);
            if (driveStatusElement) {
                driveStatusElement.textContent = 'Erreur Config ID'; driveStatusElement.classList.add('error');
                driveStatusElement.style.display = 'inline-block';
            }
            updateAuthUI(false); return;
        }
        try {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GOOGLE_DRIVE_SCOPES,
                callback: (tokenResponse) => {
                    console.log("GIS Callback: Réponse reçue, appel de tokenCallback...");
                    tokenCallback(tokenResponse);
                },
                error_callback: (error) => {
                    console.error("GIS Error Callback:", error); handleTokenError(error);
                },
                prompt: '' // Important: Ne pas forcer l'invite ici, le bouton le fera
            });
            console.log("Token Client initialisé avec succès.");
        } catch (error) {
            console.error("Erreur initialisation Token Client:", error);
            showMessage("Erreur initialisation services Google.", 5000);
            updateAuthUI(false);
            if (driveStatusElement) {
                driveStatusElement.textContent = 'Erreur Init Auth'; driveStatusElement.classList.add('error');
                driveStatusElement.style.display = 'inline-block';
            }
        }
    }
    function handleTokenError(error) {
        console.error("Erreur Token Client:", error);
        let message = `Erreur Authentification Google: ${error.type || error.error || 'Inconnue'}`;
        let statusText = 'Erreur Auth';
        if (driveStatusElement) {
            driveStatusElement.classList.remove('loading','success'); driveStatusElement.classList.add('error');
            driveStatusElement.style.display = 'inline-block';
        }
        if (error.type === 'popup_closed' || error.error === 'user_cancel' || error.error === 'popup_closed') {
            message = "Connexion Google annulée par l'utilisateur."; statusText = 'Annulé';
        } else if (error.type === 'popup_failed_to_open' || error.error === 'popup_failed_to_open') {
            message = "La fenêtre pop-up Google a été bloquée. Vérifiez les paramètres de votre navigateur."; statusText = 'Popup Bloqué';
        } else if (error.type === 'session_timed_out' || error.error === 'session_timed_out'){
            message = "Session Google expirée. Veuillez vous reconnecter."; statusText = 'Expiré';
            handleSignoutClick(false); // Déconnecte proprement l'UI
        } else if (error.type === 'unregistered_origin' || error.type === 'invalid_client' || error.type === 'redirect_uri_mismatch' || error.error === 'invalid_client') {
            message = "Erreur de configuration de l'application Google. Contactez le développeur."; statusText = 'Erreur Config App';
            console.error("Détails erreur de configuration:", error);
        } else if (error.error === 'access_denied') {
            message = "Accès refusé. Vous devez autoriser l'accès à Google Drive."; statusText = 'Accès Refusé';
        } else {
            console.error("Détails erreur d'authentification non gérée:", error);
        }
        showMessage(message, 7000);
        if (driveStatusElement) driveStatusElement.textContent = statusText;
        updateAuthUI(false); // Assure que l'UI reflète l'échec
    }
    async function tokenCallback(tokenResponse) {
        console.log("Logique tokenCallback en cours avec réponse:", tokenResponse);
        if (driveStatusElement) { driveStatusElement.classList.remove('loading', 'error', 'success'); driveStatusElement.style.display = 'inline-block'; }

        if (tokenResponse && tokenResponse.access_token) {
            console.log("Access Token reçu avec succès.");
            googleAccessToken = tokenResponse.access_token;
            updateAuthUI(true); // Met à jour l'UI *avant* le chargement
            showMessage("Connecté. Chargement des données...", 3000);
            if (driveStatusElement) { driveStatusElement.textContent = 'Chargement...'; driveStatusElement.classList.add('loading'); }

            try {
                console.log("tokenCallback: Tentative de chargement parallèle historique & programmes...");
                // Charger l'historique en premier, car il est moins critique pour démarrer
                const historyResult = await loadHistoryFromDrive();
                console.log(`tokenCallback: Historique chargé OK: ${historyResult}`);

                // Ensuite charger les programmes
                const programsResult = await loadProgramsFromDrive();
                console.log(`tokenCallback: Programmes chargés OK: ${programsResult}`);

                if (programsResult) {
                    console.log("Données Drive (programmes) chargées avec succès ou fallback.");
                    showMessage("Historique et programmes chargés.", 2500);
                    if (driveStatusElement) { driveStatusElement.textContent = 'Connecté'; driveStatusElement.classList.remove('loading'); driveStatusElement.classList.add('success'); }
                    const resumed = loadInProgressState(); // Tenter de reprendre une session
                    if (!resumed) {
                        updateAuthUI(true); // Assure que les boutons sont corrects après chargement
                    }
                } else {
                    showMessage("Erreur critique lors du chargement des programmes depuis Drive. Programmes par défaut utilisés.", 6000);
                    if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Progs'; driveStatusElement.classList.remove('loading'); driveStatusElement.classList.add('error'); }
                    updateAuthUI(true); // Met à jour l'UI même si échec programmes
                }
            } catch (error) {
                console.error("tokenCallback: ERREUR CRITIQUE pendant le chargement des données:", error);
                console.error("Stack Trace:", error.stack);
                showMessage("Erreur majeure lors du chargement des données depuis Drive.", 7000);
                loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Reset aux défauts
                workoutHistory = [];
                programsLoaded = false;
                updateAuthUI(true); // Toujours connecté, mais avec erreur
                if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Données'; driveStatusElement.classList.remove('loading'); driveStatusElement.classList.add('error'); }
                displayHistory(); // Affiche l'historique vide
                 updateAuthUI(true); // Met à jour l'UI pour refléter l'erreur de chargement
            }
        } else {
            console.error("Erreur dans la réponse Token ou access_token manquant:", tokenResponse);
            if (tokenResponse && tokenResponse.error) {
                handleTokenError(tokenResponse);
            } else {
                showMessage("Erreur: Jeton Google invalide reçu.", 5000);
                updateAuthUI(false);
                if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Jeton'; driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; }
            }
        }
    }
    function handleAuthClick() {
        initAudioContext(); // Init audio au premier clic
        console.log("Clic sur 'Connecter Drive'");
        if (!tokenClient) {
            showMessage("La bibliothèque Google n'est pas encore prête, veuillez patienter...", 3000);
            console.warn("Tentative de connexion avant l'initialisation complète du tokenClient.");
            if (driveStatusElement) { driveStatusElement.textContent = 'Non Prêt'; driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; }
            return;
        }
        console.log("Demande manuelle d'Access Token...");
        if (driveStatusElement) { driveStatusElement.textContent = 'Connexion...'; driveStatusElement.classList.add('loading'); driveStatusElement.classList.remove('error','success'); driveStatusElement.style.display = 'inline-block'; }
        // Force l'affichage de la popup de consentement si nécessaire
        tokenClient.requestAccessToken({ prompt: 'consent' });
    }
    function handleSignoutClick(showMsg = true) {
        console.log("Clic sur 'Déconnecter'");
        const token = googleAccessToken;
        if (token) {
            if (showMsg && driveStatusElement) { driveStatusElement.textContent = 'Déconnexion...'; driveStatusElement.classList.add('loading'); driveStatusElement.classList.remove('error','success'); driveStatusElement.style.display = 'inline-block'; }
            google.accounts.oauth2.revoke(token, () => {
                console.log('Token Google révoqué.');
                googleAccessToken = null;
                historyFileId = null;
                programFileIds = { Push: null, Pull: null, Legs: null };
                programsLoaded = false;
                workoutHistory = [];
                loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
                if (isWorkoutActive || currentState !== 'idle') {
                    resetCurrentWorkout(); // Réinitialise aussi l'UI via setState('idle') -> updateAuthUI
                } else {
                    updateAuthUI(false); // Met juste à jour l'UI
                }
                if (showMsg) { showMessage("Déconnecté de Google Drive.", 2500); }
                if (driveStatusElement) { driveStatusElement.textContent = ''; driveStatusElement.classList.remove('loading', 'error','success'); driveStatusElement.style.display = 'none'; }
            });
        } else {
            console.log("Pas de token à révoquer, mise à jour UI.");
            updateAuthUI(false);
            if (driveStatusElement) { driveStatusElement.textContent = ''; driveStatusElement.style.display = 'none'; }
        }
    }
    function updateAuthUI(isLoggedIn) {
        updateAuthUIDetailed(isLoggedIn);
    }
    function updateAuthUIDetailed(isLoggedIn) {
        console.log(`Mise à jour UI - Connecté: ${isLoggedIn}, Programmes Chargés: ${programsLoaded}, WorkoutType: ${currentWorkoutType}, État Timer: ${currentState}`);
        const body = document.body;
        body.classList.toggle('logged-in', isLoggedIn);
        body.classList.toggle('logged-out', !isLoggedIn);
        body.classList.toggle('workout-selected', !!currentWorkoutType); // Classe pour indiquer sélection

        // Statut Drive Header
        if (driveStatusElement) {
            driveStatusElement.style.display = isLoggedIn ? 'inline-block' : 'none';
            if (!isLoggedIn) {
                driveStatusElement.textContent = '';
                driveStatusElement.classList.remove('loading', 'error', 'success');
            }
            // Le contenu est géré par tokenCallback, handleTokenError, etc.
        }

        // Statut Drive bas (workout section)
        if (driveConnectionStatusMain && driveConnectionText && progressTracker) {
             const driveIcon = driveConnectionStatusMain.querySelector('i.fa-google-drive');
             if (isLoggedIn) {
                 driveConnectionStatusMain.style.display = 'inline-flex'; // Afficher le conteneur
                 if (driveStatusElement?.classList.contains('loading')) {
                     driveConnectionText.textContent = "Chargement Drive...";
                     if (driveIcon) driveIcon.classList.add('fa-spin');
                 } else if (driveStatusElement?.classList.contains('error')) {
                     driveConnectionText.textContent = `Erreur Drive (${driveStatusElement.textContent || '?'})`;
                     if (driveIcon) driveIcon.classList.remove('fa-spin');
                 } else {
                     driveConnectionText.textContent = "Connecté"; // Texte plus court
                     if (driveIcon) driveIcon.classList.remove('fa-spin');
                 }
             } else {
                 driveConnectionStatusMain.style.display = 'none'; // Cacher si pas loggué
                 if (driveIcon) driveIcon.classList.remove('fa-spin');
             }
        }

         // Statut Drive Historique
         if (historyDriveStatus && historyActionsContainer) {
             historyActionsContainer.style.display = isLoggedIn ? 'flex' : 'none';
             if (isLoggedIn) {
                  if (driveStatusElement?.classList.contains('loading')) {
                       historyDriveStatus.textContent = 'Sync...';
                  } else if (driveStatusElement?.classList.contains('error')) {
                      historyDriveStatus.textContent = 'Erreur Sync';
                  } else {
                      historyDriveStatus.textContent = 'Synchro OK';
                  }
             }
         }

        // Boutons Header
        themeToggleBtn.disabled = false; // Toujours actif
        navHistoryBtn.disabled = false; // Toujours actif
        navButtons.forEach(btn => btn.disabled = !(isLoggedIn && programsLoaded));
        if (exportProgramsBtn) exportProgramsBtn.disabled = !(isLoggedIn && programsLoaded);

        // Gérer les boutons de contrôle PRINCIPALEMENT dans setState.
        // Ici, on met à jour pour l'état IDLE ou après login/logout/reset.
        if (currentState === 'idle' || currentState === 'finished') {
            const canStart = isLoggedIn && programsLoaded && !!currentWorkoutType;
            startPauseBtn.disabled = !canStart;
            startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer';
            startPauseBtn.classList.remove('pause-btn');

            skipBtn.disabled = true;
            finishBtn.disabled = true;

            // Reset activé si un type est sélectionné OU si l'état est fini
             resetBtn.disabled = !(currentWorkoutType || currentState === 'finished');
        }
        // Pour les autres états (preparing, exercise, break, paused), c'est setState qui gère les boutons.

        // Mettre à jour l'affichage info workout et historique car l'état de connexion a changé
        updateWorkoutInfo();
        displayHistory(currentHistoryPeriod); // Important pour afficher/cacher message connexion
    }

    async function findOrCreateFile(filename, defaultCsvContent = "") {
        console.log(`findOrCreateFile: Recherche ou création de ${filename}`);
        if (!googleAccessToken) { console.warn("findOrCreateFile: Non connecté."); return null; }

        const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+mimeType='text/csv'+and+trashed=false&spaces=drive&fields=files(id,name)`;
        try {
            const searchRes = await fetch(searchUrl, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } });
            if (!searchRes.ok) {
                if (searchRes.status === 401 || searchRes.status === 403) {
                    console.warn(`Erreur d'authentification (${searchRes.status}) lors de la recherche de ${filename}. Tentative de déconnexion.`);
                    handleSignoutClick(false); showMessage("Session Google expirée ou invalide. Reconnexion nécessaire.", 6000); return null;
                } throw new Error(`Erreur recherche fichier ${filename} (${searchRes.status} ${searchRes.statusText})`);
            }
            const searchData = await searchRes.json();

            if (searchData.files && searchData.files.length > 0) {
                console.log(`Fichier ${filename} trouvé ID: ${searchData.files[0].id}`);
                return searchData.files[0].id;
            } else {
                console.log(`Fichier ${filename} non trouvé. Création...`);
                const createUrl = `https://www.googleapis.com/drive/v3/files`;
                const metadata = { name: filename, mimeType: 'text/csv' };
                const createRes = await fetch(createUrl, { method: 'POST', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' }, body: JSON.stringify(metadata) });
                if (!createRes.ok) {
                     if (createRes.status === 401 || createRes.status === 403) {
                         console.warn(`Erreur auth (${createRes.status}) lors création ${filename}. Déconnexion.`);
                         handleSignoutClick(false); showMessage("Session Google expirée ou invalide. Reconnexion nécessaire.", 6000); return null;
                     } throw new Error(`Erreur création fichier ${filename} (${createRes.status} ${createRes.statusText})`);
                }
                const createData = await createRes.json();
                const newFileId = createData.id;
                console.log(`Fichier ${filename} créé ID: ${newFileId}. Écriture contenu défaut...`);
                const writeSuccess = await updateFileContent(newFileId, defaultCsvContent);
                if (writeSuccess) { console.log(`Contenu défaut écrit dans ${filename}.`); return newFileId; }
                else { console.error(`Échec écriture contenu défaut dans ${filename}.`); return null; }
            }
        } catch (error) {
            console.error(`findOrCreateFile: ERREUR pour ${filename}:`, error);
            showMessage(`Erreur Drive (${filename.substring(0,15)}...): ${error.message}`, 7000);
            if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Accès'; driveStatusElement.classList.add('error'); }
            return null;
        }
    }
    async function readFileContent(fileId) {
        console.log(`readFileContent: Lecture ID ${fileId}`);
        if (!googleAccessToken || !fileId) { console.warn("readFileContent: Non connecté ou fileId manquant."); return null; }

        const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
        try {
            const response = await fetch(url, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } });
            if (!response.ok) {
                if (response.status === 404) { console.warn(`Fichier ${fileId} non trouvé (404). Sera recréé si nécessaire.`); return ""; } // Retourne vide si 404
                 if (response.status === 401 || response.status === 403) {
                     console.warn(`Erreur auth (${response.status}) lecture ${fileId}. Déconnexion.`);
                     handleSignoutClick(false); showMessage("Session Google expirée ou accès refusé. Reconnexion nécessaire.", 6000); return null;
                 } throw new Error(`Erreur lecture fichier ${fileId} (${response.status} ${response.statusText})`);
            }
            const content = await response.text();
            console.log(`Lecture fichier ${fileId} réussie.`);
            return content;
        } catch (error) {
            console.error(`readFileContent: ERREUR pour ${fileId}:`, error);
            showMessage(`Erreur Drive Lecture: ${error.message}`, 6000);
             if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Lecture'; driveStatusElement.classList.add('error'); }
            return null;
        }
    }
    async function updateFileContent(fileId, content) {
        console.log(`updateFileContent: Mise à jour ID ${fileId}`);
        if (!googleAccessToken || !fileId) { console.warn("updateFileContent: Non connecté ou fileId manquant."); return false; }

        const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`;
        try {
            const response = await fetch(url, { method: 'PATCH', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'text/csv' }, body: content });
            if (!response.ok) {
                 if (response.status === 401 || response.status === 403) {
                     console.warn(`Erreur auth (${response.status}) écriture ${fileId}. Déconnexion.`);
                     handleSignoutClick(false); showMessage("Session expirée ou accès refusé. Sauvegarde échouée.", 6000); return false;
                 } throw new Error(`Erreur écriture fichier ${fileId} (${response.status} ${response.statusText})`);
            }
            console.log(`Écriture fichier ${fileId} réussie.`);
            return true;
        } catch (error) {
            console.error(`updateFileContent: ERREUR pour ${fileId}:`, error);
            showMessage(`Erreur Drive Écriture: ${error.message}`, 6000);
             if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Écriture'; driveStatusElement.classList.add('error'); }
             if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Sync';
            return false;
        }
    }

    // --- Fonctions Cœur du Timer ---
    function formatTime(seconds) {
        const absSeconds = Math.max(0, Math.round(seconds));
        const minutes = Math.floor(absSeconds / 60);
        const remainingSeconds = absSeconds % 60;
        return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }
    function formatTimeForChart(seconds) {
        return parseFloat((Math.max(0, seconds) / 60).toFixed(1));
    }
    function calculateTotalEstimatedTime(plan) {
        let totalSeconds = 0;
        plan.forEach(item => {
            let estimatedDuration = 0;
            if (item.type === 'break') { estimatedDuration = item.duration || 0; }
            else if (item.type === 'exercise') { estimatedDuration = (item.reps || 0) * SECONDS_PER_REP; }
            item.estimatedDuration = estimatedDuration; // Stocke dans l'objet
            totalSeconds += estimatedDuration;
        });
        console.log(`Temps total estimé: ${totalSeconds.toFixed(1)}s (${formatTime(totalSeconds)})`);
        return totalSeconds;
    }
    function updateTotalProgressCircle() {
        if (!totalProgressCircle || totalWorkoutEstimatedSeconds <= 0) {
            if(totalProgressCircle) totalProgressCircle.style.background = `var(--total-progress-bg)`;
            return;
        }
        let currentTotalElapsed = 0;
        for (let i = 0; i < currentItemIndex; i++) {
            currentTotalElapsed += currentWorkoutPlan[i]?.estimatedDuration || 0;
        }
        // Ajoute la progression dans l'étape actuelle si c'est une pause mesurable
        if ((currentState === 'break' || currentState === 'paused') && currentWorkoutPlan[currentItemIndex]?.type === 'break' && totalTime > 0) {
             const progressInCurrentBreak = (totalTime - timeLeft);
             const estimatedBreakDuration = currentWorkoutPlan[currentItemIndex]?.estimatedDuration || totalTime;
             currentTotalElapsed += Math.min(progressInCurrentBreak, estimatedBreakDuration); // Ne pas dépasser l'estimé
        } else if (currentState === 'exercise' && currentWorkoutPlan[currentItemIndex]?.type === 'exercise') {
            // On pourrait estimer la progression dans l'exercice, mais c'est complexe.
            // Pour l'instant, on considère que l'estimé n'est ajouté qu'à la complétion.
        } else if (currentState === 'finished') {
            currentTotalElapsed = totalWorkoutEstimatedSeconds; // Force 100% à la fin
        }

        currentTotalElapsed = Math.min(currentTotalElapsed, totalWorkoutEstimatedSeconds); // Plafonne à 100%
        const progressPercent = totalWorkoutEstimatedSeconds > 0 ? (currentTotalElapsed / totalWorkoutEstimatedSeconds) * 100 : 0;

        // Applique le dégradé conic
        totalProgressCircle.style.background = `conic-gradient(from 180deg, var(--neon-blue) ${progressPercent}%, var(--neon-pink) ${progressPercent + 30}%, var(--total-progress-bg) ${progressPercent}%)`;
    }
    function updateTimerDisplay() {
        if (!timeLeftDisplay || !timerCircle || !totalProgressCircle) return;

        let innerProgressPercent = 0;
        let displayTime = "00:00";
        let stepColor = 'var(--secondary-text-color)'; // Gris par défaut
        let stepGlow = 'none';

        if ((currentState === 'break' || (currentState === 'paused' && currentWorkoutPlan[currentItemIndex]?.type === 'break')) && totalTime > 0) {
            innerProgressPercent = Math.max(0, Math.min(100, ((totalTime - timeLeft) / totalTime) * 100));
            displayTime = formatTime(timeLeft);
            stepColor = 'var(--neon-yellow)'; stepGlow = 'var(--glow-yellow)';
        } else if (currentState === 'preparing') {
            innerProgressPercent = Math.max(0, Math.min(100, ((PREPARE_DURATION - prepareTimeLeft) / PREPARE_DURATION) * 100));
            displayTime = formatTime(prepareTimeLeft);
            stepColor = 'var(--neon-yellow)'; stepGlow = 'var(--glow-yellow)';
        } else if (currentState === 'finished') {
            innerProgressPercent = 100;
            displayTime = "FINI";
            stepColor = 'var(--neon-green)'; stepGlow = 'var(--glow-green)';
        } else if (currentState === 'exercise') {
            innerProgressPercent = 0; // Pas de progression interne pour l'exo
            displayTime = "GO!";
            stepColor = 'var(--neon-pink)'; stepGlow = 'var(--glow-pink)';
        } else { // idle ou état inconnu
            innerProgressPercent = 0;
            displayTime = formatTime(0);
            stepColor = 'var(--secondary-text-color)'; // Gris
            stepGlow = 'none';
        }

        timeLeftDisplay.textContent = displayTime;
        // Mise à jour des variables CSS pour la couleur/glow du cercle intérieur
        timerCircle.style.setProperty('--current-step-color', stepColor);
        timerCircle.style.setProperty('--current-step-glow', stepGlow);
        // Mise à jour du dégradé du cercle intérieur
        timerCircle.style.backgroundImage = `conic-gradient(${stepColor} ${innerProgressPercent}%, transparent ${innerProgressPercent}%)`;

        // Mise à jour du cercle extérieur (progression totale)
        updateTotalProgressCircle();
    }
    function updateWorkoutInfo() {
         if (!currentExerciseContainer || !currentExerciseNameDisplay || !progressTracker || !progressTextArea) return;

         const currentItem = currentWorkoutPlan[currentItemIndex];
         let infoHtml = '';
         let nameDisplay = '';
         let progressText = '';

         if (currentState === 'idle') {
             if (googleAccessToken) {
                 if (programsLoaded) {
                     progressText = currentWorkoutType
                         ? `Prêt: ${currentWorkoutType} (${currentWorkoutPlan.length} étapes)`
                         : "Sélectionnez un entraînement.";
                 } else {
                     progressText = "Chargement programmes...";
                 }
             } else {
                 progressText = "Connectez-vous pour commencer.";
             }
             infoHtml = `<p>${progressText}</p>`; // Affiche dans la zone détail aussi
         } else if (currentState === 'finished') {
             const duration = workoutStartTime ? formatTime((Date.now() - workoutStartTime) / 1000) : 'N/A';
             nameDisplay = 'Terminé !';
             infoHtml = `<h2><i class="fas fa-check-circle" style="color: var(--neon-green)"></i> Bravo !</h2><p>Temps total: <strong>${duration}</strong></p>`;
             progressText = `Terminé (${originalCompletedWorkoutPlan.length}/${originalCompletedWorkoutPlan.length})`;
         } else if (currentState === 'preparing') {
             const nextItem = currentWorkoutPlan[0];
             nameDisplay = `Préparez : ${nextItem?.name || 'Étape Suivante'}`;
             infoHtml = `<p style="color: var(--neon-yellow); font-weight: 500;">Prêt dans ${prepareTimeLeft}s...</p>`;
             progressText = `Préparation... (1/${currentWorkoutPlan.length})`;
         } else if (currentItem) {
             nameDisplay = `${currentItem.name || (currentItem.type === 'break' ? 'Repos' : 'Étape Inconnue')}`;
             progressText = `Étape ${currentItemIndex + 1} / ${currentWorkoutPlan.length}`;
             if (currentItem.type === 'exercise') {
                 const reps = (currentItem.reps !== null && Number.isFinite(currentItem.reps)) ? `${currentItem.reps}` : '-';
                 const details = currentItem.details || 'Aucun détail';
                 infoHtml = `<div class="exercise-details"><span><i class="fas fa-hashtag"></i> Reps: <strong>${reps}</strong></span><span class="details-text"><i class="fas fa-info-circle"></i> ${details}</span></div>`;
             } else if (currentItem.type === 'break') {
                 infoHtml = `<div class="break-info"><i class="fas fa-coffee"></i><span>Pause: ${formatTime(currentItem.duration || 0)}</span></div>`;
             }
         } else if (isWorkoutActive) { // Si actif mais item courant non défini (ne devrait pas arriver)
             nameDisplay = 'Chargement...';
             infoHtml = '<p>Patientez...</p>';
             progressText = `Étape ? / ${currentWorkoutPlan.length}`;
         }

         currentExerciseNameDisplay.textContent = nameDisplay;
         currentExerciseContainer.innerHTML = infoHtml;
         progressTextArea.textContent = progressText; // Met à jour la partie texte du tracker
    }
    function setState(newState) {
        if (!startPauseBtn || !skipBtn || !finishBtn || !resetBtn || !timerStateDisplay || !workoutSection) {
            console.error("setState: Elements DOM manquants."); return;
        }
        const previousState = currentState;
        currentState = newState;
        console.log(`Transition État: ${previousState} -> ${newState}`);

        // Nettoyage des timers
        clearInterval(timerInterval); timerInterval = null;
        clearInterval(prepareCountdownInterval); prepareCountdownInterval = null;

        // Réinitialisation UI Timer
        timerStateDisplay.classList.remove('visible', 'preparing');
        startPauseBtn.classList.remove('pause-btn');
        document.body.classList.toggle('workout-active', newState !== 'idle' && newState !== 'finished');
        workoutSection.classList.remove('finished-animation'); // Retire l'anim à chaque changement d'état sauf si c'est 'finished'

        // Désactivation par défaut, activation sélective dans le switch
        startPauseBtn.disabled = true;
        skipBtn.disabled = true;
        finishBtn.disabled = true;
        resetBtn.disabled = true;

        switch (newState) {
            case 'idle':
                isTimerRunning = false; isWorkoutActive = false; workoutFinished = false;
                timeLeft = 0; totalTime = 0;
                timerStateDisplay.textContent = '';
                updateAuthUI(!!googleAccessToken); // Met à jour les boutons en fonction de login/load/selection
                break;

            case 'preparing':
                isTimerRunning = false; isWorkoutActive = true; workoutFinished = false;
                timerStateDisplay.textContent = `${PREPARE_DURATION}`;
                timerStateDisplay.classList.add('visible', 'preparing');
                prepareTimeLeft = PREPARE_DURATION;
                // Seul Reset est actif pendant la prépa
                resetBtn.disabled = !googleAccessToken || !programsLoaded;
                startPrepareCountdown();
                break;

            case 'exercise':
                isTimerRunning = false; isWorkoutActive = true; workoutFinished = false;
                timerStateDisplay.textContent = 'EXERCICE'; timerStateDisplay.classList.add('visible');
                timeLeft = 0; totalTime = 0;
                // Activer les boutons si loggué et programmes chargés
                if (googleAccessToken && programsLoaded) {
                    startPauseBtn.disabled = false;
                    startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Fait';
                    skipBtn.disabled = false;
                    finishBtn.disabled = false;
                    resetBtn.disabled = false;
                }
                break;

            case 'break':
                isTimerRunning = true; isWorkoutActive = true; workoutFinished = false;
                timerStateDisplay.textContent = 'REPOS'; timerStateDisplay.classList.add('visible');
                 if (googleAccessToken && programsLoaded) {
                    startPauseBtn.disabled = false;
                    startPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                    startPauseBtn.classList.add('pause-btn');
                    skipBtn.disabled = false;
                    finishBtn.disabled = false;
                    resetBtn.disabled = false;
                }
                startBreakTimer();
                break;

            case 'paused':
                isTimerRunning = false; isWorkoutActive = true; workoutFinished = false;
                timerStateDisplay.textContent = 'EN PAUSE'; timerStateDisplay.classList.add('visible');
                if (googleAccessToken && programsLoaded) {
                    startPauseBtn.disabled = false;
                    startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Reprendre';
                    startPauseBtn.classList.add('pause-btn');
                    skipBtn.disabled = false; // Reste actif en pause
                    finishBtn.disabled = false; // Reste actif en pause
                    resetBtn.disabled = false; // Reste actif en pause
                }
                break;

            case 'finished':
                isTimerRunning = false; isWorkoutActive = false; workoutFinished = true;
                timerStateDisplay.textContent = 'FINI !'; timerStateDisplay.classList.add('visible');
                timeLeft = 0; totalTime = 0;
                elapsedWorkoutEstimatedSeconds = totalWorkoutEstimatedSeconds; // Force la progression à 100%
                // Désactiver tous sauf Reset
                resetBtn.disabled = false; // Permet de reset après la fin
                startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Terminé';
                // Logique de fin
                showMessage('Entraînement terminé ! 💪', 4000);
                vibrate([200, 100, 200]);
                if (endSound) endSound();
                originalCompletedWorkoutPlan = JSON.parse(JSON.stringify(currentWorkoutPlan)); // Copie pour le résumé
                saveWorkoutToHistory();
                clearInProgressState();
                workoutSection.classList.add('finished-animation'); // Lancer l'animation
                setTimeout(populateAndShowSummary, FINISH_ANIMATION_DURATION); // Afficher résumé après anim
                break;

            default:
                console.error("État inconnu demandé:", newState);
                currentState = 'idle'; // Retour sûr
                updateAuthUI(!!googleAccessToken); // Réinitialiser UI/boutons
                break;
        }

        updateTimerDisplay(); // Met à jour affichage timer (temps, couleurs, barres)
        updateWorkoutInfo(); // Met à jour nom exo, détails, progression textuelle
    }

    function startPrepareCountdown() {
        if (prepareCountdownInterval) clearInterval(prepareCountdownInterval);
        updateTimerDisplay(); // Affichage initial
        updateWorkoutInfo(); // Info prépa
        timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`;

        prepareCountdownInterval = setInterval(() => {
            prepareTimeLeft--;
            updateTimerDisplay();
            updateWorkoutInfo();
            timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`;

            if (prepareTimeLeft <= 0) {
                clearInterval(prepareCountdownInterval); prepareCountdownInterval = null;
                if (endSound) endSound(); vibrate([50]);
                const firstItem = currentWorkoutPlan[0];
                if (!firstItem) { console.error("Plan vide après prépa."); resetCurrentWorkout(); return; }

                if (firstItem.type === 'exercise') { setState('exercise'); }
                else { // C'est un 'break' (ou autre type futur avec durée)
                    totalTime = firstItem.duration || 0; timeLeft = totalTime;
                    setState('break');
                }
                saveInProgressState(); // Sauvegarde l'état après la prépa
            }
        }, 1000);
    }
    function startBreakTimer() {
        if (timerInterval) clearInterval(timerInterval);
        updateTimerDisplay(); // Affichage initial du temps de pause

        timerInterval = setInterval(() => {
            if (timeLeft > 0) {
                timeLeft--;
                updateTimerDisplay();
                saveInProgressState(); // Sauvegarde la progression pendant la pause
            } else {
                clearInterval(timerInterval); timerInterval = null;
                handleItemCompletion(true); // Passe à l'étape suivante naturellement
            }
        }, 1000);
    }
    function handleItemCompletion(naturalCompletion = false) {
        if (currentState === 'finished' || currentState === 'preparing') return;

        const completedItemIndex = currentItemIndex;
        const completedItem = currentWorkoutPlan[completedItemIndex];

        // Mise à jour de la progression estimée
        if (completedItem && completedItem.estimatedDuration !== undefined) {
            elapsedWorkoutEstimatedSeconds += completedItem.estimatedDuration;
            elapsedWorkoutEstimatedSeconds = Math.min(elapsedWorkoutEstimatedSeconds, totalWorkoutEstimatedSeconds); // Plafond
            console.log(`Item ${completedItemIndex} terminé. Estimé: ${elapsedWorkoutEstimatedSeconds.toFixed(1)}/${totalWorkoutEstimatedSeconds.toFixed(1)}`);
        } else {
            console.warn(`Durée estimée non trouvée pour item ${completedItemIndex}.`);
        }
        // La mise à jour visuelle de la barre totale se fait dans updateTimerDisplay -> updateTotalProgressCircle

        // Son/Vibration si fin naturelle d'une pause
        if (naturalCompletion && currentState === 'break') {
            if (endSound) endSound(); vibrate();
        }

        currentItemIndex++;
        saveInProgressState(); // Sauvegarde le nouvel index

        if (currentItemIndex >= currentWorkoutPlan.length) {
            setState('finished'); // Fin du workout
        } else {
            const nextItem = currentWorkoutPlan[currentItemIndex];
            if (!nextItem) { console.error("Élément suivant invalide."); setState('finished'); return; }

            if (nextItem.type === 'exercise') { setState('exercise'); }
            else { // C'est une pause
                totalTime = nextItem.duration || 0; timeLeft = totalTime;
                setState('break');
            }
        }
    }
    function forceFinishWorkout() {
        if (!isWorkoutActive || workoutFinished || currentState === 'preparing') return;
        if (confirm("Terminer cet entraînement maintenant ?")) {
            clearInterval(timerInterval); clearInterval(prepareCountdownInterval);
            timerInterval = null; prepareCountdownInterval = null;
            setState('finished'); // Déclenche toute la logique de fin
            showMessage("Entraînement terminé manuellement.", 3000);
        }
    }
    function loadWorkout(type) {
        if (!googleAccessToken) { showMessage("Connectez-vous pour charger un entraînement.", 4000); setActiveWorkoutNav(null); return; }
        if (!programsLoaded) { showMessage("Programmes en cours de chargement ou erreur. Patientez.", 4000); setActiveWorkoutNav(null); return; }

        // Gérer le changement de workout en cours
        if (isWorkoutActive && !workoutFinished && currentWorkoutType !== type) {
            if (!confirm(`Entraînement "${currentWorkoutType || 'en cours'}" actif. Arrêter et charger "${type}" ?`)) {
                setActiveWorkoutNav(currentWorkoutType); // Réactive le bouton du workout en cours
                return;
            } else {
                resetCurrentWorkout(); // Arrête et nettoie l'ancien avant de charger le nouveau
            }
        } else if (currentWorkoutType === type && (isWorkoutActive || workoutFinished || currentState !== 'idle')) {
            // Si on reclique sur le même workout déjà chargé/actif/fini
            showMessage(`"${type}" déjà chargé. Cliquez sur Reset ou démarrez/reprenez.`, 3000);
            showSection('workout'); // Assure que la section workout est visible
            setActiveWorkoutNav(type);
            return;
        }

        // Chargement effectif
        if (!loadedWorkouts[type]) { console.error(`Programme '${type}' introuvable.`); showMessage(`Erreur: Programme ${type} non trouvé.`, 4000); setActiveWorkoutNav(null); return; }
        console.log(`Chargement: ${type}`);
        currentWorkoutType = type;
        currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[type])); // Copie profonde
        originalCompletedWorkoutPlan = []; // Reset pour le résumé

        if (!currentWorkoutPlan || currentWorkoutPlan.length === 0) {
            console.error(`Programme ${type} vide/invalide.`);
            showMessage(`Erreur: Programme "${type}" vide. Vérifiez le fichier Drive.`, 5000);
            currentWorkoutType = null; // Annule la sélection
            setActiveWorkoutNav(null);
            updateAuthUI(true); // Met à jour les boutons (Start sera désactivé)
            return;
        }

        // Calculs et reset état
        totalWorkoutEstimatedSeconds = calculateTotalEstimatedTime(currentWorkoutPlan);
        elapsedWorkoutEstimatedSeconds = 0;
        currentItemIndex = 0;
        workoutStartTime = null;
        workoutFinished = false;
        isWorkoutActive = false;
        isTimerRunning = false;

        setActiveWorkoutNav(type); // Met en surbrillance le bouton nav
        showSection('workout'); // Affiche la section workout
        closeSummary(); // Ferme le résumé s'il était ouvert

        // Nettoie les timers et passe à l'état 'idle' (qui mettra à jour les boutons via updateAuthUI)
        clearInterval(timerInterval); timerInterval = null;
        clearInterval(prepareCountdownInterval); prepareCountdownInterval = null;
        setState('idle'); // Met l'état à idle, prêt à démarrer

        showMessage(`Programme "${type}" (${currentWorkoutPlan.length} étapes) chargé. Prêt !`, 3500);
    }
    function resetCurrentWorkout() {
        console.log("Réinitialisation...");
        // Arrêter tous les timers
        clearInterval(timerInterval); timerInterval = null;
        clearInterval(prepareCountdownInterval); prepareCountdownInterval = null;

        const typeReset = currentWorkoutType; // Sauvegarde le type pour le message

        // Remettre à zéro les variables d'état du workout
        currentWorkoutType = null;
        currentWorkoutPlan = [];
        originalCompletedWorkoutPlan = [];
        currentItemIndex = 0;
        workoutStartTime = null;
        isTimerRunning = false;
        isWorkoutActive = false;
        workoutFinished = false;
        timeLeft = 0;
        totalTime = 0;
        prepareTimeLeft = 0;
        totalWorkoutEstimatedSeconds = 0;
        elapsedWorkoutEstimatedSeconds = 0;

        // Nettoyer la persistance locale
        clearInProgressState();
        // Fermer le résumé post-workout s'il est ouvert
        closeSummary();
        // Retirer l'animation de fin si elle était appliquée
        workoutSection.classList.remove('finished-animation');
        // Désactiver le bouton de navigation actif
        setActiveWorkoutNav(null);
        // Assurer que la section workout est visible
        showSection('workout');
        // Passer à l'état 'idle' (qui mettra à jour les boutons via updateAuthUI)
        setState('idle');

        // Afficher un message
        if (typeReset) { showMessage(`"${typeReset}" réinitialisé.`, 2500); }
        else { showMessage(`État réinitialisé.`, 2000); }

        // S'assurer que l'UI reflète l'état (boutons, infos)
        // updateAuthUI est appelé dans setState('idle'), donc c'est bon.
    }
    function showMessage(msg, duration = 3500) {
        if (!messageArea) return;
        messageArea.textContent = msg;
        messageArea.classList.add('visible');
        // Clear previous timeout if exists
        if (messageTimeoutId) { clearTimeout(messageTimeoutId); }
        // Set new timeout
        messageTimeoutId = setTimeout(() => {
            messageArea.classList.remove('visible');
            messageTimeoutId = null;
        }, duration);
    }

    // --- Gestion du Thème ---
    function applyTheme(theme) {
        const body = document.body;
        currentTheme = theme;
        const isDark = theme === 'dark';
        body.classList.remove('light-theme', 'dark-theme');
        body.classList.add(theme + '-theme');

        if (themeToggleBtn) {
            themeToggleBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        }
        try { localStorage.setItem('theme', theme); }
        catch (e) { console.warn("Impossible de sauvegarder le thème:", e); }

        // Mettre à jour le thème du graphique s'il est visible
        if (historyChart && historyChartCanvas && !historySection?.classList.contains('section-hidden')) {
            updateChartTheme();
        }
        console.log(`Thème appliqué: ${theme}`);
    }
    function updateChartTheme() {
        if (!historyChart) return;
        const bodyStyles = getComputedStyle(document.documentElement);
        const gridColor = bodyStyles.getPropertyValue('--border-color').trim();
        const textColor = bodyStyles.getPropertyValue('--primary-text-color').trim();
        const tooltipBg = bodyStyles.getPropertyValue('--secondary-bg-color').trim();
        const primaryColor = bodyStyles.getPropertyValue('--neon-blue').trim();
        const accentColor = bodyStyles.getPropertyValue('--neon-pink').trim();

        try {
            const scales = historyChart.options.scales;
            if (scales) {
                if (scales.x) { scales.x.grid.color = gridColor; scales.x.ticks.color = textColor; if (scales.x.title) scales.x.title.color = textColor; }
                if (scales.y) { scales.y.grid.color = gridColor; scales.y.ticks.color = textColor; if (scales.y.title) scales.y.title.color = textColor; }
            }
            const plugins = historyChart.options.plugins;
            if (plugins) {
                if (plugins.tooltip) { plugins.tooltip.backgroundColor = tooltipBg; plugins.tooltip.titleColor = textColor; plugins.tooltip.bodyColor = textColor; }
                if (plugins.legend && plugins.legend.labels) { plugins.legend.labels.color = textColor; }
            }
            // Mise à jour couleurs dataset
            if (historyChart.data.datasets && historyChart.data.datasets[0]) {
                 historyChart.data.datasets[0].backgroundColor = primaryColor + '99'; // Avec opacité
                 historyChart.data.datasets[0].borderColor = primaryColor;
                 historyChart.data.datasets[0].hoverBackgroundColor = accentColor + 'CC'; // Avec opacité
                 historyChart.data.datasets[0].hoverBorderColor = accentColor;
            }
            historyChart.update('none'); // Met à jour sans re-animer
            console.log("Thème du graphique mis à jour.");
        } catch (e) { console.error("Erreur mise à jour thème graphique:", e); }
    }

    // --- Gestion Affichage Sections ---
    function showSection(sectionName) {
        if (!workoutSection || !historySection || !navHistoryBtn || !navButtons) return;
        closeSummary(); // Toujours fermer le résumé en changeant de section
        const isHistory = sectionName === 'history';

        workoutSection.classList.toggle('section-hidden', isHistory);
        historySection.classList.toggle('section-hidden', !isHistory);

        navHistoryBtn.classList.toggle('active', isHistory);
        if (isHistory) {
            setActiveWorkoutNav(null); // Désactive les boutons PPL si on va sur historique
            displayHistory(currentHistoryPeriod); // Charge/affiche l'historique à chaque fois qu'on y va
        } else {
            // Si on retourne au workout, réactive le bouton PPL si un workout est chargé
            setActiveWorkoutNav(currentWorkoutType);
        }
    }
    function setActiveWorkoutNav(workoutType) {
        if (!navButtons) return;
        navButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.workout === workoutType);
        });
        // Ajoute/retire la classe au body pour CSS ciblé si besoin
         document.body.classList.toggle('workout-selected', !!workoutType);
    }

    // --- Persistance Locale (État en Cours) ---
    function saveInProgressState() {
        if (!isWorkoutActive || workoutFinished || currentState === 'idle') {
            clearInProgressState(); // Nettoie si le workout n'est plus en cours
            return;
        }
        // On sauvegarde seulement si on est dans un état récupérable (exo, pause, en pause)
        if (!['exercise', 'break', 'paused'].includes(currentState)) {
             console.log(`Pas de sauvegarde locale pour l'état: ${currentState}`);
             return;
        }

        const stateToSave = {
            type: currentWorkoutType,
            index: currentItemIndex,
            timeLeft: timeLeft,
            totalTime: totalTime, // Important pour reprendre une pause
            currentState: currentState,
            startTime: workoutStartTime,
            totalEstimated: totalWorkoutEstimatedSeconds,
            elapsedEstimated: elapsedWorkoutEstimatedSeconds
        };
        try {
            localStorage.setItem(IN_PROGRESS_KEY, JSON.stringify(stateToSave));
            console.log("État local sauvegardé:", stateToSave);
        } catch (e) {
            console.error("Sauvegarde état local échouée:", e);
            showMessage("Erreur sauvegarde locale progression.", 5000);
        }
    }
    function loadInProgressState() {
        console.log(`loadInProgressState: Recherche: "${IN_PROGRESS_KEY}"`);
        const savedStateJSON = localStorage.getItem(IN_PROGRESS_KEY);
        if (!savedStateJSON) { console.log("loadInProgressState: Aucun état sauvegardé."); return false; }

        try {
            const savedState = JSON.parse(savedStateJSON);
            console.log("État local trouvé:", savedState);

            // Validation plus stricte de l'état sauvegardé
            if ( !savedState || typeof savedState !== 'object' ||
                 !savedState.type || !PROGRAM_TYPES.includes(savedState.type) ||
                 typeof savedState.index !== 'number' || savedState.index < 0 ||
                 typeof savedState.currentState !== 'string' ||
                 !['exercise', 'break', 'paused'].includes(savedState.currentState) || // Etats récupérables
                 typeof savedState.totalEstimated !== 'number' ||
                 typeof savedState.elapsedEstimated !== 'number' ||
                 !loadedWorkouts[savedState.type] || // Vérifie si le programme correspondant est chargé
                 savedState.index >= (loadedWorkouts[savedState.type]?.length || 0) // Index valide
               ) {
                console.warn("État local invalide/incomplet/obsolète. Suppression.", savedState);
                clearInProgressState(); return false;
            }

            // Proposer la reprise seulement si connecté et programmes chargés
            if (googleAccessToken && programsLoaded) {
                const timeAgo = savedState.startTime ? ` (commencé ${new Date(savedState.startTime).toLocaleString('fr-FR', { dateStyle: 'short', timeStyle: 'short' })})` : '';
                if (confirm(`Entraînement "${savedState.type}" en cours${timeAgo}. Reprendre à l'étape ${savedState.index + 1} (${savedState.currentState}) ?`)) {
                    console.log("Reprise état local acceptée.");

                    // Appliquer l'état sauvegardé
                    currentWorkoutType = savedState.type;
                    currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[currentWorkoutType])); // Recharger la bonne version
                    totalWorkoutEstimatedSeconds = savedState.totalEstimated; // Utiliser l'estimé sauvegardé
                    elapsedWorkoutEstimatedSeconds = savedState.elapsedEstimated;
                    originalCompletedWorkoutPlan = []; // Sera rempli à la fin seulement
                    currentItemIndex = savedState.index;
                    timeLeft = savedState.timeLeft;
                    totalTime = savedState.totalTime;
                    workoutStartTime = savedState.startTime;
                    workoutFinished = false;
                    isWorkoutActive = true; // Marquer comme actif

                    setActiveWorkoutNav(currentWorkoutType);
                    showSection('workout');

                    // Restaurer l'état précis du timer
                    const stateToRestore = savedState.currentState;
                    if (stateToRestore === 'exercise') { setState('exercise'); }
                    else if (stateToRestore === 'break') { // Si était en pause, on reprend la pause
                         timeLeft = savedState.timeLeft; totalTime = savedState.totalTime;
                         setState('break'); // Redémarre le timer de pause
                    } else if (stateToRestore === 'paused') { // Si était explicitement en pause
                         timeLeft = savedState.timeLeft; totalTime = savedState.totalTime;
                         setState('paused'); // Reste en pause
                    }

                    console.log(`Reprise état: ${currentState}, Index: ${currentItemIndex}, Temps Restant: ${timeLeft}, Estimé: ${elapsedWorkoutEstimatedSeconds.toFixed(1)}/${totalWorkoutEstimatedSeconds.toFixed(1)}`);
                    showMessage(`Progression "${currentWorkoutType}" restaurée.`, 3500);
                    return true; // Reprise réussie

                } else { console.log("Reprise état local refusée."); clearInProgressState(); return false; }
            } else { console.log("État local trouvé, mais reprise impossible (non connecté ou programmes non chargés)."); return false; }

        } catch (e) { console.error("Erreur chargement/parsing état local:", e); clearInProgressState(); return false; }
    }
    function clearInProgressState() {
        try { localStorage.removeItem(IN_PROGRESS_KEY); console.log("État local supprimé."); }
        catch (e) { console.error("Erreur suppression état local:", e); }
    }

    // --- Gestion de l'Historique ---
    function saveWorkoutToHistory() {
        const finalWorkoutType = currentWorkoutType; // Utilise le type au moment de finir
        if (!finalWorkoutType || workoutStartTime === null) { console.warn("Sauvegarde historique annulée: type/heure début manquants."); return; }
        if (!googleAccessToken) { showMessage("Connectez-vous pour sauvegarder l'historique.", 4000); return; }

        const endTime = Date.now();
        const durationSeconds = Math.round((endTime - workoutStartTime) / 1000);
        if (durationSeconds < 10) { console.log(`Entraînement trop court (${durationSeconds}s), non sauvegardé.`); return; } // Évite sauvegarde si trop court

        const newEntry = {
            id: endTime.toString(), // Utilise timestamp comme ID unique
            date: new Date(endTime).toISOString(), // Format ISO 8601
            type: finalWorkoutType,
            duration: durationSeconds
        };

        console.log("Ajout historique local:", newEntry);
        workoutHistory.unshift(newEntry); // Ajoute au début (plus récent)

        // Met à jour l'affichage si la section historique est visible
        if (historySection && !historySection.classList.contains('section-hidden')) {
            displayHistory(currentHistoryPeriod);
        }

        // Sauvegarde sur Drive en arrière-plan
        saveHistoryToDrive();
    }
    async function saveHistoryToDrive() {
        if (!googleAccessToken) { console.warn("Tentative sauvegarde Drive sans connexion."); return; }
        if (!historyFileId) {
            console.log("ID fichier historique inconnu. Recherche/création...");
            const defaultHeader = "DateISO,WorkoutType,DurationSeconds,EntryID\n";
            historyFileId = await findOrCreateFile(HISTORY_FILENAME, defaultHeader);
        }
        if (!historyFileId) { showMessage("Impossible accéder/créer fichier historique Drive.", 5000); return; }

        // Préparer le contenu CSV à partir de workoutHistory local
        let csvContent = "DateISO,WorkoutType,DurationSeconds,EntryID\n";
        // Trier l'historique local par date décroissante avant de générer le CSV (pour la cohérence)
        const sortedHistory = [...workoutHistory].sort((a, b) => new Date(b.date) - new Date(a.date));
        sortedHistory.forEach(entry => {
            const cleanType = (entry.type || '').replace(/,/g, ''); // Simple échappement virgule
            const date = entry.date || new Date().toISOString();
            const duration = entry.duration || 0;
            const id = entry.id || Date.now().toString(); // Fallback ID
            csvContent += `${date},${cleanType},${duration},${id}\n`;
        });

        console.log(`Tentative maj historique Drive (${historyFileId}) avec ${sortedHistory.length} entrées.`);
        const success = await updateFileContent(historyFileId, csvContent);

        if (success) {
            console.log("Historique synchronisé avec Drive.");
            if (historyDriveStatus) historyDriveStatus.textContent = 'Synchro OK';
             // Rafraichir le statut dans le header aussi
             if (driveStatusElement && driveStatusElement.textContent !== 'Erreur') {
                 // Met à jour si pas déjà en erreur
                 // Ne change rien ici, updateAuthUI le fera
             }
        } else {
            console.error("Échec synchro historique Drive.");
            showMessage("Erreur sauvegarde historique Drive.", 4000);
            if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Sync';
        }
    }
    async function loadHistoryFromDrive() {
        console.log("loadHistoryFromDrive: Démarrage...");
        if (!googleAccessToken) {
            console.log("Non connecté, historique vidé.");
            workoutHistory = [];
            displayHistory(currentHistoryPeriod); // Affiche l'état "non connecté"
            return false; // Échec car non connecté
        }

        console.log("Chargement historique Drive...");
        if (historyDriveStatus) historyDriveStatus.textContent = 'Chargement Hist...';
        if (driveStatusElement && driveStatusElement.classList.contains('success')) {
             driveStatusElement.textContent = 'Chargement Hist...'; // Indique le chargement
             driveStatusElement.classList.remove('success');
             driveStatusElement.classList.add('loading');
        }

        if (!historyFileId) {
            const defaultHeader = "DateISO,WorkoutType,DurationSeconds,EntryID\n";
            historyFileId = await findOrCreateFile(HISTORY_FILENAME, defaultHeader);
        }
        if (!historyFileId) {
            showMessage("Impossible accéder fichier historique Drive.", 5000);
            workoutHistory = []; displayHistory(currentHistoryPeriod);
            if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Accès Hist.';
             if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Hist.'; driveStatusElement.classList.add('error'); driveStatusElement.classList.remove('loading'); }
            return false;
        }

        const csvContent = await readFileContent(historyFileId);
        if (csvContent === null) { // Erreur de lecture
            workoutHistory = [];
            showMessage("Erreur lecture historique Drive.", 4000);
            if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Lecture Hist.';
             if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Hist.'; driveStatusElement.classList.add('error'); driveStatusElement.classList.remove('loading');}
            displayHistory(currentHistoryPeriod);
            return false;
        } else if (csvContent.trim() === "" || csvContent.trim().toLowerCase() === "dateiso,workouttype,durationseconds,entryid") {
             workoutHistory = []; // Fichier vide ou juste le header
             console.log("Fichier historique Drive vide ou header seul.");
             if (historyDriveStatus) historyDriveStatus.textContent = 'Hist. Vide';
             // Ne pas mettre en erreur le statut principal si le fichier est juste vide
        } else {
            parseAndLoadHistoryCsvData(csvContent);
            console.log(`Historique chargé depuis Drive: ${workoutHistory.length} entrées.`);
            if (historyDriveStatus) historyDriveStatus.textContent = 'Synchro OK';
        }

        // Met à jour l'affichage historique et potentiellement le statut Drive principal si pas d'erreur
        displayHistory(currentHistoryPeriod);
        if (driveStatusElement && driveStatusElement.classList.contains('loading')) {
             // Si on était en chargement et pas d'erreur spécifique à l'historique
             // On attend la fin du chargement des programmes pour remettre 'Connecté'
        }
        return true; // Succès du chargement (même si vide)
    }
    function parseAndLoadHistoryCsvData(csvContent) {
        try {
            const lines = csvContent.trim().split(/\r?\n/);
            const newHistory = [];
            const existingIDs = new Set();

            if (lines.length <= 1) { console.log("CSV historique vide/header seul."); workoutHistory = []; return; }

            // Détection header simple
            const headerLine = lines[0].trim().toLowerCase();
            const hasHeader = headerLine.includes("dateiso") && headerLine.includes("workouttype") && headerLine.includes("durationseconds");
            const startIndex = hasHeader ? 1 : 0;
            console.log(`Parsing CSV historique: ${lines.length - startIndex} lignes potentielles.`);

            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const values = line.split(','); // Parsing simple, suppose pas de virgules dans les champs
                if (values.length < 3) { console.warn(`Ligne historique ignorée (< 3 champs): ${line}`); continue; }

                const dateStr = values[0]?.trim();
                const typeStr = values[1]?.trim();
                const durationStr = values[2]?.trim();
                const idStr = (values.length > 3) ? values[3]?.trim() : null; // ID optionnel

                const date = new Date(dateStr);
                const duration = parseInt(durationStr, 10);

                // Validation
                if (isNaN(date.getTime())) { console.warn(`Ligne historique ignorée (date invalide '${dateStr}'): ${line}`); continue; }
                if (!PROGRAM_TYPES.includes(typeStr)) { console.warn(`Ligne historique ignorée (type inconnu '${typeStr}'): ${line}`); continue; }
                if (isNaN(duration) || duration < 0) { console.warn(`Ligne historique ignorée (durée invalide '${durationStr}'): ${line}`); continue; }

                const entryId = idStr || `${date.getTime()}-${i}`; // Génère ID si manquant
                if (existingIDs.has(entryId)) { console.warn(`ID historique dupliqué ignoré: ${entryId} (ligne: ${line})`); continue; }

                newHistory.push({ id: entryId, date: date.toISOString(), type: typeStr, duration: duration });
                existingIDs.add(entryId);
            }
            // Trier par date décroissante (plus récent en premier)
            newHistory.sort((a, b) => new Date(b.date) - new Date(a.date));
            workoutHistory = newHistory;
            console.log(`Parsing CSV historique terminé. ${workoutHistory.length} entrées valides chargées.`);

        } catch (error) {
            console.error("Erreur parsing CSV historique:", error);
            showMessage(`Erreur parsing historique: ${error.message}`, 6000);
            workoutHistory = []; // Reset en cas d'erreur majeure
        }
    }
    function displayHistory(period = currentHistoryPeriod) {
        if (!historyList || !statsDisplay || !historyFilterBtns || !historyChartCanvas || !chartPlaceholder) {
            console.warn("displayHistory: Éléments DOM manquants."); return;
        }
        currentHistoryPeriod = period;
        // Met à jour les boutons de filtre
        historyFilterBtns.forEach(btn => { btn.classList.toggle('active', btn.dataset.period === period); });

        const isConnected = !!googleAccessToken;
        const historyToDisplay = isConnected ? workoutHistory : []; // Utilise l'historique chargé ou vide
        const filteredHistory = filterHistoryByPeriod(historyToDisplay, period);
        console.log(`Affichage historique '${period}'. ${filteredHistory.length} entrées filtrées sur ${historyToDisplay.length}. Connecté: ${isConnected}`);

        // Affichage liste
        historyList.innerHTML = ''; // Vide la liste
        if (!isConnected) {
            historyList.innerHTML = `<li class="no-history">Connectez-vous pour voir l'historique.</li>`;
        } else if (filteredHistory.length === 0) {
            historyList.innerHTML = `<li class="no-history">Aucun entraînement enregistré pour cette période.</li>`;
        } else {
            filteredHistory.forEach(entry => {
                const li = document.createElement('li');
                const entryDate = new Date(entry.date);
                const dateFormatted = entryDate.toLocaleDateString('fr-FR', { year: 'numeric', month: 'short', day: 'numeric' });
                const timeFormatted = entryDate.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                const durationFormatted = formatTime(entry.duration);
                li.innerHTML = `<span class="history-item-date">${dateFormatted} <small>(${timeFormatted})</small></span><span class="history-item-type">${entry.type}</span><span class="history-item-duration">${durationFormatted}</span>`;
                historyList.appendChild(li);
            });
        }

        // Affichage Stats & Motivation
        displayStatsAndMotivation(filteredHistory, period, isConnected);

        // Affichage Graphique
        renderHistoryChart(filteredHistory, period, isConnected);
    }
    function filterHistoryByPeriod(history, period) {
        const now = new Date();
        const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()); // Minuit aujourd'hui

        return history.filter(entry => {
            const entryDate = new Date(entry.date);
            if (isNaN(entryDate.getTime())) return false; // Ignore entrées invalides

             // Comparaison avec le début de la journée de l'entrée
            const entryDateStart = new Date(entryDate.getFullYear(), entryDate.getMonth(), entryDate.getDate());

            switch (period) {
                case 'week':
                    // Lundi de cette semaine (00:00)
                    const dayOfWeek = todayStart.getDay(); // 0 (Dim) à 6 (Sam)
                    const diffToMonday = todayStart.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); // Ajuste pour Lundi
                    const startOfWeek = new Date(now.getFullYear(), now.getMonth(), diffToMonday);
                    startOfWeek.setHours(0, 0, 0, 0);
                    return entryDate >= startOfWeek; // >= Lundi de cette semaine
                case 'month':
                    // 1er jour de ce mois (00:00)
                    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                    return entryDate >= startOfMonth;
                case 'year':
                     // 1er Janvier de cette année (00:00)
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    return entryDate >= startOfYear;
                case 'all':
                default:
                    return true; // Inclut tout
            }
        });
    }
    function displayStatsAndMotivation(filteredHistory, period, isConnected) {
        if (!statsDisplay) return;
        const stats = calculateStats(filteredHistory);
        let periodText = '';
        switch (period) {
            case 'week': periodText = 'Semaine'; break; case 'month': periodText = 'Mois'; break;
            case 'year': periodText = 'Année'; break; case 'all': periodText = 'Total'; break;
        }
        const statsTitleElement = statsDisplay.querySelector('h3');
        if (statsTitleElement) statsTitleElement.textContent = `Statistiques (${periodText})`;

        let statsHTML = "";
        if (!isConnected) {
            statsHTML = "<p>Connectez-vous pour voir vos stats.</p>";
        } else if (stats.count === 0) {
            statsHTML = "<p>Aucune donnée pour cette période.</p>";
        } else {
            statsHTML = `<p><i class="fas fa-calendar-check"></i> Nb séances: <strong>${stats.count}</strong></p>` +
                       `<p><i class="fas fa-stopwatch"></i> Durée totale: <strong>${formatTime(stats.totalDuration)}</strong></p>` +
                       `<p><i class="fas fa-hourglass-half"></i> Durée moy./séance: <strong>${formatTime(stats.avgDuration)}</strong></p>` +
                       `<p><i class="fas fa-star"></i> Type + fréquent: <strong>${stats.mostFrequentType || 'N/A'}</strong> (${stats.frequency[stats.mostFrequentType] || 0}x)</p>`;
        }
        // Remplace le contenu sauf le titre h3
        const contentContainer = document.createElement('div');
        contentContainer.innerHTML = statsHTML;
        while (statsDisplay.children.length > 1) { // Garde seulement le h3
             statsDisplay.removeChild(statsDisplay.lastChild);
        }
        statsDisplay.appendChild(contentContainer);

        // Gère le message motivationnel
        let msgElem = statsDisplay.querySelector('.motivational-message');
        if (!msgElem) {
            msgElem = document.createElement('p'); msgElem.className = 'motivational-message';
            statsDisplay.appendChild(msgElem); // Ajoute à la fin
        }
        msgElem.textContent = isConnected ? generateMotivationalMessage(stats, period) : "";
    }
    function calculateStats(history) {
        const count = history.length;
        let totalDuration = 0;
        const frequency = { Push: 0, Pull: 0, Legs: 0 };
        history.forEach(entry => {
            const duration = Number(entry.duration);
            if (!isNaN(duration)) { totalDuration += duration; }
            if (frequency.hasOwnProperty(entry.type)) { frequency[entry.type]++; }
        });
        const avgDuration = count > 0 ? Math.round(totalDuration / count) : 0;
        let mostFrequentType = null; let maxFrequency = -1;
        for (const type in frequency) {
            if (frequency[type] > maxFrequency) { maxFrequency = frequency[type]; mostFrequentType = type; }
        }
        if (maxFrequency <= 0) { mostFrequentType = null; }
        return { count, totalDuration, avgDuration, frequency, mostFrequentType };
    }
    function generateMotivationalMessage(stats, period) {
        const { count } = stats;
        if (!googleAccessToken) return "";
        if (count === 0) {
            switch (period) {
                case 'week': return "Aucune séance cette semaine. Planifiez la prochaine ! 📅";
                case 'month': return "Pas d'entraînement ce mois-ci. C'est le moment de s'y remettre ! 🚀";
                case 'year': return "Première séance de l'année à venir ? 🤔";
                case 'all': return "Commencez votre parcours fitness dès aujourd'hui ! 💪";
                default: return "Prêt à transpirer ?";
            }
        }
        switch (period) {
            case 'week':
                if (count >= 5) return `Incroyable, ${count} séances cette semaine ! Tu es en feu ! 🔥`;
                if (count >= 3) return `Super régularité (${count} séances hebdo) ! Continue comme ça ! 👍`;
                if (count >= 1) return `Bien joué (${count} séance${count > 1 ? 's' : ''}) cette semaine ! Chaque effort compte ! ✨`;
                break;
            case 'month':
                if (count >= 15) return `Quelle discipline ! ${count} séances ce mois ! 🚀 Machine !`;
                if (count >= 10) return `Solide performance (${count} entraînements) ! Les résultats arrivent ! 🎉`;
                if (count >= 5) return `Belle progression (${count} séances ce mois) ! 😊`;
                if (count >= 1) return `${count} séance${count > 1 ? 's' : ''} ce mois ! C'est un bon début ! 🌱`;
                break;
            case 'year': case 'all':
                if (count >= 100) return `Légendaire ! Plus de ${count} séances au compteur ! 🏆 Respect !`;
                if (count >= 50) return `Impressionnant ! ${count} séances ! La persévérance paie ! 🏋️‍♂️`;
                if (count >= 20) return `${count} séances, quel beau parcours ! Continue sur cette lancée ! 🌟`;
                if (count >= 1) return `Déjà ${count} entraînement${count > 1 ? 's' : ''} enregistré${count > 1 ? 's' : ''} ! Le premier pas est fait ! 🎯`;
                break;
        }
        return "Continue tes efforts, chaque goutte de sueur te rapproche de tes objectifs ! 💯";
    }

    // --- Gestion des Programmes (CSV <-> Objet) ---
    function convertProgramToCsv(programArray) {
        const header = "Type,Name,Details,Reps,Duration\n";
        let csv = header;
        const escapeCsvField = (field) => {
            if (field === null || field === undefined) return '';
            const stringField = String(field);
            // Si le champ contient une virgule, des guillemets ou un retour à la ligne, l'entourer de guillemets
            if (stringField.includes(',') || stringField.includes('"') || stringField.includes('\n')) {
                // Doubler les guillemets existants à l'intérieur
                return `"${stringField.replace(/"/g, '""')}"`;
            }
            return stringField;
        };
        programArray.forEach(item => {
            if (item.type === 'exercise') {
                const name = escapeCsvField(item.name ?? '');
                const details = escapeCsvField(item.details ?? '');
                const reps = (item.reps !== null && Number.isFinite(item.reps)) ? item.reps : ''; // Laisse vide si null/non-fini
                csv += `${item.type},${name},${details},${reps},\n`; // Duration vide pour exo
            } else if (item.type === 'break') {
                const name = escapeCsvField(item.name ?? 'Repos');
                const duration = (item.duration !== null && Number.isFinite(item.duration)) ? item.duration : '';
                csv += `${item.type},${name},,,${duration}\n`; // Name, Details, Reps vides pour pause
            }
        });
        return csv;
    }
    function parseProgramCsvData(csvContent) {
        const program = [];
        if (!csvContent || typeof csvContent !== 'string') return program;

        const lines = csvContent.trim().split(/\r?\n/);
        if (lines.length <= 1) return program; // Vide ou juste header

        // Détection header
        const headerLine = lines[0].trim().toLowerCase();
        const hasHeader = headerLine.startsWith("type,name,details,reps,duration");
        const startIndex = hasHeader ? 1 : 0;

        // Fonction pour parser une ligne CSV en gérant les guillemets
        const parseCsvLine = (line) => {
            const values = []; let currentVal = ''; let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"' && inQuotes && i + 1 < line.length && line[i+1] === '"') { // Guillemet double échappé
                    currentVal += '"'; i++;
                } else if (char === '"') { // Début ou fin de champ entre guillemets
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) { // Séparateur hors guillemets
                    values.push(currentVal); currentVal = '';
                } else { // Caractère normal
                    currentVal += char;
                }
            }
            values.push(currentVal); // Ajoute la dernière valeur
            return values.map(v => v.trim()); // Nettoie les espaces
        };

        for (let i = startIndex; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) continue; // Ignore lignes vides

            const values = parseCsvLine(line);
            if (values.length < 5) { console.warn(`Ligne programme ignorée (< 5 champs): ${line}`); continue; }

            const type = values[0]?.toLowerCase() || '';
            const name = values[1] || ''; // Peut être vide pour une pause sans nom spécifique
            const details = values[2] || '';
            const repsStr = values[3] || '';
            const durationStr = values[4] || '';

            if (type === 'exercise') {
                const reps = parseInt(repsStr, 10);
                if (!name) { console.warn(`Ligne exo ignorée (nom manquant): ${line}`); continue; }
                program.push({
                    type: 'exercise',
                    name: name,
                    details: details,
                    reps: (!isNaN(reps) && repsStr !== '') ? reps : null // null si vide ou non-nombre
                });
            } else if (type === 'break') {
                const duration = parseInt(durationStr, 10);
                if (isNaN(duration) || duration <= 0) { console.warn(`Ligne break ignorée (durée invalide '${durationStr}'): ${line}`); continue; }
                program.push({
                    type: 'break',
                    duration: duration,
                    name: name || 'Repos' // Nom par défaut si vide
                });
            } else {
                console.warn(`Ligne programme ignorée (type inconnu '${type}'): ${line}`);
            }
        }
        console.log(`Parsing programme CSV terminé. ${program.length} étapes chargées.`);
        return program;
    }
    async function loadProgramsFromDrive() {
        console.log("loadProgramsFromDrive: Démarrage...");
        if (!googleAccessToken) {
            console.warn("loadProgramsFromDrive: Non connecté. Utilisation défauts.");
            loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
            programsLoaded = false; // Marquer comme non chargé depuis Drive
            updateAuthUI(false); // Met à jour l'UI (boutons nav désactivés)
            return false; // Échec car non connecté
        }

        programsLoaded = false; // Réinitialise avant de charger
        let allLoadedSuccessfully = true; // Devient false si un échoue

        if (driveStatusElement) {
            driveStatusElement.textContent = 'Chargement Progs...';
            driveStatusElement.classList.add('loading');
            driveStatusElement.classList.remove('error','success');
            driveStatusElement.style.display = 'inline-block';
        }

        const loadPromises = PROGRAM_TYPES.map(async (type) => {
            const filename = PROGRAM_FILENAMES[type];
            const defaultProgram = defaultWorkouts[type] || []; // Fallback si défaut manquant
            const defaultCsv = convertProgramToCsv(defaultProgram);
            console.log(`Chargement programme: ${type} (${filename})`);

            // 1. Trouver ou créer le fichier
            const fileId = await findOrCreateFile(filename, defaultCsv);
            programFileIds[type] = fileId; // Stocke l'ID trouvé/créé

            if (fileId) {
                // 2. Lire le contenu
                const csvContent = await readFileContent(fileId);
                if (csvContent !== null) { // Si lecture réussie (même si vide)
                    try {
                        // 3. Parser le contenu
                        const parsedProgram = parseProgramCsvData(csvContent);
                        if (parsedProgram.length > 0) {
                            loadedWorkouts[type] = parsedProgram; // Utilise la version Drive
                            console.log(`Programme ${type} chargé depuis Drive (${parsedProgram.length} étapes).`);
                            return true; // Succès pour ce type
                        } else {
                            // Fichier lu mais parsing vide/invalide
                            console.warn(`Programme ${type} lu depuis Drive mais parsing invalide/vide. Utilisation défaut.`);
                             if (csvContent.trim() !== "" && !csvContent.trim().toLowerCase().startsWith("type,name")) {
                                 // Si le contenu n'était pas vide et ne ressemble pas au header, c'est probablement une erreur de format
                                 showMessage(`Format ${filename} invalide sur Drive. Défaut chargé.`, 5000);
                             }
                             loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram)); // Fallback au défaut
                             // On considère que c'est un "succès" car on a une version du programme
                             return true;
                        }
                    } catch (parseError) {
                        console.error(`Erreur parsing programme ${type} depuis Drive:`, parseError);
                        showMessage(`Erreur parsing ${filename}. Défaut chargé.`, 5000);
                        loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram)); // Fallback
                        return false; // Échec pour ce type à cause du parsing
                    }
                } else {
                     // Erreur de lecture (gérée dans readFileContent)
                    console.error(`Échec lecture ${filename} (ID: ${fileId}). Utilisation défaut.`);
                    loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram)); // Fallback
                    return false; // Échec pour ce type
                }
            } else {
                // Échec accès/création fichier (géré dans findOrCreateFile)
                console.error(`Échec accès/création ${filename}. Utilisation défaut.`);
                loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram)); // Fallback
                return false; // Échec pour ce type
            }
        });

        // Attendre la fin de tous les chargements
        try {
            const results = await Promise.all(loadPromises);
            allLoadedSuccessfully = results.every(success => success === true);
        } catch (error) {
            console.error("Erreur inattendue pendant Promise.all loadPrograms:", error);
            allLoadedSuccessfully = false; // Marquer comme échec global
             // Assurer fallback sur tous les programmes en cas d'erreur globale
             PROGRAM_TYPES.forEach(type => {
                 if (!loadedWorkouts[type] || loadedWorkouts[type].length === 0) {
                      loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type] || []));
                 }
             });
        }

        programsLoaded = true; // On considère les programmes chargés même si fallback utilisé
        console.log(`Fin chargement programmes. 'programsLoaded': ${programsLoaded}. Succès Drive global: ${allLoadedSuccessfully}`);

        // Mettre à jour le statut UI final
        if (driveStatusElement) {
            driveStatusElement.classList.remove('loading');
            if (!allLoadedSuccessfully) {
                driveStatusElement.textContent = 'Erreur Progs'; driveStatusElement.classList.add('error');
                showMessage("Certains programmes n'ont pu être chargés/lus correctement depuis Drive.", 5000);
            } else {
                 // Si tout s'est bien passé (chargement Drive ou fallback silencieux)
                 driveStatusElement.textContent = 'Connecté'; driveStatusElement.classList.add('success');
                 driveStatusElement.classList.remove('error');
                 console.log("Programmes chargés OK (Drive ou fallback).");
            }
        }

        // Mettre à jour l'UI (activer boutons nav, etc.) basé sur programsLoaded
        updateAuthUI(true);

        return programsLoaded; // Retourne true si on a des programmes (même défaut), false si erreur majeure
    }
    async function exportProgramsToDrive() {
        initAudioContext(); // Pour le son éventuel
        if (!googleAccessToken) { showMessage("Connectez-vous pour exporter.", 4000); return; }

        // Vérifier si les programmes sont considérés comme chargés (même si c'est les défauts)
        if (!programsLoaded && !confirm("Les programmes n'ont pas été chargés correctement depuis Drive. Voulez-vous exporter les versions actuelles (probablement par défaut) et écraser les fichiers sur Drive ?")) {
            showMessage("Export annulé.", 2000); return;
        }
        if (!confirm("Exporter les programmes actuels (Push, Pull, Legs) vers Google Drive ?\n\nATTENTION : Ceci écrasera les versions existantes sur Drive.")) {
            showMessage("Export annulé.", 2000); return;
        }

        console.log("Exportation programmes vers Drive...");
        showMessage("Exportation en cours...", 5000);
        if (driveStatusElement) {
            driveStatusElement.textContent = 'Export Progs...'; driveStatusElement.classList.add('loading');
            driveStatusElement.classList.remove('error','success'); driveStatusElement.style.display = 'inline-block';
        }
        if (exportProgramsBtn) exportProgramsBtn.disabled = true; // Désactive pendant l'export

        let successCount = 0;
        const exportPromises = PROGRAM_TYPES.map(async (type) => {
            let fileId = programFileIds[type];
            const filename = PROGRAM_FILENAMES[type];

            // Si l'ID n'est pas connu (peut arriver si chargement initial a échoué)
            if (!fileId) {
                 console.warn(`ID fichier pour ${type} inconnu. Tentative de findOrCreateFile avant export...`);
                 const defaultCsv = convertProgramToCsv(defaultWorkouts[type] || []);
                 fileId = await findOrCreateFile(filename, defaultCsv);
                 programFileIds[type] = fileId; // Met à jour l'ID
                 if (!fileId) {
                     console.error(`Impossible de trouver/créer le fichier pour ${type}. Export impossible.`);
                     showMessage(`Erreur: Impossible d'accéder au fichier ${type} sur Drive.`, 4000);
                     return false; // Échec pour ce type
                 }
            }

            try {
                // Utilise les données actuellement chargées (Drive ou défaut)
                const currentProgramData = loadedWorkouts[type] || defaultWorkouts[type] || [];
                const csvContent = convertProgramToCsv(currentProgramData);
                console.log(`Export ${type} (ID: ${fileId}) avec ${currentProgramData.length} étapes.`);

                const success = await updateFileContent(fileId, csvContent);
                if (success) { console.log(`Programme ${type} exporté avec succès.`); return true; }
                else { console.error(`Échec export du programme ${type}.`); return false; }

            } catch (error) {
                console.error(`Erreur lors de l'export du programme ${type}:`, error);
                showMessage(`Erreur export ${type}: ${error.message}`, 5000);
                return false;
            }
        });

        // Attendre la fin de tous les exports
        try {
            const results = await Promise.all(exportPromises);
            successCount = results.filter(success => success === true).length;
        } catch (error) {
            console.error("Erreur inattendue pendant Promise.all exportPrograms:", error);
            successCount = 0; // Échec global
        }

        // Mettre à jour l'UI après l'export
        if (driveStatusElement) driveStatusElement.classList.remove('loading');
        if (exportProgramsBtn) exportProgramsBtn.disabled = !(googleAccessToken && programsLoaded); // Réactive si possible

        if (successCount === PROGRAM_TYPES.length) {
            showMessage("Programmes exportés avec succès vers Google Drive !", 3000);
            if (driveStatusElement) {
                 driveStatusElement.textContent = 'Export OK'; driveStatusElement.classList.add('success');
                 // Retour au statut normal après un délai
                 setTimeout(() => {
                     if(googleAccessToken && driveStatusElement && driveStatusElement.textContent === 'Export OK') {
                         driveStatusElement.textContent = 'Connecté'; driveStatusElement.classList.add('success');
                         driveStatusElement.classList.remove('error');
                     }
                 }, 2500);
            }
        } else {
            showMessage(`Export terminé avec ${PROGRAM_TYPES.length - successCount} erreur(s). Vérifiez la console pour détails.`, 6000);
            if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Export'; driveStatusElement.classList.add('error'); }
        }
    }

    // --- Rendu du Graphique ---
    function renderHistoryChart(filteredHistory, period, isConnected) {
        if (!historyChartCanvas || !chartPlaceholder) { console.warn("Canvas/Placeholder graphique introuvable."); return; }
        const ctx = historyChartCanvas.getContext('2d');
        if (!ctx) { console.error("Impossible d'obtenir contexte 2D canvas."); return; }

        // Détruire l'ancien graphique s'il existe
        if (historyChart) { historyChart.destroy(); historyChart = null; }

        historyChartCanvas.style.display = 'block'; // Assure que le canvas est visible
        chartPlaceholder.style.display = 'none'; // Cache le message placeholder

        if (!isConnected) {
             historyChartCanvas.style.display = 'none';
             chartPlaceholder.textContent = "Connectez-vous pour voir le graphique.";
             chartPlaceholder.style.display = 'block';
             return;
        }

        const { labels, data } = aggregateChartData(filteredHistory, period);

        if (labels.length === 0 || data.every(d => d === 0)) {
            console.log("Aucune donnée graphique à afficher pour cette période.");
             historyChartCanvas.style.display = 'none';
             chartPlaceholder.textContent = "Aucune donnée d'entraînement pour cette période.";
             chartPlaceholder.style.display = 'block';
            return;
        }

        // Styles depuis les variables CSS
        const bodyStyles = getComputedStyle(document.documentElement);
        const primaryColor = bodyStyles.getPropertyValue('--neon-blue').trim() || '#00aeff';
        const accentColor = bodyStyles.getPropertyValue('--neon-pink').trim() || '#e54ac5';
        const gridColor = bodyStyles.getPropertyValue('--border-color').trim() || 'rgba(139,148,158,0.2)';
        const textColor = bodyStyles.getPropertyValue('--primary-text-color').trim() || '#c9d1d9';
        const tooltipBg = bodyStyles.getPropertyValue('--secondary-bg-color').trim() || '#161B22';

        try {
            historyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Durée totale (min)',
                        data: data.map(d => formatTimeForChart(d)), // Convertit secondes en minutes pour l'axe Y
                        backgroundColor: primaryColor + '99', // Opacité
                        borderColor: primaryColor,
                        borderWidth: 1,
                        hoverBackgroundColor: accentColor + 'CC', // Opacité au survol
                        hoverBorderColor: accentColor,
                        borderRadius: 4, // Bords arrondis
                        barPercentage: 0.7, // Espacement barres
                        categoryPercentage: 0.8
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Durée (minutes)', color: textColor, font: { size: 13, family: 'Inter' } },
                            grid: { color: gridColor },
                            ticks: { color: textColor, callback: function(value) { return value + ' min'; } }
                        },
                        x: {
                            title: { display: true, text: getChartXAxisTitle(period), color: textColor, font: { size: 13, family: 'Inter' } },
                            grid: { display: false }, // Pas de grille verticale
                            ticks: { color: textColor }
                        }
                    },
                    plugins: {
                        legend: { display: false }, // Pas besoin de légende pour un seul dataset
                        tooltip: {
                            backgroundColor: tooltipBg, titleColor: textColor, bodyColor: textColor,
                            padding: 10, cornerRadius: 6, displayColors: false, // Cache la petite couleur carrée
                            callbacks: {
                                label: function(context) {
                                    // Récupérer la durée originale en secondes pour l'infobulle
                                    const originalDurationSeconds = data[context.dataIndex] || 0;
                                    const formattedTime = formatTime(originalDurationSeconds);
                                    return `Durée: ${formattedTime}`;
                                }
                            }
                        }
                    },
                    animation: { duration: 500, easing: 'easeOutCubic' } // Animation douce
                }
            });
            console.log("Graphique historique rendu.");
        } catch (e) {
            console.error("Erreur création Chart.js:", e);
            showMessage("Erreur affichage graphique.", 4000);
             historyChartCanvas.style.display = 'none';
             chartPlaceholder.textContent = "Erreur lors de la création du graphique.";
             chartPlaceholder.style.display = 'block';
        }
    }
    function aggregateChartData(history, period) {
        const aggregated = new Map();
        // Fonction helper pour initialiser la map avec 0 pour toutes les labels
        const initializeMap = (labels) => labels.forEach(label => aggregated.set(label, 0));

        switch (period) {
            case 'week':
                const daysOfWeek = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim'];
                initializeMap(daysOfWeek);
                const nowW = new Date();
                const todayStartW = new Date(nowW.getFullYear(), nowW.getMonth(), nowW.getDate());
                const dayOfWeekNum = todayStartW.getDay(); // 0 = Dim, 1 = Lun, ...
                const diffToMonday = todayStartW.getDate() - dayOfWeekNum + (dayOfWeekNum === 0 ? -6 : 1);
                const startOfWeek = new Date(nowW.getFullYear(), nowW.getMonth(), diffToMonday);
                startOfWeek.setHours(0,0,0,0); // Début du Lundi

                history.forEach(entry => {
                    const entryDate = new Date(entry.date);
                    if (entryDate >= startOfWeek) { // Filtre déjà appliqué mais re-vérif par sécurité
                        let dayIndex = entryDate.getDay(); // 0=Dim, 1=Lun,...
                        dayIndex = dayIndex === 0 ? 6 : dayIndex - 1; // Ajuste pour Lun=0, Dim=6
                        const dayName = daysOfWeek[dayIndex];
                        aggregated.set(dayName, (aggregated.get(dayName) || 0) + (entry.duration || 0));
                    }
                });
                return { labels: daysOfWeek, data: daysOfWeek.map(day => aggregated.get(day)) };

            case 'month':
                // Agréger par semaine du mois courant
                const weeksOfMonth = ['Sem 1-7', 'Sem 8-14', 'Sem 15-21', 'Sem 22-28', 'Sem 29+'];
                initializeMap(weeksOfMonth);
                const currentMonthNum = new Date().getMonth();
                const currentYearNum = new Date().getFullYear();

                history.forEach(entry => {
                    const entryDate = new Date(entry.date);
                    if (entryDate.getMonth() === currentMonthNum && entryDate.getFullYear() === currentYearNum) {
                        const dayOfMonth = entryDate.getDate();
                        let weekIndex = 0;
                        if (dayOfMonth <= 7) weekIndex = 0;
                        else if (dayOfMonth <= 14) weekIndex = 1;
                        else if (dayOfMonth <= 21) weekIndex = 2;
                        else if (dayOfMonth <= 28) weekIndex = 3;
                        else weekIndex = 4;
                        const weekName = weeksOfMonth[weekIndex];
                        aggregated.set(weekName, (aggregated.get(weekName) || 0) + (entry.duration || 0));
                    }
                });
                return { labels: weeksOfMonth, data: weeksOfMonth.map(week => aggregated.get(week)) };

            case 'year':
                const monthsOfYear = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc'];
                initializeMap(monthsOfYear);
                const currentYear = new Date().getFullYear();

                history.forEach(entry => {
                    const entryDate = new Date(entry.date);
                    if (entryDate.getFullYear() === currentYear) {
                        const monthIndex = entryDate.getMonth(); // 0 = Jan, 1 = Fev, ...
                        const monthName = monthsOfYear[monthIndex];
                        aggregated.set(monthName, (aggregated.get(monthName) || 0) + (entry.duration || 0));
                    }
                });
                return { labels: monthsOfYear, data: monthsOfYear.map(month => aggregated.get(month)) };

            case 'all':
            default:
                // Agréger par année
                const yearData = {};
                history.forEach(entry => {
                    const year = new Date(entry.date).getFullYear();
                    yearData[year] = (yearData[year] || 0) + (entry.duration || 0);
                });
                // Trier les années pour l'axe X
                const sortedYears = Object.keys(yearData).map(Number).sort((a, b) => a - b);
                return { labels: sortedYears.map(String), data: sortedYears.map(year => yearData[year]) };
        }
    }
    function getChartXAxisTitle(period) {
        switch (period) {
            case 'week': return 'Jour (Semaine Courante)';
            case 'month': return 'Semaine (Mois Courant)';
            case 'year': return 'Mois (Année Courante)';
            case 'all': return 'Année';
            default: return '';
        }
    }

    // --- Gestion Résumé/Modification Post-Workout ---
    function populateAndShowSummary() {
        if (!originalCompletedWorkoutPlan || originalCompletedWorkoutPlan.length === 0 || !summaryTitle || !summaryItemsList || !postWorkoutSummary || !saveSummaryBtn || !cancelSummaryBtn) {
            console.error("Impossible afficher résumé: DOM/données manquants.");
            // Si on est censé être en état 'finished', mais qu'on ne peut afficher le résumé, reset pour éviter blocage.
            if (currentState === 'finished') { resetCurrentWorkout(); }
            return;
        }
        const finalWorkoutType = currentWorkoutType; // Utilise le type qui vient d'être fini
        summaryTitle.textContent = `Résumé Séance - ${finalWorkoutType || 'Inconnu'}`;
        summaryItemsList.innerHTML = ''; // Vide la liste précédente

        originalCompletedWorkoutPlan.forEach((item, index) => {
            const li = document.createElement('li');
            li.classList.add('summary-item');
            li.dataset.index = index; // Stocke l'index original

            if (item.type === 'exercise') {
                li.classList.add('item-type-exercise');
                const repsValue = (item.reps !== null && Number.isFinite(item.reps)) ? item.reps : '';
                const detailsValue = item.details || '';
                li.innerHTML = `
                    <h4><i class="fas fa-dumbbell"></i> ${item.name || 'Exercice'}</h4>
                    <label for="summary-reps-${index}">Reps:</label>
                    <div><input type="number" id="summary-reps-${index}" value="${repsValue}" min="0" step="1" placeholder="N/A"></div>
                    <label for="summary-details-${index}">Détails:</label>
                    <div><textarea id="summary-details-${index}" rows="2" placeholder="Aucun détail">${detailsValue}</textarea></div>
                `;
            } else if (item.type === 'break') {
                li.classList.add('item-type-break');
                li.innerHTML = `
                    <h4><i class="fas fa-coffee"></i> ${item.name || 'Repos'}</h4>
                    <p>Durée: ${formatTime(item.duration || 0)}</p>
                    <div></div><div></div> <!-- Placeholders pour aligner la grille -->
                `;
                // On ne permet pas la modification des pauses ici
            }
            summaryItemsList.appendChild(li);
        });

        isSavingSummary = false; // Reset flag de sauvegarde
        saveSummaryBtn.disabled = !googleAccessToken; // Active si connecté
        saveSummaryBtn.innerHTML = '<i class="fas fa-save"></i> Sauvegarder & Fermer';
        postWorkoutSummary.classList.add('visible'); // Affiche la modale
    }
    function closeSummary() {
        if (!postWorkoutSummary) return;
        postWorkoutSummary.classList.remove('visible'); // Cache la modale

        // Si on ferme le résumé alors que le workout était fini, on revient à l'état idle
        if (currentState === 'finished') {
            console.log("Fermeture résumé après workout terminé, passage 'finished' -> 'idle'.");
            resetCurrentWorkout(); // Réinitialise complètement pour être prêt à autre chose
        }
        // Retire l'animation de fin de la section workout si elle était active
         if (workoutSection) workoutSection.classList.remove('finished-animation');
    }
    async function saveSummaryChanges() {
        initAudioContext(); // Pour le son
        if (isSavingSummary || !saveSummaryBtn || !summaryItemsList || !currentWorkoutType) {
            console.warn("Sauvegarde résumé déjà en cours ou données/type manquants.");
            return;
        }
        const workoutTypeToSave = currentWorkoutType; // Le type du workout qui vient de finir
        if (!googleAccessToken || !programFileIds[workoutTypeToSave]) {
            showMessage("Erreur: Non connecté ou ID fichier programme Drive manquant.", 5000);
            return;
        }

        isSavingSummary = true;
        saveSummaryBtn.disabled = true;
        saveSummaryBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sauvegarde...';
        showMessage("Sauvegarde des modifications du programme...", 4000);

        // 1. Récupérer les données actuelles chargées pour ce type
        //    On part de la version qui était chargée *avant* le début du workout qui vient de finir.
        //    C'est important pour ne pas écraser des modifs faites ailleurs.
        //    MAIS, si on veut sauver les modifs faites PENDANT le résumé, il faut modifier
        //    la copie `loadedWorkouts[workoutTypeToSave]`
        const updatedProgram = JSON.parse(JSON.stringify(loadedWorkouts[workoutTypeToSave]));
        let changesMade = false;

        // 2. Parcourir les items du résumé et mettre à jour `updatedProgram`
        const summaryItems = summaryItemsList.querySelectorAll('.summary-item[data-index]');
        summaryItems.forEach(itemElement => {
            const index = parseInt(itemElement.dataset.index, 10);
            if (isNaN(index) || index < 0 || index >= updatedProgram.length) {
                 console.warn(`Index invalide ${index} dans le résumé.`);
                 return; // Skip cet item
            }
            const programItemToUpdate = updatedProgram[index];

            // Mettre à jour seulement les exercices
            if (programItemToUpdate && programItemToUpdate.type === 'exercise') {
                const repsInput = itemElement.querySelector(`#summary-reps-${index}`);
                const detailsInput = itemElement.querySelector(`#summary-details-${index}`);
                if (!repsInput || !detailsInput) { console.warn(`Inputs introuvables pour index ${index}.`); return; }

                const newRepsRaw = repsInput.value.trim();
                const newReps = newRepsRaw === '' ? null : parseInt(newRepsRaw, 10);
                const newDetails = detailsInput.value.trim();

                // Validation des reps
                if (newReps !== null && (isNaN(newReps) || newReps < 0)) {
                    console.warn(`Reps invalides ('${newRepsRaw}') pour index ${index}. Modification ignorée pour cet item.`);
                    showMessage(`Reps invalides pour "${programItemToUpdate.name}". Non sauvegardé.`, 3000);
                    // Ne pas marquer changesMade = true si seule la rep est invalide
                } else {
                     // Vérifier si les reps OU les détails ont changé
                     const repsChanged = programItemToUpdate.reps !== newReps && !(programItemToUpdate.reps === null && newReps === null);
                     const detailsChanged = programItemToUpdate.details !== newDetails;

                    if (repsChanged || detailsChanged) {
                        console.log(`Modif détectée ${workoutTypeToSave} index ${index}: reps=${programItemToUpdate.reps}->${newReps}, details=${programItemToUpdate.details !== newDetails}`);
                        programItemToUpdate.reps = newReps;
                        programItemToUpdate.details = newDetails;
                        changesMade = true;
                    }
                }
            }
        });

        // 3. Si des changements ont été faits, sauvegarder sur Drive
        if (!changesMade) {
            showMessage("Aucune modification détectée.", 2000);
            closeSummary(); // Ferme la modale même si rien n'a changé
        } else {
            console.log(`Modifications détectées pour ${workoutTypeToSave}. Mise à jour locale et Drive...`);
            loadedWorkouts[workoutTypeToSave] = updatedProgram; // Met à jour la version en mémoire

            try {
                const newCsvContent = convertProgramToCsv(updatedProgram);
                const success = await updateFileContent(programFileIds[workoutTypeToSave], newCsvContent);
                if (success) {
                    showMessage(`Programme "${workoutTypeToSave}" mis à jour sur Drive !`, 3500);
                    console.log(`Programme ${workoutTypeToSave} mis à jour sur Drive.`);
                    closeSummary(); // Ferme après succès
                } else {
                    // L'échec est déjà géré dans updateFileContent
                    showMessage(`Échec de la sauvegarde du programme ${workoutTypeToSave} sur Drive.`, 5000);
                    // Ne pas fermer la modale pour que l'utilisateur puisse réessayer ou annuler
                }
            } catch (error) {
                console.error(`Erreur lors de la sauvegarde du résumé pour ${workoutTypeToSave}:`, error);
                showMessage(`Erreur sauvegarde ${workoutTypeToSave}: ${error.message}`, 6000);
                 // Ne pas fermer la modale
            }
        }

        // Réactiver le bouton à la fin
        saveSummaryBtn.innerHTML = '<i class="fas fa-save"></i> Sauvegarder & Fermer';
        saveSummaryBtn.disabled = !googleAccessToken; // Réactive si connecté
        isSavingSummary = false;
    }

     // --- Clic sur le Timer ---
     function handleTimerClick() {
         initAudioContext(); // Assure que l'audio est prêt
         console.log(`Clic sur le timer. État actuel: ${currentState}`);
         if (!isWorkoutActive || workoutFinished || !googleAccessToken || !programsLoaded) return; // Ignorer si pas actif, fini, ou pas prêt

         if (currentState === 'break') {
             console.log("Timer clic: Mise en pause pendant le repos.");
             clearInterval(timerInterval); timerInterval = null;
             setState('paused');
             saveInProgressState(); // Sauvegarde l'état 'paused'
         } else if (currentState === 'paused') {
             const currentItem = currentWorkoutPlan[currentItemIndex];
             // Reprendre seulement si on était en pause pendant un break
             if (currentItem && currentItem.type === 'break') {
                 console.log("Timer clic: Reprise du repos.");
                 setState('break'); // Redémarre le timer de la pause
                 saveInProgressState(); // Sauvegarde l'état 'break'
             } else {
                  // Si on était en pause pendant un exercice (ne devrait pas arriver avec la logique actuelle)
                  // ou si l'item courant n'est pas une pause, on pourrait décider de reprendre l'exercice.
                  // Pour l'instant, on ne fait rien pour garder la cohérence avec le bouton principal.
                  console.log("Timer clic: En pause mais pas pendant un repos, utiliser le bouton 'Reprendre'.");
                  // Optionnel: déclencher la reprise via le bouton
                  // startPauseBtn.click();
             }
         } else if (currentState === 'exercise') {
              // Action pour le clic pendant l'exercice: Marquer comme "Fait" ?
              console.log("Timer clic: Pendant l'exercice. Action : Marquer comme 'Fait'.");
              handleItemCompletion(false); // Simule le clic sur le bouton "Fait"
              saveInProgressState(); // Sauvegarde le nouvel état/index
         } else {
              console.log(`Timer clic: État '${currentState}', aucune action définie pour le clic sur le cercle.`);
         }
     }


    // --- Initialisation ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Chargé. Initialisation ArmorWorkout.");

        // Assignation DOM (vérifier nullité si critique)
        timeLeftDisplay = document.getElementById('time-left');
        timerCircle = document.getElementById('timer-circle');
        totalProgressCircle = document.getElementById('total-progress-circle');
        timerStateDisplay = document.getElementById('timer-state');
        currentExerciseContainer = document.getElementById('current-exercise-container');
        progressTracker = document.getElementById('progress-tracker');
        startPauseBtn = document.getElementById('start-pause-btn');
        skipBtn = document.getElementById('skip-btn');
        finishBtn = document.getElementById('finish-btn');
        resetBtn = document.getElementById('reset-btn');
        navButtons = document.querySelectorAll('nav button[data-workout]');
        navHistoryBtn = document.getElementById('nav-history');
        themeToggleBtn = document.getElementById('theme-toggle-btn');
        messageArea = document.getElementById('message-area');
        workoutSection = document.getElementById('workout-section');
        historySection = document.getElementById('history-section');
        historyList = document.getElementById('history-list');
        statsDisplay = document.getElementById('stats-display');
        historyFilterBtns = document.querySelectorAll('.history-filters button');
        historyChartCanvas = document.getElementById('history-chart-canvas');
        signInButton = document.getElementById('signin-button');
        signOutButton = document.getElementById('signout-button');
        driveStatusElement = document.getElementById('drive-status');
        exportProgramsBtn = document.getElementById('export-programs-btn');
        postWorkoutSummary = document.getElementById('post-workout-summary');
        summaryTitle = document.getElementById('summary-title');
        summaryItemsList = document.getElementById('summary-items-list');
        saveSummaryBtn = document.getElementById('save-summary-btn');
        cancelSummaryBtn = document.getElementById('cancel-summary-btn');
        historyDriveStatus = document.getElementById('history-drive-status');
        currentExerciseNameDisplay = document.getElementById('current-exercise-name-display');
        driveConnectionStatusMain = document.getElementById('drive-connection-status-main');
        driveConnectionText = document.getElementById('drive-connection-text');
        timerDisplayElement = document.getElementById('timer-display-clickable'); // Pour le clic pause/reprise
        chartPlaceholder = document.getElementById('chart-placeholder');
        progressTextArea = document.getElementById('progress-text-area');
        historyActionsContainer = document.querySelector('.history-actions'); // Pour cacher/afficher

        // Vérifications éléments critiques
        if (!timeLeftDisplay || !startPauseBtn || !navButtons || !signInButton || !signOutButton || !timerDisplayElement || !progressTextArea) {
             console.error("ERREUR CRITIQUE : Éléments DOM essentiels manquants ! Application inutilisable.");
             document.body.innerHTML = "<h1>Erreur critique lors de l'initialisation. Vérifiez la console.</h1>";
             return; // Arrêter l'initialisation
        }

        // --- Init état & UI ---
        const savedTheme = localStorage.getItem('theme');
        applyTheme((savedTheme === 'light' || savedTheme === 'dark') ? savedTheme : 'dark'); // Défaut sombre
        workoutHistory = [];
        loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
        programsLoaded = false;
        setState('idle'); // Initialise l'état et l'UI des boutons
        updateAuthUI(false); // Met à jour l'UI pour l'état déconnecté initial

        // --- Event Listeners ---
        signInButton.addEventListener('click', handleAuthClick);
        signOutButton.addEventListener('click', () => handleSignoutClick(true));
        navButtons.forEach(button => {
             button.addEventListener('click', () => {
                 initAudioContext(); // Init audio au premier clic utilisateur
                 loadWorkout(button.dataset.workout);
             });
        });
        navHistoryBtn.addEventListener('click', () => {
             initAudioContext();
            if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') {
                if (confirm("Entraînement en cours. Arrêter pour voir l'historique ?")) {
                    resetCurrentWorkout();
                    // Léger délai pour s'assurer que le reset est fini avant de changer de section
                    setTimeout(() => showSection('history'), 100);
                }
            } else if (currentState === 'preparing') {
                showMessage("Attendez la fin de la préparation.", 2500);
            } else {
                showSection('history');
            }
        });

        startPauseBtn.addEventListener('click', () => {
            initAudioContext();
            console.log(`Clic Start/Pause/Fait/Reprendre. État: ${currentState}`);
            if (currentState === 'idle' && currentWorkoutPlan.length > 0 && currentWorkoutType) {
                workoutStartTime = Date.now(); // Démarre le chrono global
                elapsedWorkoutEstimatedSeconds = 0; // Reset progression estimée
                setState('preparing');
            } else if (currentState === 'exercise') {
                handleItemCompletion(false); // Marque l'exercice comme fait
            } else if (currentState === 'break') {
                clearInterval(timerInterval); timerInterval = null; // Arrête le timer de pause
                setState('paused');
            } else if (currentState === 'paused') {
                const currentItem = currentWorkoutPlan[currentItemIndex];
                // Reprendre seulement si on était en pause pendant une pause
                if (currentItem && currentItem.type === 'break') {
                     setState('break'); // Redémarre le timer de pause
                } else {
                    // Si on était en pause pendant un exercice (cas non standard) ou autre
                    // Pourrait reprendre l'état précédent, mais ici on force 'exercise' si possible
                     console.warn("Tentative de reprise hors d'une pause de 'break'. Retour à 'exercise' si possible.");
                     if(currentItem && currentItem.type === 'exercise') {
                         setState('exercise');
                     } else {
                          // fallback ou erreur ? Pour l'instant on ne fait rien si ce n'est pas une pause de 'break'
                          console.error("Impossible de déterminer l'état à reprendre depuis 'paused'.");
                     }
                }
            }
            saveInProgressState(); // Sauvegarde après changement d'état manuel
        });

        skipBtn.addEventListener('click', () => {
            initAudioContext();
            if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') {
                showMessage("Passage à l'étape suivante.", 1500);
                handleItemCompletion(false); // Passe à l'étape suivante (pas 'naturellement')
            }
        });

        finishBtn.addEventListener('click', () => {
            initAudioContext();
            if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') {
                forceFinishWorkout();
            }
        });

        resetBtn.addEventListener('click', () => {
            initAudioContext();
            if (currentWorkoutType || isWorkoutActive || workoutFinished) {
                if (confirm("Réinitialiser l'état actuel et désélectionner l'entraînement ?")) {
                    resetCurrentWorkout();
                }
            } else {
                showMessage("Aucun entraînement à réinitialiser.", 2000);
                // resetCurrentWorkout(); // Pourrait nettoyer l'UI même si rien n'est actif
            }
        });

        themeToggleBtn.addEventListener('click', () => {
            initAudioContext();
            applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
        });

        historyFilterBtns.forEach(button => {
            button.addEventListener('click', () => {
                 initAudioContext();
                 displayHistory(button.dataset.period);
            });
        });

        exportProgramsBtn.addEventListener('click', () => {
             initAudioContext();
             exportProgramsToDrive();
        });

        saveSummaryBtn.addEventListener('click', saveSummaryChanges);
        cancelSummaryBtn.addEventListener('click', closeSummary);

        // Listener pour clic sur le timer (pause/reprise/fait)
         timerDisplayElement.addEventListener('click', handleTimerClick);

        console.log("Initialisation terminée. Attente Google Identity Services...");
        // La fonction gisLoadedCallback sera appelée quand GSI sera prêt.
    });

</script>

<!-- Chargement Asynchrone de Google Identity Services -->
<script async defer src="https://accounts.google.com/gsi/client" onload="gisLoadedCallback()"></script>

</body>
</html>
