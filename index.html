<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workout Timer GDrive - ArmorWorkout</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Google Identity Services (GIS) - chargé à la fin -->

    <style>
        /* --- Variables Globales & Thèmes --- */
        :root {
            --primary-color-light: #4a90e2; --secondary-color-light: #f5f5f5; --text-color-light: #333; --bg-color-light: #ffffff; --accent-color-light: #50e3c2; --border-color-light: #e0e0e0; --danger-color-light: #e74c3c; --warning-color-light: #f39c12; --success-color-light: #2ecc71; --info-color-light: #3498db; --chart-grid-color-light: rgba(0, 0, 0, 0.08); --chart-tooltip-bg-light: rgba(0, 0, 0, 0.75); --chart-tooltip-text-light: #ffffff; --primary-glow-light: 0 0 15px rgba(74, 144, 226, 0.3); --export-btn-color-light: #8e44ad;

            --primary-color-dark: #58a6ff; --secondary-color-dark: #1c1c1e; --text-color-dark: #e1e1e1; --bg-color-dark: #0d1117; --accent-color-dark: #30d3b0; --border-color-dark: #3a3a3c; --danger-color-dark: #f85149; --warning-color-dark: #e3b341; --success-color-dark: #3fb950; --info-color-dark: #58a6ff; --chart-grid-color-dark: rgba(255, 255, 255, 0.1); --chart-tooltip-bg-dark: rgba(255, 255, 255, 0.85); --chart-tooltip-text-dark: #111; --primary-glow-dark: 0 0 15px rgba(88, 166, 255, 0.4); --export-btn-color-dark: #9b59b6;

            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --border-radius: 10px; --transition-speed: 0.3s; --box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);

            /* Initialisation thème clair */
            --primary-color: var(--primary-color-light); --secondary-color: var(--secondary-color-light); --text-color: var(--text-color-light); --bg-color: var(--bg-color-light); --accent-color: var(--accent-color-light); --border-color: var(--border-color-light); --danger-color: var(--danger-color-light); --warning-color: var(--warning-color-light); --success-color: var(--success-color-light); --info-color: var(--info-color-light); --chart-grid-color: var(--chart-grid-color-light); --chart-tooltip-bg: var(--chart-tooltip-bg-light); --chart-tooltip-text: var(--chart-tooltip-text-light); --primary-glow: var(--primary-glow-light); --export-btn-color: var(--export-btn-color-light);
        }
        body.dark-theme {
            --primary-color: var(--primary-color-dark); --secondary-color: var(--secondary-color-dark); --text-color: var(--text-color-dark); --bg-color: var(--bg-color-dark); --accent-color: var(--accent-color-dark); --border-color: var(--border-color-dark); --danger-color: var(--danger-color-dark); --warning-color: var(--warning-color-dark); --success-color: var(--success-color-dark); --info-color: var(--info-color-dark); --chart-grid-color: var(--chart-grid-color-dark); --chart-tooltip-bg: var(--chart-tooltip-bg-dark); --chart-tooltip-text: var(--chart-tooltip-text-dark); --primary-glow: var(--primary-glow-dark); --export-btn-color: var(--export-btn-color-dark);
            --box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        /* --- Styles de Base & Réinitialisation --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); line-height: 1.7; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; display: flex; flex-direction: column; min-height: 100vh; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }
        .container { max-width: 950px; margin: 0 auto; padding: 25px 20px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }

        /* --- En-tête & Navigation --- */
        header { background-color: rgba(var(--bg-color-rgb, 255, 255, 255), 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 15px 20px; border-bottom: 1px solid var(--border-color); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; position: sticky; top: 0; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .header-content { display: flex; justify-content: space-between; align-items: center; max-width: 950px; margin: 0 auto; flex-wrap: wrap; gap: 10px 15px; /* Ajusté gap */ }
        header h1 { font-size: 1.9em; color: var(--primary-color); margin: 0; font-weight: 700; white-space: nowrap; display: flex; align-items: center; gap: 10px; }
        header h1 .fa-dumbbell { animation: pulse 2s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }

        nav ul { list-style: none; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
        /* Style général bouton */
        .general-button { background-color: var(--primary-color); color: white; border: none; padding: 10px 18px; border-radius: var(--border-radius); cursor: pointer; font-size: 0.95em; font-weight: 500; transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 8px; white-space: nowrap; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .general-button:disabled { background-color: #bbb; color: #eee; cursor: not-allowed; opacity: 0.6; box-shadow: none; transform: none; }
        body.dark-theme .general-button:disabled { background-color: #555; color: #999; }
        .general-button:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .general-button:not(:disabled):active { transform: scale(0.97); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }

        /* Application aux boutons spécifiques */
        nav button, .history-controls button, .action-btn { /* Héritent de general-button */ }
        nav button:not(:disabled):hover, .history-controls button:hover, .action-btn:not(:disabled):hover { background-color: var(--accent-color); }
        nav button.active { background-color: var(--accent-color); color: var(--bg-color); font-weight: bold; box-shadow: var(--primary-glow); }
        #nav-history { background-color: var(--info-color); } #nav-history:not(:disabled):hover { background-color: color-mix(in srgb, var(--info-color) 85%, black); } #nav-history.active { background-color: var(--accent-color); }

        .theme-toggle button { /* Style spécifique car pas general-button */ background-color: transparent; color: var(--text-color); font-size: 1.4em; padding: 5px; box-shadow: none; border: none; cursor: pointer; border-radius: var(--border-radius); transition: all var(--transition-speed) ease; }
        .theme-toggle button:hover { background-color: rgba(var(--primary-color-rgb), 0.1); transform: scale(1.1); }

        /* --- Contrôles d'Authentification & Export --- */
        .header-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; } /* Nouveau conteneur */
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button { background-color: var(--success-color); } /* Hérite general-button via CSS */
        .auth-controls button#signout-button { background-color: var(--danger-color); }
        .auth-controls button:not(:disabled):hover { background-color: color-mix(in srgb, var(--success-color) 85%, black); }
        .auth-controls button#signout-button:not(:disabled):hover { background-color: color-mix(in srgb, var(--danger-color) 85%, black); }

        #export-programs-btn { background-color: var(--export-btn-color); padding: 8px 14px; font-size: 0.9em;} /* Hérite general-button */
        #export-programs-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--export-btn-color) 85%, black); }

        #drive-status { font-size: 0.85em; opacity: 0.8; margin-left: 8px; transition: opacity 0.3s; min-width: 100px; text-align: right; font-style: italic; }
        #drive-status.loading { opacity: 1; font-weight: bold; color: var(--warning-color); }

        /* Logique d'affichage connexion/déconnexion */
        body.logged-out #signin-button { display: inline-flex; } body.logged-out #signout-button { display: none; } body.logged-out #drive-status { display: none; } body.logged-out #export-programs-btn { display: none; } /* Cache Export si déconnecté */
        body.logged-in #signin-button { display: none; } body.logged-in #signout-button { display: inline-flex; } body.logged-in #drive-status { display: inline-block; } body.logged-in #export-programs-btn { display: inline-flex; } /* Affiche Export si connecté */

        /* --- Contenu Principal --- */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 40px; position: relative; }
        .workout-section, .history-section { background-color: var(--secondary-color); padding: 35px; border-radius: var(--border-radius); box-shadow: var(--box-shadow); width: 100%; max-width: 650px; text-align: center; transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); position: relative; overflow: visible; margin-bottom: 40px; border: 1px solid var(--border-color); }
        .section-hidden { transform: scale(0.9) translateY(30px); opacity: 0; pointer-events: none; max-height: 0; padding: 0; margin-bottom: 0; border: none; overflow: hidden; }

        /* --- Affichage du Timer --- */
        .timer-display { margin-bottom: 35px; position: relative; }
        .timer-circle { width: 220px; height: 220px; margin: 0 auto; position: relative; border-radius: 50%; background: conic-gradient(var(--accent-color) 0%, var(--border-color) 0%); display: flex; justify-content: center; align-items: center; transition: background var(--transition-speed) ease, box-shadow var(--transition-speed) ease; box-shadow: inset 0 0 15px rgba(0,0,0,0.1), var(--primary-glow); }
        .timer-circle::before { content: ''; position: absolute; width: 88%; height: 88%; background-color: var(--secondary-color); border-radius: 50%; transition: background-color var(--transition-speed) ease; }
        .time-left { font-size: 4em; font-weight: bold; color: var(--primary-color); z-index: 1; transition: color var(--transition-speed) ease; font-variant-numeric: tabular-nums; }
        .timer-state { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 1em; color: var(--warning-color); font-weight: bold; text-transform: uppercase; opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease; background-color: var(--secondary-color); padding: 3px 10px; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .timer-state.visible { opacity: 1; transform: translateX(-50%) translateY(5px); }

        /* --- Info Entraînement --- */
        .workout-info { margin-bottom: 35px; min-height: 180px; position: relative; }
        .exercise-card { padding: 18px; border: 1px solid var(--border-color); border-radius: var(--border-radius); margin-bottom: 18px; background-color: var(--bg-color); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s ease, background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; text-align: left; box-shadow: 0 3px 6px rgba(0,0,0,0.05); }
        .exercise-card h2, .exercise-card h3 { color: var(--primary-color); margin-bottom: 8px; font-size: 1.5em; font-weight: 600; }
        .exercise-card h3 { font-size: 1.2em; opacity: 0.85; }
        .exercise-card p { font-size: 1.05em; color: var(--text-color); margin-bottom: 6px; }
        .exercise-card p strong { color: var(--accent-color); font-weight: 600; }
        .exercise-enter { opacity: 0; transform: translateX(30px); }
        .exercise-exit { opacity: 0; transform: translateX(-30px); position: absolute; width: calc(100% - 40px); left: 20px; }
        .current-exercise .exercise-card { border-left: 6px solid var(--primary-color); }
        .next-exercise .exercise-card { border-left: 6px solid var(--accent-color); opacity: 0.75; }
        .next-exercise h3 { color: var(--accent-color); }
        .progress-tracker { font-size: 1em; color: var(--text-color); margin-bottom: 25px; opacity: 0.9; font-weight: 500; }

        /* --- Contrôles Timer --- */
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin-top: 25px; }
        .controls button { /* Hérite de general-button */ padding: 14px 18px; font-size: 1em; width: 100%; justify-content: center; }
        .controls button:disabled { background-color: #bbb; color: #eee; } /* Style disabled spécifique aux controls */
        body.dark-theme .controls button:disabled { background-color: #555; color: #999; }
        .controls button:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .controls button:not(:disabled):active { transform: scale(0.97); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .controls .pause-btn { background-color: var(--warning-color); } .controls .pause-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--warning-color) 90%, black); }
        .controls .skip-btn { background-color: var(--accent-color); color: var(--bg-color); } .controls .skip-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--accent-color) 90%, black); }
        .controls .finish-btn { background-color: var(--info-color); } .controls .finish-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--info-color) 90%, black); }
        .controls .reset-btn { background-color: var(--danger-color); } .controls .reset-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--danger-color) 90%, black); }
        /* Span reset button */
        @media (min-width: 560px) { .controls { grid-template-columns: repeat(4, 1fr); } .controls .reset-btn { grid-column: span 1; } }
        @media (max-width: 559px) and (min-width: 400px) { .controls { grid-template-columns: repeat(2, 1fr); } .controls .reset-btn { grid-column: span 2; } }
        @media (max-width: 399px) { .controls { grid-template-columns: 1fr; } .controls .reset-btn { grid-column: auto; } }

        /* --- Section Historique --- */
         .history-section { max-width: 850px; text-align: left; }
         .history-section h2 { text-align: center; color: var(--primary-color); margin-bottom: 30px; font-size: 1.8em; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .history-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 20px; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid var(--border-color); }
        .history-filters { display: flex; gap: 10px; flex-wrap: wrap; } /* Ajout flex-wrap */
        .history-filters button { /* Hérite general-button */ background-color: var(--info-color); opacity: 0.8; font-size: 0.9em; padding: 8px 14px; }
        .history-filters button:not(:disabled):hover { background-color: color-mix(in srgb, var(--info-color) 85%, black); }
        .history-filters button.active { opacity: 1; font-weight: bold; background-color: var(--primary-color); box-shadow: var(--primary-glow); }
        .history-actions { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; font-size: 0.9em; opacity: 0.8; color: var(--text-color); align-items: center; }
        .history-actions i { color: var(--success-color); margin-right: 5px;}

        /* --- Conteneur Graphique --- */
        .chart-container { position: relative; margin: 30px auto; padding: 20px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius); max-width: 100%; height: 380px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; box-shadow: inset 0 0 10px rgba(0,0,0,0.05); }
        .chart-container canvas { max-width: 100%; height: 100% !important; }

        /* --- Affichage Statistiques --- */
        .stats-display { background-color: var(--bg-color); padding: 20px; border-radius: var(--border-radius); margin-bottom: 30px; border: 1px solid var(--border-color); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; box-shadow: 0 3px 6px rgba(0,0,0,0.05); }
        .stats-display h3 { color: var(--primary-color); margin-bottom: 15px; text-align: center; font-size: 1.4em; }
        .stats-display p { margin-bottom: 10px; font-size: 1em; }
        .stats-display p strong { color: var(--accent-color); font-weight: 600; }
        .motivational-message { font-style: italic; color: var(--success-color); margin-top: 18px; text-align: center; font-weight: 500; font-size: 1.1em; background: linear-gradient(45deg, var(--success-color), var(--accent-color)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-fill-color: transparent; }

        /* --- Liste Historique --- */
        .history-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: var(--bg-color); box-shadow: inset 0 1px 4px rgba(0,0,0,0.04); }
        .history-list li { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; padding: 14px 18px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s ease; gap: 5px 10px; }
        .history-list li:last-child { border-bottom: none; }
        .history-list li:nth-child(even) { background-color: var(--secondary-color); }
        .history-list li:hover { background-color: rgba(var(--primary-color-rgb, 74, 144, 226), 0.1); transform: translateX(5px); }
        .history-item-date { font-weight: 500; flex-basis: 200px; flex-grow: 1; font-size: 0.95em; }
        .history-item-type { flex-basis: 80px; text-align: center; font-weight: bold; color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); padding: 3px 6px; border-radius: 4px; font-size: 0.9em; }
        .history-item-duration { flex-basis: 90px; text-align: right; color: var(--accent-color); font-weight: bold; font-size: 1.05em; }
        .history-list .no-history { text-align: center; padding: 20px; font-style: italic; opacity: 0.7; }

        /* Helper pour RGBA */
        body { --primary-color-rgb: 74, 144, 226; --bg-color-rgb: 255, 255, 255; --text-color-rgb: 51, 51, 51; }
        body.dark-theme { --primary-color-rgb: 88, 166, 255; --bg-color-rgb: 13, 17, 23; --text-color-rgb: 225, 225, 225; }

        /* --- Zone de Messages Flottante --- */
        .message-area { position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%); background-color: rgba(var(--text-color-rgb), 0.9); color: var(--bg-color); padding: 14px 28px; border-radius: var(--border-radius); z-index: 1001; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease; pointer-events: none; font-size: 1em; box-shadow: 0 4px 15px rgba(0,0,0,0.2); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        body.dark-theme .message-area { background-color: rgba(var(--text-color-rgb), 0.9); color: var(--bg-color); }
        .message-area.visible { opacity: 1; transform: translate(-50%, -10px); pointer-events: auto; }

        /* --- Pied de Page --- */
        footer { text-align: center; padding: 20px; margin-top: 40px; font-size: 0.9em; color: var(--text-color); opacity: 0.7; border-top: 1px solid var(--border-color); transition: color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        footer .fab.fa-google-drive { color: #1aa260; margin-left: 5px; }
        footer a { color: var(--primary-color); text-decoration: none; transition: color 0.2s; }
        footer a:hover { text-decoration: underline; }

        /* --- Styles Responsives --- */
        @media (max-width: 992px) { /* Ajustement breakpoint pour header */
             .header-content { flex-direction: column; align-items: center; }
             nav { order: 3; margin-top: 10px; }
             .header-actions { order: 2; margin-top: 10px; }
             header h1 { order: 1; margin-bottom: 5px; }
        }
        @media (max-width: 768px) {
            .container { padding: 20px 15px; }
            header h1 { font-size: 1.6em; }
            nav ul { justify-content: center; }
            .timer-circle { width: 180px; height: 180px; } .time-left { font-size: 3.2em; }
            .history-controls { flex-direction: column; align-items: stretch; gap: 15px;}
            .history-filters { justify-content: center; }
            .history-actions { justify-content: center; }
            .history-list li { flex-direction: column; align-items: flex-start; gap: 8px; }
            .history-item-date, .history-item-type, .history-item-duration { flex-basis: auto; text-align: left; width: 100%; }
            .history-item-type { text-align: left; display: inline-block; width: auto; }
            .history-item-duration { text-align: left; }
            .chart-container { height: 320px; }
        }
        @media (max-width: 480px) {
            html { font-size: 15px; }
            .container { padding: 15px 10px; }
            header h1 { font-size: 1.4em; }
            .general-button, nav button, .history-controls button, .action-btn, .auth-controls button { padding: 9px 14px; font-size: 0.9em; gap: 6px; }
            .workout-section, .history-section { padding: 25px; }
            .timer-circle { width: 160px; height: 160px; } .time-left { font-size: 2.8em; }
            .controls button { padding: 12px 15px; font-size: 0.95em; }
            .history-filters button { padding: 7px 10px; font-size: 0.85em; }
            .chart-container { height: 280px; }
            .message-area { width: calc(100% - 40px); bottom: 15px; font-size: 0.95em; padding: 12px 20px; }
        }

    </style>
</head>
<body class="logged-out"> <!-- Commence déconnecté -->

    <header>
        <div class="header-content">
            <h1><i class="fas fa-dumbbell"></i> ArmorWorkout</h1>
            <nav>
                <ul>
                    <!-- Appliquer la classe .general-button pour styles hérités -->
                    <li><button id="nav-push" data-workout="Push" class="general-button" disabled>Push</button></li>
                    <li><button id="nav-pull" data-workout="Pull" class="general-button" disabled>Pull</button></li>
                    <li><button id="nav-legs" data-workout="Legs" class="general-button" disabled>Legs</button></li>
                    <li><button id="nav-history" class="general-button"><i class="fas fa-history"></i> Historique</button></li>
                </ul>
            </nav>
            <!-- Nouveau conteneur pour Auth et Export -->
            <div class="header-actions">
                 <div class="auth-controls">
                     <!-- Appliquer .general-button -->
                     <button id="signin-button" class="general-button"><i class="fab fa-google"></i> Connecter Drive</button>
                     <button id="signout-button" class="general-button"><i class="fas fa-sign-out-alt"></i> Déconnecter</button>
                      <span id="drive-status"></span>
                 </div>
                 <!-- Bouton Export Programme (caché si déconnecté par CSS) -->
                 <button id="export-programs-btn" class="general-button"><i class="fas fa-upload"></i> Exporter Progs</button>
            </div>
            <div class="theme-toggle">
                <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-moon"></i></button>
            </div>
        </div>
    </header>

    <div class="container">
        <main>
            <!-- Section Timer Entraînement -->
            <div class="workout-section" id="workout-section">
                <div class="timer-display"> <div class="timer-circle" id="timer-circle"><span class="time-left" id="time-left">00:00</span></div> <div class="timer-state" id="timer-state"></div> </div>
                <div class="workout-info" id="workout-info"> <div class="current-exercise" id="current-exercise-container"> <p>Connexion à Google Drive...</p> </div> <div class="next-exercise" id="next-exercise-container"></div> </div>
                <div class="progress-tracker" id="progress-tracker"></div>
                <div class="controls">
                    <!-- Appliquer .general-button -->
                    <button id="start-pause-btn" class="general-button" disabled><i class="fas fa-play"></i> Démarrer</button>
                    <button id="skip-btn" class="skip-btn general-button" disabled><i class="fas fa-forward-step"></i> Suivant</button>
                    <button id="finish-btn" class="finish-btn general-button" disabled><i class="fas fa-flag-checkered"></i> Terminer</button>
                    <button id="reset-btn" class="reset-btn general-button" disabled><i class="fas fa-redo"></i> Réinitialiser</button>
                </div>
            </div>

            <!-- Section Historique -->
            <div class="history-section section-hidden" id="history-section">
                 <h2><i class="fas fa-chart-line"></i> Historique & Statistiques</h2>
                 <div class="history-controls">
                     <div class="history-filters">
                         <!-- Appliquer .general-button -->
                         <button data-period="week" class="general-button active"><i class="fas fa-calendar-week"></i> Semaine</button>
                         <button data-period="month" class="general-button"><i class="fas fa-calendar-alt"></i> Mois</button>
                         <button data-period="year" class="general-button"><i class="fas fa-calendar-check"></i> Année</button>
                         <button data-period="all" class="general-button"><i class="fas fa-infinity"></i> Tout</button>
                     </div>
                     <div class="history-actions"> <i class="fab fa-google-drive"></i> <span>Données synchronisées avec Google Drive</span> </div>
                 </div>
                 <div class="chart-container"> <canvas id="history-chart-canvas"></canvas> </div>
                 <div class="stats-display" id="stats-display"> <h3>Statistiques</h3> <p>Connectez-vous pour afficher les statistiques.</p> <p class="motivational-message" id="motivational-message"></p> </div>
                 <ul class="history-list" id="history-list"> <li class="no-history">Connectez-vous pour afficher l'historique.</li> </ul>
            </div>
        </main>
    </div>

    <footer>
        <p>© 2024 ArmorWorkout par IronWorkout. Intégré avec <i class="fab fa-google-drive"></i> Google Drive.</p>
        <p><a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i> Voir sur GitHub</a></p>
    </footer>

    <div id="message-area" class="message-area"></div>

    <script>
        // --- CONFIGURATION ---
        const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
        const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const HISTORY_FILENAME = "armorworkout_history.csv";
        // Nouveaux noms pour les fichiers de programmes
        const PROGRAM_FILENAMES = {
            Push: "armorworkout_push_program.csv",
            Pull: "armorworkout_pull_program.csv",
            Legs: "armorworkout_legs_program.csv"
        };
        const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];

        // --- DONNÉES D'ENTRAÎNEMENT PAR DÉFAUT ---
        // Utilisées si les fichiers Drive n'existent pas ou sont illisibles
        const defaultWorkouts = {
            Push: [ { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 }, { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 }, { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 14 }, { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 }, { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 }, { type: 'break', duration: 60 }, { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 }, { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 }, ],
            Pull: [ { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 }, { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 }, { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 13 }, { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 15 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 }, { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 }, { type: 'break', duration: 60 }, { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 }, { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 }, ],
            Legs: [ { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 }, { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 }, { type: 'break', duration: 90 }, { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 }, { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 }, { type: 'break', duration: 90 }, { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 14 }, { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 11 }, { type: 'break', duration: 90 }, { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 }, { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 }, { type: 'break', duration: 60 }, { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 }, { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 }, ]
        };

        // --- Éléments DOM ---
        // (Identique à la version précédente, mais ajout de exportProgramsBtn)
        const timeLeftDisplay = document.getElementById('time-left'); const timerCircle = document.getElementById('timer-circle'); const timerStateDisplay = document.getElementById('timer-state'); const currentExerciseContainer = document.getElementById('current-exercise-container'); const nextExerciseContainer = document.getElementById('next-exercise-container'); const progressTracker = document.getElementById('progress-tracker'); const startPauseBtn = document.getElementById('start-pause-btn'); const skipBtn = document.getElementById('skip-btn'); const finishBtn = document.getElementById('finish-btn'); const resetBtn = document.getElementById('reset-btn'); const navButtons = document.querySelectorAll('nav button[data-workout]'); const navHistoryBtn = document.getElementById('nav-history'); const themeToggleBtn = document.getElementById('theme-toggle-btn'); const messageArea = document.getElementById('message-area'); const workoutSection = document.getElementById('workout-section'); const historySection = document.getElementById('history-section'); const historyList = document.getElementById('history-list'); const statsDisplay = document.getElementById('stats-display'); const motivationalMessage = document.getElementById('motivational-message'); const historyFilterBtns = document.querySelectorAll('.history-filters button'); const historyChartCanvas = document.getElementById('history-chart-canvas'); const signInButton = document.getElementById('signin-button'); const signOutButton = document.getElementById('signout-button'); const driveStatusElement = document.getElementById('drive-status');
        const exportProgramsBtn = document.getElementById('export-programs-btn'); // Nouveau bouton

        // --- Variables d'État ---
        let currentWorkoutType = null; let currentWorkoutPlan = []; let currentItemIndex = 0; let timerInterval = null; let totalTime = 0; let timeLeft = 0; let isTimerRunning = false; let isWorkoutActive = false; let workoutFinished = false; let currentState = 'idle'; let workoutStartTime = null; let workoutHistory = []; let currentHistoryPeriod = 'week'; let historyChart = null;
        let googleAccessToken = null; let tokenClient = null;
        let historyFileId = null; // Renommé pour clarté
        let programFileIds = { Push: null, Pull: null, Legs: null }; // Pour stocker les IDs des fichiers programmes
        let programsLoaded = false; // Indicateur si les programmes sont chargés depuis Drive

        // NOUVEAU: Variable pour stocker les programmes chargés (ou par défaut)
        let loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Commence avec les défauts

        // --- Audio & Vibration --- (Identique)
        let endSound = null; let audioContext = null; function initAudioContext(){ if (!audioContext && (window.AudioContext || window.webkitAudioContext)) { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext ok."); const buffer = audioContext.createBuffer(1, 1, 22050); const source = audioContext.createBufferSource(); source.buffer = buffer; source.connect(audioContext.destination); source.start(0); source.stop(audioContext.currentTime + 0.001); } catch (e) { console.warn("AudioContext échec:", e); audioContext = null; } } if (audioContext) { endSound = () => { if (!audioContext || audioContext.state === 'suspended') { audioContext?.resume().then(() => playActualSound()).catch(e => console.error("Erreur reprise Audio", e)); } else { playActualSound(); } }; } else { endSound = () => console.log("Beep!"); } } function playActualSound(){ if (!audioContext) return; const o = audioContext.createOscillator(); const g = audioContext.createGain(); o.connect(g); g.connect(audioContext.destination); o.type = 'triangle'; o.frequency.setValueAtTime(523.25, audioContext.currentTime); g.gain.setValueAtTime(0.3, audioContext.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5); o.start(); o.stop(audioContext.currentTime + 0.5); } const vibrate = (pattern = [100, 50, 100]) => { if ('vibrate' in navigator) { try { navigator.vibrate(pattern); } catch (e) { console.warn("Vibration échec:", e); } } };

        // --- Google Identity Services (GIS) & Drive API ---

        function gisLoadedCallback() { /* Identique */ console.log("GIS Library Loaded"); if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID === "VOTRE ID CLIENT ICI") { console.error("ERREUR: GOOGLE_CLIENT_ID non configuré !"); showMessage("Erreur config ID Client Google.", 10000); driveStatusElement.textContent = 'Erreur Config'; return; } try { tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CLIENT_ID, scope: GOOGLE_DRIVE_SCOPES, callback: tokenCallback, error_callback: handleTokenError, prompt: '' }); console.log("Token Client Initialized"); } catch (error) { console.error("Erreur init Token Client:", error); showMessage("Erreur init Google.", 5000); updateAuthUI(false); driveStatusElement.textContent = 'Erreur Init'; } }
        function handleTokenError(error) { /* Identique */ console.error("Token Client Error:", error); if (error.type === 'popup_closed') { showMessage("Connexion Google annulée.", 3000); driveStatusElement.textContent = 'Annulé'; } else if (error.type === 'popup_failed_to_open') { showMessage("Popup Google bloqué. Veuillez autoriser les popups.", 5000); driveStatusElement.textContent = 'Popup bloqué'; } else { showMessage(`Erreur Auth Google: ${error.type || error.message || 'Inconnue'}`, 5000); driveStatusElement.textContent = 'Erreur Auth'; } updateAuthUI(false); }

        // MODIFIÉ : Appelle le chargement de l'historique ET des programmes
        async function tokenCallback(tokenResponse) {
            if (tokenResponse && tokenResponse.access_token) {
                console.log("Access Token Received");
                googleAccessToken = tokenResponse.access_token;
                updateAuthUI(true); // Met à jour l'UI (active boutons, etc.)
                showMessage("Connecté à Google Drive. Chargement données...", 3000);
                driveStatusElement.textContent = 'Chargement...';
                driveStatusElement.classList.add('loading');

                // Charger l'historique ET les programmes en parallèle pour gagner du temps
                try {
                    await Promise.all([
                        loadHistoryFromDrive(),
                        loadProgramsFromDrive() // Nouvelle fonction
                    ]);
                     // Si les programmes sont bien chargés, activer les boutons de sélection
                     if (programsLoaded) {
                          navButtons.forEach(btn => btn.disabled = false);
                          checkEnableStartButton(); // Met à jour le bouton Démarrer
                          console.log("Données chargées, interface prête.");
                          showMessage("Historique et programmes chargés.", 2500);
                          driveStatusElement.textContent = 'Connecté';
                          driveStatusElement.classList.remove('loading');
                          // Essayer de reprendre un état local APRÈS chargement des données
                          loadInProgressState();
                     } else {
                          // Si les programmes n'ont pas pu être chargés (erreur majeure)
                          showMessage("Erreur chargement programmes depuis Drive. Utilisation défauts.", 5000);
                          // L'UI devrait déjà refléter les boutons désactivés si programsLoaded est false
                     }

                } catch (error) {
                     console.error("Erreur lors du chargement parallèle:", error);
                     showMessage("Erreur chargement données Drive.", 5000);
                      // Utiliser les programmes par défaut en cas d'erreur globale
                     loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
                     programsLoaded = false; // Marquer comme non chargé
                     updateAuthUI(true); // S'assurer que l'UI est correcte pour l'état connecté mais sans progs
                     driveStatusElement.textContent = 'Erreur chargement';
                     driveStatusElement.classList.remove('loading');
                }

            } else {
                console.error("Token Response Error:", tokenResponse);
                showMessage("Erreur: Jeton Google invalide.", 5000);
                updateAuthUI(false);
                driveStatusElement.textContent = 'Erreur Jeton';
            }
        }

        function handleAuthClick() { /* Identique */ if (!tokenClient) { showMessage("Biblio Google charge...", 3000); return; } initAudioContext(); console.log("Requesting Access Token..."); driveStatusElement.textContent = 'Connexion...'; driveStatusElement.classList.add('loading'); tokenClient.requestAccessToken({ prompt: 'consent' }); }
        function handleSignoutClick() { /* Identique */ if (googleAccessToken) { driveStatusElement.textContent = 'Déconnexion...'; driveStatusElement.classList.add('loading'); google.accounts.oauth2.revoke(googleAccessToken, () => { console.log('Token revoked'); googleAccessToken = null; historyFileId = null; programFileIds = { Push: null, Pull: null, Legs: null }; // Reset IDs programmes programsLoaded = false; // Reset état chargement workoutHistory = []; loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Retour aux défauts updateAuthUI(false); showMessage("Déconnecté de Google Drive.", 2500); }); } else { updateAuthUI(false); } }

        // MODIFIÉ : Gère l'état des boutons en fonction de la connexion ET du chargement des programmes
        function updateAuthUI(isLoggedIn) {
            console.log(`Update UI - LoggedIn: ${isLoggedIn}, ProgramsLoaded: ${programsLoaded}`);
            document.body.classList.toggle('logged-in', isLoggedIn);
            document.body.classList.toggle('logged-out', !isLoggedIn);
            driveStatusElement.textContent = isLoggedIn ? (programsLoaded ? 'Connecté' : 'Chargement...') : '';
            driveStatusElement.classList.remove('loading');

            // Boutons toujours fonctionnels : connexion, thème, historique (pour voir msg)
            // signInButton : visibilité gérée par CSS
            themeToggleBtn.disabled = false;
            navHistoryBtn.disabled = false;

            if (!isLoggedIn) {
                // Déconnecté : Désactiver tout sauf connexion, thème, historique
                googleAccessToken = null; historyFileId = null; programFileIds = { Push: null, Pull: null, Legs: null }; programsLoaded = false; workoutHistory = []; loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));

                startPauseBtn.disabled = true; skipBtn.disabled = true; finishBtn.disabled = true; resetBtn.disabled = true;
                navButtons.forEach(btn => btn.disabled = true);
                 exportProgramsBtn.disabled = true; // Désactiver export si déconnecté

                if (isWorkoutActive || currentState !== 'idle') { resetCurrentWorkout(); }
                else { updateWorkoutInfo(); }
                displayHistory(currentHistoryPeriod);

            } else { // Connecté
                // Activer la navigation et l'export SEULEMENT si les programmes sont chargés
                navButtons.forEach(btn => btn.disabled = !programsLoaded);
                exportProgramsBtn.disabled = !programsLoaded;

                // Mettre à jour les boutons de contrôle du timer
                checkEnableStartButton(); // Met à jour Start/Pause
                 // Les autres (Skip, Finish, Reset) dépendent du currentState, géré par setState
                 if (currentState === 'idle' || currentState === 'finished') {
                     skipBtn.disabled = true;
                     finishBtn.disabled = true;
                      resetBtn.disabled = !currentWorkoutType || !programsLoaded; // Peut reset si connecté, progs chargés et workout choisi/fini
                 } else { // 'exercise', 'break', 'paused'
                      skipBtn.disabled = !programsLoaded;
                      finishBtn.disabled = !programsLoaded;
                      resetBtn.disabled = !programsLoaded;
                 }

                updateWorkoutInfo(); // Afficher message approprié ("Sélectionnez..." ou "Chargement...")
            }
        }

         function checkEnableStartButton() { /* Identique */ if (currentState === 'idle') { startPauseBtn.disabled = !googleAccessToken || !programsLoaded || !currentWorkoutType; startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer'; } }

        // --- Fonctions Drive Génériques ---
        // MODIFIÉ : findOrCreateFile pour être générique + contenu par défaut
        async function findOrCreateFile(filename, defaultCsvContent) {
            if (!googleAccessToken) { console.warn("findOrCreateFile: Non connecté"); return null; }
            console.log(`Recherche/Création: ${filename}`);
            // Ne pas changer driveStatus ici pour éviter trop de flicker
            try {
                const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+mimeType='text/csv'+and+trashed=false&spaces=drive&fields=files(id,name)`;
                const searchRes = await fetch(searchUrl, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } });
                if (!searchRes.ok) { if (searchRes.status === 401 || searchRes.status === 403) { handleSignoutClick(); showMessage("Session Google expirée.", 5000); return null; } throw new Error(`Erreur recherche ${filename} (${searchRes.status})`); }
                const searchData = await searchRes.json();
                if (searchData.files && searchData.files.length > 0) { console.log(`Fichier ${filename} trouvé: ${searchData.files[0].id}`); return searchData.files[0].id; }
                else {
                    console.log(`Fichier ${filename} non trouvé. Création...`);
                    const createUrl = `https://www.googleapis.com/drive/v3/files`;
                    const metadata = { name: filename, mimeType: 'text/csv' };
                    const createRes = await fetch(createUrl, { method: 'POST', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' }, body: JSON.stringify(metadata) });
                    if (!createRes.ok) throw new Error(`Erreur création ${filename} (${createRes.status})`);
                    const createData = await createRes.json(); const newFileId = createData.id;
                    console.log(`Fichier ${filename} créé: ${newFileId}. Écriture contenu défaut...`);
                    // Écrire le contenu par défaut immédiatement
                    const writeSuccess = await updateFileContent(newFileId, defaultCsvContent);
                    if (writeSuccess) { console.log(`Contenu défaut écrit pour ${filename}.`); return newFileId; }
                    else { console.error(`Échec écriture contenu défaut pour ${filename}.`); return null; /* Erreur */ }
                }
            } catch (error) { console.error(`Erreur find/create ${filename}:`, error); showMessage(`Erreur Drive (${filename}): ${error.message}`, 6000); return null; }
        }

        // readFileContent reste générique (prend fileId) - Identique
        async function readFileContent(fileId) { if (!googleAccessToken || !fileId) return null; console.log(`Lecture fichier Drive: ${fileId}`); const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`; try { const response = await fetch(url, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!response.ok) { if (response.status === 404) { console.warn(`Fichier ${fileId} non trouvé (404).`); return ""; /* Fichier non trouvé = contenu vide */ } if (response.status === 401 || response.status === 403) { handleSignoutClick(); showMessage("Session expirée.", 5000); return null; } throw new Error(`Erreur lecture ${fileId} (${response.status})`); } const content = await response.text(); console.log(`Lecture ${fileId} réussie.`); return content; } catch (error) { console.error(`Erreur lecture ${fileId}:`, error); showMessage(`Erreur Drive Lecture: ${error.message}`, 6000); return null; } }

        // updateFileContent reste générique (prend fileId, content) - Identique
        async function updateFileContent(fileId, content) { if (!googleAccessToken || !fileId) return false; console.log(`Mise à jour fichier Drive: ${fileId}`); const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`; try { const response = await fetch(url, { method: 'PATCH', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'text/csv' }, body: content }); if (!response.ok) { if (response.status === 401 || response.status === 403) { handleSignoutClick(); showMessage("Session expirée. Sauvegarde échouée.", 6000); return false; } throw new Error(`Erreur écriture ${fileId} (${response.status})`); } console.log(`Écriture ${fileId} réussie.`); return true; } catch (error) { console.error(`Erreur écriture ${fileId}:`, error); showMessage(`Erreur Drive Écriture: ${error.message}`, 6000); return false; } }


        // --- Fonctions Cœur du Timer --- (Utilisent maintenant `loadedWorkouts`)
        function formatTime(seconds) { /* Identique */ const absSeconds = Math.abs(Math.round(seconds)); const m = Math.floor(absSeconds / 60); const s = absSeconds % 60; return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; }
        function formatTimeForChart(seconds) { /* Identique */ return parseFloat((seconds / 60).toFixed(1)); }

        function updateTimerDisplay() { /* Identique */ timeLeftDisplay.textContent = formatTime(timeLeft); let progressPercent = 0; if ((currentState === 'break' || currentState === 'paused') && totalTime > 0) { progressPercent = Math.max(0, Math.min(100, ((totalTime - timeLeft) / totalTime) * 100)); } else if (currentState === 'finished') { progressPercent = 100; } timerCircle.style.background = `conic-gradient(var(--accent-color) ${progressPercent}%, var(--border-color) 0%)`; }

        // MODIFIÉ : Utilise `currentWorkoutPlan` qui est une copie de `loadedWorkouts[type]`
        function updateWorkoutInfo(animate = false) {
            // currentWorkoutPlan est défini dans loadWorkout
            const currentItem = currentWorkoutPlan[currentItemIndex];
            const nextItem = (currentItemIndex + 1 < currentWorkoutPlan.length) ? currentWorkoutPlan[currentItemIndex + 1] : null;
            const createCardHTML = (item, isCurrent) => { /* Identique */ if (!item) return ''; const title = isCurrent ? 'En cours' : 'Suivant'; const tagName = isCurrent ? 'h2' : 'h3'; const icon = item.type === 'exercise' ? '<i class="fas fa-weight-hanging"></i>' : '<i class="fas fa-coffee"></i>'; let cardContent = `<${tagName}>${icon} ${title}: ${item.name || 'Repos'}</${tagName}>`; if (item.details) cardContent += `<p>${item.details}</p>`; if (item.reps) cardContent += `<p><strong>${item.reps} reps</strong></p>`; if (item.duration) cardContent += `<p><strong><i class="fas fa-clock"></i> Durée: ${formatTime(item.duration)}</strong></p>`; return `<div class="exercise-card">${cardContent}</div>`; };
            const currentCardHTML = createCardHTML(currentItem, true); const nextCardHTML = createCardHTML(nextItem, false);
            const updateDOMContent = () => { /* Identique */ let finalCurrentHTML = '', finalNextHTML = '', finalProgressText = ''; if (currentState === 'idle') { finalCurrentHTML = googleAccessToken ? (programsLoaded ? `Sélectionnez un entraînement.` : `Chargement des programmes...`) : `Connectez-vous à Google Drive...`; } else if (currentState === 'finished') { const durationFinished = workoutStartTime ? formatTime((Date.now() - workoutStartTime) / 1000) : 'N/A'; finalCurrentHTML = `<div class="exercise-card"><h2><i class="fas fa-check-circle" style="color: var(--success-color)"></i> Terminé !</h2><p>Temps: <strong>${durationFinished}</strong></p></div>`; finalProgressText = `Terminé (${currentWorkoutPlan.length}/${currentWorkoutPlan.length})`; } else if (currentItem) { finalCurrentHTML = currentCardHTML; finalNextHTML = nextCardHTML; finalProgressText = `Étape ${currentItemIndex + 1} / ${currentWorkoutPlan.length}`; } else { finalCurrentHTML = `<p>Chargement...</p>`; } currentExerciseContainer.innerHTML = finalCurrentHTML; nextExerciseContainer.innerHTML = finalNextHTML; progressTracker.textContent = finalProgressText; void currentExerciseContainer.offsetWidth; void nextExerciseContainer.offsetWidth; };
            if (animate && currentState !== 'idle' && currentState !== 'finished') { /* Identique */ const oldCurrentCard = currentExerciseContainer.querySelector('.exercise-card'); const oldNextCard = nextExerciseContainer.querySelector('.exercise-card'); if (oldCurrentCard) oldCurrentCard.classList.add('exercise-exit'); if (oldNextCard) oldNextCard.classList.add('exercise-exit'); const animationDuration = 400; setTimeout(() => { updateDOMContent(); const newCurrentCard = currentExerciseContainer.querySelector('.exercise-card'); const newNextCard = nextExerciseContainer.querySelector('.exercise-card'); if (newCurrentCard) newCurrentCard.classList.add('exercise-enter'); if (newNextCard) newNextCard.classList.add('exercise-enter'); requestAnimationFrame(() => { requestAnimationFrame(() => { if (newCurrentCard) newCurrentCard.classList.remove('exercise-enter'); if (newNextCard) newNextCard.classList.remove('exercise-enter'); }); }); }, animationDuration / 2); }
            else { updateDOMContent(); }
        }

        // setState : Logique de gestion des états et boutons (identique fonctionnellement)
        function setState(newState) { /* Identique à la version précédente */ const previousState = currentState; currentState = newState; console.log(`Transition State: ${previousState} -> ${newState}`); timerStateDisplay.classList.remove('visible'); clearInterval(timerInterval); timerInterval = null; if (['idle'].includes(previousState) && ['exercise', 'break', 'paused'].includes(newState)) { if (workoutStartTime === null) { workoutStartTime = Date.now(); console.log("Début entraînement:", new Date(workoutStartTime)); } } startPauseBtn.disabled = true; skipBtn.disabled = true; finishBtn.disabled = true; resetBtn.disabled = true; startPauseBtn.classList.remove('pause-btn'); switch (newState) { case 'idle': startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer'; startPauseBtn.disabled = !googleAccessToken || !programsLoaded || !currentWorkoutType; resetBtn.disabled = !googleAccessToken || !programsLoaded || !currentWorkoutType; isTimerRunning = false; isWorkoutActive = false; workoutFinished = false; timeLeft = 0; totalTime = 0; updateTimerDisplay(); break; case 'exercise': startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Fait'; startPauseBtn.disabled = false; skipBtn.disabled = false; finishBtn.disabled = false; resetBtn.disabled = false; isTimerRunning = false; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'EXERCICE'; timerStateDisplay.classList.add('visible'); timeLeft = 0; totalTime = 0; updateTimerDisplay(); break; case 'break': startPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause'; startPauseBtn.disabled = false; startPauseBtn.classList.add('pause-btn'); skipBtn.disabled = false; finishBtn.disabled = false; resetBtn.disabled = false; isTimerRunning = true; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'REPOS'; timerStateDisplay.classList.add('visible'); startBreakTimer(); break; case 'paused': startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Reprendre'; startPauseBtn.disabled = false; skipBtn.disabled = false; finishBtn.disabled = false; resetBtn.disabled = false; isTimerRunning = false; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'EN PAUSE'; timerStateDisplay.classList.add('visible'); updateTimerDisplay(); break; case 'finished': startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Terminé'; startPauseBtn.disabled = true; skipBtn.disabled = true; finishBtn.disabled = true; resetBtn.disabled = !googleAccessToken || !programsLoaded; isTimerRunning = false; isWorkoutActive = false; workoutFinished = true; timerStateDisplay.textContent = 'FINI !'; timerStateDisplay.classList.add('visible'); timeLeft = 0; totalTime = 0; updateTimerDisplay(); showMessage('Entraînement terminé ! Bravo ! 💪', 4000); vibrate([200, 100, 200]); if (endSound) endSound(); saveWorkoutToHistory(); clearInProgressState(); currentWorkoutType = null; setActiveWorkoutNav(null); break; } if (newState === 'idle') checkEnableStartButton(); const shouldAnimateInfo = previousState !== 'idle' && previousState !== 'finished'; updateWorkoutInfo(shouldAnimateInfo); }

        function startBreakTimer() { /* Identique */ if (timerInterval) clearInterval(timerInterval); updateTimerDisplay(); timerInterval = setInterval(() => { if (timeLeft > 0) { timeLeft--; updateTimerDisplay(); } else { handleItemCompletion(true); } }, 1000); }
        function handleItemCompletion(naturalCompletion = false) { /* Identique */ if (currentState === 'finished') return; if (naturalCompletion && currentState === 'break') { if (endSound) endSound(); vibrate(); } currentItemIndex++; saveInProgressState(); if (currentItemIndex >= currentWorkoutPlan.length) { setState('finished'); } else { const nextItem = currentWorkoutPlan[currentItemIndex]; if (nextItem.type === 'exercise') { setState('exercise'); } else { totalTime = nextItem.duration; timeLeft = nextItem.duration; setState('break'); } } }
        function forceFinishWorkout() { /* Identique */ if (!isWorkoutActive || workoutFinished) return; if (confirm("Terminer cet entraînement maintenant ? La progression sera sauvegardée.")) { clearInterval(timerInterval); timerInterval = null; setState('finished'); showMessage("Entraînement terminé manuellement.", 3000); } }

        // MODIFIÉ : Utilise `loadedWorkouts` pour obtenir le plan
        function loadWorkout(type) {
            if (!googleAccessToken || !programsLoaded) { showMessage("Connectez-vous et attendez le chargement des programmes.", 4000); return; }
            if (isWorkoutActive && !workoutFinished && currentWorkoutType !== type) { if (!confirm(`Arrêter "${currentWorkoutType}" (progrès perdus) et charger "${type}" ?`)) { return; } else { resetCurrentWorkout(); } }
            else if (currentWorkoutType === type && isWorkoutActive && !workoutFinished) { showMessage(`"${type}" est déjà en cours.`, 2000); showSection('workout'); return; }
            if (!loadedWorkouts[type]) { console.error(`Programme chargé pour '${type}' introuvable.`); showMessage(`Erreur: Programme ${type} non chargé.`, 4000); return; }

            console.log(`Chargement workout: ${type}`);
            currentWorkoutType = type;
            // *** Utilise loadedWorkouts et copie profonde ***
            currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[type]));
            if (!currentWorkoutPlan || currentWorkoutPlan.length === 0) {
                 console.error(`Le programme chargé pour ${type} est vide ou invalide.`);
                 showMessage(`Erreur: Programme ${type} chargé est vide.`, 4000);
                 currentWorkoutType = null;
                 return;
            }
            currentItemIndex = 0; workoutStartTime = null; workoutFinished = false; isWorkoutActive = false;
            setActiveWorkoutNav(type); showSection('workout'); clearInterval(timerInterval); timerInterval = null; isTimerRunning = false;

            const firstItem = currentWorkoutPlan[0];
            if (firstItem.type === 'exercise') { setState('idle'); timeLeft = 0; totalTime = 0; }
            else { totalTime = firstItem.duration; timeLeft = firstItem.duration; setState('paused'); startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer Pause'; timerStateDisplay.textContent = 'PRÊT ?'; timerStateDisplay.classList.add('visible'); updateTimerDisplay(); }
            updateWorkoutInfo(false); showMessage(`Programme "${type}" chargé. Prêt !`, 3000); saveInProgressState(); checkEnableStartButton();
        }

        function resetCurrentWorkout() { /* Identique */ console.log("Réinitialisation entraînement."); clearInterval(timerInterval); timerInterval = null; const typeReset = currentWorkoutType; currentWorkoutType = null; currentWorkoutPlan = []; currentItemIndex = 0; workoutStartTime = null; isTimerRunning = false; isWorkoutActive = false; workoutFinished = false; timeLeft = 0; totalTime = 0; clearInProgressState(); setState('idle'); setActiveWorkoutNav(null); updateWorkoutInfo(false); if (typeReset) { showMessage(`Entraînement "${typeReset}" réinitialisé.`, 2500); } checkEnableStartButton(); }
        let messageTimeoutId = null; function showMessage(msg, duration = 3500) { /* Identique */ messageArea.textContent = msg; messageArea.classList.add('visible'); if (messageTimeoutId) clearTimeout(messageTimeoutId); messageTimeoutId = setTimeout(() => { messageArea.classList.remove('visible'); messageTimeoutId = null; }, duration); }

        // --- Gestion du Thème --- (Identique)
        function applyTheme(theme) { const body = document.body; const isDark = theme === 'dark'; body.classList.toggle('dark-theme', isDark); themeToggleBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>'; localStorage.setItem('theme', theme); const primaryColor = getComputedStyle(body).getPropertyValue(isDark ? '--primary-color-dark' : '--primary-color-light').trim(); const bgColor = getComputedStyle(body).getPropertyValue(isDark ? '--bg-color-dark' : '--bg-color-light').trim(); const textColor = getComputedStyle(body).getPropertyValue(isDark ? '--text-color-dark' : '--text-color-light').trim(); body.style.setProperty('--primary-color-rgb', colorToRgb(primaryColor) || (isDark ? '88, 166, 255' : '74, 144, 226')); body.style.setProperty('--bg-color-rgb', colorToRgb(bgColor) || (isDark ? '13, 17, 23' : '255, 255, 255')); body.style.setProperty('--text-color-rgb', colorToRgb(textColor) || (isDark ? '225, 225, 225' : '51, 51, 51')); if (historyChart && !historySection.classList.contains('section-hidden')) { updateChartTheme(); } }
        function colorToRgb(color) { if (!color) return null; if (color.startsWith('#')) { const bigint = parseInt(color.slice(1), 16); const r = (bigint >> 16) & 255; const g = (bigint >> 8) & 255; const b = bigint & 255; return `${r}, ${g}, ${b}`; } else if (color.startsWith('rgb')) { return color.match(/\d+/g).slice(0, 3).join(', '); } return null; }
        function updateChartTheme() { /* Identique */ if (!historyChart) return; const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-color').trim(); const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim(); const tooltipBg = getComputedStyle(document.documentElement).getPropertyValue('--chart-tooltip-bg').trim(); const tooltipText = getComputedStyle(document.documentElement).getPropertyValue('--chart-tooltip-text').trim(); const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim(); historyChart.options.scales.x.grid.color = gridColor; historyChart.options.scales.y.grid.color = gridColor; historyChart.options.scales.x.ticks.color = textColor; historyChart.options.scales.y.ticks.color = textColor; historyChart.options.scales.x.title.color = textColor; historyChart.options.scales.y.title.color = textColor; historyChart.options.plugins.tooltip.backgroundColor = tooltipBg; historyChart.options.plugins.tooltip.titleColor = tooltipText; historyChart.options.plugins.tooltip.bodyColor = tooltipText; historyChart.options.plugins.legend.labels.color = textColor; historyChart.data.datasets[0].backgroundColor = primaryColor + 'BF'; historyChart.data.datasets[0].borderColor = primaryColor; historyChart.data.datasets[0].hoverBackgroundColor = accentColor + 'DF'; historyChart.data.datasets[0].hoverBorderColor = accentColor; historyChart.update(); }

        // --- Gestion Affichage Sections --- (Identique)
        function showSection(sectionName) { if (sectionName === 'history') { workoutSection.classList.add('section-hidden'); historySection.classList.remove('section-hidden'); navHistoryBtn.classList.add('active'); navButtons.forEach(btn => btn.classList.remove('active')); displayHistory(currentHistoryPeriod); } else { workoutSection.classList.remove('section-hidden'); historySection.classList.add('section-hidden'); navHistoryBtn.classList.remove('active'); setActiveWorkoutNav(currentWorkoutType); } }
        function setActiveWorkoutNav(workoutType) { navButtons.forEach(btn => { btn.classList.toggle('active', btn.dataset.workout === workoutType); }); }

        // --- Persistance Locale (État EN COURS) --- (Identique)
        const IN_PROGRESS_KEY = 'armorWorkoutStateInProgress';
        function saveInProgressState() { if (!isWorkoutActive || workoutFinished || currentState === 'idle') { clearInProgressState(); return; } const stateToSave = { type: currentWorkoutType, index: currentItemIndex, timeLeft: timeLeft, totalTime: totalTime, currentState: currentState, startTime: workoutStartTime }; try { localStorage.setItem(IN_PROGRESS_KEY, JSON.stringify(stateToSave)); console.log("État local sauvegardé:", stateToSave); } catch (e) { console.error("Sauvegarde locale échouée:", e); showMessage("Erreur: Sauvegarde locale échouée.", 5000); } }
        function loadInProgressState() { const savedStateJSON = localStorage.getItem(IN_PROGRESS_KEY); if (!savedStateJSON) return false; try { const savedState = JSON.parse(savedStateJSON); if (!savedState.type || !loadedWorkouts[savedState.type] /* Vérifie si le prog est chargé */ || typeof savedState.index !== 'number' || typeof savedState.currentState !== 'string') { console.warn("État local invalide/prog non chargé. Suppression."); clearInProgressState(); return false; } if (googleAccessToken && programsLoaded && confirm(`Reprendre "${savedState.type}" (${savedState.currentState}) ?`)) { console.log("Reprise état local."); currentWorkoutType = savedState.type; currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[currentWorkoutType])); currentItemIndex = savedState.index; timeLeft = savedState.timeLeft; totalTime = savedState.totalTime; workoutStartTime = savedState.startTime; isWorkoutActive = true; workoutFinished = false; setActiveWorkoutNav(currentWorkoutType); showSection('workout'); const stateToRestore = savedState.currentState; currentState = stateToRestore; console.log(`Reprise état: ${currentState}`); if (stateToRestore === 'exercise') { /*...*/ setState('exercise'); /* Utiliser setState pour cohérance UI */ } else if (stateToRestore === 'break') { currentState = 'paused'; /* Forcer pause */ setState('paused'); } else if (stateToRestore === 'paused') { setState('paused'); } else { console.warn("Reprise état inattendu:", stateToRestore); resetCurrentWorkout(); return false; } updateWorkoutInfo(false); updateTimerDisplay(); showMessage(`Progression "${currentWorkoutType}" restaurée.`, 3500); return true; } else if (googleAccessToken) { console.log("Reprise locale refusée."); clearInProgressState(); return false; } else { console.log("Non connecté, reprise locale impossible."); return false; } } catch (e) { console.error("Erreur chargement état local:", e); clearInProgressState(); return false; } }
        function clearInProgressState() { localStorage.removeItem(IN_PROGRESS_KEY); console.log("État local 'en cours' supprimé."); }

        // --- Gestion de l'Historique --- (Identique, utilise historyFileId)
        function saveWorkoutToHistory() { /* Identique */ if (!currentWorkoutType || workoutStartTime === null) return; if (!googleAccessToken) { showMessage("Connectez-vous pour sauvegarder.", 4000); return; } const endTime = Date.now(); const durationSeconds = Math.round((endTime - workoutStartTime) / 1000); if (durationSeconds < 10) return; const newEntry = { id: endTime.toString(), date: new Date(endTime).toISOString(), type: currentWorkoutType, duration: durationSeconds }; console.log("Ajout historique local:", newEntry); workoutHistory.unshift(newEntry); if (!historySection.classList.contains('section-hidden')) displayHistory(currentHistoryPeriod); saveHistoryToDrive(); }
        async function saveHistoryToDrive() { /* Identique */ if (!googleAccessToken) return; if (!historyFileId) { historyFileId = await findOrCreateFile(HISTORY_FILENAME, "DateISO,WorkoutType,DurationSeconds,EntryID\n"); } if (!historyFileId) { showMessage("Impossible d'accéder fichier historique Drive.", 5000); return; } let csvContent = "DateISO,WorkoutType,DurationSeconds,EntryID\n"; workoutHistory.forEach(entry => { const cleanType = entry.type.replace(/,/g, ''); csvContent += `${entry.date},${cleanType},${entry.duration},${entry.id}\n`; }); const success = await updateFileContent(historyFileId, csvContent); if(success) console.log("Historique Sync Drive OK."); }
        async function loadHistoryFromDrive() { /* Identique */ if (!googleAccessToken) { workoutHistory = []; displayHistory(currentHistoryPeriod); return; } if (!historyFileId) { historyFileId = await findOrCreateFile(HISTORY_FILENAME, "DateISO,WorkoutType,DurationSeconds,EntryID\n"); } if (!historyFileId) { showMessage("Impossible d'accéder fichier historique Drive.", 5000); workoutHistory = []; displayHistory(currentHistoryPeriod); return; } const csvContent = await readFileContent(historyFileId); if (csvContent === null) { workoutHistory = []; } else if (csvContent === "") { workoutHistory = []; } else { parseAndLoadHistoryCsvData(csvContent); /* Renommé pour clarté */ console.log(`Historique chargé: ${workoutHistory.length} entrées.`); } displayHistory(currentHistoryPeriod); }
        function parseAndLoadHistoryCsvData(csvContent) { /* Identique - Renommé */ try { /* ... parsing logic ... */ workoutHistory = newHistory; } catch (error) { /* ... error handling ... */ workoutHistory = []; } } // Remplacer par le code de parseAndLoadCsvData précédent
        function displayHistory(period = 'week') { /* Identique */ currentHistoryPeriod = period; historyFilterBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.period === period)); const isConnected = googleAccessToken; const historyToDisplay = isConnected ? workoutHistory : []; const filteredHistory = filterHistoryByPeriod(historyToDisplay, period); historyList.innerHTML = ''; if (!isConnected) { historyList.innerHTML = `<li class="no-history">Connectez-vous pour voir l'historique.</li>`; } else if (filteredHistory.length === 0) { historyList.innerHTML = `<li class="no-history">Aucun entraînement pour cette période.</li>`; } else { filteredHistory.forEach(entry => { /* ... Remplissage li ... */ }); } displayStatsAndMotivation(filteredHistory, period, isConnected); renderHistoryChart(filteredHistory, period); }
        function filterHistoryByPeriod(history, period) { /* Identique */ /* ... filtering logic ... */ }
        function displayStatsAndMotivation(filteredHistory, period, isConnected) { /* Identique */ /* ... stats display logic ... */ }
        function calculateStats(history) { /* Identique */ /* ... stats calculation ... */ }
        function generateMotivationalMessage(stats, period) { /* Identique */ /* ... motivation logic ... */ }

        // --- Gestion des Programmes (Nouveau) ---

        // Convertit un tableau JS de programme en chaîne CSV
        function convertProgramToCsv(programArray) {
            const header = "Type,Name,Details,Reps,Duration\n";
            let csv = header;
            programArray.forEach(item => {
                // Fonction simple pour échapper les guillemets dans une chaîne et l'entourer de guillemets
                const escapeCsvField = (field) => {
                    if (field === null || field === undefined) return '';
                    const stringField = String(field);
                    // Remplace " par "" et entoure de " s'il contient une virgule, un guillemet ou un retour à la ligne
                    if (stringField.includes(',') || stringField.includes('"') || stringField.includes('\n')) {
                        return `"${stringField.replace(/"/g, '""')}"`;
                    }
                    return stringField;
                };

                if (item.type === 'exercise') {
                     // Assure que les valeurs numériques sont bien des nombres ou vides
                    const reps = Number.isFinite(item.reps) ? item.reps : '';
                    csv += `${item.type},${escapeCsvField(item.name)},${escapeCsvField(item.details)},${reps},\n`;
                } else if (item.type === 'break') {
                    const duration = Number.isFinite(item.duration) ? item.duration : '';
                    csv += `${item.type},,,,${duration}\n`; // Name, Details, Reps vides
                }
            });
            return csv;
        }

        // Parse une chaîne CSV de programme en tableau JS
        function parseProgramCsvData(csvContent) {
            const lines = csvContent.trim().split(/\r?\n/);
            const program = [];
            if (lines.length <= 1) return program; // Vide ou juste l'en-tête

             const headerLine = lines[0].trim().toLowerCase();
             const hasHeader = headerLine.includes("type") && headerLine.includes("name"); // Simple check
             const startIndex = hasHeader ? 1 : 0;

             // Basic CSV value parser (doesn't handle complex quoting perfectly but ok for this)
             const parseCsvLine = (line) => {
                 const values = [];
                 let currentVal = '';
                 let inQuotes = false;
                 for (let i = 0; i < line.length; i++) {
                     const char = line[i];
                     if (char === '"') {
                         if (inQuotes && line[i+1] === '"') { // Handle "" escape sequence
                             currentVal += '"';
                             i++; // Skip next quote
                         } else {
                             inQuotes = !inQuotes;
                         }
                     } else if (char === ',' && !inQuotes) {
                         values.push(currentVal.trim());
                         currentVal = '';
                     } else {
                         currentVal += char;
                     }
                 }
                 values.push(currentVal.trim()); // Add last value
                 return values;
             };


            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                const values = parseCsvLine(line); // Utiliser le parser simple

                 // Vérifier si on a assez de colonnes (au moins Type)
                 if (values.length < 1) continue;

                const type = values[0]?.toLowerCase(); // Utiliser optional chaining
                const name = values[1] || ''; // || '' pour éviter undefined
                const details = values[2] || '';
                const repsStr = values[3] || '';
                const durationStr = values[4] || '';

                if (type === 'exercise') {
                    const reps = parseInt(repsStr, 10);
                    if (!name) { console.warn(`Ligne programme ignorée (nom exercice manquant): ${line}`); continue; }
                    program.push({
                        type: 'exercise',
                        name: name,
                        details: details,
                        reps: !isNaN(reps) ? reps : null // Mettre null si reps invalide
                    });
                } else if (type === 'break') {
                    const duration = parseInt(durationStr, 10);
                    if (isNaN(duration) || duration <= 0) { console.warn(`Ligne programme ignorée (durée pause invalide): ${line}`); continue; }
                    program.push({
                        type: 'break',
                        duration: duration
                    });
                } else {
                     console.warn(`Ligne programme ignorée (type inconnu '${type}'): ${line}`);
                }
            }
            return program;
        }

        // Charge les définitions de programmes depuis Drive
        async function loadProgramsFromDrive() {
            if (!googleAccessToken) return;
            console.log("Chargement des programmes depuis Google Drive...");
            programsLoaded = false; // Marquer comme non chargé initialement
            let allLoadedSuccessfully = true;

            driveStatusElement.textContent = 'Chargement Progs...';
            driveStatusElement.classList.add('loading');

            for (const type of PROGRAM_TYPES) {
                const filename = PROGRAM_FILENAMES[type];
                // Générer le contenu CSV par défaut pour ce type
                const defaultCsv = convertProgramToCsv(defaultWorkouts[type]);

                // Trouver/Créer le fichier et obtenir l'ID
                const fileId = await findOrCreateFile(filename, defaultCsv);
                programFileIds[type] = fileId; // Stocker l'ID

                if (fileId) {
                    const csvContent = await readFileContent(fileId);
                    if (csvContent !== null) { // Vérifier si la lecture a réussi (pas d'erreur Drive)
                        try {
                             const parsedProgram = parseProgramCsvData(csvContent);
                             if (parsedProgram.length > 0) {
                                 loadedWorkouts[type] = parsedProgram;
                                 console.log(`Programme ${type} chargé depuis Drive (${parsedProgram.length} étapes).`);
                             } else {
                                  console.warn(`Programme ${type} chargé depuis Drive est vide ou invalide. Utilisation défaut.`);
                                  loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type])); // Revenir au défaut pour ce type
                                   // Pas une erreur bloquante, on utilise le défaut
                             }
                        } catch (parseError) {
                             console.error(`Erreur parsing programme ${type}:`, parseError);
                             showMessage(`Erreur parsing ${type}. Utilisation défaut.`, 4000);
                             loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type])); // Revenir au défaut
                              // Pas une erreur bloquante
                        }
                    } else {
                        // Erreur de lecture Drive (message déjà affiché)
                        console.error(`Échec lecture fichier ${type}. Utilisation défaut.`);
                        loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type])); // Revenir au défaut
                        allLoadedSuccessfully = false; // Marquer qu'il y a eu un problème
                    }
                } else {
                    // Erreur findOrCreateFile (message déjà affiché)
                    console.error(`Échec accès/création fichier ${type}. Utilisation défaut.`);
                    loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type])); // Revenir au défaut
                    allLoadedSuccessfully = false; // Marquer qu'il y a eu un problème
                }
            }

            programsLoaded = allLoadedSuccessfully; // Marquer comme chargé seulement si tout s'est bien passé
            console.log("Fin chargement programmes. État loaded:", programsLoaded);
            // L'UI (boutons, etc.) sera mise à jour dans tokenCallback après cet appel
             driveStatusElement.classList.remove('loading');
             driveStatusElement.textContent = programsLoaded ? 'Connecté' : 'Erreur Progs';
             if (programsLoaded) updateAuthUI(true); // Confirme état UI si succès
             else updateAuthUI(true); // Confirme état UI même si erreur, mais boutons resteront désactivés
        }


        // Exporte les programmes ACTUELS (`loadedWorkouts`) vers Drive
        async function exportProgramsToDrive() {
            if (!googleAccessToken || !programsLoaded) {
                showMessage("Connectez-vous et chargez les programmes avant d'exporter.", 4000);
                return;
            }
            if (!confirm("Exporter les programmes actuels vers Google Drive ? Les fichiers existants seront écrasés.")) {
                return;
            }

            console.log("Exportation des programmes vers Google Drive...");
            showMessage("Exportation en cours...", 5000);
            driveStatusElement.textContent = 'Export Progs...';
            driveStatusElement.classList.add('loading');
            exportProgramsBtn.disabled = true; // Désactiver pendant l'export

            let successCount = 0;
            for (const type of PROGRAM_TYPES) {
                const fileId = programFileIds[type];
                const filename = PROGRAM_FILENAMES[type];
                if (!fileId) {
                    console.error(`ID de fichier manquant pour ${type}, impossible d'exporter.`);
                    showMessage(`Erreur: ID fichier manquant pour ${type}.`, 4000);
                    continue; // Passer au suivant
                }

                try {
                    const csvContent = convertProgramToCsv(loadedWorkouts[type]);
                    const success = await updateFileContent(fileId, csvContent);
                    if (success) {
                        console.log(`Programme ${type} exporté avec succès vers ${filename}.`);
                        successCount++;
                    } else {
                        console.error(`Échec de l'exportation du programme ${type}.`);
                         // Message d'erreur déjà affiché par updateFileContent
                    }
                } catch (error) {
                    console.error(`Erreur lors de l'export du programme ${type}:`, error);
                    showMessage(`Erreur export ${type}: ${error.message}`, 5000);
                }
            }

            driveStatusElement.classList.remove('loading');
            exportProgramsBtn.disabled = false; // Réactiver le bouton

            if (successCount === PROGRAM_TYPES.length) {
                showMessage("Tous les programmes ont été exportés avec succès !", 3000);
                driveStatusElement.textContent = 'Export OK';
                 setTimeout(() => { if(googleAccessToken) driveStatusElement.textContent = 'Connecté'; }, 1500);
            } else {
                showMessage(`Exportation terminée avec ${PROGRAM_TYPES.length - successCount} erreur(s).`, 5000);
                 driveStatusElement.textContent = 'Erreur Export';
            }
        }


        // --- Rendu du Graphique --- (Identique)
        function renderHistoryChart(filteredHistory, period) { /* Identique */ if (!historyChartCanvas) return; const ctx = historyChartCanvas.getContext('2d'); const { labels, data } = aggregateChartData(filteredHistory, period); if (historyChart) { historyChart.destroy(); } const bodyStyles = getComputedStyle(document.documentElement); const primaryColor = bodyStyles.getPropertyValue('--primary-color').trim(); const accentColor = bodyStyles.getPropertyValue('--accent-color').trim(); const gridColor = bodyStyles.getPropertyValue('--chart-grid-color').trim(); const textColor = bodyStyles.getPropertyValue('--text-color').trim(); const tooltipBg = bodyStyles.getPropertyValue('--chart-tooltip-bg').trim(); const tooltipText = bodyStyles.getPropertyValue('--chart-tooltip-text').trim(); historyChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Durée totale', data: data.map(d => formatTimeForChart(d)), backgroundColor: primaryColor + 'BF', borderColor: primaryColor, borderWidth: 1, hoverBackgroundColor: accentColor + 'DF', hoverBorderColor: accentColor, borderRadius: 4, }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'Durée (minutes)', color: textColor, font: { size: 13 } }, grid: { color: gridColor }, ticks: { color: textColor } }, x: { title: { display: true, text: getChartXAxisTitle(period), color: textColor, font: { size: 13 } }, grid: { color: gridColor }, ticks: { color: textColor } } }, plugins: { legend: { display: false }, tooltip: { backgroundColor: tooltipBg, titleColor: tooltipText, bodyColor: tooltipText, padding: 10, cornerRadius: 6, displayColors: false, callbacks: { label: function(context) { const originalDurationSeconds = data[context.dataIndex] || 0; const formattedTime = formatTime(originalDurationSeconds); return `Durée: ${formattedTime}`; } } } }, animation: { duration: 500, easing: 'easeOutCubic' } } }); }
        function aggregateChartData(history, period) { /* Identique */ /* ... aggregation logic ... */ }
        function getChartXAxisTitle(period) { /* Identique */ /* ... title logic ... */ }


         // --- Initialisation de l'Application ---
         document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Chargé. Initialisation ArmorWorkout.");
             const savedTheme = localStorage.getItem('theme') || 'light'; applyTheme(savedTheme);
             workoutHistory = [];
             // Initialise avec les programmes par défaut avant chargement Drive
             loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
             programsLoaded = false; // Marquer comme non chargé au début
             updateAuthUI(false); // Init UI déconnecté

             // Attacher les écouteurs (simplifié pour clarté)
             signInButton.addEventListener('click', handleAuthClick);
             signOutButton.addEventListener('click', handleSignoutClick);
             navButtons.forEach(button => { button.addEventListener('click', () => { initAudioContext(); loadWorkout(button.dataset.workout); }); });
             navHistoryBtn.addEventListener('click', () => { initAudioContext(); if (isWorkoutActive && !workoutFinished) { if (confirm("Arrêter entraînement en cours (progrès perdus) ?")) { resetCurrentWorkout(); setTimeout(() => showSection('history'), 50); } } else { showSection('history'); } });
             startPauseBtn.addEventListener('click', () => { initAudioContext(); /* ... logique start/pause ... */ saveInProgressState(); }); // Logique inchangée, utilise currentState
             skipBtn.addEventListener('click', () => { initAudioContext(); /* ... logique skip ... */ }); // Logique inchangée
             finishBtn.addEventListener('click', () => { initAudioContext(); /* ... logique finish ... */ }); // Logique inchangée
             resetBtn.addEventListener('click', () => { initAudioContext(); /* ... logique reset ... */ }); // Logique inchangée
             themeToggleBtn.addEventListener('click', () => { initAudioContext(); const isDark = document.body.classList.contains('dark-theme'); applyTheme(isDark ? 'light' : 'dark'); });
             historyFilterBtns.forEach(button => { button.addEventListener('click', () => { initAudioContext(); displayHistory(button.dataset.period); }); });
             // NOUVEAU: Listener pour le bouton d'export
             exportProgramsBtn.addEventListener('click', () => {
                 initAudioContext();
                 exportProgramsToDrive();
             });

             console.log("App initialisée. Attente GIS et connexion Google.");
        });

        // Dupliquer le code complet des fonctions si nécessaire
         function parseAndLoadHistoryCsvData(csvContent) { try { const lines = csvContent.trim().split(/\r?\n/); const newHistory = []; const existingIDs = new Set(); if (lines.length <= 1) { console.log("CSV historique vide ou en-tête seul."); workoutHistory = []; return; } const headerLine = lines[0].trim().toLowerCase(); const hasHeader = headerLine.includes("dateiso") && headerLine.includes("workouttype"); const startIndex = hasHeader ? 1 : 0; for (let i = startIndex; i < lines.length; i++) { const line = lines[i].trim(); if (!line) continue; const values = line.split(','); if (values.length < 3) { console.warn(`Ligne historique ignorée (valeurs manquantes): ${line}`); continue; } const dateStr = values[0].trim(); const typeStr = values[1].trim(); const durationStr = values[2].trim(); const idStr = (values.length > 3) ? values[3].trim() : null; const date = new Date(dateStr); const duration = parseInt(durationStr, 10); if (isNaN(date.getTime())) { console.warn(`Ligne historique ignorée (date invalide): ${line}`); continue; } /* Utilise loadedWorkouts pour valider ? Non, historique est indépendant des programmes actuels */ if (!PROGRAM_TYPES.includes(typeStr)) { console.warn(`Ligne historique ignorée (type inconnu): '${typeStr}' dans ${line}`); continue; } if (isNaN(duration) || duration < 0) { console.warn(`Ligne historique ignorée (durée invalide): ${line}`); continue; } const entryId = idStr || `${date.getTime()}-${i}`; if (existingIDs.has(entryId)) { console.warn(`Ligne historique ignorée (ID dupliqué): ${entryId} dans ${line}`); continue; } newHistory.push({ id: entryId, date: date.toISOString(), type: typeStr, duration: duration }); existingIDs.add(entryId); } newHistory.sort((a, b) => new Date(b.date) - new Date(a.date)); workoutHistory = newHistory; } catch (error) { console.error("Erreur parsing CSV historique:", error); showMessage(`Erreur parsing historique: ${error.message}`, 6000); workoutHistory = []; } }
        function displayStatsAndMotivation(filteredHistory, period, isConnected) { const stats = calculateStats(filteredHistory); let periodText = ''; switch (period) { case 'week': periodText = 'Cette Semaine'; break; case 'month': periodText = 'Ce Mois'; break; case 'year': periodText = 'Cette Année'; break; case 'all': periodText = 'Total'; break; } const statsTitleElement = statsDisplay.querySelector('h3'); if (statsTitleElement) statsTitleElement.textContent = `Statistiques (${periodText})`; let statsHTML = ""; if (!isConnected) { statsHTML = "<p>Connectez-vous pour voir les stats.</p>"; } else if (stats.count === 0) { statsHTML = "<p>Aucune donnée pour cette période.</p>"; } else { statsHTML = `<p><i class="fas fa-calendar-check"></i> Nb séances: <strong>${stats.count}</strong></p><p><i class="fas fa-stopwatch"></i> Durée totale: <strong>${formatTime(stats.totalDuration)}</strong></p><p><i class="fas fa-hourglass-half"></i> Durée moy./séance: <strong>${formatTime(stats.avgDuration)}</strong></p><p><i class="fas fa-star"></i> Type + fréquent: <strong>${stats.mostFrequentType || 'N/A'}</strong> (${stats.frequency[stats.mostFrequentType] || 0}x)</p>`; } const messageElement = statsDisplay.querySelector('.motivational-message'); statsDisplay.innerHTML = (statsTitleElement ? statsTitleElement.outerHTML : `<h3>Statistiques (${periodText})</h3>`) + statsHTML; let msgElem = statsDisplay.querySelector('.motivational-message'); if (!msgElem) { msgElem = document.createElement('p'); msgElem.className = 'motivational-message'; statsDisplay.appendChild(msgElem); } msgElem.textContent = isConnected ? generateMotivationalMessage(stats, period) : ""; }
        function calculateStats(history) { const count = history.length; let totalDuration = 0; const frequency = { Push: 0, Pull: 0, Legs: 0 }; history.forEach(entry => { totalDuration += entry.duration; if (frequency.hasOwnProperty(entry.type)) { frequency[entry.type]++; } }); const avgDuration = count > 0 ? totalDuration / count : 0; let mostFrequentType = null; let maxFrequency = 0; for (const type in frequency) { if (frequency[type] > maxFrequency) { maxFrequency = frequency[type]; mostFrequentType = type; } } return { count: count, totalDuration: totalDuration, avgDuration: avgDuration, frequency: frequency, mostFrequentType: mostFrequentType }; }
        function generateMotivationalMessage(stats, period) { const { count } = stats; if (count === 0 && period !== 'all') return "Planifie ton prochain entraînement ! 📅"; if (count === 0 && period === 'all') return "Commence ton aventure fitness ! 💪"; switch (period) { case 'week': if (count >= 5) return `Wow, ${count} séances cette semaine ! Machine ! 🔥`; if (count >= 3) return `Super semaine (${count} séances) ! Régularité ! 👍`; if (count >= 1) return `Bien joué cette semaine ! ✨`; break; case 'month': if (count >= 15) return `Incroyable, ${count} séances ce mois-ci ! 🚀`; if (count >= 10) return `${count} entraînements ce mois-ci, solide ! 🎉`; if (count >= 5) return `Belle progression ce mois-ci ! 😊`; if (count >= 1) return `Premier(s) pas ce mois-ci ! 🌱`; break; case 'year': case 'all': if (count >= 100) return `+${count} séances ! Légendaire ! 🏆`; if (count >= 50) return `${count} séances ! Athlète ! 🏋️‍♂️`; if (count >= 20) return `${count} séances, beau parcours ! 🌟`; if (count >= 1) return `Déjà ${count} entraînement(s) ! 🎯`; break; } return "Continue tes efforts ! 💯"; }
         function aggregateChartData(history, period) { const aggregated = new Map(); const initializeMap = (labels) => labels.forEach(label => aggregated.set(label, 0)); switch (period) { case 'week': const daysOfWeek = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim']; initializeMap(daysOfWeek); history.forEach(entry => { const entryDate = new Date(entry.date); let dayIndex = entryDate.getDay(); dayIndex = dayIndex === 0 ? 6 : dayIndex - 1; const dayName = daysOfWeek[dayIndex]; aggregated.set(dayName, (aggregated.get(dayName) || 0) + entry.duration); }); return { labels: daysOfWeek, data: daysOfWeek.map(day => aggregated.get(day)) }; case 'month': const weeksOfMonth = ['Sem 1', 'Sem 2', 'Sem 3', 'Sem 4', 'Sem 5+']; initializeMap(weeksOfMonth); history.forEach(entry => { const entryDate = new Date(entry.date); const dayOfMonth = entryDate.getDate(); const weekIndex = Math.min(Math.floor((dayOfMonth - 1) / 7), 4); const weekName = weeksOfMonth[weekIndex]; aggregated.set(weekName, (aggregated.get(weekName) || 0) + entry.duration); }); return { labels: weeksOfMonth, data: weeksOfMonth.map(week => aggregated.get(week)) }; case 'year': const monthsOfYear = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc']; initializeMap(monthsOfYear); history.forEach(entry => { const entryDate = new Date(entry.date); const monthIndex = entryDate.getMonth(); const monthName = monthsOfYear[monthIndex]; aggregated.set(monthName, (aggregated.get(monthName) || 0) + entry.duration); }); return { labels: monthsOfYear, data: monthsOfYear.map(month => aggregated.get(month)) }; case 'all': default: history.forEach(entry => { const entryDate = new Date(entry.date); const year = entryDate.getFullYear(); aggregated.set(year, (aggregated.get(year) || 0) + entry.duration); }); const sortedYears = Array.from(aggregated.keys()).sort((a, b) => a - b); const sortedData = sortedYears.map(year => aggregated.get(year)); return { labels: sortedYears.map(String), data: sortedData }; } }
         function getChartXAxisTitle(period) { switch (period) { case 'week': return 'Jour de la Semaine'; case 'month': return 'Semaine du Mois'; case 'year': return 'Mois'; case 'all': return 'Année'; default: return ''; } }


    </script>

    <!-- Chargement Google Identity Services -->
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoadedCallback()"></script>

</body>
</html>
