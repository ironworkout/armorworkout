<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workout Timer GDrive - ArmorWorkout</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Google Identity Services (GIS) - chargé à la fin -->

    <style>
        /* --- Variables Globales & Thèmes --- */
        :root {
            --primary-color-light: #4a90e2; --secondary-color-light: #f5f5f5; --text-color-light: #333; --bg-color-light: #ffffff; --accent-color-light: #50e3c2; --border-color-light: #e0e0e0; --danger-color-light: #e74c3c; --warning-color-light: #f39c12; --success-color-light: #2ecc71; --info-color-light: #3498db; --chart-grid-color-light: rgba(0, 0, 0, 0.08); --chart-tooltip-bg-light: rgba(0, 0, 0, 0.75); --chart-tooltip-text-light: #ffffff; --primary-glow-light: 0 0 15px rgba(74, 144, 226, 0.3); --export-btn-color-light: #8e44ad;

            --primary-color-dark: #58a6ff; --secondary-color-dark: #1c1c1e; --text-color-dark: #e1e1e1; --bg-color-dark: #0d1117; --accent-color-dark: #30d3b0; --border-color-dark: #3a3a3c; --danger-color-dark: #f85149; --warning-color-dark: #e3b341; --success-color-dark: #3fb950; --info-color-dark: #58a6ff; --chart-grid-color-dark: rgba(255, 255, 255, 0.1); --chart-tooltip-bg-dark: rgba(255, 255, 255, 0.85); --chart-tooltip-text-dark: #111; --primary-glow-dark: 0 0 15px rgba(88, 166, 255, 0.4); --export-btn-color-dark: #9b59b6;

            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --border-radius: 10px; --transition-speed: 0.3s; --box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);

            /* Initialisation thème clair */
            --primary-color: var(--primary-color-light); --secondary-color: var(--secondary-color-light); --text-color: var(--text-color-light); --bg-color: var(--bg-color-light); --accent-color: var(--accent-color-light); --border-color: var(--border-color-light); --danger-color: var(--danger-color-light); --warning-color: var(--warning-color-light); --success-color: var(--success-color-light); --info-color: var(--info-color-light); --chart-grid-color: var(--chart-grid-color-light); --chart-tooltip-bg: var(--chart-tooltip-bg-light); --chart-tooltip-text: var(--chart-tooltip-text-light); --primary-glow: var(--primary-glow-light); --export-btn-color: var(--export-btn-color-light);
        }
        body.dark-theme {
            --primary-color: var(--primary-color-dark); --secondary-color: var(--secondary-color-dark); --text-color: var(--text-color-dark); --bg-color: var(--bg-color-dark); --accent-color: var(--accent-color-dark); --border-color: var(--border-color-dark); --danger-color: var(--danger-color-dark); --warning-color: var(--warning-color-dark); --success-color: var(--success-color-dark); --info-color: var(--info-color-dark); --chart-grid-color: var(--chart-grid-color-dark); --chart-tooltip-bg: var(--chart-tooltip-bg-dark); --chart-tooltip-text: var(--chart-tooltip-text-dark); --primary-glow: var(--primary-glow-dark); --export-btn-color: var(--export-btn-color-dark);
            --box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        /* --- Styles de Base & Réinitialisation --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); line-height: 1.7; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; display: flex; flex-direction: column; min-height: 100vh; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }
        .container { max-width: 950px; margin: 0 auto; padding: 25px 20px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }

        /* --- En-tête & Navigation --- */
        header { background-color: rgba(var(--bg-color-rgb, 255, 255, 255), 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); padding: 15px 20px; border-bottom: 1px solid var(--border-color); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; position: sticky; top: 0; z-index: 1000; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .header-content { display: flex; justify-content: space-between; align-items: center; max-width: 950px; margin: 0 auto; flex-wrap: wrap; gap: 10px 15px; /* Ajusté gap */ }
        header h1 { font-size: 1.9em; color: var(--primary-color); margin: 0; font-weight: 700; white-space: nowrap; display: flex; align-items: center; gap: 10px; }
        header h1 .fa-dumbbell { animation: pulse 2s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }

        nav ul { list-style: none; display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
        /* Style général bouton */
        .general-button { background-color: var(--primary-color); color: white; border: none; padding: 10px 18px; border-radius: var(--border-radius); cursor: pointer; font-size: 0.95em; font-weight: 500; transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 8px; white-space: nowrap; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .general-button:disabled { background-color: #bbb; color: #eee; cursor: not-allowed; opacity: 0.6; box-shadow: none; transform: none; }
        body.dark-theme .general-button:disabled { background-color: #555; color: #999; }
        .general-button:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .general-button:not(:disabled):active { transform: scale(0.97); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }

        /* Application aux boutons spécifiques */
        nav button, .history-controls button, .action-btn { /* Héritent de general-button */ }
        nav button:not(:disabled):hover, .history-controls button:hover, .action-btn:not(:disabled):hover { background-color: var(--accent-color); }
        nav button.active { background-color: var(--accent-color); color: var(--bg-color); font-weight: bold; box-shadow: var(--primary-glow); }
        #nav-history { background-color: var(--info-color); } #nav-history:not(:disabled):hover { background-color: color-mix(in srgb, var(--info-color) 85%, black); } #nav-history.active { background-color: var(--accent-color); }

        .theme-toggle button { /* Style spécifique car pas general-button */ background-color: transparent; color: var(--text-color); font-size: 1.4em; padding: 5px; box-shadow: none; border: none; cursor: pointer; border-radius: var(--border-radius); transition: all var(--transition-speed) ease; }
        .theme-toggle button:hover { background-color: rgba(var(--primary-color-rgb), 0.1); transform: scale(1.1); }

        /* --- Contrôles d'Authentification & Export --- */
        .header-actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; } /* Nouveau conteneur */
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button { background-color: var(--success-color); } /* Hérite general-button via CSS */
        .auth-controls button#signout-button { background-color: var(--danger-color); }
        .auth-controls button:not(:disabled):hover { background-color: color-mix(in srgb, var(--success-color) 85%, black); }
        .auth-controls button#signout-button:not(:disabled):hover { background-color: color-mix(in srgb, var(--danger-color) 85%, black); }

        #export-programs-btn { background-color: var(--export-btn-color); padding: 8px 14px; font-size: 0.9em;} /* Hérite general-button */
        #export-programs-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--export-btn-color) 85%, black); }

        #drive-status { font-size: 0.85em; opacity: 0.8; margin-left: 8px; transition: opacity 0.3s; min-width: 100px; text-align: right; font-style: italic; }
        #drive-status.loading { opacity: 1; font-weight: bold; color: var(--warning-color); }

        /* Logique d'affichage connexion/déconnexion */
        body.logged-out #signin-button { display: inline-flex; } body.logged-out #signout-button { display: none; } body.logged-out #drive-status { display: none; } body.logged-out #export-programs-btn { display: none; }
        body.logged-in #signin-button { display: none; } body.logged-in #signout-button { display: inline-flex; } body.logged-in #drive-status { display: inline-block; } body.logged-in #export-programs-btn { display: inline-flex; }

        /* --- Contenu Principal --- */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 40px; position: relative; }
        .workout-section, .history-section { background-color: var(--secondary-color); padding: 35px; border-radius: var(--border-radius); box-shadow: var(--box-shadow); width: 100%; max-width: 650px; text-align: center; transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); position: relative; overflow: visible; margin-bottom: 40px; border: 1px solid var(--border-color); }
        .section-hidden { transform: scale(0.9) translateY(30px); opacity: 0; pointer-events: none; max-height: 0; padding: 0; margin-bottom: 0; border: none; overflow: hidden; }

        /* --- Affichage du Timer --- */
        .timer-display { margin-bottom: 35px; position: relative; }
        .timer-circle { width: 220px; height: 220px; margin: 0 auto; position: relative; border-radius: 50%; background: conic-gradient(var(--accent-color) 0%, var(--border-color) 0%); display: flex; justify-content: center; align-items: center; transition: background var(--transition-speed) ease, box-shadow var(--transition-speed) ease; box-shadow: inset 0 0 15px rgba(0,0,0,0.1), var(--primary-glow); }
        .timer-circle::before { content: ''; position: absolute; width: 88%; height: 88%; background-color: var(--secondary-color); border-radius: 50%; transition: background-color var(--transition-speed) ease; }
        .time-left { font-size: 4em; font-weight: bold; color: var(--primary-color); z-index: 1; transition: color var(--transition-speed) ease; font-variant-numeric: tabular-nums; }
        .timer-state { position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 1em; color: var(--warning-color); font-weight: bold; text-transform: uppercase; opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease; background-color: var(--secondary-color); padding: 3px 10px; border-radius: 6px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .timer-state.visible { opacity: 1; transform: translateX(-50%) translateY(5px); }

        /* --- Info Entraînement --- */
        .workout-info { margin-bottom: 35px; min-height: 180px; position: relative; }
        .exercise-card { padding: 18px; border: 1px solid var(--border-color); border-radius: var(--border-radius); margin-bottom: 18px; background-color: var(--bg-color); transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s ease, background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; text-align: left; box-shadow: 0 3px 6px rgba(0,0,0,0.05); }
        .exercise-card h2, .exercise-card h3 { color: var(--primary-color); margin-bottom: 8px; font-size: 1.5em; font-weight: 600; }
        .exercise-card h3 { font-size: 1.2em; opacity: 0.85; }
        .exercise-card p { font-size: 1.05em; color: var(--text-color); margin-bottom: 6px; }
        .exercise-card p strong { color: var(--accent-color); font-weight: 600; }
        .exercise-enter { opacity: 0; transform: translateX(30px); }
        .exercise-exit { opacity: 0; transform: translateX(-30px); position: absolute; width: calc(100% - 40px); left: 20px; }
        .current-exercise .exercise-card { border-left: 6px solid var(--primary-color); }
        .next-exercise .exercise-card { border-left: 6px solid var(--accent-color); opacity: 0.75; }
        .next-exercise h3 { color: var(--accent-color); }
        .progress-tracker { font-size: 1em; color: var(--text-color); margin-bottom: 25px; opacity: 0.9; font-weight: 500; }

        /* --- Contrôles Timer --- */
        .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin-top: 25px; }
        .controls button { /* Hérite de general-button */ padding: 14px 18px; font-size: 1em; width: 100%; justify-content: center; }
        .controls button:disabled { background-color: #bbb; color: #eee; } /* Style disabled spécifique */
        body.dark-theme .controls button:disabled { background-color: #555; color: #999; }
        .controls button:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .controls button:not(:disabled):active { transform: scale(0.97); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .controls .pause-btn { background-color: var(--warning-color); } .controls .pause-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--warning-color) 90%, black); }
        .controls .skip-btn { background-color: var(--accent-color); color: var(--bg-color); } .controls .skip-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--accent-color) 90%, black); }
        .controls .finish-btn { background-color: var(--info-color); } .controls .finish-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--info-color) 90%, black); }
        .controls .reset-btn { background-color: var(--danger-color); } .controls .reset-btn:not(:disabled):hover { background-color: color-mix(in srgb, var(--danger-color) 90%, black); }
        @media (min-width: 560px) { .controls { grid-template-columns: repeat(4, 1fr); } .controls .reset-btn { grid-column: span 1; } }
        @media (max-width: 559px) and (min-width: 400px) { .controls { grid-template-columns: repeat(2, 1fr); } .controls .reset-btn { grid-column: span 2; } }
        @media (max-width: 399px) { .controls { grid-template-columns: 1fr; } .controls .reset-btn { grid-column: auto; } }

        /* --- Section Historique --- */
         .history-section { max-width: 850px; text-align: left; }
         .history-section h2 { text-align: center; color: var(--primary-color); margin-bottom: 30px; font-size: 1.8em; display: flex; align-items: center; justify-content: center; gap: 10px; }
        .history-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 20px; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 1px solid var(--border-color); }
        .history-filters { display: flex; gap: 10px; flex-wrap: wrap; }
        .history-filters button { /* Hérite general-button */ background-color: var(--info-color); opacity: 0.8; font-size: 0.9em; padding: 8px 14px; }
        .history-filters button:not(:disabled):hover { background-color: color-mix(in srgb, var(--info-color) 85%, black); }
        .history-filters button.active { opacity: 1; font-weight: bold; background-color: var(--primary-color); box-shadow: var(--primary-glow); }
        .history-actions { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; font-size: 0.9em; opacity: 0.8; color: var(--text-color); align-items: center; }
        .history-actions i { color: var(--success-color); margin-right: 5px;}

        /* --- Conteneur Graphique --- */
        .chart-container { position: relative; margin: 30px auto; padding: 20px; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius); max-width: 100%; height: 380px; transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; box-shadow: inset 0 0 10px rgba(0,0,0,0.05); }
        .chart-container canvas { max-width: 100%; height: 100% !important; }

        /* --- Affichage Statistiques --- */
        .stats-display { background-color: var(--bg-color); padding: 20px; border-radius: var(--border-radius); margin-bottom: 30px; border: 1px solid var(--border-color); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; box-shadow: 0 3px 6px rgba(0,0,0,0.05); }
        .stats-display h3 { color: var(--primary-color); margin-bottom: 15px; text-align: center; font-size: 1.4em; }
        .stats-display p { margin-bottom: 10px; font-size: 1em; }
        .stats-display p strong { color: var(--accent-color); font-weight: 600; }
        .motivational-message { font-style: italic; color: var(--success-color); margin-top: 18px; text-align: center; font-weight: 500; font-size: 1.1em; background: linear-gradient(45deg, var(--success-color), var(--accent-color)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-fill-color: transparent; }

        /* --- Liste Historique --- */
        .history-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: var(--border-radius); background-color: var(--bg-color); box-shadow: inset 0 1px 4px rgba(0,0,0,0.04); }
        .history-list li { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; padding: 14px 18px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s ease; gap: 5px 10px; }
        .history-list li:last-child { border-bottom: none; }
        .history-list li:nth-child(even) { background-color: var(--secondary-color); }
        .history-list li:hover { background-color: rgba(var(--primary-color-rgb, 74, 144, 226), 0.1); transform: translateX(5px); }
        .history-item-date { font-weight: 500; flex-basis: 200px; flex-grow: 1; font-size: 0.95em; }
        .history-item-type { flex-basis: 80px; text-align: center; font-weight: bold; color: var(--primary-color); background-color: rgba(var(--primary-color-rgb), 0.1); padding: 3px 6px; border-radius: 4px; font-size: 0.9em; }
        .history-item-duration { flex-basis: 90px; text-align: right; color: var(--accent-color); font-weight: bold; font-size: 1.05em; }
        .history-list .no-history { text-align: center; padding: 20px; font-style: italic; opacity: 0.7; }

        /* Helper pour RGBA */
        body { --primary-color-rgb: 74, 144, 226; --bg-color-rgb: 255, 255, 255; --text-color-rgb: 51, 51, 51; }
        body.dark-theme { --primary-color-rgb: 88, 166, 255; --bg-color-rgb: 13, 17, 23; --text-color-rgb: 225, 225, 225; }

        /* --- Zone de Messages Flottante --- */
        .message-area { position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%); background-color: rgba(var(--text-color-rgb), 0.9); color: var(--bg-color); padding: 14px 28px; border-radius: var(--border-radius); z-index: 1001; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease; pointer-events: none; font-size: 1em; box-shadow: 0 4px 15px rgba(0,0,0,0.2); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
        body.dark-theme .message-area { background-color: rgba(var(--text-color-rgb), 0.9); color: var(--bg-color); }
        .message-area.visible { opacity: 1; transform: translate(-50%, -10px); pointer-events: auto; }

        /* --- Pied de Page --- */
        footer { text-align: center; padding: 20px; margin-top: 40px; font-size: 0.9em; color: var(--text-color); opacity: 0.7; border-top: 1px solid var(--border-color); transition: color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        footer .fab.fa-google-drive { color: #1aa260; margin-left: 5px; }
        footer a { color: var(--primary-color); text-decoration: none; transition: color 0.2s; }
        footer a:hover { text-decoration: underline; }

        /* --- Styles Responsives --- */
        @media (max-width: 992px) { /* Ajustement breakpoint pour header */
             .header-content { flex-direction: column; align-items: center; }
             nav { order: 3; margin-top: 10px; width: 100%; } /* Assure pleine largeur */
             nav ul { justify-content: center; } /* Centre les boutons nav */
             .header-actions { order: 2; margin-top: 10px; width: 100%; justify-content: center;} /* Centre Auth/Export */
             header h1 { order: 1; margin-bottom: 5px; }
        }
        @media (max-width: 768px) {
            .container { padding: 20px 15px; }
            header h1 { font-size: 1.6em; }
            .timer-circle { width: 180px; height: 180px; } .time-left { font-size: 3.2em; }
            .history-controls { flex-direction: column; align-items: stretch; gap: 15px;}
            .history-filters { justify-content: center; }
            .history-actions { justify-content: center; }
            .history-list li { flex-direction: column; align-items: flex-start; gap: 8px; }
            .history-item-date, .history-item-type, .history-item-duration { flex-basis: auto; text-align: left; width: 100%; }
            .history-item-type { text-align: left; display: inline-block; width: auto; }
            .history-item-duration { text-align: left; }
            .chart-container { height: 320px; }
        }
        @media (max-width: 480px) {
            html { font-size: 15px; }
            .container { padding: 15px 10px; }
            header h1 { font-size: 1.4em; }
            .general-button, nav button, .history-controls button, .action-btn, .auth-controls button, #export-programs-btn { padding: 9px 14px; font-size: 0.9em; gap: 6px; }
            .workout-section, .history-section { padding: 25px; }
            .timer-circle { width: 160px; height: 160px; } .time-left { font-size: 2.8em; }
            .controls button { padding: 12px 15px; font-size: 0.95em; }
            .history-filters button { padding: 7px 10px; font-size: 0.85em; }
            .chart-container { height: 280px; }
            .message-area { width: calc(100% - 40px); bottom: 15px; font-size: 0.95em; padding: 12px 20px; }
        }

    </style>
</head>
<body class="logged-out">

    <header>
        <div class="header-content">
            <h1><i class="fas fa-dumbbell"></i> ArmorWorkout</h1>
            <nav>
                <ul>
                    <li><button id="nav-push" data-workout="Push" class="general-button" disabled>Push</button></li>
                    <li><button id="nav-pull" data-workout="Pull" class="general-button" disabled>Pull</button></li>
                    <li><button id="nav-legs" data-workout="Legs" class="general-button" disabled>Legs</button></li>
                    <li><button id="nav-history" class="general-button"><i class="fas fa-history"></i> Historique</button></li>
                </ul>
            </nav>
            <div class="header-actions">
                 <div class="auth-controls">
                     <button id="signin-button" class="general-button"><i class="fab fa-google"></i> Connecter Drive</button>
                     <button id="signout-button" class="general-button"><i class="fas fa-sign-out-alt"></i> Déconnecter</button>
                      <span id="drive-status"></span>
                 </div>
                 <button id="export-programs-btn" class="general-button"><i class="fas fa-upload"></i> Exporter Progs</button>
            </div>
            <div class="theme-toggle">
                <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-moon"></i></button>
            </div>
        </div>
    </header>

    <div class="container">
        <main>
            <div class="workout-section" id="workout-section">
                <div class="timer-display"> <div class="timer-circle" id="timer-circle"><span class="time-left" id="time-left">00:00</span></div> <div class="timer-state" id="timer-state"></div> </div>
                <div class="workout-info" id="workout-info"> <div class="current-exercise" id="current-exercise-container"> <p>Connexion à Google Drive...</p> </div> <div class="next-exercise" id="next-exercise-container"></div> </div>
                <div class="progress-tracker" id="progress-tracker"></div>
                <div class="controls">
                    <button id="start-pause-btn" class="general-button" disabled><i class="fas fa-play"></i> Démarrer</button>
                    <button id="skip-btn" class="skip-btn general-button" disabled><i class="fas fa-forward-step"></i> Suivant</button>
                    <button id="finish-btn" class="finish-btn general-button" disabled><i class="fas fa-flag-checkered"></i> Terminer</button>
                    <button id="reset-btn" class="reset-btn general-button" disabled><i class="fas fa-redo"></i> Réinitialiser</button>
                </div>
            </div>

            <div class="history-section section-hidden" id="history-section">
                 <h2><i class="fas fa-chart-line"></i> Historique & Statistiques</h2>
                 <div class="history-controls">
                     <div class="history-filters">
                         <button data-period="week" class="general-button active"><i class="fas fa-calendar-week"></i> Semaine</button>
                         <button data-period="month" class="general-button"><i class="fas fa-calendar-alt"></i> Mois</button>
                         <button data-period="year" class="general-button"><i class="fas fa-calendar-check"></i> Année</button>
                         <button data-period="all" class="general-button"><i class="fas fa-infinity"></i> Tout</button>
                     </div>
                     <div class="history-actions"> <i class="fab fa-google-drive"></i> <span>Données synchronisées avec Google Drive</span> </div>
                 </div>
                 <div class="chart-container"> <canvas id="history-chart-canvas"></canvas> </div>
                 <div class="stats-display" id="stats-display"> <h3>Statistiques</h3> <p>Connectez-vous pour afficher les statistiques.</p> <p class="motivational-message" id="motivational-message"></p> </div>
                 <ul class="history-list" id="history-list"> <li class="no-history">Connectez-vous pour afficher l'historique.</li> </ul>
            </div>
        </main>
    </div>

    <footer>
        <p>© 2024 ArmorWorkout par IronWorkout. Intégré avec <i class="fab fa-google-drive"></i> Google Drive.</p>
        <p><a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i> Voir sur GitHub</a></p>
    </footer>

    <div id="message-area" class="message-area"></div>

    <script>
        // --- CONFIGURATION ---
        const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
        const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const HISTORY_FILENAME = "armorworkout_history.csv";
        const PROGRAM_FILENAMES = { Push: "armorworkout_push_program.csv", Pull: "armorworkout_pull_program.csv", Legs: "armorworkout_legs_program.csv" };
        const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];

        // --- DONNÉES D'ENTRAÎNEMENT PAR DÉFAUT ---
        const defaultWorkouts = {
            Push: [ { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 }, { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 }, { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 14 }, { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 }, { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 }, { type: 'break', duration: 60 }, { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 }, { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 }, ],
            Pull: [ { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 }, { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 }, { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 13 }, { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 15 }, { type: 'break', duration: 75 }, { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 }, { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 }, { type: 'break', duration: 60 }, { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 }, { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 }, ],
            Legs: [ { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 }, { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 }, { type: 'break', duration: 90 }, { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 }, { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 }, { type: 'break', duration: 90 }, { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 14 }, { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 11 }, { type: 'break', duration: 90 }, { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 }, { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 }, { type: 'break', duration: 60 }, { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 }, { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 }, ]
        };

        // --- Éléments DOM ---
        const timeLeftDisplay = document.getElementById('time-left'); const timerCircle = document.getElementById('timer-circle'); const timerStateDisplay = document.getElementById('timer-state'); const currentExerciseContainer = document.getElementById('current-exercise-container'); const nextExerciseContainer = document.getElementById('next-exercise-container'); const progressTracker = document.getElementById('progress-tracker'); const startPauseBtn = document.getElementById('start-pause-btn'); const skipBtn = document.getElementById('skip-btn'); const finishBtn = document.getElementById('finish-btn'); const resetBtn = document.getElementById('reset-btn'); const navButtons = document.querySelectorAll('nav button[data-workout]'); const navHistoryBtn = document.getElementById('nav-history'); const themeToggleBtn = document.getElementById('theme-toggle-btn'); const messageArea = document.getElementById('message-area'); const workoutSection = document.getElementById('workout-section'); const historySection = document.getElementById('history-section'); const historyList = document.getElementById('history-list'); const statsDisplay = document.getElementById('stats-display'); const motivationalMessage = document.getElementById('motivational-message'); const historyFilterBtns = document.querySelectorAll('.history-filters button'); const historyChartCanvas = document.getElementById('history-chart-canvas'); const signInButton = document.getElementById('signin-button'); const signOutButton = document.getElementById('signout-button'); const driveStatusElement = document.getElementById('drive-status'); const exportProgramsBtn = document.getElementById('export-programs-btn');

        // --- Variables d'État ---
        let currentWorkoutType = null; let currentWorkoutPlan = []; let currentItemIndex = 0; let timerInterval = null; let totalTime = 0; let timeLeft = 0; let isTimerRunning = false; let isWorkoutActive = false; let workoutFinished = false; let currentState = 'idle'; let workoutStartTime = null; let workoutHistory = []; let currentHistoryPeriod = 'week'; let historyChart = null;
        let googleAccessToken = null; let tokenClient = null; let historyFileId = null; let programFileIds = { Push: null, Pull: null, Legs: null }; let programsLoaded = false;
        let loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));

        // --- Audio & Vibration ---
        let endSound = null; let audioContext = null; function initAudioContext(){ if (!audioContext && (window.AudioContext || window.webkitAudioContext)) { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); console.log("AudioContext ok."); const buffer = audioContext.createBuffer(1, 1, 22050); const source = audioContext.createBufferSource(); source.buffer = buffer; source.connect(audioContext.destination); source.start(0); source.stop(audioContext.currentTime + 0.001); } catch (e) { console.warn("AudioContext échec:", e); audioContext = null; } } if (audioContext) { endSound = () => { if (!audioContext || audioContext.state === 'suspended') { audioContext?.resume().then(() => playActualSound()).catch(e => console.error("Erreur reprise Audio", e)); } else { playActualSound(); } }; } else { endSound = () => console.log("Beep!"); } } function playActualSound(){ if (!audioContext) return; const o = audioContext.createOscillator(); const g = audioContext.createGain(); o.connect(g); g.connect(audioContext.destination); o.type = 'triangle'; o.frequency.setValueAtTime(523.25, audioContext.currentTime); g.gain.setValueAtTime(0.3, audioContext.currentTime); g.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5); o.start(); o.stop(audioContext.currentTime + 0.5); } const vibrate = (pattern = [100, 50, 100]) => { if ('vibrate' in navigator) { try { navigator.vibrate(pattern); } catch (e) { console.warn("Vibration échec:", e); } } };

        // --- Google Identity Services (GIS) & Drive API ---

        // !!! IMPORTANT : Définir gisLoadedCallback dans la portée globale !!!
        function gisLoadedCallback() {
            console.log("GIS Library Loaded Callback Executed");
            if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID === "VOTRE ID CLIENT ICI") {
                 console.error("ERREUR: GOOGLE_CLIENT_ID non configuré !");
                 showMessage("Erreur config ID Client Google.", 10000);
                 driveStatusElement.textContent = 'Erreur Config';
                 return;
            }
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID,
                    scope: GOOGLE_DRIVE_SCOPES,
                    callback: tokenCallback,
                    error_callback: handleTokenError,
                    prompt: ''
                });
                console.log("Token Client Initialized");
                 // Tenter une connexion silencieuse si l'utilisateur est déjà connecté à Google
                 // Ceci peut éviter le clic initial sur "Connecter Drive"
                 // tokenClient.requestAccessToken({ prompt: 'none' }); // Désactivé pour l'instant, peut causer des popups non désirés si mal configuré
            } catch (error) {
                console.error("Erreur init Token Client:", error);
                showMessage("Erreur init Google.", 5000);
                updateAuthUI(false);
                driveStatusElement.textContent = 'Erreur Init';
            }
        } // Fin de gisLoadedCallback

        function handleTokenError(error) {
             console.error("Token Client Error:", error);
             if (error.type === 'popup_closed' || error.type === 'user_cancel') {
                 showMessage("Connexion Google annulée.", 3000);
                 driveStatusElement.textContent = 'Annulé';
             } else if (error.type === 'popup_failed_to_open') {
                 showMessage("Popup Google bloqué. Veuillez autoriser les popups.", 5000);
                 driveStatusElement.textContent = 'Popup bloqué';
             } else if (error.type === 'session_timed_out') {
                  showMessage("Session Google expirée. Veuillez vous reconnecter.", 4000);
                  driveStatusElement.textContent = 'Expiré';
             } else if (error.type === 'unregistered_origin' || error.type === 'invalid_client' || error.type === 'redirect_uri_mismatch') {
                  showMessage("Erreur configuration application Google (origine/client).", 6000);
                  driveStatusElement.textContent = 'Erreur Config App';
                  console.error("Détails erreur config:", error);
             } else {
                 showMessage(`Erreur Auth Google: ${error.type || error.error || 'Inconnue'}`, 5000);
                 driveStatusElement.textContent = 'Erreur Auth';
                  console.error("Détails erreur Auth:", error);
             }
              driveStatusElement.classList.remove('loading'); // Assurer que loading est enlevé
             updateAuthUI(false); // Assure que l'UI est en mode déconnecté
         }

        async function tokenCallback(tokenResponse) {
            console.log("Token Callback received:", tokenResponse);
             driveStatusElement.classList.remove('loading'); // Retirer "Connexion..." si c'était un clic

            if (tokenResponse && tokenResponse.access_token) {
                console.log("Access Token Received successfully.");
                googleAccessToken = tokenResponse.access_token;
                updateAuthUI(true);
                showMessage("Connecté. Chargement données...", 3000);
                driveStatusElement.textContent = 'Chargement...';
                driveStatusElement.classList.add('loading');

                try {
                    await Promise.all([
                        loadHistoryFromDrive(),
                        loadProgramsFromDrive()
                    ]);

                    if (programsLoaded) {
                        console.log("Données Drive chargées.");
                        showMessage("Historique et programmes chargés.", 2500);
                        driveStatusElement.textContent = 'Connecté';
                        driveStatusElement.classList.remove('loading');
                        loadInProgressState(); // Essayer de reprendre après chargement
                    } else {
                        showMessage("Erreur chargement programmes. Utilisation défauts.", 5000);
                        driveStatusElement.textContent = 'Erreur Progs';
                        driveStatusElement.classList.remove('loading');
                         // L'UI est déjà mise à jour par updateAuthUI(true) et loadProgramsFromDrive
                    }
                    // Mettre à jour l'état des boutons nav une dernière fois
                     navButtons.forEach(btn => btn.disabled = !programsLoaded);
                     exportProgramsBtn.disabled = !programsLoaded;
                     checkEnableStartButton();

                } catch (error) {
                    console.error("Erreur chargement parallèle données:", error);
                    showMessage("Erreur chargement données Drive.", 5000);
                    loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Fallback défauts
                    programsLoaded = false;
                    updateAuthUI(true); // Assurer UI cohérente (connecté mais sans progs)
                    driveStatusElement.textContent = 'Erreur Données';
                    driveStatusElement.classList.remove('loading');
                }

            } else {
                console.error("Token Response Error ou access_token manquant:", tokenResponse);
                 // Vérifier si c'est une erreur connue (ex: accès refusé)
                 if (tokenResponse && tokenResponse.error) {
                      handleTokenError(tokenResponse); // Utiliser le handler générique
                 } else {
                      showMessage("Erreur: Jeton Google invalide reçu.", 5000);
                      updateAuthUI(false);
                      driveStatusElement.textContent = 'Erreur Jeton';
                 }
            }
        }

        function handleAuthClick() {
            if (!tokenClient) { showMessage("Biblio Google non prête...", 3000); console.warn("Tentative de connexion avant initialisation tokenClient."); return; }
            initAudioContext();
            console.log("Demande manuelle d'Access Token...");
            driveStatusElement.textContent = 'Connexion...';
            driveStatusElement.classList.add('loading');
            // Force l'affichage du popup de consentement
            tokenClient.requestAccessToken({ prompt: 'consent' });
        }

        function handleSignoutClick() {
            if (googleAccessToken) {
                 driveStatusElement.textContent = 'Déconnexion...'; driveStatusElement.classList.add('loading');
                 google.accounts.oauth2.revoke(googleAccessToken, () => {
                     console.log('Token revoked'); googleAccessToken = null; historyFileId = null; programFileIds = { Push: null, Pull: null, Legs: null }; programsLoaded = false; workoutHistory = []; loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
                     updateAuthUI(false); // Réinitialise l'UI et l'état interne
                     showMessage("Déconnecté de Google Drive.", 2500);
                 });
            } else { updateAuthUI(false); } // Force l'état déconnecté
        }

        function updateAuthUI(isLoggedIn) {
            console.log(`Update UI - LoggedIn: ${isLoggedIn}, ProgramsLoaded: ${programsLoaded}`);
            const wasLoggedIn = document.body.classList.contains('logged-in');
            document.body.classList.toggle('logged-in', isLoggedIn);
            document.body.classList.toggle('logged-out', !isLoggedIn);

             // Mettre à jour le statut seulement si l'état de connexion change ou si on est connecté
            if (isLoggedIn) {
                 driveStatusElement.textContent = programsLoaded ? 'Connecté' : 'Chargement...';
                 // Ne pas enlever 'loading' ici, car loadPrograms peut encore tourner
            } else {
                 driveStatusElement.textContent = ''; // Vide si déconnecté
                 driveStatusElement.classList.remove('loading');
            }


            // Gérer l'état activé/désactivé des boutons
            themeToggleBtn.disabled = false; // Toujours actif
            navHistoryBtn.disabled = false; // Toujours actif (pour voir message)

            if (!isLoggedIn) {
                // --- État Déconnecté ---
                if (wasLoggedIn) { // Si on vient de se déconnecter
                    googleAccessToken = null; historyFileId = null; programFileIds = { Push: null, Pull: null, Legs: null }; programsLoaded = false; workoutHistory = []; loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
                    if (isWorkoutActive || currentState !== 'idle') { resetCurrentWorkout(); }
                    else { updateWorkoutInfo(); } // Met à jour le message "Connectez-vous..."
                    displayHistory(currentHistoryPeriod); // Affiche le message connexion
                }
                // Désactiver les boutons qui nécessitent connexion/programmes
                startPauseBtn.disabled = true; skipBtn.disabled = true; finishBtn.disabled = true; resetBtn.disabled = true;
                navButtons.forEach(btn => btn.disabled = true);
                exportProgramsBtn.disabled = true;

            } else {
                // --- État Connecté ---
                // Activer les boutons de navigation et export SEULEMENT si les programmes sont chargés
                navButtons.forEach(btn => btn.disabled = !programsLoaded);
                exportProgramsBtn.disabled = !programsLoaded;

                // Mise à jour des boutons de contrôle du timer
                checkEnableStartButton();
                 if (currentState === 'idle' || currentState === 'finished') {
                     skipBtn.disabled = true; finishBtn.disabled = true;
                     resetBtn.disabled = !currentWorkoutType || !programsLoaded;
                 } else { // exercise, break, paused
                     skipBtn.disabled = !programsLoaded; finishBtn.disabled = !programsLoaded; resetBtn.disabled = !programsLoaded;
                 }
                updateWorkoutInfo(); // Màj message ("Sélectionnez..." ou "Chargement...")
            }
        }

        function checkEnableStartButton() {
            if (currentState === 'idle') {
                startPauseBtn.disabled = !googleAccessToken || !programsLoaded || !currentWorkoutType;
                startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer';
            }
            // Les autres états gèrent leur bouton dans setState
        }

        // --- Fonctions Drive Génériques ---
        async function findOrCreateFile(filename, defaultCsvContent) { if (!googleAccessToken) { console.warn("findOrCreateFile: Non connecté"); return null; } console.log(`Recherche/Création: ${filename}`); try { const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+mimeType='text/csv'+and+trashed=false&spaces=drive&fields=files(id,name)`; const searchRes = await fetch(searchUrl, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!searchRes.ok) { if (searchRes.status === 401 || searchRes.status === 403) { handleSignoutClick(); showMessage("Session Google expirée.", 5000); return null; } throw new Error(`Erreur recherche ${filename} (${searchRes.status})`); } const searchData = await searchRes.json(); if (searchData.files && searchData.files.length > 0) { console.log(`Fichier ${filename} trouvé: ${searchData.files[0].id}`); return searchData.files[0].id; } else { console.log(`Fichier ${filename} non trouvé. Création...`); const createUrl = `https://www.googleapis.com/drive/v3/files`; const metadata = { name: filename, mimeType: 'text/csv' }; const createRes = await fetch(createUrl, { method: 'POST', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' }, body: JSON.stringify(metadata) }); if (!createRes.ok) throw new Error(`Erreur création ${filename} (${createRes.status})`); const createData = await createRes.json(); const newFileId = createData.id; console.log(`Fichier ${filename} créé: ${newFileId}. Écriture contenu défaut...`); const writeSuccess = await updateFileContent(newFileId, defaultCsvContent); if (writeSuccess) { console.log(`Contenu défaut écrit pour ${filename}.`); return newFileId; } else { console.error(`Échec écriture contenu défaut pour ${filename}.`); return null; } } } catch (error) { console.error(`Erreur find/create ${filename}:`, error); showMessage(`Erreur Drive (${filename}): ${error.message}`, 6000); return null; } }
        async function readFileContent(fileId) { if (!googleAccessToken || !fileId) return null; console.log(`Lecture fichier Drive: ${fileId}`); const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`; try { const response = await fetch(url, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!response.ok) { if (response.status === 404) { console.warn(`Fichier ${fileId} non trouvé (404).`); return ""; } if (response.status === 401 || response.status === 403) { handleSignoutClick(); showMessage("Session expirée.", 5000); return null; } throw new Error(`Erreur lecture ${fileId} (${response.status})`); } const content = await response.text(); console.log(`Lecture ${fileId} réussie.`); return content; } catch (error) { console.error(`Erreur lecture ${fileId}:`, error); showMessage(`Erreur Drive Lecture: ${error.message}`, 6000); return null; } }
        async function updateFileContent(fileId, content) { if (!googleAccessToken || !fileId) return false; console.log(`Mise à jour fichier Drive: ${fileId}`); const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`; try { const response = await fetch(url, { method: 'PATCH', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'text/csv' }, body: content }); if (!response.ok) { if (response.status === 401 || response.status === 403) { handleSignoutClick(); showMessage("Session expirée. Sauvegarde échouée.", 6000); return false; } throw new Error(`Erreur écriture ${fileId} (${response.status})`); } console.log(`Écriture ${fileId} réussie.`); return true; } catch (error) { console.error(`Erreur écriture ${fileId}:`, error); showMessage(`Erreur Drive Écriture: ${error.message}`, 6000); return false; } }

        // --- Fonctions Cœur du Timer ---
        function formatTime(seconds) { const absSeconds = Math.abs(Math.round(seconds)); const m = Math.floor(absSeconds / 60); const s = absSeconds % 60; return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; }
        function formatTimeForChart(seconds) { return parseFloat((seconds / 60).toFixed(1)); }
        function updateTimerDisplay() { timeLeftDisplay.textContent = formatTime(timeLeft); let progressPercent = 0; if ((currentState === 'break' || currentState === 'paused') && totalTime > 0) { progressPercent = Math.max(0, Math.min(100, ((totalTime - timeLeft) / totalTime) * 100)); } else if (currentState === 'finished') { progressPercent = 100; } timerCircle.style.background = `conic-gradient(var(--accent-color) ${progressPercent}%, var(--border-color) 0%)`; }
        function updateWorkoutInfo(animate = false) { const currentItem = currentWorkoutPlan[currentItemIndex]; const nextItem = (currentItemIndex + 1 < currentWorkoutPlan.length) ? currentWorkoutPlan[currentItemIndex + 1] : null; const createCardHTML = (item, isCurrent) => { if (!item) return ''; const title = isCurrent ? 'En cours' : 'Suivant'; const tagName = isCurrent ? 'h2' : 'h3'; const icon = item.type === 'exercise' ? '<i class="fas fa-weight-hanging"></i>' : '<i class="fas fa-coffee"></i>'; let cardContent = `<${tagName}>${icon} ${title}: ${item.name || 'Repos'}</${tagName}>`; if (item.details) cardContent += `<p>${item.details}</p>`; if (item.reps) cardContent += `<p><strong>${item.reps} reps</strong></p>`; if (item.duration) cardContent += `<p><strong><i class="fas fa-clock"></i> Durée: ${formatTime(item.duration)}</strong></p>`; return `<div class="exercise-card">${cardContent}</div>`; }; const currentCardHTML = createCardHTML(currentItem, true); const nextCardHTML = createCardHTML(nextItem, false); const updateDOMContent = () => { let finalCurrentHTML = '', finalNextHTML = '', finalProgressText = ''; if (currentState === 'idle') { finalCurrentHTML = googleAccessToken ? (programsLoaded ? `Sélectionnez un entraînement.` : `Chargement des programmes...`) : `Connectez-vous à Google Drive...`; } else if (currentState === 'finished') { const durationFinished = workoutStartTime ? formatTime((Date.now() - workoutStartTime) / 1000) : 'N/A'; finalCurrentHTML = `<div class="exercise-card"><h2><i class="fas fa-check-circle" style="color: var(--success-color)"></i> Terminé !</h2><p>Temps: <strong>${durationFinished}</strong></p></div>`; finalProgressText = `Terminé (${currentWorkoutPlan.length}/${currentWorkoutPlan.length})`; } else if (currentItem) { finalCurrentHTML = currentCardHTML; finalNextHTML = nextCardHTML; finalProgressText = `Étape ${currentItemIndex + 1} / ${currentWorkoutPlan.length}`; } else { finalCurrentHTML = `<p>Chargement...</p>`; } currentExerciseContainer.innerHTML = finalCurrentHTML; nextExerciseContainer.innerHTML = finalNextHTML; progressTracker.textContent = finalProgressText; void currentExerciseContainer.offsetWidth; void nextExerciseContainer.offsetWidth; }; if (animate && currentState !== 'idle' && currentState !== 'finished') { const oldCurrentCard = currentExerciseContainer.querySelector('.exercise-card'); const oldNextCard = nextExerciseContainer.querySelector('.exercise-card'); if (oldCurrentCard) oldCurrentCard.classList.add('exercise-exit'); if (oldNextCard) oldNextCard.classList.add('exercise-exit'); const animationDuration = 400; setTimeout(() => { updateDOMContent(); const newCurrentCard = currentExerciseContainer.querySelector('.exercise-card'); const newNextCard = nextExerciseContainer.querySelector('.exercise-card'); if (newCurrentCard) newCurrentCard.classList.add('exercise-enter'); if (newNextCard) newNextCard.classList.add('exercise-enter'); requestAnimationFrame(() => { requestAnimationFrame(() => { if (newCurrentCard) newCurrentCard.classList.remove('exercise-enter'); if (newNextCard) newNextCard.classList.remove('exercise-enter'); }); }); }, animationDuration / 2); } else { updateDOMContent(); } }
        function setState(newState) { const previousState = currentState; currentState = newState; console.log(`Transition State: ${previousState} -> ${newState}`); timerStateDisplay.classList.remove('visible'); clearInterval(timerInterval); timerInterval = null; if (['idle'].includes(previousState) && ['exercise', 'break', 'paused'].includes(newState)) { if (workoutStartTime === null) { workoutStartTime = Date.now(); console.log("Début entraînement:", new Date(workoutStartTime)); } } startPauseBtn.disabled = true; skipBtn.disabled = true; finishBtn.disabled = true; resetBtn.disabled = true; startPauseBtn.classList.remove('pause-btn'); switch (newState) { case 'idle': startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer'; startPauseBtn.disabled = !googleAccessToken || !programsLoaded || !currentWorkoutType; resetBtn.disabled = !googleAccessToken || !programsLoaded || !currentWorkoutType; isTimerRunning = false; isWorkoutActive = false; workoutFinished = false; timeLeft = 0; totalTime = 0; updateTimerDisplay(); break; case 'exercise': startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Fait'; startPauseBtn.disabled = !programsLoaded; skipBtn.disabled = !programsLoaded; finishBtn.disabled = !programsLoaded; resetBtn.disabled = !programsLoaded; isTimerRunning = false; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'EXERCICE'; timerStateDisplay.classList.add('visible'); timeLeft = 0; totalTime = 0; updateTimerDisplay(); break; case 'break': startPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause'; startPauseBtn.disabled = !programsLoaded; startPauseBtn.classList.add('pause-btn'); skipBtn.disabled = !programsLoaded; finishBtn.disabled = !programsLoaded; resetBtn.disabled = !programsLoaded; isTimerRunning = true; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'REPOS'; timerStateDisplay.classList.add('visible'); startBreakTimer(); break; case 'paused': startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Reprendre'; startPauseBtn.disabled = !programsLoaded; skipBtn.disabled = !programsLoaded; finishBtn.disabled = !programsLoaded; resetBtn.disabled = !programsLoaded; isTimerRunning = false; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'EN PAUSE'; timerStateDisplay.classList.add('visible'); updateTimerDisplay(); break; case 'finished': startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Terminé'; startPauseBtn.disabled = true; skipBtn.disabled = true; finishBtn.disabled = true; resetBtn.disabled = !googleAccessToken || !programsLoaded; isTimerRunning = false; isWorkoutActive = false; workoutFinished = true; timerStateDisplay.textContent = 'FINI !'; timerStateDisplay.classList.add('visible'); timeLeft = 0; totalTime = 0; updateTimerDisplay(); showMessage('Entraînement terminé ! Bravo ! 💪', 4000); vibrate([200, 100, 200]); if (endSound) endSound(); saveWorkoutToHistory(); clearInProgressState(); currentWorkoutType = null; setActiveWorkoutNav(null); break; } if (newState === 'idle') checkEnableStartButton(); const shouldAnimateInfo = previousState !== 'idle' && previousState !== 'finished'; updateWorkoutInfo(shouldAnimateInfo); }
        function startBreakTimer() { if (timerInterval) clearInterval(timerInterval); updateTimerDisplay(); timerInterval = setInterval(() => { if (timeLeft > 0) { timeLeft--; updateTimerDisplay(); } else { handleItemCompletion(true); } }, 1000); }
        function handleItemCompletion(naturalCompletion = false) { if (currentState === 'finished') return; if (naturalCompletion && currentState === 'break') { if (endSound) endSound(); vibrate(); } currentItemIndex++; saveInProgressState(); if (currentItemIndex >= currentWorkoutPlan.length) { setState('finished'); } else { const nextItem = currentWorkoutPlan[currentItemIndex]; if (nextItem.type === 'exercise') { setState('exercise'); } else { totalTime = nextItem.duration; timeLeft = nextItem.duration; setState('break'); } } }
        function forceFinishWorkout() { if (!isWorkoutActive || workoutFinished) return; if (confirm("Terminer cet entraînement maintenant ? La progression sera sauvegardée.")) { clearInterval(timerInterval); timerInterval = null; setState('finished'); showMessage("Entraînement terminé manuellement.", 3000); } }
        function loadWorkout(type) { if (!googleAccessToken || !programsLoaded) { showMessage("Connectez-vous et attendez le chargement des programmes.", 4000); return; } if (isWorkoutActive && !workoutFinished && currentWorkoutType !== type) { if (!confirm(`Arrêter "${currentWorkoutType}" (progrès perdus) et charger "${type}" ?`)) { return; } else { resetCurrentWorkout(); } } else if (currentWorkoutType === type && isWorkoutActive && !workoutFinished) { showMessage(`"${type}" est déjà en cours.`, 2000); showSection('workout'); return; } if (!loadedWorkouts[type]) { console.error(`Programme chargé pour '${type}' introuvable.`); showMessage(`Erreur: Programme ${type} non chargé.`, 4000); return; } console.log(`Chargement workout: ${type}`); currentWorkoutType = type; currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[type])); if (!currentWorkoutPlan || currentWorkoutPlan.length === 0) { console.error(`Le programme chargé pour ${type} est vide ou invalide.`); showMessage(`Erreur: Programme ${type} chargé est vide.`, 4000); currentWorkoutType = null; return; } currentItemIndex = 0; workoutStartTime = null; workoutFinished = false; isWorkoutActive = false; setActiveWorkoutNav(type); showSection('workout'); clearInterval(timerInterval); timerInterval = null; isTimerRunning = false; const firstItem = currentWorkoutPlan[0]; if (firstItem.type === 'exercise') { setState('idle'); timeLeft = 0; totalTime = 0; } else { totalTime = firstItem.duration; timeLeft = firstItem.duration; setState('paused'); startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer Pause'; timerStateDisplay.textContent = 'PRÊT ?'; timerStateDisplay.classList.add('visible'); updateTimerDisplay(); } updateWorkoutInfo(false); showMessage(`Programme "${type}" chargé. Prêt !`, 3000); saveInProgressState(); checkEnableStartButton(); }
        function resetCurrentWorkout() { console.log("Réinitialisation entraînement."); clearInterval(timerInterval); timerInterval = null; const typeReset = currentWorkoutType; currentWorkoutType = null; currentWorkoutPlan = []; currentItemIndex = 0; workoutStartTime = null; isTimerRunning = false; isWorkoutActive = false; workoutFinished = false; timeLeft = 0; totalTime = 0; clearInProgressState(); setState('idle'); setActiveWorkoutNav(null); updateWorkoutInfo(false); if (typeReset) { showMessage(`Entraînement "${typeReset}" réinitialisé.`, 2500); } checkEnableStartButton(); }
        let messageTimeoutId = null; function showMessage(msg, duration = 3500) { messageArea.textContent = msg; messageArea.classList.add('visible'); if (messageTimeoutId) clearTimeout(messageTimeoutId); messageTimeoutId = setTimeout(() => { messageArea.classList.remove('visible'); messageTimeoutId = null; }, duration); }

        // --- Gestion du Thème ---
        function applyTheme(theme) { const body = document.body; const isDark = theme === 'dark'; body.classList.toggle('dark-theme', isDark); themeToggleBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>'; localStorage.setItem('theme', theme); const primaryColor = getComputedStyle(body).getPropertyValue(isDark ? '--primary-color-dark' : '--primary-color-light').trim(); const bgColor = getComputedStyle(body).getPropertyValue(isDark ? '--bg-color-dark' : '--bg-color-light').trim(); const textColor = getComputedStyle(body).getPropertyValue(isDark ? '--text-color-dark' : '--text-color-light').trim(); body.style.setProperty('--primary-color-rgb', colorToRgb(primaryColor) || (isDark ? '88, 166, 255' : '74, 144, 226')); body.style.setProperty('--bg-color-rgb', colorToRgb(bgColor) || (isDark ? '13, 17, 23' : '255, 255, 255')); body.style.setProperty('--text-color-rgb', colorToRgb(textColor) || (isDark ? '225, 225, 225' : '51, 51, 51')); if (historyChart && !historySection.classList.contains('section-hidden')) { updateChartTheme(); } }
        function colorToRgb(color) { if (!color) return null; if (color.startsWith('#')) { const bigint = parseInt(color.slice(1), 16); const r = (bigint >> 16) & 255; const g = (bigint >> 8) & 255; const b = bigint & 255; return `${r}, ${g}, ${b}`; } else if (color.startsWith('rgb')) { return color.match(/\d+/g).slice(0, 3).join(', '); } return null; }
        function updateChartTheme() { if (!historyChart) return; const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-color').trim(); const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim(); const tooltipBg = getComputedStyle(document.documentElement).getPropertyValue('--chart-tooltip-bg').trim(); const tooltipText = getComputedStyle(document.documentElement).getPropertyValue('--chart-tooltip-text').trim(); const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim(); const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim(); historyChart.options.scales.x.grid.color = gridColor; historyChart.options.scales.y.grid.color = gridColor; historyChart.options.scales.x.ticks.color = textColor; historyChart.options.scales.y.ticks.color = textColor; historyChart.options.scales.x.title.color = textColor; historyChart.options.scales.y.title.color = textColor; historyChart.options.plugins.tooltip.backgroundColor = tooltipBg; historyChart.options.plugins.tooltip.titleColor = tooltipText; historyChart.options.plugins.tooltip.bodyColor = tooltipText; historyChart.options.plugins.legend.labels.color = textColor; historyChart.data.datasets[0].backgroundColor = primaryColor + 'BF'; historyChart.data.datasets[0].borderColor = primaryColor; historyChart.data.datasets[0].hoverBackgroundColor = accentColor + 'DF'; historyChart.data.datasets[0].hoverBorderColor = accentColor; historyChart.update(); }

        // --- Gestion Affichage Sections ---
        function showSection(sectionName) { if (sectionName === 'history') { workoutSection.classList.add('section-hidden'); historySection.classList.remove('section-hidden'); navHistoryBtn.classList.add('active'); navButtons.forEach(btn => btn.classList.remove('active')); displayHistory(currentHistoryPeriod); } else { workoutSection.classList.remove('section-hidden'); historySection.classList.add('section-hidden'); navHistoryBtn.classList.remove('active'); setActiveWorkoutNav(currentWorkoutType); } }
        function setActiveWorkoutNav(workoutType) { navButtons.forEach(btn => { btn.classList.toggle('active', btn.dataset.workout === workoutType); }); }

        // --- Persistance Locale (État EN COURS) ---
        const IN_PROGRESS_KEY = 'armorWorkoutStateInProgress';
        function saveInProgressState() { if (!isWorkoutActive || workoutFinished || currentState === 'idle') { clearInProgressState(); return; } const stateToSave = { type: currentWorkoutType, index: currentItemIndex, timeLeft: timeLeft, totalTime: totalTime, currentState: currentState, startTime: workoutStartTime }; try { localStorage.setItem(IN_PROGRESS_KEY, JSON.stringify(stateToSave)); console.log("État local sauvegardé:", stateToSave); } catch (e) { console.error("Sauvegarde locale échouée:", e); showMessage("Erreur: Sauvegarde locale échouée.", 5000); } }
        function loadInProgressState() { const savedStateJSON = localStorage.getItem(IN_PROGRESS_KEY); if (!savedStateJSON) return false; try { const savedState = JSON.parse(savedStateJSON); if (!savedState.type || !loadedWorkouts[savedState.type] || typeof savedState.index !== 'number' || typeof savedState.currentState !== 'string') { console.warn("État local invalide/prog non chargé. Suppression."); clearInProgressState(); return false; } if (googleAccessToken && programsLoaded && confirm(`Reprendre "${savedState.type}" (${savedState.currentState}) ?`)) { console.log("Reprise état local."); currentWorkoutType = savedState.type; currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[currentWorkoutType])); currentItemIndex = savedState.index; timeLeft = savedState.timeLeft; totalTime = savedState.totalTime; workoutStartTime = savedState.startTime; isWorkoutActive = true; workoutFinished = false; setActiveWorkoutNav(currentWorkoutType); showSection('workout'); const stateToRestore = savedState.currentState; currentState = stateToRestore; console.log(`Reprise état: ${currentState}`); if (stateToRestore === 'exercise') { setState('exercise'); } else if (stateToRestore === 'break') { currentState = 'paused'; setState('paused'); } else if (stateToRestore === 'paused') { setState('paused'); } else { console.warn("Reprise état inattendu:", stateToRestore); resetCurrentWorkout(); return false; } updateWorkoutInfo(false); updateTimerDisplay(); showMessage(`Progression "${currentWorkoutType}" restaurée.`, 3500); return true; } else if (googleAccessToken && programsLoaded) { console.log("Reprise locale refusée."); clearInProgressState(); return false; } else { console.log("Non connecté ou programmes non chargés, reprise locale impossible."); return false; } } catch (e) { console.error("Erreur chargement état local:", e); clearInProgressState(); return false; } }
        function clearInProgressState() { localStorage.removeItem(IN_PROGRESS_KEY); console.log("État local 'en cours' supprimé."); }

        // --- Gestion de l'Historique ---
        function saveWorkoutToHistory() { if (!currentWorkoutType || workoutStartTime === null) return; if (!googleAccessToken) { showMessage("Connectez-vous pour sauvegarder.", 4000); return; } const endTime = Date.now(); const durationSeconds = Math.round((endTime - workoutStartTime) / 1000); if (durationSeconds < 10) return; const newEntry = { id: endTime.toString(), date: new Date(endTime).toISOString(), type: currentWorkoutType, duration: durationSeconds }; console.log("Ajout historique local:", newEntry); workoutHistory.unshift(newEntry); if (!historySection.classList.contains('section-hidden')) displayHistory(currentHistoryPeriod); saveHistoryToDrive(); }
        async function saveHistoryToDrive() { if (!googleAccessToken) return; if (!historyFileId) { historyFileId = await findOrCreateFile(HISTORY_FILENAME, "DateISO,WorkoutType,DurationSeconds,EntryID\n"); } if (!historyFileId) { showMessage("Impossible d'accéder fichier historique Drive.", 5000); return; } let csvContent = "DateISO,WorkoutType,DurationSeconds,EntryID\n"; workoutHistory.forEach(entry => { const cleanType = entry.type.replace(/,/g, ''); csvContent += `${entry.date},${cleanType},${entry.duration},${entry.id}\n`; }); const success = await updateFileContent(historyFileId, csvContent); if(success) console.log("Historique Sync Drive OK."); }
        async function loadHistoryFromDrive() { if (!googleAccessToken) { workoutHistory = []; displayHistory(currentHistoryPeriod); return; } if (!historyFileId) { historyFileId = await findOrCreateFile(HISTORY_FILENAME, "DateISO,WorkoutType,DurationSeconds,EntryID\n"); } if (!historyFileId) { showMessage("Impossible d'accéder fichier historique Drive.", 5000); workoutHistory = []; displayHistory(currentHistoryPeriod); return; } const csvContent = await readFileContent(historyFileId); if (csvContent === null) { workoutHistory = []; } else if (csvContent === "") { workoutHistory = []; } else { parseAndLoadHistoryCsvData(csvContent); console.log(`Historique chargé: ${workoutHistory.length} entrées.`); } displayHistory(currentHistoryPeriod); }
        function parseAndLoadHistoryCsvData(csvContent) { try { const lines = csvContent.trim().split(/\r?\n/); const newHistory = []; const existingIDs = new Set(); if (lines.length <= 1) { console.log("CSV historique vide."); workoutHistory = []; return; } const headerLine = lines[0].trim().toLowerCase(); const hasHeader = headerLine.includes("dateiso") && headerLine.includes("workouttype"); const startIndex = hasHeader ? 1 : 0; for (let i = startIndex; i < lines.length; i++) { const line = lines[i].trim(); if (!line) continue; const values = line.split(','); if (values.length < 3) continue; const dateStr = values[0].trim(); const typeStr = values[1].trim(); const durationStr = values[2].trim(); const idStr = (values.length > 3) ? values[3].trim() : null; const date = new Date(dateStr); const duration = parseInt(durationStr, 10); if (isNaN(date.getTime())) continue; if (!PROGRAM_TYPES.includes(typeStr)) continue; if (isNaN(duration) || duration < 0) continue; const entryId = idStr || `${date.getTime()}-${i}`; if (existingIDs.has(entryId)) continue; newHistory.push({ id: entryId, date: date.toISOString(), type: typeStr, duration: duration }); existingIDs.add(entryId); } newHistory.sort((a, b) => new Date(b.date) - new Date(a.date)); workoutHistory = newHistory; } catch (error) { console.error("Erreur parsing CSV historique:", error); showMessage(`Erreur parsing historique: ${error.message}`, 6000); workoutHistory = []; } }
        function displayHistory(period = 'week') { currentHistoryPeriod = period; historyFilterBtns.forEach(btn => { btn.classList.toggle('active', btn.dataset.period === period); }); const isConnected = googleAccessToken; const historyToDisplay = isConnected ? workoutHistory : []; const filteredHistory = filterHistoryByPeriod(historyToDisplay, period); historyList.innerHTML = ''; if (!isConnected) { historyList.innerHTML = `<li class="no-history">Connectez-vous pour voir l'historique.</li>`; } else if (filteredHistory.length === 0) { historyList.innerHTML = `<li class="no-history">Aucun entraînement pour cette période.</li>`; } else { filteredHistory.forEach(entry => { const li = document.createElement('li'); const entryDate = new Date(entry.date); const dateFormatted = entryDate.toLocaleDateString('fr-FR', { year: 'numeric', month: 'short', day: 'numeric' }); const timeFormatted = entryDate.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }); const durationFormatted = formatTime(entry.duration); li.innerHTML = `<span class="history-item-date">${dateFormatted} <small>(${timeFormatted})</small></span><span class="history-item-type">${entry.type}</span><span class="history-item-duration">${durationFormatted}</span>`; historyList.appendChild(li); }); } displayStatsAndMotivation(filteredHistory, period, isConnected); renderHistoryChart(filteredHistory, period); }
        function filterHistoryByPeriod(history, period) { const now = new Date(); const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()); return history.filter(entry => { const entryDate = new Date(entry.date); const entryDateStart = new Date(entryDate.getFullYear(), entryDate.getMonth(), entryDate.getDate()); switch (period) { case 'week': const dayOfWeek = todayStart.getDay(); const diffToMonday = todayStart.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); const startOfWeek = new Date(todayStart.getFullYear(), todayStart.getMonth(), diffToMonday); return entryDateStart >= startOfWeek; case 'month': const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1); return entryDateStart >= startOfMonth; case 'year': const startOfYear = new Date(now.getFullYear(), 0, 1); return entryDateStart >= startOfYear; case 'all': default: return true; } }); }
        function displayStatsAndMotivation(filteredHistory, period, isConnected) { const stats = calculateStats(filteredHistory); let periodText = ''; switch (period) { case 'week': periodText = 'Cette Semaine'; break; case 'month': periodText = 'Ce Mois'; break; case 'year': periodText = 'Cette Année'; break; case 'all': periodText = 'Total'; break; } const statsTitleElement = statsDisplay.querySelector('h3'); if (statsTitleElement) statsTitleElement.textContent = `Statistiques (${periodText})`; let statsHTML = ""; if (!isConnected) { statsHTML = "<p>Connectez-vous pour voir les stats.</p>"; } else if (stats.count === 0) { statsHTML = "<p>Aucune donnée pour cette période.</p>"; } else { statsHTML = `<p><i class="fas fa-calendar-check"></i> Nb séances: <strong>${stats.count}</strong></p><p><i class="fas fa-stopwatch"></i> Durée totale: <strong>${formatTime(stats.totalDuration)}</strong></p><p><i class="fas fa-hourglass-half"></i> Durée moy./séance: <strong>${formatTime(stats.avgDuration)}</strong></p><p><i class="fas fa-star"></i> Type + fréquent: <strong>${stats.mostFrequentType || 'N/A'}</strong> (${stats.frequency[stats.mostFrequentType] || 0}x)</p>`; } const messageElement = statsDisplay.querySelector('.motivational-message'); statsDisplay.innerHTML = (statsTitleElement ? statsTitleElement.outerHTML : `<h3>Statistiques (${periodText})</h3>`) + statsHTML; let msgElem = statsDisplay.querySelector('.motivational-message'); if (!msgElem) { msgElem = document.createElement('p'); msgElem.className = 'motivational-message'; statsDisplay.appendChild(msgElem); } msgElem.textContent = isConnected ? generateMotivationalMessage(stats, period) : ""; }
        function calculateStats(history) { const count = history.length; let totalDuration = 0; const frequency = { Push: 0, Pull: 0, Legs: 0 }; history.forEach(entry => { totalDuration += entry.duration; if (frequency.hasOwnProperty(entry.type)) { frequency[entry.type]++; } }); const avgDuration = count > 0 ? totalDuration / count : 0; let mostFrequentType = null; let maxFrequency = 0; for (const type in frequency) { if (frequency[type] > maxFrequency) { maxFrequency = frequency[type]; mostFrequentType = type; } } return { count: count, totalDuration: totalDuration, avgDuration: avgDuration, frequency: frequency, mostFrequentType: mostFrequentType }; }
        function generateMotivationalMessage(stats, period) { const { count } = stats; if (count === 0 && period !== 'all') return "Planifie ton prochain entraînement ! 📅"; if (count === 0 && period === 'all') return "Commence ton aventure fitness ! 💪"; switch (period) { case 'week': if (count >= 5) return `Wow, ${count} séances cette semaine ! 🔥`; if (count >= 3) return `Super semaine (${count} séances) ! 👍`; if (count >= 1) return `Bien joué cette semaine ! ✨`; break; case 'month': if (count >= 15) return `Incroyable, ${count} séances ce mois-ci ! 🚀`; if (count >= 10) return `${count} entraînements ce mois-ci, solide ! 🎉`; if (count >= 5) return `Belle progression ce mois-ci ! 😊`; if (count >= 1) return `Premier(s) pas ce mois-ci ! 🌱`; break; case 'year': case 'all': if (count >= 100) return `+${count} séances ! Légendaire ! 🏆`; if (count >= 50) return `${count} séances ! Athlète ! 🏋️‍♂️`; if (count >= 20) return `${count} séances, beau parcours ! 🌟`; if (count >= 1) return `Déjà ${count} entraînement(s) ! 🎯`; break; } return "Continue tes efforts ! 💯"; }

        // --- Gestion des Programmes ---
        function convertProgramToCsv(programArray) { const header = "Type,Name,Details,Reps,Duration\n"; let csv = header; programArray.forEach(item => { const escapeCsvField = (field) => { if (field === null || field === undefined) return ''; const stringField = String(field); if (stringField.includes(',') || stringField.includes('"') || stringField.includes('\n')) { return `"${stringField.replace(/"/g, '""')}"`; } return stringField; }; if (item.type === 'exercise') { const reps = Number.isFinite(item.reps) ? item.reps : ''; csv += `${item.type},${escapeCsvField(item.name)},${escapeCsvField(item.details)},${reps},\n`; } else if (item.type === 'break') { const duration = Number.isFinite(item.duration) ? item.duration : ''; csv += `${item.type},,,,${duration}\n`; } }); return csv; }
        function parseProgramCsvData(csvContent) { const lines = csvContent.trim().split(/\r?\n/); const program = []; if (lines.length <= 1) return program; const headerLine = lines[0].trim().toLowerCase(); const hasHeader = headerLine.includes("type") && headerLine.includes("name"); const startIndex = hasHeader ? 1 : 0; const parseCsvLine = (line) => { const values = []; let currentVal = ''; let inQuotes = false; for (let i = 0; i < line.length; i++) { const char = line[i]; if (char === '"') { if (inQuotes && line[i+1] === '"') { currentVal += '"'; i++; } else { inQuotes = !inQuotes; } } else if (char === ',' && !inQuotes) { values.push(currentVal.trim()); currentVal = ''; } else { currentVal += char; } } values.push(currentVal.trim()); return values; }; for (let i = startIndex; i < lines.length; i++) { const line = lines[i].trim(); if (!line) continue; const values = parseCsvLine(line); if (values.length < 1) continue; const type = values[0]?.toLowerCase(); const name = values[1] || ''; const details = values[2] || ''; const repsStr = values[3] || ''; const durationStr = values[4] || ''; if (type === 'exercise') { const reps = parseInt(repsStr, 10); if (!name) { console.warn(`Ligne programme ignorée (nom manquant): ${line}`); continue; } program.push({ type: 'exercise', name: name, details: details, reps: !isNaN(reps) ? reps : null }); } else if (type === 'break') { const duration = parseInt(durationStr, 10); if (isNaN(duration) || duration <= 0) { console.warn(`Ligne programme ignorée (durée invalide): ${line}`); continue; } program.push({ type: 'break', duration: duration }); } else { console.warn(`Ligne programme ignorée (type inconnu '${type}'): ${line}`); } } return program; }
        async function loadProgramsFromDrive() { if (!googleAccessToken) return; console.log("Chargement programmes Drive..."); programsLoaded = false; let allLoadedSuccessfully = true; driveStatusElement.textContent = 'Chargement Progs...'; driveStatusElement.classList.add('loading'); for (const type of PROGRAM_TYPES) { const filename = PROGRAM_FILENAMES[type]; const defaultCsv = convertProgramToCsv(defaultWorkouts[type]); const fileId = await findOrCreateFile(filename, defaultCsv); programFileIds[type] = fileId; if (fileId) { const csvContent = await readFileContent(fileId); if (csvContent !== null) { try { const parsedProgram = parseProgramCsvData(csvContent); if (parsedProgram.length > 0) { loadedWorkouts[type] = parsedProgram; console.log(`Programme ${type} chargé (${parsedProgram.length} étapes).`); } else { console.warn(`Prog ${type} Drive vide/invalide. Utilisation défaut.`); loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type])); } } catch (parseError) { console.error(`Erreur parsing prog ${type}:`, parseError); showMessage(`Erreur parsing ${type}. Utilisation défaut.`, 4000); loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type])); } } else { console.error(`Échec lecture ${type}. Utilisation défaut.`); loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type])); allLoadedSuccessfully = false; } } else { console.error(`Échec accès/création ${type}. Utilisation défaut.`); loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type])); allLoadedSuccessfully = false; } } programsLoaded = allLoadedSuccessfully; console.log("Fin chargement programmes. État loaded:", programsLoaded); driveStatusElement.classList.remove('loading'); // Retirer ici après la boucle
          // Le statut texte sera mis à jour dans tokenCallback
         }
        async function exportProgramsToDrive() { if (!googleAccessToken || !programsLoaded) { showMessage("Connectez-vous et chargez les programmes avant d'exporter.", 4000); return; } if (!confirm("Exporter les programmes actuels vers Google Drive ? Les fichiers existants seront écrasés.")) return; console.log("Exportation programmes Drive..."); showMessage("Exportation en cours...", 5000); driveStatusElement.textContent = 'Export Progs...'; driveStatusElement.classList.add('loading'); exportProgramsBtn.disabled = true; let successCount = 0; for (const type of PROGRAM_TYPES) { const fileId = programFileIds[type]; const filename = PROGRAM_FILENAMES[type]; if (!fileId) { console.error(`ID fichier manquant pour ${type}.`); showMessage(`Erreur: ID fichier ${type} manquant.`, 4000); continue; } try { const csvContent = convertProgramToCsv(loadedWorkouts[type]); const success = await updateFileContent(fileId, csvContent); if (success) { console.log(`Prog ${type} exporté vers ${filename}.`); successCount++; } else { console.error(`Échec export ${type}.`); } } catch (error) { console.error(`Erreur export ${type}:`, error); showMessage(`Erreur export ${type}: ${error.message}`, 5000); } } driveStatusElement.classList.remove('loading'); exportProgramsBtn.disabled = false; if (successCount === PROGRAM_TYPES.length) { showMessage("Programmes exportés avec succès !", 3000); driveStatusElement.textContent = 'Export OK'; setTimeout(() => { if(googleAccessToken) driveStatusElement.textContent = 'Connecté'; }, 1500); } else { showMessage(`Export terminé avec ${PROGRAM_TYPES.length - successCount} erreur(s).`, 5000); driveStatusElement.textContent = 'Erreur Export'; } }

        // --- Rendu du Graphique ---
        function renderHistoryChart(filteredHistory, period) { if (!historyChartCanvas) return; const ctx = historyChartCanvas.getContext('2d'); const { labels, data } = aggregateChartData(filteredHistory, period); if (historyChart) { historyChart.destroy(); } const bodyStyles = getComputedStyle(document.documentElement); const primaryColor = bodyStyles.getPropertyValue('--primary-color').trim(); const accentColor = bodyStyles.getPropertyValue('--accent-color').trim(); const gridColor = bodyStyles.getPropertyValue('--chart-grid-color').trim(); const textColor = bodyStyles.getPropertyValue('--text-color').trim(); const tooltipBg = bodyStyles.getPropertyValue('--chart-tooltip-bg').trim(); const tooltipText = bodyStyles.getPropertyValue('--chart-tooltip-text').trim(); historyChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Durée totale', data: data.map(d => formatTimeForChart(d)), backgroundColor: primaryColor + 'BF', borderColor: primaryColor, borderWidth: 1, hoverBackgroundColor: accentColor + 'DF', hoverBorderColor: accentColor, borderRadius: 4, }] }, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true, title: { display: true, text: 'Durée (minutes)', color: textColor, font: { size: 13 } }, grid: { color: gridColor }, ticks: { color: textColor } }, x: { title: { display: true, text: getChartXAxisTitle(period), color: textColor, font: { size: 13 } }, grid: { color: gridColor }, ticks: { color: textColor } } }, plugins: { legend: { display: false }, tooltip: { backgroundColor: tooltipBg, titleColor: tooltipText, bodyColor: tooltipText, padding: 10, cornerRadius: 6, displayColors: false, callbacks: { label: function(context) { const originalDurationSeconds = data[context.dataIndex] || 0; const formattedTime = formatTime(originalDurationSeconds); return `Durée: ${formattedTime}`; } } } }, animation: { duration: 500, easing: 'easeOutCubic' } } }); }
        function aggregateChartData(history, period) { const aggregated = new Map(); const initializeMap = (labels) => labels.forEach(label => aggregated.set(label, 0)); switch (period) { case 'week': const daysOfWeek = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim']; initializeMap(daysOfWeek); history.forEach(entry => { const entryDate = new Date(entry.date); let dayIndex = entryDate.getDay(); dayIndex = dayIndex === 0 ? 6 : dayIndex - 1; const dayName = daysOfWeek[dayIndex]; aggregated.set(dayName, (aggregated.get(dayName) || 0) + entry.duration); }); return { labels: daysOfWeek, data: daysOfWeek.map(day => aggregated.get(day)) }; case 'month': const weeksOfMonth = ['Sem 1', 'Sem 2', 'Sem 3', 'Sem 4', 'Sem 5+']; initializeMap(weeksOfMonth); history.forEach(entry => { const entryDate = new Date(entry.date); const dayOfMonth = entryDate.getDate(); const weekIndex = Math.min(Math.floor((dayOfMonth - 1) / 7), 4); const weekName = weeksOfMonth[weekIndex]; aggregated.set(weekName, (aggregated.get(weekName) || 0) + entry.duration); }); return { labels: weeksOfMonth, data: weeksOfMonth.map(week => aggregated.get(week)) }; case 'year': const monthsOfYear = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc']; initializeMap(monthsOfYear); history.forEach(entry => { const entryDate = new Date(entry.date); const monthIndex = entryDate.getMonth(); const monthName = monthsOfYear[monthIndex]; aggregated.set(monthName, (aggregated.get(monthName) || 0) + entry.duration); }); return { labels: monthsOfYear, data: monthsOfYear.map(month => aggregated.get(month)) }; case 'all': default: history.forEach(entry => { const entryDate = new Date(entry.date); const year = entryDate.getFullYear(); aggregated.set(year, (aggregated.get(year) || 0) + entry.duration); }); const sortedYears = Array.from(aggregated.keys()).sort((a, b) => a - b); const sortedData = sortedYears.map(year => aggregated.get(year)); return { labels: sortedYears.map(String), data: sortedData }; } }
        function getChartXAxisTitle(period) { switch (period) { case 'week': return 'Jour de la Semaine'; case 'month': return 'Semaine du Mois'; case 'year': return 'Mois'; case 'all': return 'Année'; default: return ''; } }

         // --- Initialisation de l'Application ---
         document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Chargé. Initialisation ArmorWorkout.");
             const savedTheme = localStorage.getItem('theme') || 'light'; applyTheme(savedTheme);
             workoutHistory = [];
             loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
             programsLoaded = false;
             updateAuthUI(false); // Init UI déconnecté, active Connect btn

             // Listeners
             signInButton.addEventListener('click', handleAuthClick);
             signOutButton.addEventListener('click', handleSignoutClick);
             navButtons.forEach(button => { button.addEventListener('click', () => { initAudioContext(); loadWorkout(button.dataset.workout); }); });
             navHistoryBtn.addEventListener('click', () => { initAudioContext(); if (isWorkoutActive && !workoutFinished) { if (confirm("Arrêter entraînement en cours (progrès perdus) ?")) { resetCurrentWorkout(); setTimeout(() => showSection('history'), 50); } } else { showSection('history'); } });
             startPauseBtn.addEventListener('click', () => { initAudioContext(); if (currentState === 'idle' && currentWorkoutPlan.length > 0) { const firstItem = currentWorkoutPlan[0]; if (firstItem.type === 'exercise') { setState('exercise'); } else { totalTime = firstItem.duration; timeLeft = firstItem.duration; setState('break'); } } else if (currentState === 'exercise') { handleItemCompletion(); } else if (currentState === 'break') { setState('paused'); } else if (currentState === 'paused') { setState('break'); } saveInProgressState(); });
             skipBtn.addEventListener('click', () => { initAudioContext(); if (isWorkoutActive && !workoutFinished) { showMessage("Passage étape suivante.", 2000); handleItemCompletion(false); } });
             finishBtn.addEventListener('click', () => { initAudioContext(); if (isWorkoutActive && !workoutFinished) { forceFinishWorkout(); } });
             resetBtn.addEventListener('click', () => { initAudioContext(); if (currentWorkoutType || isWorkoutActive) { if (confirm("Réinitialiser ? Progression en cours perdue.")) { resetCurrentWorkout(); } } else { resetCurrentWorkout(); } });
             themeToggleBtn.addEventListener('click', () => { initAudioContext(); const isDark = document.body.classList.contains('dark-theme'); applyTheme(isDark ? 'light' : 'dark'); });
             historyFilterBtns.forEach(button => { button.addEventListener('click', () => { initAudioContext(); displayHistory(button.dataset.period); }); });
             exportProgramsBtn.addEventListener('click', () => { initAudioContext(); exportProgramsToDrive(); });

             console.log("App initialisée. Attente GIS et connexion Google.");
             // Le script GIS externe se chargera et appellera gisLoadedCallback()
        }); // !!! FIN DU DOMCONTENTLOADED - Assurez-vous que c'est bien fermé !!!

    </script>

    <!-- Chargement Google Identity Services -->
    <!-- onload="gisLoadedCallback()" est crucial et doit pointer vers une fonction globale -->
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoadedCallback()"></script>

</body>
</html>
