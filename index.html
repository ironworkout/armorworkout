<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Timer d'Entraînement Avancé</title>
    <!-- Font Awesome (CDNJS for reliability) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- Google Identity Services (GIS) - chargé à la fin du body -->
    <style>
        /* --- Variables Globales & Thèmes --- */
        :root {
            /* Thème Sombre (Base) */
            --bg-color-dark: #0D1117; --secondary-bg-color-dark: #161B22; --primary-text-color-dark: #c9d1d9; --secondary-text-color-dark: #8b949e; --border-color-dark: #30363d; --accent-border-color-dark: #58a6ff33; --input-bg-dark: #0d1117;
            /* Couleurs Néon (Thème Sombre) */
            --neon-blue: #58a6ff; --neon-pink: #f778ba; --neon-red: #ff7b72; --neon-yellow: #facc15; --neon-green: #3fb950; --neon-purple: #bc8cff; --neon-orange: #f9a825; /* Ajout Orange */
            /* Glows (Thème Sombre) */
            --glow-blue: 0 0 12px rgba(88, 166, 255, 0.6); --glow-pink: 0 0 12px rgba(247, 120, 186, 0.6); --glow-red: 0 0 10px rgba(255, 123, 114, 0.6); --glow-yellow: 0 0 10px rgba(250, 204, 21, 0.5); --glow-green: 0 0 10px rgba(63, 185, 80, 0.6); --glow-purple: 0 0 12px rgba(188, 140, 255, 0.6); --glow-orange: 0 0 10px rgba(249, 168, 37, 0.6); /* Ajout Orange */
            /* Couleurs spécifiques aux états/types */
            --color-exercise: var(--neon-pink); --glow-exercise: var(--glow-pink); --color-exercise-rgb: 247, 120, 186; --icon-exercise: "\f44b"; /* fa-dumbbell */
            --color-break: var(--neon-yellow); --glow-break: var(--glow-yellow); --color-break-rgb: 250, 204, 21; --icon-break: "\f252"; /* fa-hourglass-half */
            --color-prepare: var(--neon-yellow); --glow-prepare: var(--glow-yellow); --color-prepare-rgb: 250, 204, 21; --icon-prepare: "\f110"; /* fa-spinner */
            --color-finished: var(--neon-green); --glow-finished: var(--glow-green); --color-finished-rgb: 63, 185, 80; --icon-finished: "\f058"; /* fa-check-circle */
            --color-paused: var(--neon-purple); --glow-paused: var(--glow-purple); --color-paused-rgb: 188, 140, 255; --icon-paused: "\f28b"; /* fa-pause-circle */
            --color-idle: var(--secondary-text-color-dark); --glow-idle: none; --color-idle-rgb: 139, 148, 158; --icon-idle: "\f144"; /* fa-play-circle */
            /* --- Autres Variables --- */
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --border-radius-lg: 12px; --border-radius-md: 8px; --border-radius-sm: 6px; --transition-speed: 0.25s; --section-transition-speed: 0.3s; /* Vitesse transition sections */
            /* Initialisation Thème Sombre par Défaut */
            --bg-color: var(--bg-color-dark); --secondary-bg-color: var(--secondary-bg-color-dark); --primary-text-color: var(--primary-text-color-dark); --secondary-text-color: var(--secondary-text-color-dark); --border-color: var(--border-color-dark); --accent-border-color: var(--accent-border-color-dark); --input-bg: var(--input-bg-dark);
            /* Variables pour le timer */
            --current-step-color: var(--color-idle); --current-step-glow: var(--glow-idle);
            /* Total progress est une variable pour JS */
            --total-progress-gradient: var(--total-progress-bg, #2a2f36);
            --total-progress-bg: #2a2f36;
            /* Boutons Contrôle Timer */
            --button-reset-color: var(--neon-red); --button-reset-glow: var(--glow-red); --button-next-color: var(--neon-purple); --button-next-glow: var(--glow-purple); --button-prev-color: var(--neon-orange); --button-prev-glow: var(--glow-orange); /* Ajout Précédent */ --button-end-color: var(--secondary-text-color-dark); --button-end-glow: none; --button-start-color: var(--neon-blue); --button-start-glow: var(--glow-blue); --button-pause-color: var(--color-paused); --button-pause-glow: var(--glow-paused); --button-resume-color: var(--color-paused); --button-resume-glow: var(--glow-paused); --button-done-color: var(--color-exercise); --button-done-glow: var(--glow-exercise);
            /* Boutons Connexion */
            --button-connect-color: var(--neon-green); --button-connect-glow: var(--glow-green); --button-disconnect-color: var(--neon-red); --button-disconnect-glow: var(--glow-red); --link-color: var(--neon-blue);
            /* Variables RGBA */
            --neon-blue-rgb: 88, 166, 255; --neon-pink-rgb: 247, 120, 186; --neon-red-rgb: 255, 123, 114; --neon-yellow-rgb: 250, 204, 21; --neon-green-rgb: 63, 185, 80; --neon-purple-rgb: 188, 140, 255; --neon-orange-rgb: 249, 168, 37; /* Ajout Orange */
            --secondary-text-color-dark-rgb: 139, 148, 158; --bg-color-dark-rgb: 13, 17, 23; --secondary-bg-color-dark-rgb: 22, 27, 34; --primary-text-color-dark-rgb: 201, 209, 217;
            --color-exercise-rgb: 247, 120, 186; --color-break-rgb: 250, 204, 21; --color-prepare-rgb: 250, 204, 21; --color-finished-rgb: 63, 185, 80; --color-paused-rgb: 188, 140, 255; --color-idle-rgb: 139, 148, 158;
        }

        body.light-theme {
            /* Thème Clair */
            --bg-color: #ffffff; --secondary-bg-color: #f6f8fa; --primary-text-color: #24292f; --secondary-text-color: #57606a; --border-color: #d0d7de; --accent-border-color: #0969da33; --input-bg: #f6f8fa;
            /* Couleurs Néon adaptées */
            --neon-blue: #0969da; --neon-pink: #bf3989; --neon-red: #d73a49; --neon-yellow: #dbab09; --neon-green: #2da44e; --neon-purple: #8250df; --neon-orange: #f66a0a;
            /* Glows (Subtils ou désactivés en clair) */
            --glow-blue: 0 0 8px rgba(9, 105, 218, 0.3); --glow-pink: 0 0 8px rgba(191, 57, 137, 0.3); --glow-red: 0 0 8px rgba(215, 58, 73, 0.3); --glow-yellow: 0 0 8px rgba(219, 171, 9, 0.3); --glow-green: 0 0 8px rgba(45, 164, 78, 0.3); --glow-purple: 0 0 8px rgba(130, 80, 223, 0.3); --glow-orange: 0 0 8px rgba(246, 106, 10, 0.3);
            --total-progress-bg: #e1e4e8; --button-end-color: #57606a; --link-color: #0969da;
            /* Adapter les variables RGBA */
            --bg-color-dark-rgb: 255, 255, 255; --secondary-bg-color-dark-rgb: 246, 248, 250; --primary-text-color-dark-rgb: 36, 41, 47; --secondary-text-color-dark-rgb: 87, 96, 106;
            --color-exercise-rgb: 191, 57, 137; --color-break-rgb: 219, 171, 9; --color-prepare-rgb: 219, 171, 9; --color-finished-rgb: 45, 164, 78; --color-paused-rgb: 130, 80, 223; --color-idle-rgb: 87, 96, 106; --neon-orange-rgb: 246, 106, 10;
        }

        /* --- Styles de Base & Réinitialisation --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family); background-color: var(--bg-color); color: var(--primary-text-color);
            line-height: 1.6; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            display: flex; flex-direction: column; min-height: 100vh;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden; /* Empêche le débordement horizontal */
        }
        .container { max-width: 1100px; margin: 0 auto; padding: 30px 25px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }

        /* --- En-tête --- */
        header {
            padding: 15px 0; border-bottom: 1px solid var(--border-color);
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
            position: sticky; top: 0; z-index: 1000;
            background-color: rgba(var(--bg-color-dark-rgb), 0.8); /* Effet verre dépoli */
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        }
        .header-content { display: flex; justify-content: space-between; align-items: center; max-width: 1100px; margin: 0 auto; padding: 0 25px; flex-wrap: wrap; gap: 15px 20px; }
        header h1 { font-size: 1.5em; color: var(--primary-text-color); margin: 0; font-weight: 700; display: flex; align-items: center; gap: 10px; }
        header h1 i { color: var(--neon-blue); animation: pulse 2s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.1); opacity: 1; } }

        /* --- Navigation Header --- */
        nav ul { list-style: none; display: flex; gap: 25px; flex-wrap: wrap; justify-content: center; align-items: center; }
        nav button {
            background: none; border: none; color: var(--secondary-text-color); font-size: 1em; font-weight: 500; padding: 5px 0;
            cursor: pointer; transition: color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            position: relative; border-bottom: 2px solid transparent;
        }
        nav button:disabled {
             color: rgba(var(--secondary-text-color-dark-rgb), 0.5); cursor: not-allowed; border-bottom-color: transparent !important; box-shadow: none !important; opacity: 0.6; pointer-events: none; /* Ajouté */
        }
        nav button:not(:disabled):hover { color: var(--primary-text-color); }
        nav button.active { color: var(--neon-blue); font-weight: 700; border-bottom-color: var(--neon-blue); box-shadow: 0 5px 15px -5px rgba(var(--neon-blue-rgb), 0.4); }

        /* Styles spécifiques pour boutons Historique et Progression */
        #nav-history { color: var(--secondary-text-color); border-bottom-color: transparent; }
        #nav-history:hover:not(:disabled) { color: var(--neon-pink); }
        #nav-history.active { color: var(--neon-pink); border-bottom-color: var(--neon-pink); box-shadow: 0 5px 15px -5px rgba(var(--neon-pink-rgb), 0.4); }
        #nav-history i { margin-right: 5px; }

        #nav-progress { color: var(--secondary-text-color); border-bottom-color: transparent; }
        #nav-progress:hover:not(:disabled) { color: var(--neon-green); }
        #nav-progress.active { color: var(--neon-green); border-bottom-color: var(--neon-green); box-shadow: 0 5px 15px -5px rgba(var(--neon-green-rgb), 0.4); }
        #nav-progress i { margin-right: 5px; }

        /* --- Actions Header --- */
        .header-actions { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button {
            background: none; border: 1px solid var(--accent-border-color); color: var(--secondary-text-color); padding: 6px 14px;
            border-radius: var(--border-radius-md); font-size: 0.85em; font-weight: 500; cursor: pointer;
            transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 6px;
        }
        .auth-controls button:disabled {
            opacity: 0.5; cursor: not-allowed; pointer-events: none; /* Crucial pour le bouton Drive */ border-color: var(--border-color) !important; color: var(--secondary-text-color) !important; box-shadow: none !important; background-color: transparent !important;
        }
        .auth-controls button:not(:disabled):hover { border-color: var(--primary-text-color); color: var(--primary-text-color); }
        #signin-button { border-color: var(--button-connect-color); color: var(--button-connect-color); }
        #signin-button:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--glow-green); border-color: var(--neon-green); }
        #signout-button { border-color: var(--button-disconnect-color); color: var(--button-disconnect-color); }
        #signout-button:not(:disabled):hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--glow-red); border-color: var(--neon-red); }
        #export-button { border-color: var(--neon-blue); color: var(--neon-blue); }
        #export-button:not(:disabled):hover { background-color: rgba(var(--neon-blue-rgb), 0.1); box-shadow: var(--glow-blue); border-color: var(--neon-blue); }

        #drive-status {
            font-size: 0.8em; color: var(--secondary-text-color); margin-left: 5px; transition: opacity 0.3s, color 0.3s, border-color 0.3s;
            min-width: fit-content; text-align: right; font-style: normal; padding: 4px 8px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5);
            border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); display: none; /* Initialement caché */
        }
        #drive-status.loading { color: var(--neon-yellow); border-color: var(--neon-yellow); animation: blink-border 1.5s infinite ease-in-out; }
        #drive-status.error { color: var(--neon-red); border-color: var(--neon-red); }
        #drive-status.success { color: var(--neon-green); border-color: var(--neon-green); }
        @keyframes blink-border { 50% { border-color: rgba(var(--neon-yellow-rgb), 0.4); } }

        .theme-toggle button { background: none; border: none; color: var(--secondary-text-color); font-size: 1.2em; padding: 5px; cursor: pointer; transition: color var(--transition-speed) ease; }
        .theme-toggle button:hover { color: var(--neon-yellow); }

        /* Logique affichage connexion/déconnexion */
        body.logged-out #signin-button { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-out #drive-status { display: none; }
        body.logged-out .history-actions { display: none !important; } /* Forcé car contrôlé par JS */
        body.logged-out #drive-connection-status-main { display: none; }
        body.logged-out #export-button { display: none; }
        body.logged-out #nav-progress { display: none; } /* Cacher progression si pas loggué */

        body.logged-in #signin-button { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-in #drive-status { display: inline-block; }
        body.logged-in .history-actions { display: flex !important; } /* Forcé car contrôlé par JS */
        body.logged-in #drive-connection-status-main { display: inline-flex; }
        body.logged-in #export-button { display: inline-flex; }
        body.logged-in #nav-progress { display: inline-block; }

        /* --- Contenu Principal --- */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 50px; position: relative; }
        /* Style de base pour toutes les sections + transition */
        .app-section {
            background-color: var(--secondary-bg-color);
            padding: 35px;
            border-radius: var(--border-radius-lg);
            border: 1px solid var(--border-color);
            width: 100%;
            margin-bottom: 40px;
            transition: opacity var(--section-transition-speed) ease-in-out, /* Transition fade */
                        visibility 0s linear var(--section-transition-speed), /* Cacher après fade */
                        max-height 0s linear var(--section-transition-speed), /* Cacher après fade */
                        border-color var(--transition-speed) ease,
                        background-color var(--transition-speed) ease;
            max-height: 5000px; /* Assez grand pour contenir n'importe quoi */
            opacity: 1;
            visibility: visible;
            overflow: hidden;
        }
        /* Style spécifique workout section (pas de fond/bordure) */
        .workout-section {
            background-color: transparent;
            border: none;
            padding: 0;
            max-width: 600px;
            text-align: center;
            /* Transition pour la section workout reste potentiellement utile si on la cache */
            transition: opacity var(--section-transition-speed) ease-in-out,
                        visibility 0s linear var(--section-transition-speed),
                        max-height 0s linear var(--section-transition-speed);
        }
         .history-section, .progress-section {
            max-width: 850px;
            text-align: left;
         }

        /* Style pour cacher les sections */
        .section-hidden {
            opacity: 0;
            max-height: 0 !important; /* Forcer collapse */
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
            border-width: 0 !important;
            visibility: hidden;
            transition: opacity var(--section-transition-speed) ease-in-out, /* Transition fade */
                        visibility 0s linear var(--section-transition-speed),
                        max-height 0s linear var(--section-transition-speed),
                        padding var(--section-transition-speed) ease-out,
                        margin var(--section-transition-speed) ease-out,
                        border-width var(--section-transition-speed) ease-out;
        }
        /* Ajustement spécifique pour workout-section cachée */
         .workout-section.section-hidden {
             border: none !important;
         }


        /* --- Affichage Timer --- */
        .timer-display { margin-bottom: 50px; position: relative; display: flex; justify-content: center; align-items: center; width: 320px; height: 320px; margin-left: auto; margin-right: auto; cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent; }
        .timer-circle-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; pointer-events: none; }
        #total-progress-circle, .timer-circle { position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%; display: flex; justify-content: center; align-items: center; border: 12px solid transparent; background-clip: padding-box; background-origin: border-box; box-sizing: border-box; }
        #total-progress-circle {
            border-color: var(--total-progress-bg);
            background: var(--total-progress-gradient, var(--total-progress-bg)); /* Utilise la variable JS */
            box-shadow: 0 0 25px rgba(var(--neon-blue-rgb), 0.3), 0 0 35px rgba(var(--neon-pink-rgb), 0.2), inset 0 0 20px rgba(var(--bg-color-dark-rgb), 0.5);
            z-index: 1; transition: background 0.3s linear;
        }
        .timer-circle {
            width: calc(100% - 48px); height: calc(100% - 48px); top: 24px; left: 24px;
            border-color: var(--border-color);
            background-image: conic-gradient(var(--current-step-color, var(--color-idle)) 0%, transparent 0%); /* Progression étape actuelle */
            box-shadow: var(--current-step-glow, var(--glow-idle)), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6);
            z-index: 3; transition: background-image 0.15s linear, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            background-size: 100% 100%; background-repeat: no-repeat; background-position: center center;
        }
        .timer-circle::before { /* Cache interne pour masquer la progression */
             content: ''; position: absolute; width: calc(100% - 24px); height: calc(100% - 24px); background-color: var(--bg-color); border-radius: 50%; z-index: 4; transition: background-color var(--transition-speed) ease;
        }
        .time-left { font-size: 5.5em; font-weight: 900; color: var(--primary-text-color); z-index: 5; transition: color var(--transition-speed) ease; font-variant-numeric: tabular-nums; position: relative; text-shadow: 0 0 10px rgba(var(--primary-text-color-dark-rgb), 0.3); }

        .timer-state {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); font-size: 0.9em; letter-spacing: 0.08em;
            color: var(--current-step-color, var(--color-idle));
            font-weight: 500; text-transform: uppercase; opacity: 0; transition: opacity 0.3s ease, color var(--transition-speed) ease;
            background-color: transparent; padding: 0; box-shadow: none; z-index: 6;
            text-shadow: 0 0 8px rgba(var(--bg-color-dark-rgb), 0.7);
        }
        .timer-state.visible { opacity: 0.9; }
        .timer-state.preparing { animation: countdown-pulse 1s infinite; font-size: 1.1em; }
        @keyframes countdown-pulse { 0%, 100% { transform: translateX(-50%) scale(1); opacity: 1; } 50% { transform: translateX(-50%) scale(1.05); opacity: 0.85; } }

        /* --- Rep Adjustment Overlay --- */
        .rep-adjustment-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 10; background-color: rgba(var(--bg-color-dark-rgb), 0.85);
            padding: 20px; border-radius: var(--border-radius-md); border: 1px solid var(--border-color);
            box-shadow: 0 10px 25px rgba(0,0,0,0.3); display: none; flex-direction: column;
            align-items: center; gap: 15px; backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            width: 280px; /* Fix width */
        }
        .rep-adjustment-overlay.visible { display: flex; animation: fadeInScale 0.3s ease-out forwards; }
        @keyframes fadeInScale { from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
        .rep-adjustment-overlay .title { font-size: 1.1em; font-weight: 700; color: var(--primary-text-color); text-align: center; margin-bottom: 5px;}
        .rep-adjustment-controls { display: flex; align-items: center; gap: 15px; }
        .rep-adjustment-btn {
            width: 45px; height: 45px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
            font-size: 1.4em; font-weight: 700; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.9);
            border: 1px solid var(--border-color); color: var(--primary-text-color); cursor: pointer;
            transition: all var(--transition-speed) ease;
        }
        .rep-adjustment-btn.minus { border-color: var(--neon-red); color: var(--neon-red); }
        .rep-adjustment-btn.minus:hover { background-color: rgba(var(--neon-red-rgb), 0.15); box-shadow: var(--glow-red); }
        .rep-adjustment-btn.plus { border-color: var(--neon-green); color: var(--neon-green); }
        .rep-adjustment-btn.plus:hover { background-color: rgba(var(--neon-green-rgb), 0.15); box-shadow: var(--glow-green); }
        .rep-adjustment-btn:active { transform: scale(0.95); }
        .current-reps {
            font-size: 2.2em; font-weight: 900; color: var(--primary-text-color); font-variant-numeric: tabular-nums;
            min-width: 60px; text-align: center;
        }
        .rep-adjustment-next-exercise { font-size: 0.95em; color: var(--color-exercise); font-weight: 500; text-align: center; margin-top: 5px; }

        /* --- Infos Exercice --- */
        .workout-info { margin-bottom: 40px; min-height: 100px; position: relative; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #current-exercise-name-display { display: block; font-size: 1.4em; font-weight: 700; color: var(--primary-text-color); margin-bottom: 8px; padding: 0 10px; min-height: 1.5em; transition: color 0.3s ease; }
        /* Coloration du titre selon l'état via classe body */
        body.state-exercise #current-exercise-name-display { color: var(--color-exercise); }
        body.state-break #current-exercise-name-display { color: var(--color-break); }
        body.state-paused #current-exercise-name-display { color: var(--color-paused); }
        body.state-preparing #current-exercise-name-display { color: var(--color-prepare); }
        body.state-finished #current-exercise-name-display { color: var(--color-finished); }

        #current-exercise-container { display: flex; flex-direction: column; align-items: center; gap: 8px; font-size: 1.1em; color: var(--secondary-text-color); min-height: 3em; width: 100%; }
        #current-exercise-container .exercise-details,
        #current-exercise-container .break-info,
        #current-exercise-container .idle-message {
            display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px 20px;
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3); padding: 10px 18px; border-radius: var(--border-radius-md);
            border: 1px solid var(--border-color); width: fit-content; max-width: 90%;
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        #current-exercise-container .exercise-details span,
        #current-exercise-container .break-info span { display: flex; align-items: center; gap: 6px; font-weight: 500; }
        #current-exercise-container .exercise-details span i { color: var(--color-exercise); width: 16px; text-align: center; } /* Icônes alignées */
        #current-exercise-container .break-info i { color: var(--color-break); width: 16px; text-align: center; }
        #current-exercise-container .exercise-details .details-text { font-size: 0.9em; opacity: 0.8; }
        #current-exercise-container .idle-message { border-style: dashed; opacity: 0.7; }
        #current-exercise-container .idle-message i { color: var(--neon-blue); }

        /* Performances Précédentes */
        .previous-performance {
            margin-top: 10px; padding: 8px 15px; background-color: rgba(var(--neon-blue-rgb), 0.1);
            border: 1px dashed var(--neon-blue); border-radius: var(--border-radius-md); font-size: 0.9em;
            color: var(--neon-blue); display: flex; align-items: center; gap: 10px; max-width: 90%;
            opacity: 0; animation: fadeIn 0.5s 0.2s ease-out forwards; /* Animation d'apparition */
        }
        @keyframes fadeIn { to { opacity: 1; } }
        .previous-performance i { font-size: 1.1em; }
        .previous-performance strong { font-weight: 700; }

        /* --- Progress Tracker --- */
        .progress-tracker { font-size: 0.9em; color: var(--secondary-text-color); margin-top: 30px; opacity: 0.8; font-weight: 500; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 5px 15px; min-height: 1.2em; }
        #drive-connection-status-main { align-items: center; gap: 6px; }
        #drive-connection-status-main i.fa-google-drive { color: var(--neon-green); font-size: 1.1em; transition: color 0.3s ease; }
        #drive-connection-status-main i.fa-google-drive.fa-spin { animation: fa-spin 2s linear infinite; }
        #drive-connection-status-main i.fa-google-drive.error { color: var(--neon-red); animation: none; }
        @keyframes fa-spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #progress-text-area { font-weight: 500; }

        /* --- Contrôles Timer --- */
        .controls { display: flex; justify-content: center; gap: 10px; margin-top: 40px; flex-wrap: wrap; } /* Espace réduit */
        .controls button {
            background: transparent; border: 2px solid var(--accent-border-color); color: var(--primary-text-color); flex-grow: 1; /* Prend espace dispo */ max-width: 150px; /* Limite largeur */ padding: 10px 15px; /* Padding ajusté */
            border-radius: var(--border-radius-lg); font-size: 1.05em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        }
        .controls button i { font-size: 0.9em; transition: transform 0.2s ease; }
        .controls button:disabled {
             border-color: var(--border-color) !important; color: var(--secondary-text-color) !important; opacity: 0.5; cursor: not-allowed; box-shadow: none !important; transform: none !important; background-color: transparent !important; pointer-events: none;
        }
        .controls button:not(:disabled):hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .controls button:not(:disabled):hover i { transform: scale(1.1); }
        .controls button:not(:disabled):active { transform: scale(0.97); }

        /* Styles spécifiques aux boutons basés sur la classe JS */
        #start-pause-btn.start-btn { border-color: var(--button-start-color); color: var(--button-start-color); }
        #start-pause-btn.start-btn:not(:disabled):hover { box-shadow: var(--glow-blue), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--neon-blue-rgb), 0.08); }
        #start-pause-btn.pause-btn { border-color: var(--button-pause-color); color: var(--button-pause-color); }
        #start-pause-btn.pause-btn:not(:disabled):hover { box-shadow: var(--glow-paused), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--color-paused-rgb), 0.08); }
        #start-pause-btn.resume-btn { border-color: var(--button-resume-color); color: var(--button-resume-color); }
        #start-pause-btn.resume-btn:not(:disabled):hover { box-shadow: var(--glow-paused), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--color-paused-rgb), 0.08); }
        #start-pause-btn.done-btn { border-color: var(--button-done-color); color: var(--button-done-color); }
        #start-pause-btn.done-btn:not(:disabled):hover { box-shadow: var(--glow-exercise), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--color-exercise-rgb), 0.08); }
        #start-pause-btn.finished-btn { border-color: var(--color-finished); color: var(--color-finished); }
        #start-pause-btn.finished-btn:not(:disabled):hover { box-shadow: var(--glow-finished), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--color-finished-rgb), 0.08); }
        #start-pause-btn.preparing-btn { border-color: var(--color-prepare); color: var(--color-prepare); opacity: 0.7; cursor: default; pointer-events: none; } /* Style pour bouton pendant prépa */

        #skip-btn { border-color: var(--button-next-color); color: var(--button-next-color); }
        #skip-btn:not(:disabled):hover { box-shadow: var(--glow-purple), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--neon-purple-rgb), 0.08); }
        #prev-btn { border-color: var(--button-prev-color); color: var(--button-prev-color); } /* Style Précédent */
        #prev-btn:not(:disabled):hover { box-shadow: var(--glow-orange), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--neon-orange-rgb), 0.08); }
        #finish-btn { border-color: var(--button-end-color); color: var(--button-end-color); }
        #finish-btn:not(:disabled):hover { background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1); border-color: var(--primary-text-color); color: var(--primary-text-color); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        #reset-btn { border-color: var(--button-reset-color); color: var(--button-reset-color); }
        #reset-btn:not(:disabled):hover { box-shadow: var(--glow-red), 0 4px 8px rgba(0,0,0,0.1); background-color: rgba(var(--neon-red-rgb), 0.08); }

        /* --- Section Historique --- */
        .history-section h2 { color: var(--primary-text-color); margin-bottom: 25px; text-align: center; }
        .history-controls { padding-bottom: 20px; margin-bottom: 25px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
        .history-filters { display: flex; gap: 10px; flex-wrap: wrap; }
        .history-filters button { background-color: transparent; border: 1px solid var(--accent-border-color); color: var(--secondary-text-color); opacity: 1; font-size: 0.85em; padding: 6px 12px; border-radius: var(--border-radius-md); cursor: pointer; transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 5px; }
        .history-filters button:not(:disabled):hover { border-color: var(--primary-text-color); color: var(--primary-text-color); background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1); }
        .history-filters button.active { border-color: var(--neon-blue); color: var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); font-weight: 500; box-shadow: var(--glow-blue); }
        .history-actions { display: flex; gap: 15px; align-items: center; color: var(--secondary-text-color); }
        .history-actions i.fab.fa-google-drive { color: var(--neon-green); font-size: 1.1em; }
        #history-drive-status { font-size: 0.8em; padding: 3px 6px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5); border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); transition: color 0.3s ease, border-color 0.3s ease; }
        #history-drive-status.syncing { color: var(--neon-yellow); border-color: var(--neon-yellow); animation: blink-border 1.5s infinite ease-in-out; }
        #history-drive-status.error { color: var(--neon-red); border-color: var(--neon-red); }
        #history-drive-status.success { color: var(--neon-green); border-color: var(--neon-green); }

        .chart-container { height: 350px; margin-bottom: 30px; background-color: transparent; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 15px; box-shadow: none; position: relative; transition: border-color var(--transition-speed) ease; }
        .chart-placeholder { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-text-color); font-style: italic; text-align: center; padding: 0 10px; transition: opacity 0.3s ease; }
        #history-chart-canvas { display: block; width: 100% !important; height: 100% !important; transition: opacity 0.3s ease; }

        .stats-display { margin-bottom: 30px; padding: 20px; background-color: transparent; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); box-shadow: none; transition: border-color var(--transition-speed) ease; }
        .stats-display h3 { color: var(--primary-text-color); margin-bottom: 15px; font-size: 1.15em;}
        .stats-display .content-wrapper p { margin-bottom: 8px; display: flex; align-items: center; gap: 8px;} /* Cibler le contenu généré */
        .stats-display .content-wrapper p i { width: 16px; text-align: center; color: var(--neon-blue); opacity: 0.8;}
        .stats-display .content-wrapper p strong { color: var(--primary-text-color); font-weight: 500; }
        .stats-display .content-wrapper p:last-child { margin-bottom: 0; }
        .stats-display .motivational-message {
            font-style: italic; font-weight: 500; margin-top: 15px !important;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-blue));
            -webkit-background-clip: text; background-clip: text;
            -webkit-text-fill-color: transparent; /* Correction pour compatibilité */
            color: transparent; /* Fallback */
        }

        .history-list { list-style: none; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); background-color: transparent; box-shadow: none; max-height: 400px; overflow-y: auto; transition: border-color var(--transition-speed) ease; }
        .history-list li { display: grid; /* Utiliser grid pour meilleur alignement */ grid-template-columns: auto 1fr auto auto; align-items: center; padding: 12px 15px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s ease, border-color var(--transition-speed) ease; gap: 10px 15px; }
        .history-list li:last-child { border-bottom: none; }
        .history-list li:nth-child(even) { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3); }
        .history-list li:hover { background-color: rgba(var(--neon-blue-rgb), 0.08); }
        .history-item-date { color: var(--primary-text-color); font-size: 0.9em; grid-column: 1 / 2; }
        .history-item-date small { color: var(--secondary-text-color); font-size: 0.9em;}
        .history-item-type { color: var(--neon-pink); background-color: rgba(var(--neon-pink-rgb), 0.1); border-radius: var(--border-radius-sm); padding: 3px 8px; font-size: 0.85em; font-weight: 500; text-align: center; grid-column: 2 / 3; justify-self: start; /* Aligner à gauche dans la colonne */ }
        .history-item-reps { color: var(--neon-purple); font-weight: 500; font-size: 0.9em; grid-column: 3 / 4; justify-self: end; /* Aligner à droite */ }
        .history-item-reps i { margin-right: 4px; }
        .history-item-duration { color: var(--neon-blue); font-weight: 500; font-variant-numeric: tabular-nums; grid-column: 4 / 5; justify-self: end; /* Aligner à droite */ }
        .history-list .no-history { grid-column: 1 / -1; color: var(--secondary-text-color); text-align: center; padding: 30px 15px; font-style: italic; border: none; background: none !important; }

        /* --- Section Progression --- */
        .progress-section h2 { color: var(--primary-text-color); margin-bottom: 25px; text-align: center; }
        .progress-controls { padding-bottom: 20px; margin-bottom: 25px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }

        .progress-filters { display: flex; gap: 10px; flex-wrap: wrap; }
        .progress-filters .filter-group { display: flex; flex-direction: column; gap: 8px; min-width: 180px; }
        .progress-filters .filter-group label { font-size: 0.85em; color: var(--secondary-text-color); margin-bottom: -2px; }
        .progress-filters select {
            background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); color: var(--primary-text-color);
            border-radius: var(--border-radius-sm); padding: 6px 10px; font-size: 0.9em; cursor: pointer;
            transition: all var(--transition-speed) ease; max-width: 100%; appearance: none; -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23${getComputedStyle(document.documentElement).getPropertyValue('--secondary-text-color').substring(1)}'%3E%3Cpath fill-rule='evenodd' d='M4.22 6.22a.75.75 0 011.06 0L8 8.94l2.72-2.72a.75.75 0 111.06 1.06l-3.25 3.25a.75.75 0 01-1.06 0L4.22 7.28a.75.75 0 010-1.06z' clip-rule='evenodd'/%3E%3C/svg%3E"); /* Chevron */
            background-repeat: no-repeat; background-position: right 8px center; background-size: 16px 16px; padding-right: 30px;
        }
        .progress-filters select:hover { border-color: var(--neon-blue); }
        .progress-filters select:focus { outline: none; border-color: var(--neon-blue); box-shadow: var(--glow-blue); }
        .progress-filters option { background-color: var(--bg-color); color: var(--primary-text-color); }
        /* Cacher le filtre métrique car une seule option */
        .filter-group:has(#metric-select) { display: none; }

        .muscle-map-container {
            margin-bottom: 30px; padding: 20px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3);
            border: 1px solid var(--border-color); border-radius: var(--border-radius-md);
            display: flex; flex-direction: column; align-items: center; gap: 15px; transition: border-color var(--transition-speed) ease;
        }
        .muscle-map-container h3 { color: var(--primary-text-color); font-size: 1.15em; margin-bottom: 5px; }
        .muscle-map {
            position: relative; width: 100%; max-width: 600px; height: 400px;
            background-color: rgba(var(--bg-color-dark-rgb), 0.2); border-radius: var(--border-radius-sm);
            display: flex; justify-content: center; align-items: center;
        }
        .muscle-map-placeholder { color: var(--secondary-text-color); font-style: italic; text-align: center; font-size: 0.9em; }

        .exercise-progress-container { margin-bottom: 30px; }
        .exercise-progress-container h3 { color: var(--primary-text-color); font-size: 1.15em; margin-bottom: 15px; }
        .exercise-chart-container {
            height: 350px; background-color: transparent; border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md); padding: 15px; position: relative; transition: border-color var(--transition-speed) ease;
        }
        #exercise-progress-chart { display: block; width: 100% !important; height: 100% !important; transition: opacity 0.3s ease; } /* Canvas, pas la classe */
        /* Section Volume retirée */

        /* --- Résumé Post-Workout (MODAL) --- */
        .post-workout-summary {
            position: fixed; inset: 0; background-color: rgba(var(--bg-color-dark-rgb), 0.85); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            z-index: 2000; display: flex; align-items: center; justify-content: center; padding: 20px; opacity: 0; visibility: hidden; pointer-events: none;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s;
        }
        .post-workout-summary.visible { opacity: 1; visibility: visible; pointer-events: auto; transition: opacity 0.3s ease, visibility 0s linear 0s; }
        .post-workout-summary-content {
            background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-lg); box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 100%; max-width: 550px; max-height: 90vh; display: flex; flex-direction: column; overflow: hidden;
            transform: scale(0.95); transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }
        .post-workout-summary.visible .post-workout-summary-content { transform: scale(1); }
        .post-workout-summary h2 { color: var(--primary-text-color); font-size: 1.5em; font-weight: 700; padding: 20px 25px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; text-align: center; background-color: rgba(var(--bg-color-dark-rgb), 0.2); transition: color var(--transition-speed) ease, border-color var(--transition-speed) ease, background-color var(--transition-speed) ease; }
        .summary-items-list { list-style: none; padding: 15px 25px; overflow-y: auto; flex-grow: 1; background: var(--bg-color); border-bottom: 1px solid var(--border-color); transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease; }
        .summary-item {
            display: grid;
            grid-template-columns: 1fr auto; /* Nom | Input reps */
            gap: 10px 15px;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .summary-item:last-child { border-bottom: none; }
        .summary-item .exercise-name {
            color: var(--primary-text-color);
            font-weight: 500;
            font-size: 1em;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
         .summary-item .exercise-name i {
             color: var(--color-exercise);
             margin-right: 8px;
             opacity: 0.9;
         }
         .summary-item .exercise-name small {
             font-size: 0.8em;
             color: var(--secondary-text-color);
             margin-left: 8px;
         }
        .summary-item .input-container {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-self: end; /* Aligner à droite */
        }
         .summary-item label { /* Label pour accessibilité */
             position: absolute;
             width: 1px; height: 1px;
             padding: 0; margin: -1px;
             overflow: hidden; clip: rect(0, 0, 0, 0);
             white-space: nowrap; border: 0;
         }
         .summary-item input[type="number"] {
            background-color: var(--input-bg); border: 1px solid var(--border-color); color: var(--primary-text-color);
            border-radius: var(--border-radius-sm); padding: 6px 10px; font-size: 0.95em;
            width: 70px; /* Largeur fixe pour input reps */
            text-align: center;
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, color var(--transition-speed) ease;
            -moz-appearance: textfield;
        }
        .summary-item input[type="number"]::-webkit-outer-spin-button,
        .summary-item input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .summary-item input:focus { border-color: var(--neon-blue); background-color: var(--bg-color); outline: none; box-shadow: 0 0 0 3px rgba(var(--neon-blue-rgb), 0.3); }

        .summary-controls {
            padding: 20px 25px; display: flex; justify-content: center; /* Centrer le bouton Fin */ gap: 15px;
            flex-shrink: 0; flex-wrap: wrap; border-top: 1px solid var(--border-color); background-color: rgba(var(--bg-color-dark-rgb), 0.2); transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
        }
        .summary-controls button {
            border: none; color: white; min-width: 160px; padding: 10px 22px; border-radius: var(--border-radius-md);
            font-size: 1em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease;
            display: inline-flex; align-items: center; justify-content: center; gap: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .summary-controls button:disabled { opacity: 0.6; cursor: not-allowed; box-shadow: none; background-color: var(--secondary-text-color) !important; }
        .summary-controls button:not(:disabled):hover { filter: brightness(1.1); box-shadow: 0 4px 10px rgba(0,0,0,0.25); transform: translateY(-1px); }
        .summary-controls button:not(:disabled):active { filter: brightness(0.95); transform: translateY(0); box-shadow: 0 1px 3px rgba(0,0,0,0.2); }

        #finish-summary-btn { background-color: var(--neon-green); } /* Nouveau bouton unique */

        /* --- Animation Fin Workout --- */
        .timer-display.finished-animation .timer-circle { animation: finish-circle-glow 1.5s ease-out forwards; }
        @keyframes finish-circle-glow {
            0% { box-shadow: var(--current-step-glow), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6); border-color: var(--border-color); }
            50% { box-shadow: 0 0 35px 15px rgba(var(--color-finished-rgb), 0.7), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.4); border-color: var(--color-finished); }
            100% { box-shadow: var(--glow-finished), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6); border-color: var(--color-finished); }
        }

        /* --- Zone de Messages Flottante --- */
        .message-area {
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%);
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.9); color: var(--primary-text-color);
            border: 1px solid var(--border-color); padding: 12px 25px; border-radius: var(--border-radius-md);
            z-index: 3000; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease, background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            pointer-events: none; font-size: 0.95em; box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); max-width: 90%; text-align: center;
        }
        .message-area.visible { opacity: 1; transform: translate(-50%, 0); bottom: 40px; pointer-events: auto; }
<footer>
    <p>© 2024 ArmorWorkout. Sauvegarde automatique sur <i class="fab fa-google-drive" aria-hidden="true"></i> Google Drive.</p>
    <p><a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> Voir sur GitHub</a></p>

    <!-- Bloc pour les boutons de navigation externes -->
    <div class="external-nav-buttons">

        <!-- Bouton Évolution Musculaire -->
        <a href="https://ironworkout.github.io/armorworkout/muscle-evolution.html"
           class="external-btn" <!-- Ajout d'une classe commune -->
           id="btn-evolution" <!-- ID spécifique -->
           target="_blank"
           rel="noopener noreferrer"
           title="Accéder à l'outil d'analyse de l'évolution musculaire">
            <i class="fas fa-chart-line" style="color: var(--neon-green);"></i> <!-- Icône Chart + Couleur -->
            Évolution
        </a>

        <!-- Bouton Éditeur de Programme -->
        <a href="https://ironworkout.github.io/armorworkout/program-edito.html"
           class="external-btn" <!-- Ajout d'une classe commune -->
           id="btn-editor" <!-- ID spécifique -->
           target="_blank"
           rel="noopener noreferrer"
           title="Accéder à l'éditeur de programme">
            <i class="fas fa-edit" style="color: var(--neon-purple);"></i> <!-- Icône Edit + Couleur -->
            Éditeur Programme
        </a>

    </div>
</footer>
        }
        footer a { color: var(--link-color); text-decoration: none; transition: color var(--transition-speed) ease; }
        footer a:hover { color: var(--primary-text-color); text-decoration: underline; }
        footer .fab.fa-google-drive { color: #4CAF50; }

        /* --- Styles Responsives --- */
        @media (max-width: 768px) {
            /* ... (styles responsives) ... */
             .history-list li { font-size: 0.9em; grid-template-columns: auto 1fr auto; gap: 5px 10px; } /* Ajuster grid pour petit écran */
             .history-item-reps { grid-column: 3 / 4; justify-self: start; } /* Aligner reps à gauche */
             .history-item-duration { grid-column: 1 / -1; grid-row: 2 / 3; justify-self: end; } /* Durée sur 2ème ligne à droite */
             .controls button { max-width: none; } /* Permettre boutons de prendre plus de place */
             .summary-item { grid-template-columns: 1fr auto; } /* Simplifier grille résumé */
        }
        @media (max-width: 480px) {
            /* ... (styles responsives) ... */
            .controls { flex-direction: row; flex-wrap: wrap; } /* Revenir à row pour très petits */
            .controls button { flex-basis: calc(50% - 5px); /* 2 boutons par ligne */ max-width: none;}
             .history-list li { grid-template-columns: auto 1fr; }
             .history-item-type { grid-column: 2 / 3; }
             .history-item-reps { grid-column: 1 / 2; grid-row: 2 / 3; justify-self: start; }
             .history-item-duration { grid-column: 2 / 3; grid-row: 2 / 3; justify-self: end; }
             .summary-controls button { width: 100%; }
             .summary-item { grid-template-columns: 1fr auto; }
        }
    </style>
</head>
<body class="logged-out dark-theme state-idle"> <!-- Classe d'état initiale -->

<header>
    <div class="header-content">
        <h1><i class="fas fa-shield-halved"></i> ArmorWorkout</h1>
        <nav>
            <ul>
                <li><button id="nav-push" data-workout="Push" disabled>Push</button></li>
                <li><button id="nav-pull" data-workout="Pull" disabled>Pull</button></li>
                <li><button id="nav-legs" data-workout="Legs" disabled>Legs</button></li>
                <li><button id="nav-history"><i class="fas fa-history"></i> Historique</button></li>
                <li><button id="nav-progress" disabled><i class="fas fa-chart-line"></i> Progression</button></li>
            </ul>
        </nav>
        <div class="header-actions">
            <div class="auth-controls">
                <!-- Bouton désactivé par défaut, activé par JS après chargement GIS -->
                <button id="signin-button" disabled><i class="fab fa-google"></i> Connecter Drive</button>
                <button id="signout-button" disabled><i class="fas fa-sign-out-alt"></i> Déconnecter</button>
                <button id="export-button" disabled><i class="fas fa-file-export"></i> Exporter</button>
            </div>
            <span id="drive-status"></span>
            <div class="theme-toggle">
                <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button>
            </div>
        </div>
    </div>
</header>

<div class="container">
    <main>
        <!-- Section Entraînement -->
        <div class="workout-section app-section" id="workout-section"> <!-- Ajout app-section -->
            <div class="timer-display" id="timer-display-clickable" aria-label="Affichage du timer - Cliquer pour ajuster les répétitions">
                <div class="timer-circle-container">
                    <div id="total-progress-circle" aria-hidden="true"></div>
                    <div class="timer-circle" id="timer-circle" aria-hidden="true">
                        <span class="time-left" id="time-left">00:00</span>
                    </div>
                </div>
                <div class="timer-state" id="timer-state" aria-live="polite"></div>
                <!-- Overlay Ajustement Répétitions -->
                <div class="rep-adjustment-overlay" id="rep-adjustment-overlay">
                    <div class="title">Ajuster Répétitions</div>
                    <div class="rep-adjustment-next-exercise" id="rep-adjustment-exercise-name">Exercice</div>
                    <div class="rep-adjustment-controls">
                        <button class="rep-adjustment-btn minus" id="rep-adjust-minus" aria-label="Diminuer répétitions">-</button>
                        <span class="current-reps" id="current-reps-display" aria-live="polite">12</span>
                        <button class="rep-adjustment-btn plus" id="rep-adjust-plus" aria-label="Augmenter répétitions">+</button>
                    </div>
                </div>
            </div>
            <div class="workout-info" id="workout-info">
                <div id="current-exercise-name-display">ArmorWorkout</div> <!-- Titre initial -->
                <div id="current-exercise-container" aria-live="polite">
                    <div class="idle-message"><i class="fas fa-info-circle"></i> Connectez-vous à Google Drive pour commencer.</div>
                </div>
            </div>
            <div class="controls">
                 <button id="prev-btn" disabled><i class="fas fa-backward-step"></i> Précédent</button> <!-- Bouton Précédent -->
                <button id="start-pause-btn" disabled><i class="fas fa-play"></i> Démarrer</button>
                <button id="skip-btn" disabled><i class="fas fa-forward-step"></i> Suivant</button>
                <button id="finish-btn" disabled><i class="fas fa-flag-checkered"></i> Finir</button>
                <button id="reset-btn" disabled><i class="fas fa-redo"></i> Reset</button>
            </div>
            <div class="progress-tracker" id="progress-tracker">
                <span id="progress-text-area">Sélectionnez un entraînement</span>
                <span id="drive-connection-status-main" style="display: none;">
                    <i class="fab fa-google-drive"></i>
                    <span id="drive-connection-text">Connecté</span>
                </span>
            </div>
        </div>

        <!-- Section Historique -->
        <div class="history-section app-section section-hidden" id="history-section"> <!-- Ajout app-section -->
            <h2><i class="fas fa-history"></i> Historique & Statistiques</h2>
            <div class="history-controls">
                <div class="history-filters" role="group" aria-label="Filtres période historique">
                    <button data-period="week" class="active"><i class="fas fa-calendar-week"></i> Semaine</button>
                    <button data-period="month"><i class="fas fa-calendar-alt"></i> Mois</button>
                    <button data-period="year"><i class="fas fa-calendar-check"></i> Année</button>
                    <button data-period="all"><i class="fas fa-infinity"></i> Tout</button>
                </div>
                <div class="history-actions" style="display: none;">
                    <i class="fab fa-google-drive" aria-hidden="true"></i>
                    <span id="history-drive-status">Synchro Drive</span>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="history-chart-canvas" role="img" aria-label="Graphique de la durée d'entraînement"></canvas>
                <p id="history-chart-placeholder" class="chart-placeholder" style="display: none;"></p> <!-- ID HTML Correct -->
            </div>
            <div class="stats-display" id="stats-display">
                <h3>Statistiques</h3>
                <div class="content-wrapper" aria-live="polite">
                     <p>Connectez-vous pour voir les statistiques.</p>
                </div>
                <p class="motivational-message"></p>
            </div>
            <ul class="history-list" id="history-list">
                <li class="no-history">Connectez-vous pour voir l'historique.</li>
            </ul>
        </div>

        <!-- Section Progression -->
        <div class="progress-section app-section section-hidden" id="progress-section"> <!-- Ajout app-section -->
            <h2><i class="fas fa-chart-line"></i> Analyse de Progression</h2>
            <div class="progress-controls">
                <div class="progress-filters">
                    <div class="filter-group">
                        <label for="exercise-select">Exercice</label>
                        <select id="exercise-select" aria-label="Sélectionner un exercice">
                            <option value="all">Tous les exercices (Total Reps)</option> <!-- Texte clarifié -->
                            <!-- Rempli dynamiquement -->
                        </select>
                    </div>
                    <!-- Filtre métrique retiré -->
                    <div class="filter-group" style="display:none;">
                        <label for="metric-select">Métrique</label>
                        <select id="metric-select" aria-label="Sélectionner une métrique">
                            <option value="reps">Répétitions</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label for="period-select">Période</label>
                        <select id="period-select" aria-label="Sélectionner une période">
                            <option value="3months">3 derniers mois</option>
                            <option value="6months">6 derniers mois</option>
                            <option value="all">Tout l'historique</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="exercise-progress-container">
                <h3>Progression (Répétitions)</h3>
                <div class="exercise-chart-container">
                    <canvas id="exercise-progress-chart" role="img" aria-label="Graphique de progression des répétitions"></canvas>
                    <p id="exercise-progress-placeholder" class="chart-placeholder">Sélectionnez un exercice pour voir sa progression.</p> <!-- ID HTML Correct -->
                </div>
            </div>

             <!-- Section Volume retirée -->

            <div class="muscle-map-container">
                <h3>Carte des Groupes Musculaires</h3>
                <div class="muscle-map">
                    <p class="muscle-map-placeholder">La visualisation des groupes musculaires sera disponible prochainement.</p>
                </div>
            </div>
        </div>
    </main>
</div>

<footer>
    <p>© 2024 ArmorWorkout. Sauvegarde automatique sur <i class="fab fa-google-drive" aria-hidden="true"></i> Google Drive.</p>
    <p><a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> Voir sur GitHub</a></p>
</footer>

<!-- Zone de Message Flottante -->
<div id="message-area" class="message-area" role="status" aria-live="polite"></div>

<!-- Modal Résumé Post-Workout -->
<div id="post-workout-summary" class="post-workout-summary" role="dialog" aria-modal="true" aria-labelledby="summary-title">
    <div class="post-workout-summary-content">
        <h2 id="summary-title">Résumé & Objectifs Prochaine Séance</h2>
        <ul id="summary-items-list" class="summary-items-list">
             <!-- Contenu généré par JS -->
        </ul>
        <div class="summary-controls">
            <button id="finish-summary-btn"><i class="fas fa-check"></i> Fin & Sauvegarder Objectifs</button>
        </div>
    </div>
</div>

<!-- Google Identity Services Script - SANS onload -->
<script async defer src="https://accounts.google.com/gsi/client"></script>

<script>
    // --- CONFIGURATION & CONSTANTES ---
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const HISTORY_FILENAME = "armorworkout_history.json";
    const PROGRAM_FILENAMES = { Push: "armorworkout_push_program.json", Pull: "armorworkout_pull_program.json", Legs: "armorworkout_legs_program.json" };
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const PREPARE_DURATION = 3;
    const SECONDS_PER_REP = 2.5;
    const IN_PROGRESS_KEY = 'armorWorkoutStateInProgress';
    const GIS_CHECK_INTERVAL = 100; // ms
    const GIS_MAX_RETRIES = 50; // 50 * 100ms = 5 secondes

    // --- DONNÉES PAR DÉFAUT ---
    const defaultWorkouts = { Push: [ {type:"exercise",name:"Band Standing Chest Press",details:"Élastique 15kg à porte",reps:13,weight:15}, {type:"exercise",name:"Band Bench Press",details:"Élastique 25kg",reps:15,weight:25}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Band Standing Chest Press",details:"Élastique 15kg à porte",reps:13,weight:15}, {type:"exercise",name:"Band Bench Press",details:"Élastique 25kg",reps:15,weight:25}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Band Standing Chest Press",details:"Élastique 15kg à porte",reps:14,weight:15}, {type:"exercise",name:"Band Bench Press",details:"Élastique 25kg",reps:15,weight:25}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Overhead Press",details:"Élastique 15kg",reps:12,weight:15}, {type:"exercise",name:"Triceps Pushdown",details:"Élastique 15kg",reps:15,weight:15}, {type:"break",duration:60,name:"Repos"}, {type:"exercise",name:"Overhead Press",details:"Élastique 15kg",reps:12,weight:15}, {type:"exercise",name:"Triceps Pushdown",details:"Élastique 15kg",reps:15,weight:15} ], Pull: [ {type:"exercise",name:"Band Bent-over Row",details:"Élastique 25 kg",reps:12,weight:25}, {type:"exercise",name:"Band Face Pull",details:"Élastique 15 kg",reps:14,weight:15}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Band Bent-over Row",details:"Élastique 25 kg",reps:12,weight:25}, {type:"exercise",name:"Band Face Pull",details:"Élastique 15 kg",reps:14,weight:15}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Band Bent-over Row",details:"Élastique 25 kg",reps:13,weight:25}, {type:"exercise",name:"Band Face Pull",details:"Élastique 15 kg",reps:15,weight:15}, {type:"break",duration:75,name:"Repos"}, {type:"exercise",name:"Bicep Curls",details:"Élastique 15 kg",reps:12,weight:15}, {type:"exercise",name:"Lat Pulldown (Band)",details:"Élastique 25 kg",reps:12,weight:25}, {type:"break",duration:60,name:"Repos"}, {type:"exercise",name:"Bicep Curls",details:"Élastique 15 kg",reps:12,weight:15}, {type:"exercise",name:"Lat Pulldown (Band)",details:"Élastique 25 kg",reps:12,weight:25} ], Legs: [ {type:"exercise",name:"Front squat",details:"Élastique 15+25 kg + Haltère 5kg",reps:13,weight:45}, {type:"exercise",name:"Fentes Arrière",details:"Élastique 25 kg",reps:10,weight:25}, {type:"break",duration:90,name:"Repos"}, {type:"exercise",name:"Front squat",details:"Élastique 15+25 kg + Haltère 5kg",reps:13,weight:45}, {type:"exercise",name:"Fentes Arrière",details:"Élastique 25 kg",reps:10,weight:25}, {type:"break",duration:90,name:"Repos"}, {type:"exercise",name:"Front squat",details:"Élastique 15+25 kg + Haltère 5kg",reps:14,weight:45}, {type:"exercise",name:"Fentes Arrière",details:"Élastique 25 kg",reps:11,weight:25}, {type:"break",duration:90,name:"Repos"}, {type:"exercise",name:"Romanian Deadlift (Band)",details:"Élastique 25kg",reps:15,weight:25}, {type:"exercise",name:"Calf Raises",details:"Bodyweight or Band",reps:20,weight:10}, {type:"break",duration:60,name:"Repos"}, {type:"exercise",name:"Romanian Deadlift (Band)",details:"Élastique 25kg",reps:15,weight:25}, {type:"exercise",name:"Calf Raises",details:"Bodyweight or Band",reps:20,weight:10} ] };

    // --- Éléments DOM ---
    let timeLeftDisplay, timerCircle, timerStateDisplay, currentExerciseContainer,
        progressTracker, startPauseBtn, skipBtn, finishBtn, resetBtn, navButtons = [],
        navHistoryBtn, navProgressBtn, themeToggleBtn, messageArea, workoutSection, historySection, progressSection,
        historyList, statsDisplay, statsContentWrapper, historyFilterBtns = [],
        signInButton, signOutButton, exportButton, driveStatusElement,
        postWorkoutSummary, summaryTitle, summaryItemsList, finishSummaryBtn,
        historyDriveStatus, totalProgressCircle,
        currentExerciseNameDisplay, driveConnectionStatusMain, driveConnectionText,
        timerDisplayElement, chartPlaceholder, progressTextArea, historyActionsContainer,
        exerciseSelect, metricSelect, periodSelect,
        exerciseChartPlaceholder, /* volumeChartPlaceholder retiré */
        repAdjustmentOverlay, repAdjustMinusBtn, repAdjustPlusBtn, currentRepsDisplay, repAdjustmentExerciseName,
        historyChartCanvasEl, exerciseProgressChartCanvasEl, /* volumeChartCanvasEl retiré */
        prevBtn;

    // --- Variables d'État ---
    let currentWorkoutType = null, currentWorkoutPlan = [], originalCompletedWorkoutPlan = [];
    let currentItemIndex = 0, timerInterval = null, prepareCountdownInterval = null;
    let totalTime = 0, timeLeft = 0, prepareTimeLeft = 0;
    let totalWorkoutEstimatedSeconds = 0, elapsedWorkoutEstimatedSeconds = 0;
    let isTimerRunning = false, isWorkoutActive = false, workoutFinished = false, wasFinishedState = false;
    let currentState = 'idle';
    let workoutStartTime = null, workoutHistory = [];
    let currentHistoryPeriod = 'week';
    let historyChartInstance = null, exercisePerfChartInstance = null; /* volumeLoadChartInstance retiré */
    let googleAccessToken = null, tokenClient = null;
    let historyFileId = null, programFileIds = { Push: null, Pull: null, Legs: null };
    let programsLoaded = false, loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
    // summaryChangesMade retiré
    let isSavingDriveData = false;
    let currentTheme = 'dark', messageTimeoutId = null;
    let audioContext = null;
    let nextExerciseIndexForAdjustment = -1, currentRepAdjustment = 0, isRepAdjustmentVisible = false;
    let gisCheckRetries = 0;
    let halfwayTimeoutId = null;

    // --- Audio & Vibration ---
    let soundLaser, sound5, sound4, sound3, sound2, sound1, soundWindows, soundET;

    function initSounds() { /* ... (code inchangé) ... */ }
    function playSound(audioElement) { /* ... (code inchangé) ... */ }
    function initAudioContext() { /* ... (code inchangé) ... */ }
    const playTransitionSound = () => playSound(soundLaser);
    const vibrate = (pattern = [100]) => { if ('vibrate' in navigator) { try { navigator.vibrate(pattern); } catch (e) { /* Ignore vibration errors */ } } };

    // --- Google Identity Services (GIS) & Drive API ---
    // Fonction d'initialisation interne, appelée une fois que l'API Google est prête
    async function gisInitInternal() {
        console.log(">>> gisInitInternal appelée - Initialisation du Token Client...");
        const clientIdValid = GOOGLE_CLIENT_ID && !GOOGLE_CLIENT_ID.includes("YOUR_CLIENT_ID");

        if (!clientIdValid) {
            console.error("CRITICAL: GOOGLE_CLIENT_ID n'est pas configuré !");
            showMessage("Erreur critique : ID Client Google manquant.", 10000, true);
             if(signInButton) signInButton.disabled = true; // Garder désactivé
            return;
        }

        // Vérifier la présence de l'API Google
        if (!google || !google.accounts || !google.accounts.oauth2) {
            console.error("L'API Google Identity Services n'a pas été correctement chargée ou initialisée.");
            showMessage("Erreur chargement API Google.", 6000, true);
            if(signInButton) signInButton.disabled = true; // Garder désactivé
            return;
        }

        try {
            console.log("Tentative d'initialisation de initTokenClient...");
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GOOGLE_DRIVE_SCOPES,
                callback: tokenCallback,
                error_callback: handleTokenError,
                prompt: '' // Pas de prompt auto
            });
            console.log("Token Client Google initialisé avec succès via gisInitInternal.");
            if (signInButton) {
                signInButton.disabled = false;
                console.log("Bouton Sign In activé via gisInitInternal.");
            } else {
                console.warn("Le bouton Sign In n'a pas été trouvé dans le DOM au moment de l'activation (gisInitInternal).");
            }
        } catch (error) {
            console.error("Erreur lors de l'appel à google.accounts.oauth2.initTokenClient (gisInitInternal):", error);
            showMessage("Erreur initialisation services Google.", 5000, true);
            updateAuthUI(false);
            if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Init Auth'; driveStatusElement.classList.remove('loading', 'success'); driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; }
             if(signInButton) signInButton.disabled = true;
        }
         console.log(">>> gisInitInternal - Fin d'exécution");
    }

    // Fonction pour vérifier périodiquement si l'API Google est chargée
    function checkAndInitGis() {
        console.log(`Vérification GIS (Essai ${gisCheckRetries + 1}/${GIS_MAX_RETRIES})...`);
        // Vérification plus robuste de l'existence de la fonction nécessaire
        if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2 && typeof google.accounts.oauth2.initTokenClient === 'function') {
            console.log("API Google OAuth2 détectée ! Lancement de gisInitInternal.");
            gisInitInternal(); // L'API est prête, on initialise
        } else if (gisCheckRetries < GIS_MAX_RETRIES) {
            gisCheckRetries++;
            setTimeout(checkAndInitGis, GIS_CHECK_INTERVAL); // Réessayer après un délai
        } else {
            console.error(`Échec de la détection de l'API Google après ${GIS_MAX_RETRIES} essais.`);
            showMessage("Impossible de charger les services Google. Vérifiez votre connexion ou bloqueur de script.", 10000, true);
            if(signInButton) signInButton.disabled = true; // Garder désactivé
        }
    }

    function handleTokenError(error) { console.error("Erreur Google Token Client:", error); let userMessage = `Erreur Auth Google: ${error.type || error.error || 'Inconnue'}`; let statusText = 'Erreur Auth'; if (driveStatusElement) { driveStatusElement.classList.remove('loading', 'success'); driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; } if (error.error === 'popup_closed_by_user' || error.error === 'user_cancel' || error.type === 'popup_closed') { userMessage = "Connexion Google annulée par l'utilisateur."; statusText = 'Annulé'; } else if (error.error === 'popup_failed_to_open' || error.type === 'popup_failed_to_open') { userMessage = "La fenêtre pop-up Google a été bloquée par le navigateur."; statusText = 'Popup Bloqué'; } else if (error.error === 'access_denied' || error.type === 'access_denied') { userMessage = "Accès à Google Drive refusé."; statusText = 'Accès Refusé'; } else if (error.error === 'token_network_error') { userMessage = "Erreur réseau lors de l'authentification Google."; statusText = 'Erreur Réseau'; } else if (error.error === 'invalid_grant') { userMessage = "Autorisation Google invalide ou révoquée."; statusText = 'Autorisation Invalide'; googleAccessToken = null; } showMessage(userMessage, 6000, true); if (driveStatusElement) driveStatusElement.textContent = statusText; updateAuthUI(false); }
    async function tokenCallback(tokenResponse) {
        if (driveStatusElement) { driveStatusElement.classList.remove('loading', 'error', 'success'); driveStatusElement.style.display = 'inline-block'; }
        if (tokenResponse.error) { handleTokenError(tokenResponse); return; }
        if (tokenResponse && tokenResponse.access_token) {
            console.log("Access Token reçu avec succès.");
            googleAccessToken = tokenResponse.access_token;
            // Ne pas appeler updateAuthUI ici immédiatement
            showMessage("Connecté ! Chargement des données...", 2500);
            if (driveStatusElement) { driveStatusElement.textContent = 'Chargement...'; driveStatusElement.classList.add('loading'); }

            let historyLoaded = false;
            let programsSuccess = false;
            try {
                // Charger séquentiellement
                console.log("Début chargement historique...");
                await loadHistoryFromDrive();
                historyLoaded = true;
                console.log("Historique chargé. Début chargement programmes...");
                programsSuccess = await loadProgramsFromDrive();

                // **Correction : Définir programsLoaded APRÈS et SELON le succès**
                programsLoaded = programsSuccess;
                console.log(`Fin chargement données dans tokenCallback. programsSuccess: ${programsSuccess}, programsLoaded: ${programsLoaded}`);


                if (programsLoaded) {
                    showMessage("Données prêtes. Sélectionnez un entraînement.", 3000);
                    if (driveStatusElement) { driveStatusElement.textContent = 'Connecté'; driveStatusElement.classList.remove('loading', 'error'); driveStatusElement.classList.add('success'); }
                } else {
                    showMessage("Erreur chargement programmes. Utilisation des défauts.", 5000, true);
                     if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Progs'; driveStatusElement.classList.remove('loading'); driveStatusElement.classList.add('error'); }
                     programsLoaded = true; // Forcer pour permettre usage avec défauts
                     console.warn("Utilisation des programmes par défaut suite à une erreur de chargement.");
                }

            } catch (error) {
                console.error("Erreur CRITIQUE pendant le chargement séquentiel des données Drive:", error);
                showMessage("Erreur majeure lors du chargement des données Drive.", 6000, true);
                if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Données'; driveStatusElement.classList.remove('loading', 'success'); driveStatusElement.classList.add('error'); }
                programsLoaded = false; // Erreur majeure = pas de programmes chargés
            } finally {
                // **Appeler updateAuthUI une seule fois à la fin**
                console.log("Fin du bloc try/catch/finally de tokenCallback. Mise à jour UI finale...");
                updateAuthUI(true); // Mettre à jour l'UI avec l'état final de programsLoaded
                if (programsLoaded) {
                     populateExerciseSelect();
                     displayHistory(currentHistoryPeriod); // Afficher l'historique chargé (même si vide)
                     displayExerciseProgress();
                     // displayVolumeLoad(); // Retiré
                     loadInProgressState();
                } else {
                    console.warn("Les programmes n'ont pas pu être chargés, certaines fonctionnalités seront limitées.");
                }
            }
        } else {
            handleTokenError({ error: "invalid_response", details: "Réponse inattendue du serveur Google." });
        }
    }
    function handleAuthClick() { initAudioContext(); if (!tokenClient) { showMessage("Les services Google ne sont pas encore prêts...", 3000); console.warn("Tentative de connexion avant initialisation du tokenClient."); if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID.includes("YOUR_CLIENT_ID")) { showMessage("Erreur critique : ID Client Google manquant.", 8000, true); } return; } if (driveStatusElement) { driveStatusElement.textContent = 'Connexion...'; driveStatusElement.classList.add('loading'); driveStatusElement.classList.remove('error', 'success'); driveStatusElement.style.display = 'inline-block'; } tokenClient.requestAccessToken({ prompt: 'consent' }); }
    function handleSignoutClick(showMessages = true) { const token = googleAccessToken; if (!token) { console.log("Déjà déconnecté."); updateAuthUI(false); return; } if (showMessages && driveStatusElement) { driveStatusElement.textContent = 'Déconnexion...'; driveStatusElement.classList.add('loading'); driveStatusElement.style.display = 'inline-block'; } google.accounts.oauth2.revoke(token, () => { console.log('Token Google révoqué.'); googleAccessToken = null; historyFileId = null; programFileIds = { Push: null, Pull: null, Legs: null }; programsLoaded = false; workoutHistory = []; loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); clearInProgressState(); if (isWorkoutActive || currentState !== 'idle') { resetCurrentWorkout(); } else { updateAuthUI(false); } if (showMessages) { showMessage("Déconnecté de Google Drive.", 3000); } if (driveStatusElement) { driveStatusElement.textContent = ''; driveStatusElement.style.display = 'none'; } displayHistory(currentHistoryPeriod); clearCharts(); populateExerciseSelect(); }); }
    function updateAuthUI(isLoggedIn) {
        console.log(`Update UI - Connecté: ${isLoggedIn}, Programmes Chargés: ${programsLoaded}, État Timer: ${currentState}, Workout Type: ${currentWorkoutType}`);
        const body = document.body; body.classList.toggle('logged-in', isLoggedIn); body.classList.toggle('logged-out', !isLoggedIn);
        if (driveStatusElement) { driveStatusElement.style.display = isLoggedIn ? 'inline-block' : 'none'; if (!isLoggedIn) driveStatusElement.textContent = ''; }
        const driveIconMain = driveConnectionStatusMain?.querySelector('i.fa-google-drive'); if (driveConnectionStatusMain && driveConnectionText && driveIconMain) { driveConnectionStatusMain.style.display = isLoggedIn ? 'inline-flex' : 'none'; if (isLoggedIn) { if (driveStatusElement?.classList.contains('loading')) { driveConnectionText.textContent = "Chargement..."; driveIconMain.classList.add('fa-spin'); driveIconMain.classList.remove('error'); } else if (driveStatusElement?.classList.contains('error')) { driveConnectionText.textContent = `Erreur Drive`; driveIconMain.classList.remove('fa-spin'); driveIconMain.classList.add('error'); } else { driveConnectionText.textContent = "Connecté"; driveIconMain.classList.remove('fa-spin', 'error'); } } else { driveIconMain.classList.remove('fa-spin', 'error'); } }
        if (historyDriveStatus && historyActionsContainer) { historyActionsContainer.style.display = isLoggedIn ? 'flex' : 'none'; if (isLoggedIn) { historyDriveStatus.classList.remove('syncing', 'error', 'success'); if (isSavingDriveData) { historyDriveStatus.textContent = 'Synchro...'; historyDriveStatus.classList.add('syncing'); } else if (driveStatusElement?.classList.contains('loading')) { historyDriveStatus.textContent = 'Chargement...'; historyDriveStatus.classList.add('syncing'); } else if (driveStatusElement?.classList.contains('error')) { historyDriveStatus.textContent = 'Erreur Synchro'; historyDriveStatus.classList.add('error'); } else { historyDriveStatus.textContent = 'Synchro OK'; historyDriveStatus.classList.add('success'); } } }
        if(themeToggleBtn) themeToggleBtn.disabled = false;
        if(signInButton) signInButton.disabled = isLoggedIn || !tokenClient; // Désactivé si loggué OU si tokenClient pas prêt
        if(signOutButton) signOutButton.disabled = !isLoggedIn;
        if(exportButton) exportButton.disabled = !isLoggedIn;

        const isTimerActive = ['preparing', 'exercise', 'break', 'paused'].includes(currentState);
        // **Activation/Désactivation des boutons P/P/L**
        navButtons.forEach(btn => {
            if(btn) btn.disabled = !(isLoggedIn && programsLoaded && !isTimerActive);
        });
        if(navHistoryBtn) navHistoryBtn.disabled = isTimerActive;
        if(navProgressBtn) navProgressBtn.disabled = !isLoggedIn || isTimerActive;

        // **Activation/Désactivation du bouton Démarrer (gérée DANS setState('idle'))**
        if (currentState === 'idle') {
            const canStartWorkout = isLoggedIn && programsLoaded && !!currentWorkoutType && currentWorkoutPlan && currentWorkoutPlan.length > 0;
            if(startPauseBtn) {
                 startPauseBtn.disabled = !canStartWorkout;
                 startPauseBtn.innerHTML = `<i class="fas fa-play"></i> Démarrer`;
                 startPauseBtn.className = 'start-btn';
            }
        } else {
             if(startPauseBtn) startPauseBtn.disabled = true;
        }
         // Activation bouton Précédent (aussi gérée dans setState)
         if(prevBtn) prevBtn.disabled = !(isTimerActive && currentItemIndex > 0);
         // Les autres boutons (Skip, Finish, Reset) sont gérés dans setState

        updateWorkoutInfo();
        displayHistory(currentHistoryPeriod);
    }
    async function findOrCreateFile(filename, defaultContent = "", mimeType = 'application/json') { console.log(`Drive: Recherche/Création de ${filename}`); if (!googleAccessToken) { console.warn("findOrCreateFile: Pas de token Google."); return null; } const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+trashed=false&spaces=drive&fields=files(id,name)`; try { const searchRes = await fetch(searchUrl, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!searchRes.ok) { if (searchRes.status === 401 || searchRes.status === 403) { console.warn(`findOrCreateFile(${filename}): Erreur d'autorisation (${searchRes.status}). Déconnexion.`); handleSignoutClick(false); showMessage("Session Google expirée. Reconnectez-vous.", 5000, true); return null; } throw new Error(`Recherche échouée (${searchRes.status}): ${await searchRes.text()}`); } const searchData = await searchRes.json(); if (searchData.files && searchData.files.length > 0) { console.log(`Drive: Fichier ${filename} trouvé (ID: ${searchData.files[0].id}).`); return searchData.files[0].id; } console.log(`Drive: Fichier ${filename} non trouvé. Création...`); const createUrl = `https://www.googleapis.com/drive/v3/files`; const metadata = { name: filename, mimeType: mimeType }; const createRes = await fetch(createUrl, { method: 'POST', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' }, body: JSON.stringify(metadata) }); if (!createRes.ok) { throw new Error(`Création échouée (${createRes.status}): ${await createRes.text()}`); } const createData = await createRes.json(); const newFileId = createData.id; console.log(`Drive: Fichier ${filename} créé (ID: ${newFileId}). Écriture du contenu par défaut...`); const writeSuccess = await updateFileContent(newFileId, defaultContent); if (writeSuccess) { console.log(`Drive: Contenu par défaut écrit avec succès dans ${filename}.`); return newFileId; } else { console.error(`Drive: Échec de l'écriture du contenu par défaut dans ${filename}.`); return null; } } catch (error) { console.error(`Erreur Drive (findOrCreate ${filename}):`, error); showMessage(`Erreur Drive (${filename.substring(0, 15)}...): ${error.message}`, 6000, true); return null; } }
    async function readFileContent(fileId) { if (!googleAccessToken || !fileId) { console.warn("readFileContent: Pas de token ou d'ID de fichier."); return null; } console.log(`Drive: Lecture du fichier ${fileId}`); const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`; try { const response = await fetch(url, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!response.ok) { if (response.status === 404) { console.warn(`readFileContent(${fileId}): Fichier non trouvé (404).`); return ""; } if (response.status === 401 || response.status === 403) { console.warn(`readFileContent(${fileId}): Erreur d'autorisation (${response.status}). Déconnexion.`); handleSignoutClick(false); showMessage("Session Google expirée. Reconnectez-vous.", 5000, true); return null; } throw new Error(`Lecture échouée (${response.status}): ${await response.text()}`); } const content = await response.text(); console.log(`Drive: Contenu du fichier ${fileId} lu avec succès.`); return content; } catch (error) { console.error(`Erreur Drive (readFile ${fileId}):`, error); showMessage(`Erreur Lecture Drive (${fileId}): ${error.message}`, 6000, true); return null; } }
    async function updateFileContent(fileId, content) { if (!googleAccessToken || !fileId) { console.warn("updateFileContent: Pas de token ou d'ID de fichier."); return false; } if (isSavingDriveData) { showMessage("Sauvegarde Drive déjà en cours...", 1500); console.warn("Tentative d'écriture concurrente sur Drive annulée."); return false; } console.log(`Drive: Écriture dans le fichier ${fileId}...`); isSavingDriveData = true; if (historyDriveStatus) historyDriveStatus.textContent = 'Synchro...'; historyDriveStatus.className = 'syncing'; updateAuthUI(true); const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`; const isJson = typeof content === 'object'; const contentToSend = isJson ? JSON.stringify(content, null, 2) : content; const contentType = isJson ? 'application/json; charset=UTF-8' : 'text/plain; charset=UTF-8'; let success = false; try { const response = await fetch(url, { method: 'PATCH', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': contentType }, body: contentToSend }); if (!response.ok) { if (response.status === 401 || response.status === 403) { console.warn(`updateFileContent(${fileId}): Erreur d'autorisation (${response.status}). Déconnexion.`); handleSignoutClick(false); showMessage("Session expirée. Sauvegarde échouée.", 6000, true); } else { throw new Error(`Écriture échouée (${response.status}): ${await response.text()}`); } } else { console.log(`Drive: Fichier ${fileId} mis à jour avec succès.`); success = true; } } catch (error) { console.error(`Erreur Drive (updateFile ${fileId}):`, error); showMessage(`Erreur Écriture Drive: ${error.message}`, 6000, true); success = false; if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Synchro'; historyDriveStatus.className = 'error'; } finally { isSavingDriveData = false; updateAuthUI(!!googleAccessToken); console.log(`Drive: Écriture ${fileId} terminée. Succès: ${success}`); } return success; }

    // --- Fonctions Cœur du Timer ---
    function formatTime(seconds) { const cleanSeconds = Math.max(0, Math.round(seconds)); const minutes = Math.floor(cleanSeconds / 60); const remainingSeconds = cleanSeconds % 60; return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`; }
    function calculateTotalEstimatedTime(plan) { let totalSeconds = 0; plan.forEach(item => { let estimatedDuration = 0; if (item.type === 'break') { estimatedDuration = item.duration || 0; } else if (item.type === 'exercise') { estimatedDuration = item.duration || (item.reps || 0) * SECONDS_PER_REP; } item.estimatedDuration = estimatedDuration; totalSeconds += estimatedDuration; }); return totalSeconds; }
    function updateTotalProgressCircle() { if (!totalProgressCircle || totalWorkoutEstimatedSeconds <= 0 || !isWorkoutActive) { totalProgressCircle.style.setProperty('--total-progress-gradient', `var(--total-progress-bg)`); return; } let elapsedSeconds = 0; for (let i = 0; i < currentItemIndex; i++) { elapsedSeconds += currentWorkoutPlan[i]?.estimatedDuration || 0; } const currentItem = currentWorkoutPlan[currentItemIndex]; if (currentItem) { if (currentState === 'break' && totalTime > 0) { const elapsedInBreak = Math.min(totalTime - timeLeft, currentItem.estimatedDuration || totalTime); elapsedSeconds += elapsedInBreak; } else if (currentState === 'preparing' && PREPARE_DURATION > 0) { const elapsedInPrepare = Math.min(PREPARE_DURATION - prepareTimeLeft, PREPARE_DURATION); } else if (currentState === 'paused') { if (currentItem.type === 'break' && totalTime > 0) { const elapsedInBreak = Math.min(totalTime - timeLeft, currentItem.estimatedDuration || totalTime); elapsedSeconds += elapsedInBreak; } } } if (currentState === 'finished') { elapsedSeconds = totalWorkoutEstimatedSeconds; } const percentage = totalWorkoutEstimatedSeconds > 0 ? Math.min(100, (elapsedSeconds / totalWorkoutEstimatedSeconds) * 100) : 0; const gradient = `conic-gradient( var(--neon-blue) ${percentage * 0.6}%, var(--neon-pink) ${percentage}%, var(--total-progress-bg) ${percentage}% )`; totalProgressCircle.style.setProperty('--total-progress-gradient', gradient); }
    function updateTimerDisplay() { if (!timeLeftDisplay || !timerCircle || !timerStateDisplay) return; let percentage = 0; let timeString = "00:00"; let stepColorVar = '--color-idle'; let stepGlowVar = '--glow-idle'; let stateText = ''; const item = currentWorkoutPlan[currentItemIndex]; switch(currentState) { case 'exercise': timeString = "GO!"; stepColorVar = '--color-exercise'; stepGlowVar = '--glow-exercise'; stateText = item?.name || 'Exercice'; percentage = 100; break; case 'break': if (totalTime > 0) percentage = Math.min(100, ((totalTime - timeLeft) / totalTime) * 100); timeString = formatTime(timeLeft); stepColorVar = '--color-break'; stepGlowVar = '--glow-break'; stateText = 'Repos'; break; case 'paused': if (item?.type === 'break' && totalTime > 0) { percentage = Math.min(100, ((totalTime - timeLeft) / totalTime) * 100); timeString = formatTime(timeLeft); } else { percentage = item?.type === 'exercise' ? 100 : 0; timeString = "PAUSE"; } stepColorVar = '--color-paused'; stepGlowVar = '--glow-paused'; stateText = 'En Pause'; break; case 'preparing': percentage = Math.min(100, ((PREPARE_DURATION - prepareTimeLeft) / PREPARE_DURATION) * 100); timeString = formatTime(prepareTimeLeft); stepColorVar = '--color-prepare'; stepGlowVar = '--glow-prepare'; stateText = 'Préparation'; break; case 'finished': percentage = 100; timeString = "FINI !"; stepColorVar = '--color-finished'; stepGlowVar = '--glow-finished'; stateText = 'Terminé !'; break; default: percentage = 0; timeString = formatTime(0); stepColorVar = '--color-idle'; stepGlowVar = '--glow-idle'; stateText = ''; break; } timeLeftDisplay.textContent = timeString; timerCircle.style.setProperty('--current-step-color', `var(${stepColorVar})`); timerCircle.style.setProperty('--current-step-glow', `var(${stepGlowVar})`); timerCircle.style.backgroundImage = `conic-gradient(var(${stepColorVar}) ${percentage}%, transparent ${percentage}%)`; timerStateDisplay.textContent = stateText; timerStateDisplay.style.color = `var(${stepColorVar})`; updateTotalProgressCircle(); }
    function findPreviousPerformance(exerciseName) { if (!workoutHistory || workoutHistory.length === 0) return null; for (let i = workoutHistory.length - 1; i >= 0; i--) { const entry = workoutHistory[i]; if (!entry.exercises) continue; const foundExercise = entry.exercises.find(ex => ex.name === exerciseName); if (foundExercise) { return { reps: foundExercise.actualReps ?? foundExercise.reps, weight: foundExercise.actualWeight ?? foundExercise.weight, date: new Date(entry.date) }; } } return null; }
    function updateWorkoutInfo() { if (!currentExerciseContainer || !currentExerciseNameDisplay || !progressTracker || !progressTextArea) { console.error("updateWorkoutInfo: Éléments DOM manquants."); return; } const item = currentWorkoutPlan[currentItemIndex]; let infoHtml = ''; let exerciseName = ''; let progressText = ''; const body = document.body; switch (currentState) { case 'idle': exerciseName = "ArmorWorkout"; if (!googleAccessToken) { progressText = "Connectez-vous à Google Drive"; infoHtml = `<div class="idle-message"><i class="fas fa-sign-in-alt"></i> ${progressText} pour commencer.</div>`; } else if (!programsLoaded) { progressText = "Chargement des programmes..."; infoHtml = `<div class="idle-message"><i class="fas fa-spinner fa-spin"></i> ${progressText}</div>`; } else if (!currentWorkoutType) { progressText = "Sélectionnez un entraînement (Push/Pull/Legs)"; infoHtml = `<div class="idle-message"><i class="fas fa-hand-pointer"></i> ${progressText}</div>`; } else { progressText = `Prêt: ${currentWorkoutType}`; infoHtml = `<div class="idle-message"><i class="fas fa-play-circle"></i> Appuyez sur Démarrer pour commencer "${currentWorkoutType}".</div>`; } break; case 'finished': const durationSeconds = workoutStartTime ? (Date.now() - workoutStartTime) / 1000 : 0; exerciseName = 'Entraînement Terminé !'; infoHtml = `<div class="exercise-details"> <span><i class="fas ${getIconForState('finished')}"></i> Bravo ! Séance finie.</span> ${durationSeconds > 0 ? `<span><i class="fas fa-stopwatch"></i> Durée: <strong>${formatTime(durationSeconds)}</strong></span>` : ''} </div>`; progressText = `Fini (${originalCompletedWorkoutPlan.length}/${originalCompletedWorkoutPlan.length})`; break; case 'preparing': const nextItem = currentWorkoutPlan[0]; exerciseName = `Préparation...`; infoHtml = `<div class="break-info" style="border-color: var(--color-prepare);"> <i class="fas ${getIconForState('preparing')} fa-spin"></i> <span>Prêt pour <strong>${nextItem?.name || '?'}</strong> dans ${prepareTimeLeft}s...</span> </div>`; progressText = `Prépa... (1/${currentWorkoutPlan.length})`; break; case 'exercise': case 'paused': case 'break': if (!item) { exerciseName = 'Erreur'; infoHtml = '<p>Erreur : Étape inconnue.</p>'; progressText = `Étape ?/${currentWorkoutPlan.length}`; break; } exerciseName = `${item.name || (item.type === 'break' ? 'Repos' : 'Étape inconnue')}`; progressText = `Étape ${currentItemIndex + 1}/${currentWorkoutPlan.length}`; if (item.type === 'exercise') { const reps = (item.actualReps !== undefined ? item.actualReps : item.reps) ?? '-'; const weight = (item.actualWeight !== undefined ? item.actualWeight : item.weight) ?? '-'; const details = item.details || ''; infoHtml = `<div class="exercise-details"> <span><i class="fas ${getIconForType('exercise')}"></i> Reps: <strong>${reps}</strong></span> <span><i class="fas fa-weight-hanging"></i> Poids: <strong>${weight}${weight !== '-' ? ' kg' : ''}</strong></span> ${details ? `<span class="details-text"><i class="fas fa-info-circle"></i> ${details}</span>` : ''} </div>`; const prevPerf = findPreviousPerformance(item.name); if (prevPerf) { const dateStr = prevPerf.date.toLocaleDateString('fr-FR', { day: '2-digit', month: 'short' }); const prevReps = prevPerf.reps ?? '-'; const prevWeight = prevPerf.weight ?? '-'; infoHtml += `<div class="previous-performance"> <i class="fas fa-history"></i> <span>Dernière fois (${dateStr}): <strong>${prevReps} reps</strong> à <strong>${prevWeight}${prevWeight !== '-' ? ' kg' : ''}</strong></span> </div>`; } } else if (item.type === 'break') { infoHtml = `<div class="break-info"> <i class="fas ${getIconForType('break')}"></i> <span>Pause: ${formatTime(item.duration || 0)}</span> </div>`; const nextExerciseIndex = currentItemIndex + 1; if (nextExerciseIndex < currentWorkoutPlan.length && currentWorkoutPlan[nextExerciseIndex].type === 'exercise') { const nextEx = currentWorkoutPlan[nextExerciseIndex]; const nextReps = nextEx.reps ?? '-'; const nextWeight = nextEx.weight ?? '-'; infoHtml += `<div class="break-info" style="margin-top: 8px; opacity: 0.8;"> <i class="fas fa-arrow-right"></i> <span>Suivant: ${nextEx.name || '?'} (${nextReps} reps @ ${nextWeight}${nextWeight !== '-' ? 'kg' : ''})</span> </div>`; } } break; default: exerciseName = 'Inconnu'; infoHtml = '<p>État inconnu.</p>'; progressText = ''; break; } if(currentExerciseNameDisplay) currentExerciseNameDisplay.textContent = exerciseName; if(currentExerciseContainer) currentExerciseContainer.innerHTML = infoHtml; if(progressTextArea) progressTextArea.textContent = progressText; const stateClassPrefix = 'state-'; body.className = Array.from(body.classList) .filter(cls => !cls.startsWith(stateClassPrefix)) .join(' ') + ` ${stateClassPrefix}${currentState}`; body.classList.toggle('workout-active', !['idle', 'finished'].includes(currentState)); }
    function getIconForState(state){ switch(state){ case 'exercise': return 'fa-dumbbell'; case 'break': return 'fa-hourglass-half'; case 'preparing': return 'fa-spinner'; case 'paused': return 'fa-pause-circle'; case 'finished': return 'fa-check-circle'; case 'idle': return 'fa-play-circle'; default: return 'fa-question-circle'; }}
    function getIconForType(type){ return type === 'exercise' ? 'fa-dumbbell' : 'fa-hourglass-half'; }
    function setState(newState) { if (!startPauseBtn || !skipBtn || !finishBtn || !resetBtn || !timerStateDisplay || !workoutSection || !timerDisplayElement || !prevBtn) { console.error("setState: Éléments DOM critiques manquants."); return; } const previousState = currentState; if (previousState === newState && newState !== 'idle') { console.log(`State: Déjà en état '${newState}'.`); /* return; */ } currentState = newState; console.log(`Changement d'état: ${previousState} -> ${newState}`); clearInterval(timerInterval); clearInterval(prepareCountdownInterval); clearTimeout(halfwayTimeoutId); // Annuler son mi-pause
        if(timerStateDisplay) { timerStateDisplay.classList.remove('preparing'); timerStateDisplay.classList.toggle('visible', newState !== 'idle'); } if(timerDisplayElement) timerDisplayElement.classList.remove('finished-animation'); const stateClassPrefix = 'state-'; document.body.className = Array.from(document.body.classList) .filter(cls => !cls.startsWith(stateClassPrefix)) .join(' ') + ` ${stateClassPrefix}${currentState}`; document.body.classList.toggle('workout-active', !['idle', 'finished'].includes(newState)); if(startPauseBtn) startPauseBtn.className = ''; if(startPauseBtn) startPauseBtn.disabled = true; if(skipBtn) skipBtn.disabled = true; if(prevBtn) prevBtn.disabled = true; /* Désactiver Précédent par défaut */ if(finishBtn) finishBtn.disabled = true; if(resetBtn) resetBtn.disabled = true; const isTimerActive = ['preparing', 'exercise', 'break', 'paused'].includes(newState); navButtons.forEach(btn => { if(btn) btn.disabled = !(googleAccessToken && programsLoaded && !isTimerActive); }); if(navHistoryBtn) navHistoryBtn.disabled = isTimerActive; if(navProgressBtn) navProgressBtn.disabled = !googleAccessToken || isTimerActive; hideRepAdjustmentOverlay(); switch (newState) { case 'idle': isTimerRunning=false; isWorkoutActive=false; workoutFinished=false; timeLeft=0; totalTime=0;
             const isLoggedInIdle = !!googleAccessToken; const hasWorkoutTypeIdle = !!currentWorkoutType; const planIsValidIdle = !!currentWorkoutPlan && Array.isArray(currentWorkoutPlan) && currentWorkoutPlan.length > 0; const canStartIdle = isLoggedInIdle && programsLoaded && hasWorkoutTypeIdle && planIsValidIdle; console.log(`setState('idle'): Check start -> isLoggedIn: ${isLoggedInIdle}, programsLoaded: ${programsLoaded}, hasWorkoutType: ${hasWorkoutTypeIdle}, planIsValid: ${planIsValidIdle}, Result(canStart): ${canStartIdle}`);
             if(startPauseBtn) startPauseBtn.disabled = !canStartIdle;
             if(startPauseBtn) { startPauseBtn.innerHTML = `<i class="fas ${getIconForState('idle')}"></i> Démarrer`; startPauseBtn.className = 'start-btn'; } if(resetBtn) resetBtn.disabled = !(googleAccessToken && !!currentWorkoutType); prevBtn.disabled = true; break; case 'preparing': isWorkoutActive=true; if(timerStateDisplay) timerStateDisplay.classList.add('preparing'); prepareTimeLeft = PREPARE_DURATION; if(startPauseBtn) { startPauseBtn.innerHTML = `<i class="fas ${getIconForState('preparing')} fa-spin"></i> Prêt...`; startPauseBtn.className = 'preparing-btn'; startPauseBtn.disabled = true; } if(resetBtn) resetBtn.disabled = !googleAccessToken; if(prevBtn) prevBtn.disabled = true; startPrepareCountdown(); if (!workoutStartTime) workoutStartTime = Date.now(); break; case 'exercise': isWorkoutActive=true; isTimerRunning = false; timeLeft=0; totalTime=0; if (googleAccessToken) { if(startPauseBtn) { startPauseBtn.disabled=false; startPauseBtn.innerHTML=`<i class="fas ${getIconForType('exercise')}"></i> Fait`; startPauseBtn.className='done-btn'; } if(skipBtn) skipBtn.disabled=false; if(prevBtn) prevBtn.disabled = currentItemIndex <= 0; if(finishBtn) finishBtn.disabled=false; if(resetBtn) resetBtn.disabled=false; } findNextExerciseForAdjustment(); break; case 'break': isTimerRunning=true; isWorkoutActive=true; if (googleAccessToken) { if(startPauseBtn) { startPauseBtn.disabled=false; startPauseBtn.innerHTML=`<i class="fas ${getIconForState('paused')}"></i> Pause`; startPauseBtn.className='pause-btn'; } if(skipBtn) skipBtn.disabled=false; if(prevBtn) prevBtn.disabled = currentItemIndex <= 0; if(finishBtn) finishBtn.disabled=false; if(resetBtn) resetBtn.disabled=false; } startBreakTimer(); findNextExerciseForAdjustment(); break; case 'paused': isTimerRunning=false; isWorkoutActive=true; if (googleAccessToken) { if(startPauseBtn) { startPauseBtn.disabled=false; startPauseBtn.innerHTML=`<i class="fas fa-play"></i> Reprendre`; startPauseBtn.className='resume-btn'; } if(skipBtn) skipBtn.disabled=false; if(prevBtn) prevBtn.disabled = currentItemIndex <= 0; if(finishBtn) finishBtn.disabled=false; if(resetBtn) resetBtn.disabled=false; } break; case 'finished': isWorkoutActive=false; isTimerRunning = false; workoutFinished=true; wasFinishedState=true; timeLeft=0; totalTime=0; elapsedWorkoutEstimatedSeconds=totalWorkoutEstimatedSeconds; if(startPauseBtn) { startPauseBtn.disabled=true; startPauseBtn.innerHTML=`<i class="fas ${getIconForState('finished')}"></i> Terminé`; startPauseBtn.className='finished-btn'; } if(skipBtn) skipBtn.disabled = true; if(prevBtn) prevBtn.disabled = true; if(finishBtn) finishBtn.disabled = true; if(resetBtn) resetBtn.disabled = !googleAccessToken; showMessage('Entraînement terminé ! 💪', 3000); vibrate([150, 50, 150]); playSound(soundET); originalCompletedWorkoutPlan = JSON.parse(JSON.stringify(currentWorkoutPlan)); saveWorkoutToHistory(); clearInProgressState(); if(timerDisplayElement) timerDisplayElement.classList.add('finished-animation'); setTimeout(populateAndShowSummary, 500); break; default: console.error("État inconnu rencontré:", newState); currentState = 'idle'; updateAuthUI(!!googleAccessToken); break; } updateTimerDisplay(); updateWorkoutInfo(); }
    function startPrepareCountdown() { if (prepareCountdownInterval) clearInterval(prepareCountdownInterval); prepareTimeLeft = PREPARE_DURATION; updateTimerDisplay(); updateWorkoutInfo(); if(timerStateDisplay) timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`; prepareCountdownInterval = setInterval(() => { prepareTimeLeft--; updateTimerDisplay(); updateWorkoutInfo(); if(timerStateDisplay) timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`; if (prepareTimeLeft <= 0) { clearInterval(prepareCountdownInterval); playTransitionSound(); vibrate(); const firstItem = currentWorkoutPlan[0]; if (!firstItem) { resetCurrentWorkout(); return; } const nextState = firstItem.type === 'exercise' ? 'exercise' : 'break'; setState(nextState); if (nextState === 'break') { totalTime = firstItem.duration || 0; timeLeft = totalTime; } saveInProgressState(); } }, 1000); }
    function startBreakTimer() {
        if (timerInterval) clearInterval(timerInterval);
        updateTimerDisplay(); // Afficher temps initial

        // Gérer le son de mi-pause
        clearTimeout(halfwayTimeoutId); // Annuler le précédent
        const halfwayPoint = Math.floor(totalTime / 2);
        const halfwayTriggerTime = halfwayPoint + 5; // 5s avant mi-temps
        if (totalTime >= 10 && timeLeft > halfwayTriggerTime) { // Condition pour déclencher son mi-temps
             const delay = (timeLeft - halfwayTriggerTime) * 1000;
             if (delay >= 0) {
                  console.log(`Programmation du son mi-pause dans ${delay/1000}s (timeLeft: ${timeLeft}, trigger: ${halfwayTriggerTime})`);
                  halfwayTimeoutId = setTimeout(() => {
                      console.log("Playing halfway sound");
                      playSound(soundWindows);
                  }, delay);
             }
        }

        timerInterval = setInterval(() => {
            if (timeLeft > 0) {
                timeLeft--;
                updateTimerDisplay();
                saveInProgressState();
                // Gérer le compte à rebours
                if (timeLeft === 5) playSound(sound5);
                else if (timeLeft === 4) playSound(sound4);
                else if (timeLeft === 3) playSound(sound3);
                else if (timeLeft === 2) playSound(sound2);
                else if (timeLeft === 1) playSound(sound1);
            } else {
                clearInterval(timerInterval);
                clearTimeout(halfwayTimeoutId); // Assurer annulation si fin exacte
                handleItemCompletion(true); // Gérer fin de pause naturelle
            }
        }, 1000);
    }
    function handleItemCompletion(naturalEnd = false) {
        clearTimeout(halfwayTimeoutId); // Annuler son mi-pause si on passe
        if (!['exercise', 'break', 'paused'].includes(currentState)) return;
        playTransitionSound(); // Jouer son de fin d'étape

        const completedItemIndex = currentItemIndex;
        const completedItem = currentWorkoutPlan[completedItemIndex];
        if (completedItem?.estimatedDuration) { elapsedWorkoutEstimatedSeconds += completedItem.estimatedDuration; }
        if (completedItem?.type === 'exercise' && currentRepAdjustment !== 0) { const baseReps = completedItem.reps || 0; completedItem.actualReps = Math.max(0, baseReps + currentRepAdjustment); console.log(`Reps ajustées pour ${completedItem.name}: ${baseReps} + (${currentRepAdjustment}) = ${completedItem.actualReps}`); currentRepAdjustment = 0; }

        // Vibration seulement si fin naturelle de pause
        if (naturalEnd && currentState === 'break') { vibrate(); }

        currentItemIndex++;
        saveInProgressState();
        if (currentItemIndex >= currentWorkoutPlan.length) { setState('finished'); }
        else { const nextItem = currentWorkoutPlan[currentItemIndex]; if (!nextItem) { setState('finished'); return; } const nextState = nextItem.type === 'exercise' ? 'exercise' : 'break'; setState(nextState); if (nextState === 'break') { totalTime = nextItem.duration || 0; timeLeft = totalTime; } }
    }
    function handlePreviousClick() {
        if (!isWorkoutActive || currentItemIndex <= 0) return;
        clearTimeout(halfwayTimeoutId); // Annuler son mi-pause
        console.log(`Retour à l'étape précédente (depuis index ${currentItemIndex})`);

        // Retirer la durée estimée de l'étape ACTUELLE (qu'on quitte prématurément)
        const currentItemLeaving = currentWorkoutPlan[currentItemIndex];
        if (currentItemLeaving?.estimatedDuration && elapsedWorkoutEstimatedSeconds > 0) {
             elapsedWorkoutEstimatedSeconds = Math.max(0, elapsedWorkoutEstimatedSeconds - currentItemLeaving.estimatedDuration);
        }

        currentItemIndex--; // Aller à l'index précédent

        // Retirer aussi la durée de l'étape précédente (celle où on retourne) car elle va être refaite
         const previousItemReturningTo = currentWorkoutPlan[currentItemIndex];
         if (previousItemReturningTo?.estimatedDuration && elapsedWorkoutEstimatedSeconds > 0) {
              elapsedWorkoutEstimatedSeconds = Math.max(0, elapsedWorkoutEstimatedSeconds - previousItemReturningTo.estimatedDuration);
         }

        const previousState = currentWorkoutPlan[currentItemIndex].type === 'exercise' ? 'exercise' : 'break';
        console.log(`Nouvel index: ${currentItemIndex}, Nouvel état: ${previousState}`);

        // Réinitialiser le temps pour la nouvelle étape
        if (previousState === 'break') {
            totalTime = currentWorkoutPlan[currentItemIndex].duration || 0;
            timeLeft = totalTime; // Recommencer la pause
        } else {
            timeLeft = 0;
            totalTime = 0;
        }
        currentRepAdjustment = 0; // Annuler ajustement en cours

        setState(previousState); // Appliquer le nouvel état
        saveInProgressState(); // Sauvegarder le nouvel état
        showMessage("Retour à l'étape précédente.", 1500);
        playTransitionSound(); // Son pour indiquer le changement
        vibrate([50,50,50]); // Vibration distincte pour retour
    }
    function forceFinishWorkout() { if (!isWorkoutActive || workoutFinished || currentState === 'preparing') return; if (confirm("Êtes-vous sûr de vouloir terminer l'entraînement maintenant ?")) { clearTimeout(halfwayTimeoutId); clearInterval(timerInterval); clearInterval(prepareCountdownInterval); setState('finished'); showMessage("Entraînement terminé manuellement.", 2500); } }
    function loadWorkout(type) {
        console.log(`Tentative de chargement: ${type}`);
        if (!googleAccessToken) { showMessage("Connectez-vous pour charger un entraînement.", 3000, true); return; }
        if (!programsLoaded) { showMessage("Programmes non disponibles. Attente du chargement...", 3000, true); return; }

        console.log(`Vérification loadedWorkouts['${type}'] :`, loadedWorkouts[type]);

        // Vérification renforcée du programme chargé
        if (!loadedWorkouts[type] || !Array.isArray(loadedWorkouts[type])) {
            showMessage(`Erreur: Programme "${type}" invalide ou non trouvé.`, 4000, true);
            console.error(`Programme invalide pour "${type}". Données:`, loadedWorkouts[type]);
            currentWorkoutType = null; setActiveWorkoutNav(null); setState('idle'); return;
        }
        // **Vérifier si le programme est vide**
        if (loadedWorkouts[type].length === 0) {
            showMessage(`Attention: Le programme "${type}" est vide. Impossible de démarrer.`, 4000, true);
            currentWorkoutType = type; setActiveWorkoutNav(type);
            currentWorkoutPlan = []; // Assurer plan vide
            setState('idle'); return; // Bouton démarrer restera désactivé
        }

        // Confirmation si autre workout actif
        if (isWorkoutActive && currentWorkoutType !== type) { if (!confirm(`Un entraînement "${currentWorkoutType}" est en cours. Voulez-vous l'arrêter et charger "${type}" ?`)) { setActiveWorkoutNav(currentWorkoutType); return; } resetCurrentWorkout(); }
        else if (currentState === 'finished' && currentWorkoutType !== type) { resetCurrentWorkout(); }
        else if (currentWorkoutType === type && (isWorkoutActive || currentState === 'idle' || currentState === 'finished')) { showMessage(`"${type}" est déjà ${currentState === 'idle' ? 'sélectionné' : (currentState === 'finished' ? 'terminé' : 'en cours')}. Utilisez Reset pour recommencer.`, 3000); showSection('workout-section'); setActiveWorkoutNav(type); return; }

        console.log(`Chargement du programme: ${type}`);
        currentWorkoutType = type;
        currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[type]));
        console.log("currentWorkoutPlan après copie (longueur):", currentWorkoutPlan?.length); // Vérifier la longueur

        totalWorkoutEstimatedSeconds = calculateTotalEstimatedTime(currentWorkoutPlan);
        elapsedWorkoutEstimatedSeconds = 0; currentItemIndex = 0; workoutStartTime = null;
        isTimerRunning = false; isWorkoutActive = false; workoutFinished = false; currentRepAdjustment = 0;

        setActiveWorkoutNav(type); showSection('workout-section'); closeSummary(false);
        setState('idle'); // **CRUCIAL: déclenche updateAuthUI avec les nouvelles conditions**
        showMessage(`Programme "${type}" chargé. Prêt à démarrer !`, 2500);
    }
    function resetCurrentWorkout() { console.log("Réinitialisation de l'entraînement..."); clearTimeout(halfwayTimeoutId); clearInterval(timerInterval); clearInterval(prepareCountdownInterval); const typeReset = currentWorkoutType; currentWorkoutType=null; currentWorkoutPlan=[]; originalCompletedWorkoutPlan=[]; currentItemIndex=0; workoutStartTime=null; isTimerRunning=false; isWorkoutActive=false; workoutFinished=false; wasFinishedState=false; timeLeft=0; totalTime=0; prepareTimeLeft=0; totalWorkoutEstimatedSeconds=0; elapsedWorkoutEstimatedSeconds=0; currentRepAdjustment=0; clearInProgressState(); closeSummary(false); if(timerDisplayElement) timerDisplayElement.classList.remove('finished-animation'); setActiveWorkoutNav(null); showSection('workout-section'); setState('idle'); if (typeReset) { showMessage(`Entraînement "${typeReset}" réinitialisé.`, 2000); } }
    function showMessage(msg, duration = 3000, isError = false) { if (!messageArea) return; messageArea.textContent = msg; messageArea.style.backgroundColor = isError ? 'var(--neon-red)' : 'rgba(var(--secondary-bg-color-dark-rgb), 0.9)'; messageArea.style.color = isError ? '#fff' : 'var(--primary-text-color)'; messageArea.style.borderColor = isError ? 'var(--neon-red)' : 'var(--border-color)'; messageArea.classList.add('visible'); if (messageTimeoutId) clearTimeout(messageTimeoutId); messageTimeoutId = setTimeout(() => { messageArea.classList.remove('visible'); }, duration); }

    // --- Gestion Thème ---
    function applyTheme(theme) { const body = document.body; currentTheme = theme; body.classList.remove('light-theme', 'dark-theme'); body.classList.add(theme + '-theme'); if (themeToggleBtn) { themeToggleBtn.innerHTML = theme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>'; themeToggleBtn.setAttribute('aria-label', theme === 'dark' ? 'Passer au thème clair' : 'Passer au thème sombre'); } try { localStorage.setItem('theme', theme); console.log(`Thème appliqué et sauvegardé: ${theme}`); } catch (e) { console.warn("Impossible de sauvegarder le thème dans localStorage:", e); } updateChartColors(); }
    function toggleTheme() { const newTheme = currentTheme === 'dark' ? 'light' : 'dark'; applyTheme(newTheme); }
    function loadSavedTheme() { let savedTheme = 'dark'; try { savedTheme = localStorage.getItem('theme') || 'dark'; } catch (e) { console.warn("Impossible de lire le thème depuis localStorage:", e); } applyTheme(savedTheme); }

    // --- Navigation & Affichage Sections ---
    function showSection(sectionId) { const sections = [workoutSection, historySection, progressSection]; const navLinks = { 'workout-section': [...navButtons], 'history-section': [navHistoryBtn], 'progress-section': [navProgressBtn] }; sections.forEach(section => section?.classList.add('section-hidden')); Object.values(navLinks).flat().forEach(btn => btn?.classList.remove('active')); const sectionToShow = document.getElementById(sectionId); if (sectionToShow) { sectionToShow.classList.remove('section-hidden'); console.log(`Affichage section: ${sectionId}`); const linksToActivate = navLinks[sectionId]; if (linksToActivate) { if (sectionId === 'workout-section' && currentWorkoutType) { const activeWorkoutBtn = document.getElementById(`nav-${currentWorkoutType.toLowerCase()}`); activeWorkoutBtn?.classList.add('active'); } else { linksToActivate.forEach(btn => btn?.classList.add('active')); } } } else { console.error(`Section introuvable: ${sectionId}`); } }
    function setActiveWorkoutNav(type) { navButtons.forEach(btn => { if(btn) btn.classList.toggle('active', btn.dataset.workout === type); }); if (type) { showSection('workout-section'); } }

    // --- Gestion Historique & Statistiques ---
    function displayHistory(period = 'week') { if (!historyList || !statsDisplay || !historyChartCanvasEl) return; if (!googleAccessToken) { historyList.innerHTML = '<li class="no-history">Connectez-vous pour voir l\'historique.</li>'; if(statsContentWrapper) statsContentWrapper.innerHTML = '<p>Connectez-vous pour voir les statistiques.</p>'; clearCharts(); setChartPlaceholder('history-chart-canvas', "Connectez-vous pour voir le graphique."); return; } console.log(`Affichage historique pour période: ${period}`); currentHistoryPeriod = period; historyFilterBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.period === period)); const filteredHistory = filterHistoryByPeriod(workoutHistory, period); renderHistoryList(filteredHistory); calculateAndDisplayStats(filteredHistory); renderHistoryChart(filteredHistory); }
    function filterHistoryByPeriod(history, period) { const now = new Date(); let startDate = new Date(); switch (period) { case 'week': startDate.setDate(now.getDate() - 7); break; case 'month': startDate.setMonth(now.getMonth() - 1); break; case 'year': startDate.setFullYear(now.getFullYear() - 1); break; case 'all': return history; default: startDate.setDate(now.getDate() - 7); } startDate.setHours(0, 0, 0, 0); return history.filter(entry => new Date(entry.date) >= startDate); }
    function renderHistoryList(filteredHistory) {
        if (!historyList) return;
        if (filteredHistory.length === 0) {
            historyList.innerHTML = '<li class="no-history">Aucun entraînement enregistré pour cette période.</li>';
            return;
        }
        historyList.innerHTML = filteredHistory
            .sort((a, b) => new Date(b.date) - new Date(a.date))
            .map(entry => {
                const date = new Date(entry.date);
                const formattedDate = date.toLocaleDateString('fr-FR', { weekday: 'short', day: '2-digit', month: 'short' });
                const formattedTime = date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                const durationSeconds = entry.durationSeconds || 0;
                const formattedDuration = durationSeconds > 0 ? formatTime(durationSeconds) : 'N/A';
                const type = entry.type || 'Inconnu';
                const totalReps = entry.totalReps ?? '?'; // Utiliser totalReps

                return `
                    <li>
                        <span class="history-item-date">
                            ${formattedDate} <small>(${formattedTime})</small>
                        </span>
                        <span class="history-item-type">${type}</span>
                         <span class="history-item-reps"><i class="fas fa-hashtag"></i> ${totalReps}</span>
                        <span class="history-item-duration">${formattedDuration}</span>
                    </li>
                `;
            }).join('');
    }
    function calculateAndDisplayStats(filteredHistory) {
        if (!statsContentWrapper || !statsDisplay) return;
        const numWorkouts = filteredHistory.length;
        let totalDuration = 0;
        let workoutTypes = {};
        let totalRepsSum = 0; // Utiliser totalRepsSum au lieu de volume
        filteredHistory.forEach(entry => {
            totalDuration += entry.durationSeconds || 0;
            const type = entry.type || 'Inconnu';
            workoutTypes[type] = (workoutTypes[type] || 0) + 1;
            totalRepsSum += entry.totalReps || 0; // Sommer les reps totales par entrée
        });
        const avgDuration = numWorkouts > 0 ? totalDuration / numWorkouts : 0;
        const avgReps = numWorkouts > 0 ? Math.round(totalRepsSum / numWorkouts) : 0;
        const formattedAvgDuration = formatTime(avgDuration);
        let statsHtml = `<p><i class="fas fa-calendar-check"></i> Séances: <strong>${numWorkouts}</strong></p>`;
        if (numWorkouts > 0) {
            statsHtml += `<p><i class="fas fa-stopwatch"></i> Durée totale: <strong>${formatTime(totalDuration)}</strong></p>`;
            statsHtml += `<p><i class="fas fa-clock"></i> Durée moyenne: <strong>${formattedAvgDuration}</strong></p>`;
            statsHtml += `<p><i class="fas fa-hashtag"></i> Reps totales: <strong>${totalRepsSum}</strong> (Moy: ${avgReps})</p>`;
            // Ligne volume retirée
            statsHtml += `<p><i class="fas fa-tags"></i> Répartition:</p><ul>`;
            for (const type in workoutTypes) {
                statsHtml += `<li style="margin-left: 25px; font-size: 0.95em;">- ${type}: ${workoutTypes[type]}</li>`;
            }
            statsHtml += `</ul>`;
        } else {
            statsHtml += '<p>Aucune donnée pour calculer les statistiques.</p>';
        }
        statsContentWrapper.innerHTML = statsHtml;
        const motivationalMessage = statsDisplay.querySelector('.motivational-message');
        if (motivationalMessage) { if (numWorkouts > 5) motivationalMessage.textContent = "Super régularité ! Continuez comme ça ! 💪"; else if (numWorkouts > 0) motivationalMessage.textContent = "Chaque séance compte ! Bien joué !"; else motivationalMessage.textContent = "Prêt à commencer votre première séance ?"; }
    }
    // --- Fonctions Graphiques (MAJ pour Durée) ---
    function aggregateChartData(hist, period, metric = 'durationSeconds') { // Ajout paramètre métrique
        const agg = new Map();
        let labels = [];

        switch (period) {
            case 'week':
                labels = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim'];
                labels.forEach(l => agg.set(l, 0));
                const nowW = new Date();
                const todayW = new Date(nowW.getFullYear(), nowW.getMonth(), nowW.getDate());
                const wd = todayW.getDay(); // 0=Dim, 1=Lun, ..., 6=Sam
                const diff = todayW.getDate() - wd + (wd === 0 ? -6 : 1); // Premier jour de la semaine (Lundi)
                const startW = new Date(nowW.getFullYear(), nowW.getMonth(), diff);
                startW.setHours(0, 0, 0, 0);
                hist.forEach(e => {
                    const d = new Date(e.date);
                    if (d >= startW) {
                        let dayIndex = d.getDay(); dayIndex = dayIndex === 0 ? 6 : dayIndex - 1; // Ajuster pour Lun=0, Dim=6
                        const value = metric === 'durationSeconds' ? (e.durationSeconds || 0) : (e.totalReps || 0); // Utiliser reps si demandé
                        agg.set(labels[dayIndex], (agg.get(labels[dayIndex]) || 0) + value);
                    }
                });
                break;
            case 'month':
                 labels = ['S1-7', 'S8-14', 'S15-21', 'S22-28', 'S29+'];
                 labels.forEach(l => agg.set(l, 0));
                 const curM = new Date().getMonth(); const curY = new Date().getFullYear();
                 hist.forEach(e => {
                     const d = new Date(e.date);
                     if (d.getMonth() === curM && d.getFullYear() === curY) {
                         const dayOfMonth = d.getDate(); let weekIndex = 0;
                         if (dayOfMonth <= 7) weekIndex = 0; else if (dayOfMonth <= 14) weekIndex = 1;
                         else if (dayOfMonth <= 21) weekIndex = 2; else if (dayOfMonth <= 28) weekIndex = 3;
                         else weekIndex = 4;
                         const value = metric === 'durationSeconds' ? (e.durationSeconds || 0) : (e.totalReps || 0);
                         agg.set(labels[weekIndex], (agg.get(labels[weekIndex]) || 0) + value);
                     }
                 });
                 break;
            case 'year':
                 labels = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc'];
                 labels.forEach(l => agg.set(l, 0));
                 const curY2 = new Date().getFullYear();
                 hist.forEach(e => {
                     const d = new Date(e.date);
                     if (d.getFullYear() === curY2) {
                         const monthIndex = d.getMonth(); // 0=Jan, 11=Dec
                         const value = metric === 'durationSeconds' ? (e.durationSeconds || 0) : (e.totalReps || 0);
                         agg.set(labels[monthIndex], (agg.get(labels[monthIndex]) || 0) + value);
                     }
                 });
                 break;
            default: // 'all'
                 const yearData = {};
                 hist.forEach(e => {
                     const y = new Date(e.date).getFullYear();
                     if (!isNaN(y)) {
                         const value = metric === 'durationSeconds' ? (e.durationSeconds || 0) : (e.totalReps || 0);
                         yearData[y] = (yearData[y] || 0) + value;
                     }
                 });
                 labels = Object.keys(yearData).map(Number).sort((a, b) => a - b).map(String);
                 labels.forEach(y => agg.set(y, yearData[y]));
                 break;
        }
        return { labels, data: labels.map(l => agg.get(l) || 0) };
    }
    function getChartXAxisTitle(period){ switch(period){ case 'week': return 'Jour (Sem. Courante)'; case 'month': return 'Semaine (Mois Courant)'; case 'year': return 'Mois (Année Courante)'; default: return 'Année'; }}

    function renderHistoryChart(filteredHistory) {
        if (!historyChartCanvasEl) { console.warn("Canvas historique introuvable"); return; }
        const ctx = historyChartCanvasEl.getContext('2d');
        if (!ctx) return;

        // **Utilisation de la durée pour l'historique**
        const { labels, data } = aggregateChartData(filteredHistory, currentHistoryPeriod, 'durationSeconds');

        if (labels.length === 0 || data.every(d => d === 0)) {
            setChartPlaceholder('history-chart-canvas', "Aucune donnée d'entraînement pour cette période.");
            if (historyChartInstance) { historyChartInstance.destroy(); historyChartInstance = null; }
            return;
        } else {
            setChartPlaceholder('history-chart-canvas', "", false);
        }

        const styles = getComputedStyle(document.documentElement);
        const primColor = styles.getPropertyValue('--neon-blue').trim();
        const primColorRgb = styles.getPropertyValue('--neon-blue-rgb');
        const gridColor = styles.getPropertyValue('--accent-border-color').trim();
        const textColor = styles.getPropertyValue('--secondary-text-color').trim();
        const tooltipBg = `rgba(${styles.getPropertyValue('--secondary-bg-color-dark-rgb')}, 0.8)`;
        const tooltipText = styles.getPropertyValue('--primary-text-color').trim();

        const chartData = {
            labels,
            datasets: [{
                label: 'Durée (min)',
                data: data.map(d => Math.round(d / 60)), // Convertir en minutes
                backgroundColor: `rgba(${primColorRgb}, 0.6)`,
                borderColor: primColor,
                borderWidth: 1,
                borderRadius: 3,
                hoverBackgroundColor: `rgba(${primColorRgb}, 0.8)`,
                hoverBorderColor: primColor
            }]
        };

        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { beginAtZero: true, title: { display: true, text: 'Minutes', color: textColor }, ticks: { color: textColor, callback: v => v + 'm' }, grid: { color: gridColor } },
                x: { title: { display: true, text: getChartXAxisTitle(currentHistoryPeriod), color: textColor }, ticks: { color: textColor }, grid: { display: false } }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: tooltipBg, titleColor: tooltipText, bodyColor: tooltipText,
                    padding: 10, cornerRadius: 4, displayColors: false,
                    callbacks: {
                        label: ctx => `Durée: ${formatTime(data[ctx.dataIndex] || 0)}` // Afficher MM:SS
                    }
                }
            }
        };

        if (historyChartInstance) {
            historyChartInstance.data = chartData;
            historyChartInstance.options = chartOptions; // Réappliquer pour le thème
            historyChartInstance.update();
        } else {
            historyChartInstance = new Chart(ctx, { type: 'bar', data: chartData, options: chartOptions }); // Type 'bar'
        }
    }
    function updateChartColors() {
        const styles = getComputedStyle(document.documentElement);
        const textColor = styles.getPropertyValue('--secondary-text-color').trim();
        const gridColor = styles.getPropertyValue('--accent-border-color').trim();
        const tooltipBg = `rgba(${styles.getPropertyValue('--secondary-bg-color-dark-rgb')}, 0.8)`;
        const tooltipText = styles.getPropertyValue('--primary-text-color').trim();
        const primColor = styles.getPropertyValue('--neon-blue').trim();
        const secColor = styles.getPropertyValue('--neon-green').trim(); // Pour le volume (retiré)
        const terColor = styles.getPropertyValue('--neon-pink').trim(); // Potentiel pour 2ème axe exo
        const primColorRgb = styles.getPropertyValue('--neon-blue-rgb');
        const secColorRgb = styles.getPropertyValue('--neon-green-rgb');
        const terColorRgb = styles.getPropertyValue('--neon-pink-rgb');

        [historyChartInstance, exercisePerfChartInstance /* volumeLoadChartInstance retiré */].forEach(chartInstance => {
            if (chartInstance) {
                try {
                    // Options générales
                    chartInstance.options.scales.x.ticks.color = textColor;
                    chartInstance.options.scales.x.grid.color = gridColor;
                     if (chartInstance.options.scales.x.title) chartInstance.options.scales.x.title.color = textColor;
                    chartInstance.options.scales.y.ticks.color = textColor;
                    chartInstance.options.scales.y.grid.color = gridColor;
                     if (chartInstance.options.scales.y.title) chartInstance.options.scales.y.title.color = textColor;
                     // Spécifique à l'axe Y secondaire (si existe)
                    if(chartInstance.options.scales.yMetric) { // Axe principal progression
                         chartInstance.options.scales.yMetric.ticks.color = textColor;
                         chartInstance.options.scales.yMetric.grid.color = gridColor;
                         if (chartInstance.options.scales.yMetric.title) chartInstance.options.scales.yMetric.title.color = textColor;
                    }
                     if(chartInstance.options.scales.yReps) { // Axe secondaire (si activé plus tard)
                         chartInstance.options.scales.yReps.ticks.color = textColor;
                         if (chartInstance.options.scales.yReps.title) chartInstance.options.scales.yReps.title.color = textColor;
                    }
                    chartInstance.options.plugins.tooltip.backgroundColor = tooltipBg;
                    chartInstance.options.plugins.tooltip.titleColor = tooltipText;
                    chartInstance.options.plugins.tooltip.bodyColor = textColorTooltip;

                    // Options spécifiques aux datasets
                    chartInstance.data.datasets.forEach((dataset, i) => {
                        let mainColor = primColor;
                         let mainColorRgb = primColorRgb;
                        // if (chartInstance === volumeLoadChartInstance) { // Condition retirée
                        //     mainColor = secColor; mainColorRgb = secColorRgb;
                        // } else
                        if (chartInstance === exercisePerfChartInstance) { // Graphique progression exo
                           mainColor = primColor; mainColorRgb = primColorRgb; // Toujours bleu pour la métrique principale
                             if(i === 1) { // Si 2ème dataset (ex: reps)
                                 mainColor = terColor; mainColorRgb = terColorRgb;
                             }
                        } else if (chartInstance === historyChartInstance) { // Graphique historique (barres)
                            mainColor = primColor; mainColorRgb = primColorRgb;
                        }

                        dataset.borderColor = mainColor;
                        dataset.backgroundColor = `rgba(${mainColorRgb}, ${chartInstance.config.type === 'bar' || dataset.fill ? 0.6 : 0.2})`;
                        if(dataset.pointBackgroundColor) dataset.pointBackgroundColor = mainColor;
                        if(dataset.pointBorderColor) dataset.pointBorderColor = mainColor;
                        if(dataset.hoverBackgroundColor) dataset.hoverBackgroundColor = `rgba(${mainColorRgb}, 0.8)`;
                        if(dataset.hoverBorderColor) dataset.hoverBorderColor = mainColor;
                    });

                    chartInstance.update('none');
                } catch(e) {
                    console.error("Erreur pendant updateChartColors:", e, "sur chart:", chartInstance);
                }
            }
        });
    }
    function clearCharts() { [historyChartInstance, exercisePerfChartInstance /* volumeLoadChartInstance retiré */].forEach((chartInstance, index) => { if (chartInstance) { chartInstance.destroy(); } }); historyChartInstance = null; exercisePerfChartInstance = null; /* volumeLoadChartInstance = null; */ setChartPlaceholder('history-chart-canvas', ''); setChartPlaceholder('exercise-progress-chart', ''); /* setChartPlaceholder('volume-chart', ''); */ }
    function setChartPlaceholder(canvasId, message, show = true) {
        const placeholderId = canvasId.replace('-canvas', '-placeholder');
        const placeholder = document.getElementById(placeholderId);
        const canvasEl = document.getElementById(canvasId);

        if (placeholder && canvasEl) {
            placeholder.textContent = message;
            placeholder.style.display = show ? 'block' : 'none';
            canvasEl.style.opacity = show ? '0.3' : '1';
            canvasEl.style.display = show ? 'none' : 'block';
        } else {
            if (!placeholder) console.warn(`Placeholder introuvable avec ID: ${placeholderId} (pour canvas ${canvasId})`);
            if (!canvasEl) console.warn(`Canvas introuvable pour ID: ${canvasId}`);
        }
    }


    // --- Gestion Progression ---
    function populateExerciseSelect() { if (!exerciseSelect || !workoutHistory) return; const uniqueExercises = new Set(); workoutHistory.forEach(entry => { entry.exercises?.forEach(ex => uniqueExercises.add(ex.name)); }); const sortedExercises = Array.from(uniqueExercises).sort(); exerciseSelect.innerHTML = '<option value="all">Tous les exercices (Total Reps)</option>'; // Texte maj
        sortedExercises.forEach(exName => { const option = document.createElement('option'); option.value = exName; option.textContent = exName; exerciseSelect.appendChild(option); }); displayExerciseProgress(); /* displayVolumeLoad() retiré */ }
    function displayExerciseProgress() {
        if (!exerciseProgressChartCanvasEl) { console.warn("Canvas progression exercice introuvable"); return; }
        const ctx = exerciseProgressChartCanvasEl.getContext('2d');
        if (!ctx) return;

        if (!googleAccessToken) { setChartPlaceholder('exercise-progress-chart', "Connectez-vous pour voir la progression."); if (exercisePerfChartInstance) { exercisePerfChartInstance.destroy(); exercisePerfChartInstance = null; } return; }

        const selectedExercise = exerciseSelect.value;
        // const selectedMetric = metricSelect.value; // Retiré
        const selectedPeriod = periodSelect.value;
        const filteredHistory = filterHistoryByPeriod(workoutHistory, selectedPeriod);

        let chartData;
        let chartOptions;
        let chartType = 'line'; // Défaut

        if (selectedExercise === 'all') {
            // --- LOGIQUE POUR "Tous les exercices" ---
            console.log("Affichage Progression: Tous les exercices (Total Reps)");
            const { labels, data } = aggregateChartData(filteredHistory, selectedPeriod, 'totalReps'); // Agréger par totalReps

            if (labels.length === 0 || data.every(d => d === 0)) {
                setChartPlaceholder('exercise-progress-chart', "Aucune donnée de répétition pour cette période.");
                 if (exercisePerfChartInstance) { exercisePerfChartInstance.destroy(); exercisePerfChartInstance = null; }
                return;
            } else {
                setChartPlaceholder('exercise-progress-chart', "", false);
            }

            const styles = getComputedStyle(document.documentElement);
            const primColor = styles.getPropertyValue('--neon-purple').trim(); // Violet pour le total
            const primColorRgb = styles.getPropertyValue('--neon-purple-rgb');
            const gridColor = styles.getPropertyValue('--accent-border-color').trim();
            const textColor = styles.getPropertyValue('--secondary-text-color').trim();
            const tooltipBg = `rgba(${styles.getPropertyValue('--secondary-bg-color-dark-rgb')}, 0.8)`;
            const tooltipText = styles.getPropertyValue('--primary-text-color').trim();

             chartData = {
                labels,
                datasets: [{
                    label: 'Total Répétitions par Séance',
                    data: data,
                    borderColor: primColor,
                    backgroundColor: `rgba(${primColorRgb}, 0.5)`,
                    tension: 0.1,
                    fill: true, // Rendre comme un area chart
                    pointRadius: 2,
                    pointBackgroundColor: primColor,
                }]
            };
             chartOptions = {
                responsive: true, maintainAspectRatio: false,
                scales: {
                    x: { ticks: { color: textColor }, grid: { display: false }, title: {display: true, text: getChartXAxisTitle(selectedPeriod), color: textColor} }, // Utiliser le titre X dynamique
                    y: { beginAtZero: true, title: { display: true, text: 'Total Répétitions', color: textColor }, ticks: { color: textColor }, grid: { color: gridColor } }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: tooltipBg, titleColor: tooltipText, bodyColor: tooltipText,
                        padding: 10, cornerRadius: 4, displayColors: false,
                        callbacks: {
                            title: (tooltipItems) => tooltipItems[0]?.label || '', // Afficher le label de l'axe X (jour, semaine, mois, année)
                            label: (context) => `Total Reps: ${context.parsed.y}`
                        }
                    }
                }
            };
            chartType = 'line'; // Garder en ligne/aire pour le total

        } else {
            // --- LOGIQUE POUR UN EXERCICE SPECIFIQUE (Reps uniquement) ---
            console.log(`Affichage Progression: Exercice ${selectedExercise} (Reps)`);
            const exerciseData = [];
            filteredHistory.forEach(entry => { entry.exercises?.forEach(ex => { if (ex.name === selectedExercise) { exerciseData.push({ date: new Date(entry.date), reps: ex.actualReps ?? ex.reps ?? 0 }); } }); });
            exerciseData.sort((a, b) => a.date - b.date);

            if (exerciseData.length === 0) { setChartPlaceholder('exercise-progress-chart', "Aucune donnée pour cet exercice/période."); if (exercisePerfChartInstance) { exercisePerfChartInstance.destroy(); exercisePerfChartInstance = null; } return; }
            else { setChartPlaceholder('exercise-progress-chart', "", false); }

            const labels = exerciseData.map(d => d.date.toLocaleDateString('fr-CA'));
            const styles = getComputedStyle(document.documentElement);
            const primColor = styles.getPropertyValue('--neon-blue').trim();
            const primColorRgb = styles.getPropertyValue('--neon-blue-rgb');
            const gridColor = styles.getPropertyValue('--accent-border-color').trim();
            const textColor = styles.getPropertyValue('--secondary-text-color').trim();
            const tooltipBg = `rgba(${styles.getPropertyValue('--secondary-bg-color-dark-rgb')}, 0.8)`;
            const tooltipText = styles.getPropertyValue('--primary-text-color').trim();

            chartData = {
                labels,
                datasets: [{
                    label: 'Répétitions',
                    data: exerciseData.map(d => d.reps),
                    borderColor: primColor,
                    backgroundColor: `rgba(${primColorRgb}, 0.2)`,
                    tension: 0.3, fill: false,
                    pointRadius: 3, pointBackgroundColor: primColor, pointBorderColor: primColor, pointHoverRadius: 5,
                    yAxisID: 'yMetric' // Renommé pour cohérence (même si une seule métrique)
                }]
            };
            chartOptions = {
                responsive: true, maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    x: { ticks: { color: textColor }, grid: { display: false }, title: {display: true, text: 'Date', color: textColor} },
                    yMetric: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Répétitions', color: textColor }, ticks: { color: textColor }, grid: { color: gridColor } }
                },
                plugins: {
                     legend: { display: false },
                     tooltip: {
                         backgroundColor: tooltipBg, titleColor: tooltipText, bodyColor: tooltipText,
                         padding: 10, cornerRadius: 4, displayColors: false,
                         callbacks: {
                             title: (tooltipItems) => tooltipItems[0] ? new Date(tooltipItems[0].label).toLocaleDateString('fr-FR') : '',
                             label: (context) => `${context.dataset.label}: ${context.parsed.y}`
                         }
                     }
                }
            };
             chartType = 'line';
        }

        // Mise à jour ou création du graphique
        if (exercisePerfChartInstance) {
             // Si le type de graphique change (ligne vs barre/aire), il faut détruire et recréer
             if (exercisePerfChartInstance.config.type !== chartType) {
                 exercisePerfChartInstance.destroy();
                 exercisePerfChartInstance = new Chart(ctx, { type: chartType, data: chartData, options: chartOptions });
             } else {
                 exercisePerfChartInstance.data = chartData;
                 exercisePerfChartInstance.options = chartOptions;
                 exercisePerfChartInstance.update();
             }
        } else {
            exercisePerfChartInstance = new Chart(ctx, { type: chartType, data: chartData, options: chartOptions });
        }
    }
    // function displayVolumeLoad() retirée

    // --- Résumé Post-Workout (Modal) ---
    function populateAndShowSummary() {
        if (!postWorkoutSummary || !summaryItemsList || !finishSummaryBtn) { console.error("Éléments du modal de résumé manquants."); return; }
        const planToSummarize = originalCompletedWorkoutPlan;
        if(summaryTitle) summaryTitle.textContent = `Résumé & Objectifs Prochaine Séance (${currentWorkoutType || '?'})`;
        if(summaryItemsList) {
            summaryItemsList.innerHTML = ''; // Vider
            planToSummarize.forEach((item, index) => {
                 if (item.type === 'exercise') { // Afficher seulement les exercices
                    const li = document.createElement('li');
                    li.classList.add('summary-item');
                    li.dataset.originalIndex = index; // Stocker l'index original du plan

                    const performedReps = item.actualReps ?? item.reps ?? 0;
                    const nextTargetReps = item.reps ?? 0; // Cible initiale = reps prévues

                    // Champ pour les répétitions de la *prochaine* séance
                    let contentHtml = `
                        <div class="exercise-name">
                             <i class="fas ${getIconForType(item.type)}" style="color:var(--color-exercise)"></i>
                            ${item.name || 'Exercice'}
                            <small>(${performedReps} fait)</small>
                        </div>
                        <div class="input-container">
                            <label for="next-reps-${index}">Prochain objectif:</label>
                            <input type="number" id="next-reps-${index}" value="${nextTargetReps}" min="0" step="1" placeholder="Reps">
                        </div>`;
                     li.innerHTML = contentHtml;
                     summaryItemsList.appendChild(li);
                 }
            });
        }
        if(finishSummaryBtn) finishSummaryBtn.disabled = false; // Bouton Fin toujours actif
        if(postWorkoutSummary) postWorkoutSummary.classList.add('visible');
    }
    // Les fonctions handleSummaryAdjustClick et handleSummaryInputChange sont retirées

    // Fonction pour le bouton "Fin" du modal (sauvegarde les objectifs)
    async function finishSummary() {
        console.log("Clic sur 'Fin & Sauvegarder Objectifs'...");
        if (!googleAccessToken || !currentWorkoutType || !programFileIds[currentWorkoutType]) {
            showMessage("Erreur: Non connecté ou ID programme manquant pour sauvegarder les objectifs.", 4000, true);
            resetCurrentWorkout(); // Reset même si erreur sauvegarde objectifs
            return;
        }
        if (isSavingDriveData) {
            showMessage("Sauvegarde déjà en cours...", 2000);
            return;
        }

        // 1. Lire les nouvelles cibles de répétitions et mettre à jour loadedWorkouts
        let changesMade = false;
        const programToUpdate = loadedWorkouts[currentWorkoutType]; // Référence directe pour MAJ
        summaryItemsList.querySelectorAll('.summary-item[data-original-index]').forEach(li => {
             const index = parseInt(li.dataset.originalIndex, 10);
             const input = li.querySelector(`#next-reps-${index}`);
             if (input && programToUpdate[index] && programToUpdate[index].type === 'exercise') {
                 const nextRepsRaw = input.value.trim();
                 const nextReps = nextRepsRaw === '' ? null : parseInt(nextRepsRaw, 10);
                 if (nextReps !== null && (!isNaN(nextReps) && nextReps >= 0)) {
                      if (programToUpdate[index].reps !== nextReps) {
                          console.log(`Mise à jour objectif reps pour ${programToUpdate[index].name} (index ${index}): ${programToUpdate[index].reps} -> ${nextReps}`);
                          programToUpdate[index].reps = nextReps; // MAJ direct sur loadedWorkouts
                          changesMade = true;
                      }
                 } else if (nextRepsRaw !== '' ) {
                     console.warn(`Valeur invalide ignorée pour ${programToUpdate[index].name}: ${nextRepsRaw}`);
                 }
             }
        });

        // 2. Sauvegarder le programme mis à jour si des changements ont été faits
        if (changesMade) {
             console.log("Sauvegarde des nouveaux objectifs de répétitions sur Drive...");
             if(finishSummaryBtn) {
                 finishSummaryBtn.disabled = true;
                 finishSummaryBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Sauvegarde...`;
             }
             const success = await updateFileContent(programFileIds[currentWorkoutType], programToUpdate);
             if (success) {
                 showMessage(`Objectifs pour "${currentWorkoutType}" mis à jour !`, 2500);
             } else {
                 showMessage(`Échec sauvegarde objectifs sur Drive pour ${currentWorkoutType}.`, 5000, true);
             }
              // Réactiver bouton même si échec sauvegarde pour permettre fermeture
             if(finishSummaryBtn) {
                  finishSummaryBtn.disabled = false;
                  finishSummaryBtn.innerHTML = `<i class="fas fa-check"></i> Fin`;
             }
        } else {
            console.log("Aucun changement d'objectif de répétitions détecté.");
        }

        // 3. Réinitialiser l'état (ferme aussi le modal)
        resetCurrentWorkout();
    }

    function closeSummary(updateUI = true) { // Gardée mais ne fait que masquer
        if(postWorkoutSummary) postWorkoutSummary.classList.remove('visible');
        if (updateUI) {
            setState(currentState); // Mettre à jour l'UI (ex: réactiver boutons si état idle)
        }
    }

    // --- Sauvegarde & Chargement (Drive & LocalStorage) ---
    async function saveHistoryToDrive() { if (!googleAccessToken) return; if (isSavingDriveData) { console.log("Sauvegarde Drive déjà en cours..."); return; } console.log("Tentative de sauvegarde de l'historique sur Drive..."); if (!historyFileId) { historyFileId = await findOrCreateFile(HISTORY_FILENAME, JSON.stringify([])); } if (historyFileId) { await updateFileContent(historyFileId, workoutHistory); } else { console.error("Impossible d'obtenir l'ID du fichier historique pour la sauvegarde."); showMessage("Erreur: Fichier historique Drive inaccessible.", 5000, true); } }
    async function loadHistoryFromDrive() { if (!googleAccessToken) return; console.log("Chargement de l'historique depuis Drive..."); historyFileId = await findOrCreateFile(HISTORY_FILENAME, JSON.stringify([])); if (historyFileId) { const content = await readFileContent(historyFileId); if (content !== null) { try { workoutHistory = JSON.parse(content || "[]"); console.log(`Historique chargé depuis Drive (${workoutHistory.length} entrées).`); } catch (e) { console.error("Erreur parsing JSON historique depuis Drive:", e); showMessage("Erreur: Format historique Drive invalide. Utilisation d'un historique vide.", 5000, true); workoutHistory = []; } } else { console.warn("Lecture du fichier historique Drive échouée. Utilisation d'un historique vide."); workoutHistory = []; } } else { console.error("Impossible d'obtenir l'ID du fichier historique pour le chargement."); showMessage("Erreur: Fichier historique Drive inaccessible.", 5000, true); workoutHistory = []; } displayHistory(currentHistoryPeriod); }
    async function saveProgramsToDrive() { /* ... (Code inchangé, sauvegarde loadedWorkouts[type]) ... */ if (!googleAccessToken) return; /* Retiré !programsLoaded */ if (isSavingDriveData) { console.log("Sauvegarde Drive déjà en cours..."); return; } console.log("Sauvegarde des programmes sur Drive..."); let allSaved = true; for (const type of PROGRAM_TYPES) { if (!programFileIds[type]) { const defaultProgContent = defaultWorkouts[type] ? JSON.stringify(defaultWorkouts[type], null, 2) : '[]'; programFileIds[type] = await findOrCreateFile(PROGRAM_FILENAMES[type], defaultProgContent); } if (programFileIds[type]) { const success = await updateFileContent(programFileIds[type], loadedWorkouts[type] || []); if (!success) allSaved = false; } else { console.error(`Impossible d'obtenir l'ID pour le programme ${type}.`); allSaved = false; } } if (allSaved) { showMessage("Programmes sauvegardés sur Drive.", 2500); } else { showMessage("Erreur lors de la sauvegarde de certains programmes sur Drive.", 5000, true); } }
    async function loadProgramsFromDrive() {
        if (!googleAccessToken) return false;
        console.log("Chargement des programmes depuis Drive...");
        let allLoadedSuccessfully = true;
        loadedWorkouts = {};
        for (const type of PROGRAM_TYPES) {
            console.log(`Chargement du programme: ${type}...`);
            programFileIds[type] = await findOrCreateFile(PROGRAM_FILENAMES[type], JSON.stringify(defaultWorkouts[type] || [], null, 2));
            if (programFileIds[type]) {
                const content = await readFileContent(programFileIds[type]);
                if (content !== null) {
                    try {
                        loadedWorkouts[type] = JSON.parse(content || '[]');
                        console.log(`Programme ${type} parsé avec succès (${loadedWorkouts[type].length} étapes).`);
                    } catch (e) {
                        console.error(`Erreur parsing JSON programme ${type}:`, e, "Contenu:", content);
                        showMessage(`Erreur format programme ${type}. Utilisation du défaut.`, 4000, true);
                        loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type] || []));
                        allLoadedSuccessfully = false;
                    }
                } else {
                     console.warn(`Lecture programme ${type} échouée (readFileContent a retourné null). Utilisation du défaut.`);
                    loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type] || []));
                    allLoadedSuccessfully = false;
                }
            } else {
                console.error(`Impossible d'obtenir l'ID pour le programme ${type}. Utilisation du défaut.`);
                loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultWorkouts[type] || []));
                allLoadedSuccessfully = false;
            }
             console.log(`Fin du traitement pour ${type}. Success partiel: ${allLoadedSuccessfully}`);
        }
        console.log("Fin de la boucle de chargement des programmes (loadProgramsFromDrive). Résultat global:", allLoadedSuccessfully, "Données:", loadedWorkouts);
        return allLoadedSuccessfully; // Retourne le succès global du chargement
    }
    function saveInProgressState() { if (!isWorkoutActive || currentState === 'preparing') return; if (typeof localStorage === 'undefined') return; const stateToSave = { currentWorkoutType, currentItemIndex, timeLeft: currentState === 'break' || currentState === 'paused' ? timeLeft : 0, currentState, workoutStartTime, currentWorkoutPlan, totalWorkoutEstimatedSeconds, elapsedWorkoutEstimatedSeconds, timestamp: Date.now() }; try { localStorage.setItem(IN_PROGRESS_KEY, JSON.stringify(stateToSave)); console.log("État en cours sauvegardé localement."); } catch (e) { console.warn("Échec sauvegarde état en cours dans localStorage:", e); } }
    function loadInProgressState() { if (typeof localStorage === 'undefined') return; if (!googleAccessToken) return; try { const savedStateJSON = localStorage.getItem(IN_PROGRESS_KEY); if (!savedStateJSON) return; const savedState = JSON.parse(savedStateJSON); const maxAge = 24 * 60 * 60 * 1000; if (Date.now() - savedState.timestamp > maxAge) { console.log("État sauvegardé trop ancien, ignoré."); clearInProgressState(); return; } if (confirm(`Un entraînement "${savedState.currentWorkoutType}" était en cours. Voulez-vous le reprendre ?`)) { console.log("Reprise de l'entraînement sauvegardé..."); currentWorkoutType = savedState.currentWorkoutType; currentItemIndex = savedState.currentItemIndex; currentState = savedState.currentState; workoutStartTime = savedState.workoutStartTime; currentWorkoutPlan = savedState.currentWorkoutPlan; totalWorkoutEstimatedSeconds = savedState.totalWorkoutEstimatedSeconds; elapsedWorkoutEstimatedSeconds = savedState.elapsedWorkoutEstimatedSeconds; if (currentState === 'break' || (currentState === 'paused' && currentWorkoutPlan[currentItemIndex]?.type === 'break')) { totalTime = currentWorkoutPlan[currentItemIndex]?.duration || 0; timeLeft = Math.max(0, Math.min(savedState.timeLeft, totalTime)); } else { timeLeft = 0; totalTime = 0; } setActiveWorkoutNav(currentWorkoutType); showSection('workout-section'); setState(currentState); showMessage(`Entraînement "${currentWorkoutType}" repris.`, 3000); } else { console.log("Reprise annulée par l'utilisateur."); clearInProgressState(); } } catch (e) { console.error("Erreur lors du chargement/parsing de l'état sauvegardé:", e); clearInProgressState(); } }
    function clearInProgressState() { if (typeof localStorage === 'undefined') return; try { localStorage.removeItem(IN_PROGRESS_KEY); console.log("État en cours supprimé de localStorage."); } catch (e) { console.warn("Échec suppression état en cours de localStorage:", e); } }
    function saveWorkoutToHistory() {
        if (!googleAccessToken || !originalCompletedWorkoutPlan || originalCompletedWorkoutPlan.length === 0) {
            console.log("Sauvegarde historique annulée (non connecté ou plan vide).");
            return;
        }
        const endTime = Date.now();
        const durationSeconds = workoutStartTime ? (endTime - workoutStartTime) / 1000 : 0;

        // Calcul du total des répétitions
        let totalReps = 0;
        originalCompletedWorkoutPlan.forEach(item => {
            if (item.type === 'exercise') {
                totalReps += item.actualReps ?? item.reps ?? 0;
            }
        });

        const historyEntry = {
            date: new Date(workoutStartTime || endTime).toISOString(),
            type: currentWorkoutType || 'Inconnu',
            durationSeconds: Math.round(durationSeconds),
            totalReps: totalReps, // Ajout du total des reps
            exercises: originalCompletedWorkoutPlan.map(item => ({ ...item })) // Copie pour éviter refs
        };

        workoutHistory.unshift(historyEntry); // Ajouter au début pour tri facile
        console.log("Entraînement ajouté à l'historique local:", historyEntry);

        saveHistoryToDrive(); // Sauvegarde asynchrone

        // Mettre à jour affichages
        displayHistory(currentHistoryPeriod);
        populateExerciseSelect();
        displayExerciseProgress();
        // displayVolumeLoad(); // Retiré
    }
    function exportHistory() { if (!googleAccessToken) { showMessage("Connectez-vous pour exporter.", 3000, true); return; } if (workoutHistory.length === 0) { showMessage("Historique vide, rien à exporter.", 3000); return; } try { const jsonData = JSON.stringify(workoutHistory, null, 2); const blob = new Blob([jsonData], { type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; const dateStr = new Date().toISOString().split('T')[0]; a.download = `armorworkout_history_${dateStr}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); showMessage("Historique exporté avec succès.", 2500); } catch (e) { console.error("Erreur lors de l'export de l'historique:", e); showMessage("Erreur lors de l'exportation.", 4000, true); } }

    // --- Gestion Overlay Ajustement Répétitions ---
    function showRepAdjustmentOverlay() { if (!isWorkoutActive || currentState === 'finished' || currentState === 'preparing' || currentState === 'paused') return; // *Ne pas montrer si en pause*
        const itemForAdjustment = currentWorkoutPlan[nextExerciseIndexForAdjustment]; if (!itemForAdjustment || itemForAdjustment.type !== 'exercise') { hideRepAdjustmentOverlay(); return; } if(repAdjustmentExerciseName) repAdjustmentExerciseName.textContent = itemForAdjustment.name; const baseReps = itemForAdjustment.reps || 0; if(currentRepsDisplay) currentRepsDisplay.textContent = Math.max(0, baseReps + currentRepAdjustment); if (!isRepAdjustmentVisible && repAdjustmentOverlay) { repAdjustmentOverlay.classList.add('visible'); isRepAdjustmentVisible = true; } }
    function hideRepAdjustmentOverlay() { if (isRepAdjustmentVisible && repAdjustmentOverlay) { repAdjustmentOverlay.classList.remove('visible'); isRepAdjustmentVisible = false; } }
    function handleRepAdjustClick(event) { const adjustment = event.target.id === 'rep-adjust-plus' ? 1 : -1; currentRepAdjustment += adjustment; const itemForAdjustment = currentWorkoutPlan[nextExerciseIndexForAdjustment]; if (itemForAdjustment && currentRepsDisplay) { const baseReps = itemForAdjustment.reps || 0; currentRepsDisplay.textContent = Math.max(0, baseReps + currentRepAdjustment); } console.log(`Ajustement reps: ${currentRepAdjustment}`); }
    function findNextExerciseForAdjustment() { nextExerciseIndexForAdjustment = -1; if (!currentWorkoutPlan) return; for (let i = currentItemIndex + 1; i < currentWorkoutPlan.length; i++) { if (currentWorkoutPlan[i].type === 'exercise') { nextExerciseIndexForAdjustment = i; return; } } }

    // --- Initialisation Générale ---
    function initializeDOMReferences() {
        console.log("Début initializeDOMReferences");
        try {
            timeLeftDisplay = document.getElementById('time-left');
            timerCircle = document.getElementById('timer-circle');
            timerStateDisplay = document.getElementById('timer-state');
            currentExerciseContainer = document.getElementById('current-exercise-container');
            progressTracker = document.getElementById('progress-tracker');
            startPauseBtn = document.getElementById('start-pause-btn');
            skipBtn = document.getElementById('skip-btn');
            finishBtn = document.getElementById('finish-btn');
            resetBtn = document.getElementById('reset-btn');
            prevBtn = document.getElementById('prev-btn'); // Nouveau bouton
            themeToggleBtn = document.getElementById('theme-toggle-btn');
            messageArea = document.getElementById('message-area');
            workoutSection = document.getElementById('workout-section');
            historySection = document.getElementById('history-section');
            progressSection = document.getElementById('progress-section');
            historyList = document.getElementById('history-list');
            statsDisplay = document.getElementById('stats-display');
            statsContentWrapper = statsDisplay?.querySelector('.content-wrapper');
            historyFilterBtns = Array.from(document.querySelectorAll('.history-filters button'));
            historyChartCanvasEl = document.getElementById('history-chart-canvas');
            exerciseProgressChartCanvasEl = document.getElementById('exercise-progress-chart');
            // volumeChartCanvasEl retiré
            signInButton = document.getElementById('signin-button');
            signOutButton = document.getElementById('signout-button');
            exportButton = document.getElementById('export-button');
            driveStatusElement = document.getElementById('drive-status');
            postWorkoutSummary = document.getElementById('post-workout-summary');
            summaryTitle = document.getElementById('summary-title');
            summaryItemsList = document.getElementById('summary-items-list');
            finishSummaryBtn = document.getElementById('finish-summary-btn'); // Utiliser le nouvel ID
            historyDriveStatus = document.getElementById('history-drive-status');
            totalProgressCircle = document.getElementById('total-progress-circle');
            currentExerciseNameDisplay = document.getElementById('current-exercise-name-display');
            driveConnectionStatusMain = document.getElementById('drive-connection-status-main');
            driveConnectionText = document.getElementById('drive-connection-text');
            timerDisplayElement = document.querySelector('.timer-display');
            progressTextArea = document.getElementById('progress-text-area');
            historyActionsContainer = document.querySelector('.history-actions');
            exerciseSelect = document.getElementById('exercise-select');
            metricSelect = document.getElementById('metric-select');
            periodSelect = document.getElementById('period-select');
            exerciseChartPlaceholder = document.getElementById('exercise-progress-placeholder');
            // volumeChartPlaceholder retiré
            repAdjustmentOverlay = document.getElementById('rep-adjustment-overlay');
            repAdjustMinusBtn = document.getElementById('rep-adjust-minus');
            repAdjustPlusBtn = document.getElementById('rep-adjust-plus');
            currentRepsDisplay = document.getElementById('current-reps-display');
            repAdjustmentExerciseName = document.getElementById('rep-adjustment-exercise-name');
            navHistoryBtn = document.getElementById('nav-history');
            navProgressBtn = document.getElementById('nav-progress');
            navButtons = [ document.getElementById('nav-push'), document.getElementById('nav-pull'), document.getElementById('nav-legs') ];
            console.log("Fin initializeDOMReferences");
        } catch (e) {
            console.error("Erreur critique pendant initializeDOMReferences:", e);
             showMessage("Erreur critique lors de l'initialisation de la page.", 10000, true);
        }
    }

    function addEventListeners() {
        console.log("Début addEventListeners");
        // Utilisation de if(element) pour vérifier avant d'ajouter
        if (startPauseBtn) {
            startPauseBtn.addEventListener('click', () => {
                initAudioContext(); // Toujours essayer d'activer l'audio
                if (currentState === 'idle') setState('preparing');
                else if (currentState === 'exercise') handleItemCompletion(false);
                else if (currentState === 'break') setState('paused');
                else if (currentState === 'paused') setState(currentWorkoutPlan[currentItemIndex]?.type === 'exercise' ? 'exercise' : 'break');
            });
        } else console.warn("Élément introuvable: start-pause-btn");

        if (skipBtn) { skipBtn.addEventListener('click', () => { initAudioContext(); if (isWorkoutActive) handleItemCompletion(false); }); }
        else console.warn("Élément introuvable: skip-btn");

        if (prevBtn) { prevBtn.addEventListener('click', () => { initAudioContext(); handlePreviousClick(); }); } // Ajouter listener pour Précédent
        else console.warn("Élément introuvable: prev-btn");

        if (finishBtn) { finishBtn.addEventListener('click', () => { initAudioContext(); forceFinishWorkout(); }); }
        else console.warn("Élément introuvable: finish-btn");

         if (resetBtn) { resetBtn.addEventListener('click', () => { initAudioContext(); resetCurrentWorkout(); }); }
         else console.warn("Élément introuvable: reset-btn");

        navButtons.forEach((btn, index) => {
             const type = ['Push', 'Pull', 'Legs'][index];
             if (btn) { btn.addEventListener('click', () => { initAudioContext(); loadWorkout(btn.dataset.workout); }); }
             else console.warn(`Élément introuvable: nav-${type.toLowerCase()}`);
        });

        if(navHistoryBtn) navHistoryBtn.addEventListener('click', () => { initAudioContext(); showSection('history-section'); });
        else console.warn("Élément introuvable: nav-history");

        if(navProgressBtn) navProgressBtn.addEventListener('click', () => { initAudioContext(); showSection('progress-section'); });
        else console.warn("Élément introuvable: nav-progress");

        historyFilterBtns.forEach(btn => {
            if(btn) btn.addEventListener('click', () => { initAudioContext(); displayHistory(btn.dataset.period); });
            else console.warn("Un bouton de filtre historique est introuvable");
        });

         if(exerciseSelect) exerciseSelect.addEventListener('change', displayExerciseProgress);
         else console.warn("Élément introuvable: exercise-select");
         // Listener pour metricSelect retiré
         if(periodSelect) periodSelect.addEventListener('change', () => { displayExerciseProgress(); /* displayVolumeLoad() retiré */ });
         else console.warn("Élément introuvable: period-select");

         if(themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme);
         else console.warn("Élément introuvable: theme-toggle-btn");

         if(signInButton) signInButton.addEventListener('click', handleAuthClick);
         else console.warn("Élément introuvable: signin-button");

         if(signOutButton) signOutButton.addEventListener('click', handleSignoutClick);
         else console.warn("Élément introuvable: signout-button");

         if(exportButton) exportButton.addEventListener('click', exportHistory);
         else console.warn("Élément introuvable: export-button");

         if(finishSummaryBtn) finishSummaryBtn.addEventListener('click', finishSummary); // MAJ pour nouveau bouton
         else console.warn("Élément introuvable: finish-summary-btn");

         // Listener pour fermer modal en cliquant dehors
         if(postWorkoutSummary) postWorkoutSummary.addEventListener('click', (e) => { if (e.target === postWorkoutSummary) finishSummary(); }); // Appelle finishSummary
         else console.warn("Élément introuvable: post-workout-summary");

         if(timerDisplayElement) timerDisplayElement.addEventListener('click', () => { initAudioContext(); if (isWorkoutActive && currentState !== 'preparing' && currentState !== 'finished' && currentState !== 'paused') { /* Ne pas montrer pendant pause */ if (nextExerciseIndexForAdjustment !== -1) { showRepAdjustmentOverlay(); } } });
         else console.warn("Élément introuvable: timer-display");
         if(repAdjustMinusBtn) repAdjustMinusBtn.addEventListener('click', handleRepAdjustClick);
         else console.warn("Élément introuvable: rep-adjust-minus");
         if(repAdjustPlusBtn) repAdjustPlusBtn.addEventListener('click', handleRepAdjustClick);
         else console.warn("Élément introuvable: rep-adjust-plus");
         if(repAdjustmentOverlay) repAdjustmentOverlay.addEventListener('click', (e) => { if (e.target === repAdjustmentOverlay) hideRepAdjustmentOverlay(); });
         else console.warn("Élément introuvable: rep-adjustment-overlay");

        document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'hidden' && isWorkoutActive) { saveInProgressState(); } });
        window.addEventListener('beforeunload', () => { if (isWorkoutActive) saveInProgressState(); });
        console.log("Fin addEventListeners");
    }

    // --- Point d'entrée ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Chargé. Initialisation ArmorWorkout...");
        try {
            initializeDOMReferences();
            initSounds(); // Initialiser les sons
            addEventListeners();
            loadSavedTheme();
            setState('idle');
            updateAuthUI(!!googleAccessToken);

            // Lancer la vérification de l'API Google après le chargement du DOM
            checkAndInitGis();

            // Afficher messages initiaux dans les placeholders (utilise ID HTML)
            setChartPlaceholder('history-chart-canvas', "Connectez-vous pour voir le graphique.");
            setChartPlaceholder('exercise-progress-chart', "Connectez-vous et sélectionnez un exercice.");
            // setChartPlaceholder('volume-chart', "Connectez-vous pour voir le volume."); // Retiré
            console.log("Initialisation terminée. Attente de l'API Google...");
        } catch (error) {
             console.error("Erreur majeure lors de l'initialisation DOMContentLoaded:", error);
             const body = document.querySelector('body');
             if (body) {
                 const errorDiv = document.createElement('div');
                 errorDiv.textContent = "Erreur critique au chargement. Vérifiez la console (F12).";
                 errorDiv.style.position = 'fixed'; errorDiv.style.top = '0'; errorDiv.style.left = '0'; errorDiv.style.width = '100%';
                 errorDiv.style.padding = '20px'; errorDiv.style.backgroundColor = 'red'; errorDiv.style.color = 'white';
                 errorDiv.style.zIndex = '9999'; errorDiv.style.textAlign = 'center';
                 body.prepend(errorDiv); // Ajoute au début du body
             }
        }
    });

</script>

</body>
</html>
