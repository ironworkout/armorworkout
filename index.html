<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Timer d'Entraînement</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- Google Identity Services (GIS) - chargé à la fin -->
    <style>
        /* --- Variables Globales & Thèmes --- */
        :root {
            /* Thème Sombre (Inspiré de l'image) */
            --bg-color-dark: #0D1117;
            --secondary-bg-color-dark: #161B22;
            --primary-text-color-dark: #c9d1d9;
            --secondary-text-color-dark: #8b949e;
            --border-color-dark: #30363d;
            --accent-border-color-dark: #8b949e;
            --neon-blue: #00aeff;
            --neon-pink: #e54ac5;
            --neon-red: #ff4d4d;
            --neon-yellow: #facc15;
            --neon-green: #2ecc71;
            --glow-blue: 0 0 15px rgba(0, 174, 255, 0.5);
            --glow-pink: 0 0 15px rgba(229, 74, 197, 0.5);
            --glow-red: 0 0 10px rgba(255, 77, 77, 0.5);
            --glow-yellow: 0 0 10px rgba(250, 204, 21, 0.4);
            --glow-green: 0 0 10px rgba(46, 204, 113, 0.4);
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius-lg: 12px;
            --border-radius-md: 8px;
            --border-radius-sm: 6px;
            --transition-speed: 0.25s;

            /* Initialisation Thème Sombre par Défaut */
            --bg-color: var(--bg-color-dark);
            --secondary-bg-color: var(--secondary-bg-color-dark);
            --primary-text-color: var(--primary-text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --border-color: var(--border-color-dark);
            --accent-border-color: var(--accent-border-color-dark);
            --current-step-color: var(--neon-blue);
            --current-step-glow: var(--glow-blue);
            --total-progress-gradient: conic-gradient(from 180deg, var(--neon-blue), var(--neon-pink) 60%, var(--neon-blue));
            --total-progress-bg: #2a2f36;
            --button-reset-color: var(--neon-red);
            --button-reset-glow: var(--glow-red);
            --button-next-color: var(--neon-pink);
            --button-next-glow: var(--glow-pink);
            --button-end-color: var(--secondary-text-color-dark);
            --button-end-glow: none;
            --button-start-color: var(--neon-blue);
            --button-start-glow: var(--glow-blue);
            --button-pause-color: var(--neon-yellow);
            --button-pause-glow: var(--glow-yellow);
            --button-connect-color: var(--neon-green);
            --button-connect-glow: var(--glow-green);
            --button-disconnect-color: var(--neon-red);
            --button-disconnect-glow: var(--glow-red);
            --link-color: var(--neon-blue);

            /* --- Variables RGBA Helper --- */
            --neon-blue-rgb: 0, 174, 255;
            --neon-pink-rgb: 229, 74, 197;
            --neon-red-rgb: 255, 77, 77;
            --neon-yellow-rgb: 250, 204, 21;
            --neon-green-rgb: 46, 204, 113;
            --secondary-text-color-dark-rgb: 139, 148, 158;
            --bg-color-dark-rgb: 13, 17, 23;
            --secondary-bg-color-dark-rgb: 22, 27, 34;
            --primary-text-color-dark-rgb: 201, 209, 217;
        }

        body.light-theme {
            /* Styles pour thème clair */
            --bg-color: #ffffff;
            --secondary-bg-color: #f6f8fa;
            --primary-text-color: #24292f;
            --secondary-text-color: #57606a;
            --border-color: #d0d7de;
            --accent-border-color: #8c959f;
            --total-progress-bg: #e1e4e8;
            --button-end-color: #57606a;
            --link-color: #0969da;

            /* Adapter les variables RGBA si nécessaire pour light theme */
            --bg-color-dark-rgb: 255, 255, 255;
            --secondary-bg-color-dark-rgb: 246, 248, 250;
            --primary-text-color-dark-rgb: 36, 41, 47;
            --secondary-text-color-dark-rgb: 87, 96, 106;
        }

        /* --- Styles de Base & Réinitialisation --- */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
            font-size: 16px;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            line-height: 1.6;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 30px 25px;
            width: 100%;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* --- En-tête --- */
        header {
            padding: 20px 0;
            border-bottom: 1px solid var(--border-color);
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
            position: sticky;
            top: 0;
            z-index: 1000;
            background-color: rgba(var(--bg-color-dark-rgb), 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1100px;
            margin: 0 auto;
            padding: 0 25px;
            flex-wrap: wrap;
            gap: 15px 20px;
        }

        header h1 {
            font-size: 1.5em;
            color: var(--primary-text-color);
            margin: 0;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        header h1 i {
            color: var(--neon-blue);
            animation: pulse 2s infinite ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        /* --- Navigation Header --- */
        nav ul {
            list-style: none;
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        nav button {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            font-size: 1em;
            font-weight: 500;
            padding: 5px 0;
            cursor: pointer;
            transition: color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            position: relative;
            border-bottom: 2px solid transparent;
        }

        nav button:disabled {
            color: rgba(var(--primary-text-color-dark-rgb), 0.3);
            cursor: not-allowed;
            border-bottom-color: transparent !important;
            box-shadow: none !important;
        }

        nav button:not(:disabled):hover {
            color: var(--primary-text-color);
        }

        nav button.active {
            color: var(--neon-blue);
            font-weight: 700;
            border-bottom-color: var(--neon-blue);
            box-shadow: 0 5px 15px -5px rgba(var(--neon-blue-rgb), 0.4);
        }

        #nav-history {
            color: var(--secondary-text-color);
            border-bottom-color: transparent;
        }

        #nav-history:hover {
            color: var(--neon-pink);
        }

        #nav-history.active {
            color: var(--neon-pink);
            border-bottom-color: var(--neon-pink);
            box-shadow: 0 5px 15px -5px rgba(var(--neon-pink-rgb), 0.4);
        }

        #nav-history i { margin-right: 5px; }

        /* --- Actions Header --- */
        .header-actions {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .auth-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .auth-controls button, #export-programs-btn {
            background: none;
            border: 1px solid var(--accent-border-color);
            color: var(--secondary-text-color);
            padding: 6px 14px;
            border-radius: var(--border-radius-md);
            font-size: 0.85em;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .auth-controls button:hover, #export-programs-btn:hover {
            border-color: var(--primary-text-color);
            color: var(--primary-text-color);
        }

        #signin-button {
            border-color: var(--button-connect-color);
            color: var(--button-connect-color);
        }
        #signin-button:hover {
            background-color: rgba(var(--neon-green-rgb), 0.1);
            box-shadow: var(--glow-green);
            border-color: var(--neon-green);
        }

        #signout-button {
            border-color: var(--button-disconnect-color);
            color: var(--button-disconnect-color);
        }
        #signout-button:hover {
            background-color: rgba(var(--neon-red-rgb), 0.1);
            box-shadow: var(--glow-red);
            border-color: var(--neon-red);
        }

        #export-programs-btn {
            border-color: var(--neon-pink);
            color: var(--neon-pink);
        }
        #export-programs-btn:hover {
            background-color: rgba(var(--neon-pink-rgb), 0.1);
            box-shadow: var(--glow-pink);
            border-color: var(--neon-pink);
        }

        #drive-status {
            font-size: 0.8em;
            color: var(--secondary-text-color);
            margin-left: 5px;
            transition: opacity 0.3s, color 0.3s, border-color 0.3s;
            min-width: fit-content;
            text-align: right;
            font-style: normal;
            padding: 4px 8px;
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5);
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--border-color);
            display: none; /* Initialement caché */
        }

        #drive-status.loading { color: var(--neon-yellow); border-color: var(--neon-yellow); }
        #drive-status.error { color: var(--neon-red); border-color: var(--neon-red); }
        #drive-status.success { color: var(--neon-green); border-color: var(--neon-green); }

        .theme-toggle button {
            background: none;
            border: none;
            color: var(--secondary-text-color);
            font-size: 1.2em;
            padding: 5px;
            cursor: pointer;
            transition: color var(--transition-speed) ease;
        }
        .theme-toggle button:hover { color: var(--neon-yellow); }

        /* Logique d'affichage connexion/déconnexion */
        body.logged-out #signin-button { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-out #drive-status { display: none; }
        body.logged-out #export-programs-btn { display: none; }
        body.logged-out .history-actions i.fab.fa-google-drive { display: none; }
        body.logged-out #history-drive-status { display: none; }
        body.logged-out #drive-connection-status-main { display: none; }

        body.logged-in #signin-button { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-in #drive-status { display: inline-block; }
        body.logged-in #export-programs-btn { display: inline-flex; }
        body.logged-in .history-actions i.fab.fa-google-drive { display: inline-block; }
        body.logged-in #history-drive-status { display: inline-block; }
        body.logged-in #drive-connection-status-main { display: flex; }


        /* --- Contenu Principal --- */
        main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 50px;
            position: relative;
        }

        .workout-section {
            background-color: transparent;
            padding: 0;
            border: none;
            box-shadow: none;
            width: 100%;
            max-width: 600px;
            text-align: center;
            transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease;
            margin-bottom: 40px;
        }

        .history-section {
            background-color: var(--secondary-bg-color);
            padding: 35px;
            border-radius: var(--border-radius-lg);
            box-shadow: none;
            border: 1px solid var(--border-color);
            width: 100%;
            max-width: 850px;
            text-align: left;
            margin-bottom: 40px;
            transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease;
        }

        .section-hidden {
            transform: scale(0.9) translateY(30px);
            opacity: 0;
            pointer-events: none;
            max-height: 0;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            margin-bottom: 0 !important;
            border: none !important;
            overflow: hidden;
        }

        /* --- Affichage Timer --- */
        .timer-display {
            margin-bottom: 50px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 320px;
            height: 320px;
            margin-left: auto;
            margin-right: auto;
        }

        .timer-circle-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #total-progress-circle, .timer-circle {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 12px solid transparent;
            background-clip: padding-box;
            background-origin: border-box;
            box-sizing: border-box;
        }

        #total-progress-circle {
            border-color: var(--total-progress-bg);
            background-image: var(--total-progress-gradient);
            background-size: 100% 100%;
            box-shadow: 0 0 25px rgba(var(--neon-blue-rgb), 0.3), 0 0 35px rgba(var(--neon-pink-rgb), 0.2), inset 0 0 20px rgba(var(--bg-color-dark-rgb), 0.5);
            z-index: 1;
            transition: background 0.5s ease-out;
            background-repeat: no-repeat;
            background-position: center center;
        }

        .timer-circle {
            width: calc(100% - 48px);
            height: calc(100% - 48px);
            top: 24px;
            left: 24px;
            border-color: var(--border-color);
            background-image: conic-gradient(var(--current-step-color) 0%, transparent 0%);
            background-size: 100% 100%;
            box-shadow: var(--current-step-glow), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6);
            z-index: 3;
            transition: background-image 0.15s linear, box-shadow var(--transition-speed) ease;
            background-repeat: no-repeat;
            background-position: center center;
        }

        .timer-circle::before {
            content: '';
            position: absolute;
            width: calc(100% - 24px); /* Ajusté pour le contenu intérieur */
            height: calc(100% - 24px); /* Ajusté pour le contenu intérieur */
            background-color: var(--bg-color);
            border-radius: 50%;
            z-index: 4;
            transition: background-color var(--transition-speed) ease;
        }

        .time-left {
            font-size: 5.5em;
            font-weight: 900;
            color: var(--primary-text-color);
            z-index: 5;
            transition: color var(--transition-speed) ease;
            font-variant-numeric: tabular-nums;
            position: relative;
            text-shadow: 0 0 10px rgba(var(--primary-text-color-dark-rgb), 0.3);
        }

        .timer-state {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8em;
            letter-spacing: 0.1em;
            color: var(--secondary-text-color);
            font-weight: 500;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.3s ease;
            background-color: transparent;
            padding: 0;
            box-shadow: none;
            z-index: 6;
        }

        .timer-state.visible { opacity: 0.8; }

        .timer-state.preparing {
            color: var(--neon-yellow);
            font-size: 1em;
            animation: countdown-pulse 1s infinite;
        }

        @keyframes countdown-pulse {
            0%, 100% { transform: translateX(-50%) scale(1); opacity: 1; }
            50% { transform: translateX(-50%) scale(1.1); opacity: 0.8; }
        }

        /* --- Infos Exercice --- */
        .workout-info {
            margin-bottom: 40px;
            min-height: 100px; /* Augmenté pour laisser de la place */
            position: relative;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #current-exercise-name-display {
            display: block; /* Toujours visible quand workout active */
            font-size: 1.3em;
            font-weight: 700; /* Plus visible */
            color: var(--primary-text-color);
            margin-bottom: 5px; /* Réduit */
            padding: 0 10px;
            min-height: 1.5em; /* Éviter sauts */
        }
        body:not(.workout-active) #current-exercise-name-display {
             display: none; /* Masquer hors entraînement */
        }

        #current-exercise-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            font-size: 1.1em;
            color: var(--secondary-text-color);
            min-height: 3em; /* Éviter sauts */
        }

        #current-exercise-container .exercise-details {
             display: flex;
             align-items: center;
             gap: 15px;
             background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3);
             padding: 8px 15px;
             border-radius: var(--border-radius-md);
             border: 1px solid var(--border-color);
        }
        #current-exercise-container .exercise-details span {
             display: flex;
             align-items: center;
             gap: 5px;
             font-weight: 500;
        }
        #current-exercise-container .exercise-details span i {
            color: var(--neon-pink);
        }
        #current-exercise-container .exercise-details .details-text {
            font-size: 0.9em;
            opacity: 0.8;
        }

        #current-exercise-container .break-info {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            font-size: 1.1em;
            color: var(--neon-yellow);
        }

        body:not(.workout-active) #current-exercise-container p {
            color: var(--secondary-text-color); /* Texte initial */
            font-size: 1.1em;
            margin-top: 15px;
        }
        body:not(.workout-active) #current-exercise-container .exercise-details,
        body:not(.workout-active) #current-exercise-container .break-info {
             display: none; /* Masquer détails hors entraînement */
        }

        /* --- Progress Tracker (Maintenant utilisé pour l'état général) --- */
        .progress-tracker {
            font-size: 0.9em;
            color: var(--secondary-text-color);
            margin-top: 30px;
            opacity: 0.8;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 1.2em; /* Éviter sauts */
        }

        .progress-tracker i.fa-google-drive { color: var(--neon-green); } /* Renommé pour clarté */


        /* --- Contrôles Timer --- */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 40px;
            flex-wrap: wrap;
        }

        .controls button {
            background: transparent;
            border: 2px solid var(--accent-border-color);
            color: var(--primary-text-color);
            min-width: 120px;
            padding: 12px 25px;
            border-radius: var(--border-radius-lg);
            font-size: 1.1em;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .controls button i { font-size: 0.9em; }

        .controls button:disabled {
            border-color: var(--border-color);
            color: var(--secondary-text-color);
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
            background-color: transparent !important;
        }

        .controls button:not(:disabled):hover { transform: translateY(-2px); }
        .controls button:not(:disabled):active { transform: scale(0.97); }

        #start-pause-btn { border-color: var(--button-start-color); color: var(--button-start-color); }
        #start-pause-btn:not(:disabled):hover { box-shadow: var(--glow-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); }
        #start-pause-btn.pause-btn { border-color: var(--button-pause-color); color: var(--button-pause-color); }
        #start-pause-btn.pause-btn:not(:disabled):hover { box-shadow: var(--glow-yellow); background-color: rgba(var(--neon-yellow-rgb), 0.1); }

        #skip-btn { border-color: var(--button-next-color); color: var(--button-next-color); }
        #skip-btn:not(:disabled):hover { box-shadow: var(--glow-pink); background-color: rgba(var(--neon-pink-rgb), 0.1); }

        #finish-btn { border-color: var(--button-end-color); color: var(--button-end-color); }
        #finish-btn:not(:disabled):hover { background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1); border-color: var(--primary-text-color); color: var(--primary-text-color); }

        #reset-btn { border-color: var(--button-reset-color); color: var(--button-reset-color); }
        #reset-btn:not(:disabled):hover { box-shadow: var(--glow-red); background-color: rgba(var(--neon-red-rgb), 0.1); }

        /* --- Section Historique --- */
        .history-section h2 {
            color: var(--primary-text-color);
            margin-bottom: 25px;
            text-align: center;
        }

        .history-controls {
            padding-bottom: 20px;
            margin-bottom: 25px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .history-filters { display: flex; gap: 10px; flex-wrap: wrap; }

        .history-filters button {
            background-color: transparent;
            border: 1px solid var(--accent-border-color);
            color: var(--secondary-text-color);
            opacity: 1;
            font-size: 0.85em;
            padding: 6px 12px;
            border-radius: var(--border-radius-md);
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        .history-filters button:not(:disabled):hover {
            border-color: var(--primary-text-color);
            color: var(--primary-text-color);
            background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1);
        }
        .history-filters button.active {
            border-color: var(--neon-blue);
            color: var(--neon-blue);
            background-color: rgba(var(--neon-blue-rgb), 0.1);
            font-weight: 500;
            box-shadow: var(--glow-blue);
        }

        .history-actions { display: flex; gap: 15px; align-items: center; color: var(--secondary-text-color); }
        .history-actions i.fab.fa-google-drive { color: var(--neon-green); }
        .history-actions #export-programs-btn { font-size: 0.85em; padding: 6px 12px; margin-right: 0; } /* Style Export ajusté */
        #history-drive-status {
            font-size: 0.8em;
            padding: 3px 6px;
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5);
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--border-color);
        }

        .chart-container {
            height: 350px;
            margin-bottom: 30px;
            background-color: transparent;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            padding: 15px;
            box-shadow: none;
        }

        .stats-display {
            margin-bottom: 30px;
            padding: 20px;
            background-color: transparent;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            box-shadow: none;
        }
        .stats-display h3 { color: var(--primary-text-color); margin-bottom: 15px; font-size: 1.15em;}
        .stats-display p { margin-bottom: 8px; display: flex; align-items: center; gap: 8px;}
        .stats-display p i { width: 16px; text-align: center; color: var(--neon-blue); opacity: 0.8;}
        .stats-display p strong { color: var(--primary-text-color); font-weight: 500; }
        .stats-display p:last-child { margin-bottom: 0; } /* Espace dernier p */

        .motivational-message {
            font-style: italic;
            font-weight: 500;
            margin-top: 15px !important; /* Ajouter de l'espace */
            background: linear-gradient(90deg, var(--neon-green), var(--neon-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-fill-color: transparent;
        }

        .history-list {
            list-style: none;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            background-color: transparent;
            box-shadow: none;
            max-height: 400px;
            overflow-y: auto;
        }
        .history-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.2s ease;
            gap: 15px;
        }
        .history-list li:last-child { border-bottom: none; }
        .history-list li:nth-child(even) { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3); }
        .history-list li:hover { background-color: rgba(var(--neon-blue-rgb), 0.08); transform: none; }

        .history-item-date { color: var(--primary-text-color); font-size: 0.9em; }
        .history-item-date small { color: var(--secondary-text-color); font-size: 0.9em;}
        .history-item-type {
            color: var(--neon-pink);
            background-color: rgba(var(--neon-pink-rgb), 0.1);
            border-radius: var(--border-radius-sm);
            padding: 3px 8px;
            font-size: 0.85em;
            font-weight: 500;
            text-align: center;
            min-width: 50px;
        }
        .history-item-duration { color: var(--neon-blue); font-weight: 500; font-variant-numeric: tabular-nums;}
        .history-list .no-history {
            color: var(--secondary-text-color);
            text-align: center;
            padding: 30px 15px;
            font-style: italic;
            border: none;
            background: none !important;
        }

        /* --- Résumé Post-Workout (MODAL) --- */
        .post-workout-summary {
            position: fixed;
            inset: 0; /* top: 0; left: 0; right: 0; bottom: 0; */
            background-color: rgba(var(--bg-color-dark-rgb), 0.85); /* Fond semi-transparent */
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 2000; /* Au-dessus de tout */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .post-workout-summary.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .post-workout-summary-content {
            background-color: var(--secondary-bg-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-lg);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            width: 100%;
            max-width: 650px; /* Largeur max du contenu */
            max-height: 90vh; /* Hauteur max, pour écrans courts */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Gérer le débordement */
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }
        .post-workout-summary.visible .post-workout-summary-content {
            transform: scale(1);
        }

        .post-workout-summary h2 {
            color: var(--primary-text-color);
            font-size: 1.4em;
            padding: 20px 25px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0; /* Ne pas réduire le titre */
            text-align: center;
        }

        .summary-items-list {
            list-style: none;
            padding: 15px 25px;
            overflow-y: auto; /* Rendre la liste scrollable */
            flex-grow: 1; /* Prendre l'espace dispo */
            background: var(--bg-color);
            border-bottom: 1px solid var(--border-color);
        }

        .summary-item {
            border-bottom: 1px solid var(--border-color);
            padding: 15px 0;
            display: grid; /* Utiliser grid pour l'alignement */
            grid-template-columns: auto 1fr; /* Icon/Titre | Contenu */
            gap: 10px 20px;
            align-items: start; /* Aligner au début */
        }
        .summary-item:last-child { border-bottom: none; }

        .summary-item h4 {
            grid-column: 1 / -1; /* Titre pleine largeur */
            color: var(--primary-text-color);
            font-size: 1.1em;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .summary-item h4 i { color: var(--neon-blue); width: 18px; text-align: center;}

        .summary-item .item-type-break h4 { color: var(--neon-yellow); }
        .summary-item .item-type-break h4 i { color: var(--neon-yellow);}

        .summary-item label {
            color: var(--secondary-text-color);
            font-size: 0.9em;
            font-weight: 500;
            white-space: nowrap;
            padding-top: 6px; /* Aligner avec input */
            text-align: right;
            grid-column: 1 / 2;
        }
        .summary-item > div {
             grid-column: 2 / 3; /* Colonne pour input/textarea */
        }

        .summary-item input[type="number"],
        .summary-item input[type="text"],
        .summary-item textarea {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--primary-text-color);
            border-radius: var(--border-radius-sm);
            padding: 6px 10px;
            font-size: 1em;
            width: 100%;
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
        }
        .summary-item input[type="number"] { width: 80px; } /* Largeur fixe pour Reps */

        .summary-item input:focus,
        .summary-item textarea:focus {
            border-color: var(--neon-blue);
            background-color: var(--bg-color);
            outline: none;
            box-shadow: 0 0 0 2px rgba(var(--neon-blue-rgb), 0.3);
        }
        .summary-item textarea { min-height: 40px; resize: vertical; }

        .summary-item p { /* Pour infos Repos */
            color: var(--secondary-text-color);
            padding-top: 6px;
             grid-column: 1 / -1; /* Pleine largeur si c'est juste du texte */
             text-align: center;
             font-style: italic;
        }

        .summary-controls {
            padding: 20px 25px;
            display: flex;
            justify-content: space-between;
            gap: 15px;
            flex-shrink: 0; /* Ne pas réduire les contrôles */
            flex-wrap: wrap;
        }
        .summary-controls button {
            border-width: 2px;
            padding: 10px 20px;
            font-size: 1em;
            border-radius: var(--border-radius-md);
            flex-grow: 1; /* Prendre espace égal */
            min-width: 150px;
        }

        .summary-controls .save-summary-btn { border-color: var(--neon-green); color: var(--neon-green); }
        .summary-controls .save-summary-btn:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--glow-green); }

        .summary-controls .cancel-summary-btn { border-color: var(--neon-red); color: var(--neon-red); }
        .summary-controls .cancel-summary-btn:not(:disabled):hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--glow-red); }


        /* --- Animation Fin Workout --- */
        .workout-section.finished-animation {
            animation: finish-glow 1.5s ease-out forwards;
        }

        @keyframes finish-glow {
            0% { box-shadow: 0 0 0px 0px var(--neon-green); }
            50% { box-shadow: 0 0 25px 10px rgba(var(--neon-green-rgb), 0.5); }
            100% { box-shadow: 0 0 0px 0px rgba(var(--neon-green-rgb), 0); }
        }

        /* --- Zone de Messages Flottante --- */
        .message-area {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.9);
            color: var(--primary-text-color);
            border: 1px solid var(--border-color);
            padding: 12px 25px;
            border-radius: var(--border-radius-md);
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease;
            pointer-events: none;
            font-size: 0.95em;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            max-width: 90%;
            text-align: center;
        }

        .message-area.visible {
            opacity: 1;
            transform: translate(-50%, 0); /* Centré horizontalement, positionné par bottom */
            bottom: 40px; /* Position verticale */
            pointer-events: auto;
        }


        /* --- Pied de Page --- */
        footer {
            color: var(--secondary-text-color);
            opacity: 0.7;
            border-top: 1px solid var(--border-color);
            margin-top: 60px;
            padding: 25px;
            text-align: center;
        }
        footer a { color: var(--link-color); text-decoration: none; }
        footer a:hover { color: var(--primary-text-color); text-decoration: underline; }
        footer .fab.fa-google-drive { color: #4CAF50; }


        /* --- Styles Responsives --- */
        @media (max-width: 992px) {
            .header-content { padding: 0 15px; }
            .container { padding: 30px 15px; }
        }

        @media (max-width: 768px) {
            header h1 { font-size: 1.3em; }
            nav ul { gap: 15px; }
            .header-actions { gap: 15px; }
            .timer-display { width: 280px; height: 280px; }
            .timer-circle { width: calc(100% - 40px); height: calc(100% - 40px); top: 20px; left: 20px; border-width: 10px; }
            .timer-circle::before { width: calc(100% - 20px); height: calc(100% - 20px); }
            .time-left { font-size: 4.5em; }
            #total-progress-circle { border-width: 10px; }

            .controls { gap: 15px; }
            .controls button { min-width: 100px; padding: 10px 20px; font-size: 1em; }

            .history-controls { flex-direction: column; align-items: stretch; gap: 15px; }
            .history-actions { justify-content: center; }
            .history-actions #export-programs-btn { width: auto; }
            .chart-container { height: 320px; padding: 10px; }
            .stats-display { padding: 15px; }
            .history-list li { padding: 10px; gap: 10px; font-size: 0.95em;}

            .post-workout-summary-content { padding: 0; max-width: 95%; max-height: 85vh; }
            .post-workout-summary h2 { padding: 15px 20px; font-size: 1.3em; }
            .summary-items-list { padding: 10px 20px; }
            .summary-item { grid-template-columns: 60px 1fr; gap: 8px 15px;}
            .summary-item label { font-size: 0.85em; text-align: left; padding-top: 8px;}
            .summary-item input[type="number"] { width: 60px; }
            .summary-controls { padding: 15px 20px; flex-direction: column; }
            .summary-controls button { width: 100%; }
        }

        @media (max-width: 480px) {
            header { padding: 15px 0;}
            header h1 { font-size: 1.2em; }
            nav ul { gap: 10px; }
            .header-actions { justify-content: center; }
            .auth-controls { flex-wrap: wrap; justify-content: center; gap: 8px;}

            .timer-display { width: 240px; height: 240px; margin-bottom: 40px; }
            .timer-circle { width: calc(100% - 32px); height: calc(100% - 32px); top: 16px; left: 16px; border-width: 8px; }
            .timer-circle::before { width: calc(100% - 16px); height: calc(100% - 16px); }
            .time-left { font-size: 3.8em; }
            #total-progress-circle { border-width: 8px; }

            .workout-info { min-height: 80px; }
            #current-exercise-name-display { font-size: 1.2em; }
            #current-exercise-container { font-size: 1em; }
            #current-exercise-container .exercise-details { padding: 6px 10px; gap: 10px;}

            .controls { gap: 10px; margin-top: 30px; }
            .controls button { width: 100%; min-width: 0; padding: 12px; font-size: 1em; }
            .progress-tracker { margin-top: 25px; font-size: 0.85em;}

            .history-section { padding: 20px; }
            .history-controls { padding-bottom: 15px; margin-bottom: 20px;}
            .history-filters button { font-size: 0.8em; padding: 5px 10px; }
            .chart-container { height: 280px; }
            .stats-display { padding: 12px; font-size: 0.9em;}
            .history-list li { font-size: 0.9em;}
            .history-item-type { font-size: 0.8em; padding: 2px 6px;}

            .post-workout-summary-content { max-width: 100%; max-height: 90vh; border-radius: var(--border-radius-md); }
             .post-workout-summary h2 { font-size: 1.2em; padding: 12px 15px;}
             .summary-items-list { padding: 8px 15px; }
             .summary-item { grid-template-columns: 50px 1fr; gap: 5px 10px; padding: 12px 0;}
             .summary-item h4 {font-size: 1em;}
             .summary-item label { font-size: 0.8em; }
             .summary-controls { padding: 12px 15px; }
        }
    </style>
</head>
<body class="logged-out dark-theme"> <!-- Initialement logged-out et thème sombre -->

    <header>
        <div class="header-content">
            <h1><i class="fas fa-shield-halved"></i> ArmorWorkout</h1>
            <nav>
                <ul>
                    <li><button id="nav-push" data-workout="Push" disabled>Push</button></li>
                    <li><button id="nav-pull" data-workout="Pull" disabled>Pull</button></li>
                    <li><button id="nav-legs" data-workout="Legs" disabled>Legs</button></li>
                    <li><button id="nav-history"><i class="fas fa-history"></i> Historique</button></li>
                </ul>
            </nav>
            <div class="header-actions">
                <div class="auth-controls">
                    <button id="signin-button"><i class="fab fa-google"></i> Connecter Drive</button>
                    <button id="signout-button"><i class="fas fa-sign-out-alt"></i> Déconnecter</button>
                </div>
                <span id="drive-status"></span>
                 <button id="export-programs-btn" disabled><i class="fas fa-upload"></i> Exporter Progs</button> <!-- Déplacé ici pour regroupement logique -->
                <div class="theme-toggle">
                    <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <main>
            <!-- Section Entraînement -->
            <div class="workout-section" id="workout-section">
                <div class="timer-display">
                    <div class="timer-circle-container">
                        <div id="total-progress-circle"></div>
                        <div class="timer-circle" id="timer-circle">
                            <span class="time-left" id="time-left">00:00</span>
                        </div>
                    </div>
                    <div class="timer-state" id="timer-state"></div>
                </div>

                <div class="workout-info" id="workout-info">
                     <!-- Affichage Nom Exercice/Repos -->
                    <div id="current-exercise-name-display"></div>
                    <!-- Conteneur pour détails ou message initial -->
                    <div class="current-exercise-details" id="current-exercise-container">
                         <p>Initialisation...</p> <!-- Message par défaut -->
                    </div>
                </div>

                <div class="controls">
                    <button id="start-pause-btn" disabled><i class="fas fa-play"></i> Démarrer</button>
                    <button id="skip-btn" disabled><i class="fas fa-forward-step"></i> Suivant</button>
                    <button id="finish-btn" disabled><i class="fas fa-flag-checkered"></i> Finir</button>
                    <button id="reset-btn" disabled><i class="fas fa-redo"></i> Reset</button>
                </div>

                <div class="progress-tracker" id="progress-tracker">
                    <!-- Statut étape (ex: 3/15) ou connexion Drive affiché ici par JS -->
                    <i class="fab fa-google-drive"></i> <!-- Changé de fa-google vers fa-google-drive pour cohérence -->
                    <span id="drive-connection-status-main">Connecté à Google Drive</span>
                </div>
            </div>

            <!-- Section Historique -->
            <div class="history-section section-hidden" id="history-section">
                <h2><i class="fas fa-chart-line"></i> Historique & Statistiques</h2>
                <div class="history-controls">
                    <div class="history-filters">
                        <button data-period="week" class="active"><i class="fas fa-calendar-week"></i> Semaine</button>
                        <button data-period="month"><i class="fas fa-calendar-alt"></i> Mois</button>
                        <button data-period="year"><i class="fas fa-calendar-check"></i> Année</button>
                        <button data-period="all"><i class="fas fa-infinity"></i> Tout</button>
                    </div>
                    <div class="history-actions">
                        <!-- Export Progs est maintenant dans le header -->
                        <i class="fab fa-google-drive"></i>
                        <span id="history-drive-status">Synchro Drive</span>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="history-chart-canvas"></canvas>
                </div>
                <div class="stats-display" id="stats-display">
                    <h3>Statistiques</h3>
                    <p>Connectez-vous.</p>
                    <p class="motivational-message" id="motivational-message"></p>
                </div>
                <ul class="history-list" id="history-list">
                    <li class="no-history">Connectez-vous.</li>
                </ul>
            </div>
        </main>
    </div>

    <footer>
        <p>© 2024 ArmorWorkout. Intégré avec <i class="fab fa-google-drive"></i> Google Drive.</p>
        <p><a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i> Voir sur GitHub</a></p>
    </footer>

    <!-- Zone de Message Flottante -->
    <div id="message-area" class="message-area"></div>

    <!-- Modal Résumé Post-Workout -->
    <div id="post-workout-summary" class="post-workout-summary"> <!-- Classe ajoutée pour le style modal -->
        <div class="post-workout-summary-content">
            <h2 id="summary-title">Résumé de la Séance</h2>
            <ul id="summary-items-list" class="summary-items-list">
                <!-- Contenu généré par JS -->
            </ul>
            <div class="summary-controls">
                <button id="save-summary-btn" class="controls button save-summary-btn"><i class="fas fa-save"></i> Sauvegarder & Fermer</button>
                <button id="cancel-summary-btn" class="controls button cancel-summary-btn"><i class="fas fa-times"></i> Fermer sans Sauvegarder</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION & CONSTANTES ---
        const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
        const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const HISTORY_FILENAME = "armorworkout_history.csv";
        const PROGRAM_FILENAMES = {
            Push: "armorworkout_push_program.csv",
            Pull: "armorworkout_pull_program.csv",
            Legs: "armorworkout_legs_program.csv"
        };
        const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
        const PREPARE_DURATION = 3; // Secondes
        const FINISH_ANIMATION_DURATION = 1500; // ms
        const SECONDS_PER_REP = 2.5; // Estimation temps par rep
        const IN_PROGRESS_KEY = 'armorWorkoutStateInProgress';

        // --- DONNÉES PAR DÉFAUT ---
        const defaultWorkouts = {
            Push: [
                { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 },
                { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 },
                { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 14 },
                { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 },
                { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 },
                { type: 'break', duration: 60, name: 'Repos' },
                { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 },
                { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 },
            ],
            Pull: [
                { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 },
                { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 },
                { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 13 },
                { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 15 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 },
                { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 },
                { type: 'break', duration: 60, name: 'Repos' },
                { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 },
                { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 },
            ],
            Legs: [
                 { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 },
                 { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 },
                 { type: 'break', duration: 90, name: 'Repos' },
                 { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 },
                 { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 },
                 { type: 'break', duration: 90, name: 'Repos' },
                 { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 14 },
                 { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 11 },
                 { type: 'break', duration: 90, name: 'Repos' },
                 { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 },
                 { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 },
                 { type: 'break', duration: 60, name: 'Repos' },
                 { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 },
                 { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 },
             ]
        };

        // --- Éléments DOM (Déclaration) ---
        let timeLeftDisplay, timerCircle, timerStateDisplay, currentExerciseContainer, progressTracker, startPauseBtn, skipBtn, finishBtn, resetBtn, navButtons, navHistoryBtn, themeToggleBtn, messageArea, workoutSection, historySection, historyList, statsDisplay, motivationalMessage, historyFilterBtns, historyChartCanvas, signInButton, signOutButton, driveStatusElement, exportProgramsBtn, postWorkoutSummary, summaryTitle, summaryItemsList, saveSummaryBtn, cancelSummaryBtn, historyDriveStatus, totalProgressCircle, currentExerciseNameDisplay, driveConnectionStatusMain;

        // --- Variables d'État ---
        let currentWorkoutType = null;
        let currentWorkoutPlan = [];
        let originalCompletedWorkoutPlan = []; // Pour le résumé
        let currentItemIndex = 0;
        let timerInterval = null;
        let prepareCountdownInterval = null;
        let totalTime = 0; // Durée totale de l'étape courante (pause)
        let timeLeft = 0; // Temps restant pour l'étape courante (pause)
        let prepareTimeLeft = 0; // Temps restant pour la préparation
        let totalWorkoutEstimatedSeconds = 0; // Estimation temps total entraînement
        let elapsedWorkoutEstimatedSeconds = 0; // Estimation temps écoulé entraînement
        let isTimerRunning = false;
        let isWorkoutActive = false;
        let workoutFinished = false;
        let currentState = 'idle'; // idle, preparing, exercise, break, paused, finished
        let workoutStartTime = null; // Timestamp début entraînement
        let workoutHistory = []; // Tableau des séances terminées
        let currentHistoryPeriod = 'week'; // Filtre historique par défaut
        let historyChart = null; // Instance Chart.js
        let googleAccessToken = null;
        let tokenClient = null;
        let historyFileId = null; // ID fichier historique sur Drive
        let programFileIds = { Push: null, Pull: null, Legs: null }; // IDs fichiers programmes Drive
        let programsLoaded = false; // Statut chargement programmes depuis Drive
        let loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Programmes actuels (défaut ou Drive)
        let isSavingSummary = false; // Flag pour éviter double sauvegarde résumé
        let currentTheme = 'dark'; // Thème par défaut
        let messageTimeoutId = null; // Pour cacher message flottant

        // --- Audio & Vibration ---
        let audioContext = null;
        let endSound = () => { console.log("Beep! (AudioContext non initialisé)"); }; // Placeholder

        function initAudioContext() {
             // Création contexte au premier besoin (interaction utilisateur)
             if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log("AudioContext initialisé.");
                     // Test rapide pour débloquer sur iOS/Certains navigateurs
                     if (audioContext.state === 'suspended') {
                         audioContext.resume();
                     }
                     const buffer = audioContext.createBuffer(1, 1, 22050);
                     const source = audioContext.createBufferSource();
                     source.buffer = buffer;
                     source.connect(audioContext.destination);
                     source.start(0);
                     source.stop(audioContext.currentTime + 0.001);

                    // Définir la vraie fonction de son
                     endSound = () => {
                        if (!audioContext) return;
                        if (audioContext.state === 'suspended') {
                            audioContext.resume().then(() => playActualSound()).catch(e => console.error("Erreur reprise AudioContext", e));
                        } else {
                            playActualSound();
                        }
                    };
                } catch (e) {
                    console.warn("Initialisation AudioContext échouée:", e);
                    audioContext = null;
                }
            }
             if (!audioContext) {
                 console.warn("AudioContext non supporté ou bloqué. Utilisation de console.log pour 'Beep'.");
                 endSound = () => console.log("Beep! (AudioContext indisponible)");
             }
        }

        function playActualSound() {
            if (!audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.type = 'triangle'; // Son un peu moins agressif
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime); // Mi (E5)
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // Volume max
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5); // Fade out
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch(e) {
                console.error("Erreur lecture son:", e);
            }
        }

        const vibrate = (pattern = [100, 50, 100]) => {
            if ('vibrate' in navigator) {
                try {
                    navigator.vibrate(pattern);
                } catch (e) {
                    console.warn("Vibration échouée:", e);
                }
            }
        };

        // --- Google Identity Services (GIS) & Drive API ---
        // gisLoadedCallback est maintenant globale et appelée par le script Google
        function gisLoadedCallback() {
            console.log("GIS Library Loaded Callback Executed");
            if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID === "VOTRE ID CLIENT ICI") {
                console.error("ERREUR CRITIQUE: GOOGLE_CLIENT_ID non configuré !");
                showMessage("Erreur critique : ID Client Google manquant.", 10000);
                if (driveStatusElement) {
                    driveStatusElement.textContent = 'Erreur Config ID';
                    driveStatusElement.classList.add('error');
                    driveStatusElement.style.display = 'inline-block'; // Afficher l'erreur
                }
                 updateAuthUI(false); // Assurer que l'UI est en mode déconnecté
                return;
            }
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID,
                    scope: GOOGLE_DRIVE_SCOPES,
                    callback: (tokenResponse) => {
                        console.log("GIS Callback: Réponse reçue, appel de tokenCallback...");
                        tokenCallback(tokenResponse);
                    },
                    error_callback: (error) => {
                        console.error("GIS Error Callback:", error);
                        handleTokenError(error);
                    },
                    prompt: '' // Peut être 'consent' pour forcer l'écran de consentement
                });
                console.log("Token Client initialisé avec succès.");
                 // Vérifier si un état local existe AVANT de tenter de charger depuis Drive
                 // Cela se fera maintenant DANS tokenCallback APRÈS connexion réussie
            } catch (error) {
                console.error("Erreur initialisation Token Client:", error);
                showMessage("Erreur initialisation services Google.", 5000);
                updateAuthUI(false);
                if (driveStatusElement) {
                    driveStatusElement.textContent = 'Erreur Init Auth';
                    driveStatusElement.classList.add('error');
                     driveStatusElement.style.display = 'inline-block';
                }
            }
        }

        function handleTokenError(error) {
            console.error("Erreur Token Client:", error);
            let message = `Erreur Authentification Google: ${error.type || error.error || 'Inconnue'}`;
            let statusText = 'Erreur Auth';
            if (driveStatusElement) {
                 driveStatusElement.classList.remove('loading','success');
                 driveStatusElement.classList.add('error');
                 driveStatusElement.style.display = 'inline-block';
            }
            // Gestion plus fine des types d'erreurs courants
            if (error.type === 'popup_closed' || error.error === 'user_cancel' || error.error === 'popup_closed') {
                message = "Connexion Google annulée par l'utilisateur.";
                statusText = 'Annulé';
            } else if (error.type === 'popup_failed_to_open' || error.error === 'popup_failed_to_open') {
                message = "La fenêtre pop-up Google a été bloquée. Vérifiez les paramètres de votre navigateur.";
                statusText = 'Popup Bloqué';
            } else if (error.type === 'session_timed_out' || error.error === 'session_timed_out'){
                 message = "Session Google expirée. Veuillez vous reconnecter.";
                 statusText = 'Expiré';
                 handleSignoutClick(false); // Déconnecter l'état local si la session expire
            } else if (error.type === 'unregistered_origin' || error.type === 'invalid_client' || error.type === 'redirect_uri_mismatch' || error.error === 'invalid_client') {
                 message = "Erreur de configuration de l'application Google. Contactez le développeur.";
                 statusText = 'Erreur Config App';
                 console.error("Détails erreur de configuration:", error);
             } else if (error.error === 'access_denied') {
                 message = "Accès refusé. Vous devez autoriser l'accès à Google Drive.";
                 statusText = 'Accès Refusé';
             } else {
                 console.error("Détails erreur d'authentification non gérée:", error);
             }
             showMessage(message, 7000);
             if (driveStatusElement) driveStatusElement.textContent = statusText;
             updateAuthUI(false); // Passer en état déconnecté
        }

        async function tokenCallback(tokenResponse) {
            console.log("Logique tokenCallback en cours avec réponse:", tokenResponse);
            if (driveStatusElement) {
                driveStatusElement.classList.remove('loading', 'error', 'success');
                driveStatusElement.style.display = 'inline-block';
            }

            if (tokenResponse && tokenResponse.access_token) {
                console.log("Access Token reçu avec succès.");
                googleAccessToken = tokenResponse.access_token;
                updateAuthUI(true); // Mettre à jour l'UI en mode connecté
                showMessage("Connecté. Chargement des données...", 3000);
                 if (driveStatusElement) {
                     driveStatusElement.textContent = 'Chargement...';
                     driveStatusElement.classList.add('loading');
                 }

                try {
                    console.log("tokenCallback: Tentative de chargement parallèle historique & programmes...");
                    // Utiliser Promise.all pour charger l'historique et les programmes en parallèle
                    const [historyResult, programsResult] = await Promise.all([
                        loadHistoryFromDrive(), // Renvoie true/false ou lance une erreur
                        loadProgramsFromDrive() // Renvoie true/false ou lance une erreur
                    ]);
                    console.log(`tokenCallback: Promise.all terminé. History OK: ${historyResult}, Programs OK: ${programsResult}`);

                    if (programsResult) { // programsLoaded est mis à jour dans loadProgramsFromDrive
                        console.log("Données Drive (programmes et historique potentiellement) chargées.");
                        showMessage("Historique et programmes chargés.", 2500);
                        if (driveStatusElement) {
                            driveStatusElement.textContent = 'Connecté';
                            driveStatusElement.classList.remove('loading');
                            driveStatusElement.classList.add('success');
                        }
                         // Tenter de charger l'état en cours APRÈS que tout soit chargé
                        const resumed = loadInProgressState();
                        if(!resumed) {
                             checkEnableStartButton(); // Mettre à jour l'état du bouton Démarrer si non repris
                        }
                    } else {
                        // Si les programmes n'ont pas pu être chargés, c'est un problème majeur
                        showMessage("Erreur critique lors du chargement des programmes depuis Drive. Programmes par défaut utilisés.", 6000);
                        if (driveStatusElement) {
                            driveStatusElement.textContent = 'Erreur Progs';
                            driveStatusElement.classList.remove('loading');
                            driveStatusElement.classList.add('error');
                        }
                         checkEnableStartButton(); // Mettre à jour même en cas d'erreur
                    }

                    // Activer/désactiver les boutons de nav et export basé sur programsLoaded
                    if (navButtons) navButtons.forEach(btn => btn.disabled = !programsLoaded);
                    if (exportProgramsBtn) exportProgramsBtn.disabled = !programsLoaded;

                } catch (error) {
                    // Gérer les erreurs survenues pendant le Promise.all
                    console.error("tokenCallback: ERREUR CRITIQUE pendant le chargement parallèle des données:", error);
                    console.error("Stack Trace:", error.stack);
                    showMessage("Erreur majeure lors du chargement des données depuis Drive.", 7000);
                    // Réinitialiser à un état sûr
                    loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
                    workoutHistory = [];
                    programsLoaded = false;
                    updateAuthUI(true); // Toujours connecté, mais avec erreur
                    if (driveStatusElement) {
                        driveStatusElement.textContent = 'Erreur Données';
                        driveStatusElement.classList.remove('loading');
                        driveStatusElement.classList.add('error');
                    }
                    displayHistory(); // Afficher l'historique vide
                    if (navButtons) navButtons.forEach(btn => btn.disabled = true);
                    if (exportProgramsBtn) exportProgramsBtn.disabled = true;
                    checkEnableStartButton();
                }

            } else {
                console.error("Erreur dans la réponse Token ou access_token manquant:", tokenResponse);
                if (tokenResponse && tokenResponse.error) {
                    // Si la réponse contient une erreur structurée, la gérer
                    handleTokenError(tokenResponse);
                } else {
                    // Erreur générique si la réponse est invalide
                    showMessage("Erreur: Jeton Google invalide reçu.", 5000);
                    updateAuthUI(false);
                    if (driveStatusElement) {
                        driveStatusElement.textContent = 'Erreur Jeton';
                        driveStatusElement.classList.add('error');
                         driveStatusElement.style.display = 'inline-block';
                    }
                }
            }
        }

        function handleAuthClick() {
            console.log("Clic sur 'Connecter Drive'");
            if (!tokenClient) {
                showMessage("La bibliothèque Google n'est pas encore prête, veuillez patienter...", 3000);
                console.warn("Tentative de connexion avant l'initialisation complète du tokenClient.");
                if (driveStatusElement) {
                    driveStatusElement.textContent = 'Non Prêt';
                    driveStatusElement.classList.add('error');
                     driveStatusElement.style.display = 'inline-block';
                }
                // Essayer de relancer l'init? Ou juste attendre ? Attendre est plus sûr.
                return;
            }
             initAudioContext(); // Initialiser l'audio au premier clic d'interaction
            console.log("Demande manuelle d'Access Token...");
            if (driveStatusElement) {
                driveStatusElement.textContent = 'Connexion...';
                driveStatusElement.classList.add('loading');
                driveStatusElement.classList.remove('error','success');
                 driveStatusElement.style.display = 'inline-block';
            }
            // Demander un token, forcera le popup si nécessaire
            tokenClient.requestAccessToken({ prompt: 'consent' }); // 'consent' peut aider si les cookies bloquent
        }

        function handleSignoutClick(showMsg = true) {
            console.log("Clic sur 'Déconnecter'");
            const token = googleAccessToken;
             if (token) {
                 if (showMsg && driveStatusElement) {
                     driveStatusElement.textContent = 'Déconnexion...';
                     driveStatusElement.classList.add('loading');
                     driveStatusElement.classList.remove('error','success');
                     driveStatusElement.style.display = 'inline-block';
                 }
                 // Révoquer le token
                 google.accounts.oauth2.revoke(token, () => {
                     console.log('Token Google révoqué.');
                     googleAccessToken = null;
                     historyFileId = null;
                     programFileIds = { Push: null, Pull: null, Legs: null };
                     programsLoaded = false;
                     workoutHistory = [];
                     loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Revenir aux défauts

                     // Si un entraînement était en cours, l'arrêter et nettoyer
                     if (isWorkoutActive || currentState !== 'idle') {
                         resetCurrentWorkout(); // Ceci appellera updateAuthUI(false) à la fin
                     } else {
                         updateAuthUI(false); // Mettre à jour l'UI immédiatement si pas d'entraînement en cours
                     }

                     if (showMsg) {
                         showMessage("Déconnecté de Google Drive.", 2500);
                     }
                      if (driveStatusElement) {
                          driveStatusElement.textContent = '';
                          driveStatusElement.classList.remove('loading', 'error','success');
                          driveStatusElement.style.display = 'none'; // Cacher l'indicateur
                      }
                 });
             } else {
                  // Si pas de token, juste mettre à jour l'UI
                  console.log("Pas de token à révoquer, mise à jour UI.");
                  updateAuthUI(false);
                  if (driveStatusElement) {
                     driveStatusElement.textContent = '';
                     driveStatusElement.style.display = 'none';
                 }
             }
        }

        function updateAuthUI(isLoggedIn) {
            // Fonction détaillée pour clarifier la logique
            updateAuthUIDetailed(isLoggedIn);
        }

        function updateAuthUIDetailed(isLoggedIn) {
             console.log(`Mise à jour UI - Connecté: ${isLoggedIn}, Programmes Chargés: ${programsLoaded}, État Timer: ${currentState}`);
             const body = document.body;

             body.classList.toggle('logged-in', isLoggedIn);
             body.classList.toggle('logged-out', !isLoggedIn);
             // La classe workout-active est gérée par setState et resetCurrentWorkout

             // Mise à jour Status Drive Principal (Header)
             if (driveStatusElement) {
                 driveStatusElement.style.display = isLoggedIn ? 'inline-block' : 'none';
                 if (!isLoggedIn) {
                     driveStatusElement.textContent = '';
                     driveStatusElement.classList.remove('loading', 'error', 'success');
                 }
                 // Note: le texte ('Connecté', 'Chargement', 'Erreur') est géré par les fonctions d'auth/chargement
             }

             // Mise à jour Status Drive Secondaire (sous les boutons)
             if(driveConnectionStatusMain) {
                 const statusContainer = driveConnectionStatusMain.closest('.progress-tracker'); // Trouver le conteneur parent
                 if (statusContainer) {
                    statusContainer.style.display = isLoggedIn ? 'flex' : 'none';
                 }
                 if(isLoggedIn) {
                     // Refléter l'état du header
                     if (driveStatusElement?.classList.contains('loading')) {
                         driveConnectionStatusMain.textContent = "Chargement Drive...";
                         if (statusContainer) statusContainer.querySelector('i')?.classList.add('fa-spin');
                     } else if (driveStatusElement?.classList.contains('error')) {
                         driveConnectionStatusMain.textContent = `Erreur Drive (${driveStatusElement.textContent || '?'})`;
                         if (statusContainer) statusContainer.querySelector('i')?.classList.remove('fa-spin');
                     } else {
                         driveConnectionStatusMain.textContent = "Connecté à Google Drive";
                          if (statusContainer) statusContainer.querySelector('i')?.classList.remove('fa-spin');
                     }
                 }
             }

             // Mise à jour Status Drive dans l'Historique
             if (historyDriveStatus?.parentElement) {
                 historyDriveStatus.parentElement.style.display = isLoggedIn ? 'flex' : 'none';
                 if(isLoggedIn) {
                     // Simplifié, pourrait aussi refléter l'erreur/chargement si besoin
                     historyDriveStatus.textContent = driveStatusElement?.classList.contains('error') ? 'Erreur Sync' : 'Synchro Drive OK';
                 }
             }

             // Activer/Désactiver boutons et sections
             themeToggleBtn.disabled = false; // Thème toujours dispo
             navHistoryBtn.disabled = false; // Historique toujours accessible (affiche "connectez-vous")

             if (!isLoggedIn) {
                // État Déconnecté
                 loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // S'assurer que les défauts sont chargés
                 workoutHistory = [];
                 programsLoaded = false;
                 displayHistory(currentHistoryPeriod); // Afficher l'état "connectez-vous" dans l'historique
                 if (currentState !== 'idle') {
                     resetCurrentWorkout(); // Forcer reset si déconnexion pendant entraînement
                 }
                 updateWorkoutInfo(); // Afficher message "Connectez-vous"
                 startPauseBtn.disabled = true;
                 skipBtn.disabled = true;
                 finishBtn.disabled = true;
                 resetBtn.disabled = true;
                 navButtons.forEach(btn => btn.disabled = true);
                 if (exportProgramsBtn) exportProgramsBtn.disabled = true;
             } else {
                 // État Connecté
                 // La désactivation des boutons nav/export dépend de programsLoaded (géré ailleurs après chargement)
                 navButtons.forEach(btn => btn.disabled = !programsLoaded);
                 if (exportProgramsBtn) exportProgramsBtn.disabled = !programsLoaded;

                 // Gérer les boutons de contrôle du timer basé sur l'état actuel
                 checkEnableStartButton(); // Gère startPauseBtn pour idle/preparing
                 if (currentState === 'idle' || currentState === 'finished' || currentState === 'preparing') {
                     skipBtn.disabled = true;
                     finishBtn.disabled = true;
                     resetBtn.disabled = !currentWorkoutType || currentState === 'preparing'; // Actif si un type est chargé (même si idle), sauf si preparing
                 } else { // exercise, break, paused
                     skipBtn.disabled = !programsLoaded;
                     finishBtn.disabled = !programsLoaded;
                     resetBtn.disabled = !programsLoaded;
                 }
                 updateWorkoutInfo(); // Mettre à jour l'affichage info workout
                 displayHistory(currentHistoryPeriod); // Recharger l'historique avec les données Drive
             }
        }


        function checkEnableStartButton() {
            if (!startPauseBtn) return;

            if (currentState === 'idle') {
                 // Actif seulement si connecté, programmes chargés ET un type de workout sélectionné
                 startPauseBtn.disabled = !googleAccessToken || !programsLoaded || !currentWorkoutType;
                 startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer';
                 startPauseBtn.classList.remove('pause-btn');
            } else if (currentState === 'preparing') {
                 startPauseBtn.disabled = true; // Toujours désactivé pendant la prépa
                 startPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Prêt...';
                 startPauseBtn.classList.remove('pause-btn');
            } else if (currentState === 'exercise') {
                startPauseBtn.disabled = !programsLoaded;
                startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Fait';
                startPauseBtn.classList.remove('pause-btn');
            } else if (currentState === 'break') {
                 startPauseBtn.disabled = !programsLoaded;
                 startPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
                 startPauseBtn.classList.add('pause-btn');
            } else if (currentState === 'paused') {
                 startPauseBtn.disabled = !programsLoaded;
                 startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Reprendre';
                 startPauseBtn.classList.add('pause-btn'); // Garder style pause pour reprise
            } else if (currentState === 'finished') {
                 startPauseBtn.disabled = true; // Désactivé quand fini
                 startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Terminé';
                 startPauseBtn.classList.remove('pause-btn');
            }
        }

        async function findOrCreateFile(filename, defaultCsvContent = "") {
            console.log(`findOrCreateFile: Recherche ou création de ${filename}`);
            if (!googleAccessToken) {
                console.warn("findOrCreateFile: Non connecté à Google Drive.");
                return null;
            }

            const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+mimeType='text/csv'+and+trashed=false&spaces=drive&fields=files(id,name)`;

            try {
                const searchRes = await fetch(searchUrl, {
                    headers: { 'Authorization': `Bearer ${googleAccessToken}` }
                });

                if (!searchRes.ok) {
                    if (searchRes.status === 401 || searchRes.status === 403) {
                        console.warn(`Erreur d'authentification (${searchRes.status}) lors de la recherche de ${filename}. Tentative de déconnexion.`);
                        handleSignoutClick(false); // Déconnecter sans message pour éviter boucle
                        showMessage("Session Google expirée ou invalide. Veuillez vous reconnecter.", 6000);
                        return null; // Arrêter l'opération
                    }
                    // Gérer autres erreurs de recherche
                    throw new Error(`Erreur lors de la recherche du fichier ${filename} (${searchRes.status} ${searchRes.statusText})`);
                }

                const searchData = await searchRes.json();

                if (searchData.files && searchData.files.length > 0) {
                    // Fichier trouvé
                    console.log(`Fichier ${filename} trouvé avec l'ID: ${searchData.files[0].id}`);
                    return searchData.files[0].id;
                } else {
                    // Fichier non trouvé, il faut le créer
                    console.log(`Fichier ${filename} non trouvé. Création en cours...`);
                    const createUrl = `https://www.googleapis.com/drive/v3/files`;
                    const metadata = {
                        name: filename,
                        mimeType: 'text/csv',
                        // parents: ['appDataFolder'] // Optionnel: Pour stocker dans le dossier caché de l'appli
                    };

                    const createRes = await fetch(createUrl, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${googleAccessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(metadata)
                    });

                    if (!createRes.ok) {
                         if (createRes.status === 401 || createRes.status === 403) {
                            console.warn(`Erreur d'authentification (${createRes.status}) lors de la création de ${filename}. Tentative de déconnexion.`);
                            handleSignoutClick(false);
                            showMessage("Session Google expirée ou invalide. Veuillez vous reconnecter.", 6000);
                            return null;
                        }
                        throw new Error(`Erreur lors de la création du fichier ${filename} (${createRes.status} ${createRes.statusText})`);
                    }

                    const createData = await createRes.json();
                    const newFileId = createData.id;
                    console.log(`Fichier ${filename} créé avec l'ID: ${newFileId}. Écriture du contenu par défaut...`);

                    // Écrire le contenu par défaut dans le nouveau fichier
                    const writeSuccess = await updateFileContent(newFileId, defaultCsvContent);
                    if (writeSuccess) {
                        console.log(`Contenu par défaut écrit avec succès dans ${filename}.`);
                        return newFileId;
                    } else {
                        console.error(`Échec de l'écriture du contenu par défaut dans ${filename}. La création est considérée comme échouée.`);
                        // Idéalement, on pourrait tenter de supprimer le fichier vide créé, mais pour simplifier...
                        return null;
                    }
                }
            } catch (error) {
                console.error(`findOrCreateFile: ERREUR pour ${filename}:`, error);
                showMessage(`Erreur Drive (${filename.substring(0, 20)}...): ${error.message}`, 7000);
                return null; // Retourner null en cas d'erreur
            }
        }

        async function readFileContent(fileId) {
            console.log(`readFileContent: Lecture du fichier ID ${fileId}`);
            if (!googleAccessToken || !fileId) {
                console.warn("readFileContent: Non connecté ou fileId manquant.");
                return null; // Retourner null pour indiquer un échec
            }

            const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;

            try {
                const response = await fetch(url, {
                    headers: { 'Authorization': `Bearer ${googleAccessToken}` }
                });

                if (!response.ok) {
                     if (response.status === 404) {
                        console.warn(`Fichier ${fileId} non trouvé (404). Retourne une chaîne vide comme s'il était vide.`);
                        return ""; // Considérer comme vide plutôt qu'une erreur bloquante
                    }
                    if (response.status === 401 || response.status === 403) {
                        console.warn(`Erreur d'authentification (${response.status}) lors de la lecture de ${fileId}. Tentative de déconnexion.`);
                        handleSignoutClick(false);
                        showMessage("Session Google expirée ou accès refusé. Reconnexion nécessaire.", 6000);
                        return null; // Échec
                    }
                    // Gérer autres erreurs de lecture
                    throw new Error(`Erreur lors de la lecture du fichier ${fileId} (${response.status} ${response.statusText})`);
                }

                const content = await response.text();
                console.log(`Lecture du fichier ${fileId} réussie.`);
                return content; // Succès

            } catch (error) {
                console.error(`readFileContent: ERREUR pour ${fileId}:`, error);
                showMessage(`Erreur Drive Lecture: ${error.message}`, 6000);
                return null; // Échec
            }
        }

        async function updateFileContent(fileId, content) {
            console.log(`updateFileContent: Mise à jour du fichier ID ${fileId}`);
            if (!googleAccessToken || !fileId) {
                console.warn("updateFileContent: Non connecté ou fileId manquant.");
                return false; // Indiquer l'échec
            }

            const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`;

            try {
                const response = await fetch(url, {
                    method: 'PATCH', // Utiliser PATCH pour mettre à jour le contenu
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`,
                        'Content-Type': 'text/csv' // Spécifier le type de contenu
                    },
                    body: content // Le contenu à écrire
                });

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                         console.warn(`Erreur d'authentification (${response.status}) lors de l'écriture dans ${fileId}. Tentative de déconnexion.`);
                         handleSignoutClick(false);
                         showMessage("Session expirée ou accès refusé. Sauvegarde échouée.", 6000);
                         return false; // Échec
                    }
                     // Gérer autres erreurs d'écriture
                     throw new Error(`Erreur lors de l'écriture dans le fichier ${fileId} (${response.status} ${response.statusText})`);
                }

                console.log(`Écriture dans le fichier ${fileId} réussie.`);
                return true; // Succès

            } catch (error) {
                console.error(`updateFileContent: ERREUR pour ${fileId}:`, error);
                showMessage(`Erreur Drive Écriture: ${error.message}`, 6000);
                return false; // Échec
            }
        }


        // --- Fonctions Cœur du Timer ---

        function formatTime(seconds) {
             const absSeconds = Math.max(0, Math.round(seconds)); // Assurer >= 0
             const minutes = Math.floor(absSeconds / 60);
             const remainingSeconds = absSeconds % 60;
             return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function formatTimeForChart(seconds) {
            // Convertit les secondes en minutes avec une décimale pour le graphique
            return parseFloat((Math.max(0, seconds) / 60).toFixed(1));
        }

        function calculateTotalEstimatedTime(plan) {
             let totalSeconds = 0;
             plan.forEach(item => {
                // Calculer et stocker la durée estimée pour chaque item
                 let estimatedDuration = 0;
                 if (item.type === 'break') {
                     estimatedDuration = item.duration || 0;
                 } else if (item.type === 'exercise') {
                      // Si reps = 0 ou null, compter comme 0 temps? Ou un minimum? Pour l'instant 0.
                      estimatedDuration = (item.reps || 0) * SECONDS_PER_REP;
                 }
                 item.estimatedDuration = estimatedDuration; // Stocker dans l'objet item
                 totalSeconds += estimatedDuration;
             });
             console.log(`Temps total estimé pour le plan: ${totalSeconds.toFixed(1)}s (${formatTime(totalSeconds)})`);
             return totalSeconds;
        }

        function updateTotalProgressCircle() {
            if (!totalProgressCircle || totalWorkoutEstimatedSeconds <= 0) {
                 // Si pas de cercle ou pas de temps total, afficher comme vide/plein bg
                 if(totalProgressCircle) totalProgressCircle.style.background = `var(--total-progress-bg)`;
                 return;
            }

             // Le temps écoulé total est la somme des durées estimées des items *terminés*
             // + la progression dans l'item *actuel* (si c'est une pause)
             let currentTotalElapsed = 0;
             for (let i = 0; i < currentItemIndex; i++) {
                // Utiliser la durée estimée stockée
                 currentTotalElapsed += currentWorkoutPlan[i]?.estimatedDuration || 0;
             }

             // Ajouter la progression de l'item actuel si c'est une pause en cours
             if (currentState === 'break' && totalTime > 0) {
                 const breakProgress = (totalTime - timeLeft); // Temps écoulé de la pause
                 // On ne peut pas facilement estimer le % de la durée *estimée* totale que représente cette pause
                 // On va utiliser le temps réel écoulé de la pause comme approximation ajoutée au total
                 // MAIS il faut le borner à la durée estimée de cette pause
                 const currentItemEstimatedDuration = currentWorkoutPlan[currentItemIndex]?.estimatedDuration || totalTime;
                 currentTotalElapsed += Math.min(breakProgress, currentItemEstimatedDuration);
            } else if (currentState === 'paused' && currentWorkoutPlan[currentItemIndex]?.type === 'break' && totalTime > 0) {
                 // Si en pause pendant une pause, utiliser le temps déjà écoulé avant la pause
                 const breakProgressBeforePause = (totalTime - timeLeft);
                 const currentItemEstimatedDuration = currentWorkoutPlan[currentItemIndex]?.estimatedDuration || totalTime;
                 currentTotalElapsed += Math.min(breakProgressBeforePause, currentItemEstimatedDuration);
            }

             // Si terminé, on met à 100%
            if (currentState === 'finished') {
                 currentTotalElapsed = totalWorkoutEstimatedSeconds;
            }

             // S'assurer de ne pas dépasser le total
             currentTotalElapsed = Math.min(currentTotalElapsed, totalWorkoutEstimatedSeconds);

             const progressPercent = totalWorkoutEstimatedSeconds > 0
                ? (currentTotalElapsed / totalWorkoutEstimatedSeconds) * 100
                : 0;

             // Appliquer le dégradé au cercle externe
             // Utiliser le dégradé défini dans les variables CSS pour la partie remplie
             totalProgressCircle.style.background = `conic-gradient(from 180deg, var(--neon-blue) ${progressPercent}%, var(--neon-pink) ${progressPercent + 30}%, var(--total-progress-bg) ${progressPercent}%)`;
             // Note: Le dégradé réel pourrait être plus complexe si on veut le faire évoluer.
             // Pour simplicité, on peut utiliser une couleur unie pour la progression :
             // totalProgressCircle.style.background = `conic-gradient(var(--neon-blue) ${progressPercent}%, var(--total-progress-bg) ${progressPercent}%)`;

        }

        function updateTimerDisplay() {
            if (!timeLeftDisplay || !timerCircle || !totalProgressCircle) return;

            let innerProgressPercent = 0;
            let displayTime = "00:00";
            let stepColor = 'var(--neon-blue)'; // Couleur par défaut
            let stepGlow = 'var(--glow-blue)'; // Glow par défaut

            if (currentState === 'break' && totalTime > 0) {
                innerProgressPercent = Math.max(0, Math.min(100, ((totalTime - timeLeft) / totalTime) * 100));
                displayTime = formatTime(timeLeft);
                stepColor = 'var(--neon-yellow)'; // Couleur pause
                stepGlow = 'var(--glow-yellow)';
            } else if (currentState === 'paused' && currentWorkoutPlan[currentItemIndex]?.type === 'break') {
                // Si en pause PENDANT une pause, afficher le temps restant de la pause
                innerProgressPercent = Math.max(0, Math.min(100, ((totalTime - timeLeft) / totalTime) * 100));
                displayTime = formatTime(timeLeft);
                stepColor = 'var(--neon-yellow)'; // Garder couleur pause
                stepGlow = 'var(--glow-yellow)';
             } else if (currentState === 'preparing') {
                innerProgressPercent = Math.max(0, Math.min(100, ((PREPARE_DURATION - prepareTimeLeft) / PREPARE_DURATION) * 100));
                displayTime = formatTime(prepareTimeLeft);
                 stepColor = 'var(--neon-yellow)'; // Couleur préparation (comme pause)
                 stepGlow = 'var(--glow-yellow)';
             } else if (currentState === 'finished') {
                innerProgressPercent = 100;
                 displayTime = "FINI";
                 stepColor = 'var(--neon-green)'; // Couleur succès
                 stepGlow = 'var(--glow-green)';
             } else if (currentState === 'exercise') {
                 innerProgressPercent = 0; // Pas de progression pour l'exercice lui-même (sauf si on ajoutait un timer d'exo)
                 displayTime = "GO!"; // Indiquer qu'on est en phase d'exercice
                 stepColor = 'var(--neon-pink)'; // Couleur exercice
                 stepGlow = 'var(--glow-pink)';
             } else { // idle ou autre état non géré visuellement dans le cercle intérieur
                 innerProgressPercent = 0;
                 displayTime = formatTime(0);
                 stepColor = 'var(--secondary-text-color)'; // Couleur neutre
                 stepGlow = 'none';
             }

             // Mettre à jour le temps affiché
             timeLeftDisplay.textContent = displayTime;

             // Mettre à jour la couleur et le glow du cercle intérieur
             timerCircle.style.setProperty('--current-step-color', stepColor);
             timerCircle.style.setProperty('--current-step-glow', stepGlow);

             // Mettre à jour le remplissage du cercle intérieur
             timerCircle.style.backgroundImage = `conic-gradient(${stepColor} ${innerProgressPercent}%, transparent ${innerProgressPercent}%)`;

             // Mettre à jour le cercle de progression totale (extérieur)
             updateTotalProgressCircle();
        }

        function updateWorkoutInfo() {
            // Correction: Afficher infos exercice/repos pendant l'entraînement
            if (!currentExerciseContainer || !currentExerciseNameDisplay || !progressTracker) return;

            const currentItem = currentWorkoutPlan[currentItemIndex];
            let infoHtml = ''; // HTML pour #current-exercise-container
            let nameDisplay = ''; // Texte pour #current-exercise-name-display
            let progressText = ''; // Texte pour #progress-tracker (était déjà là)

            if (currentState === 'idle') {
                nameDisplay = ''; // Pas de nom d'exercice
                infoHtml = `<p>${googleAccessToken ? (programsLoaded ? `Sélectionnez un entraînement.` : `Chargement des programmes...`) : `Connectez-vous à Google Drive...`}</p>`;
                progressText = ''; // Pas de progression
            } else if (currentState === 'finished') {
                const durationFinished = workoutStartTime ? formatTime((Date.now() - workoutStartTime) / 1000) : 'N/A';
                nameDisplay = 'Terminé !';
                infoHtml = `<div class="exercise-card"><h2><i class="fas fa-check-circle" style="color: var(--neon-green)"></i> Bravo !</h2><p>Temps total: <strong>${durationFinished}</strong></p></div>`;
                progressText = originalCompletedWorkoutPlan.length > 0 ? `Terminé (${originalCompletedWorkoutPlan.length}/${originalCompletedWorkoutPlan.length})` : 'Terminé';
            } else if (currentState === 'preparing') {
                const nextItem = currentWorkoutPlan[0]; // Le premier item qui va suivre
                 nameDisplay = `Préparez : ${nextItem?.name || 'Prochaine étape'}`;
                 infoHtml = `<p style="color: var(--neon-yellow); font-weight: 500;">Prêt dans ${prepareTimeLeft}s...</p>`;
                 progressText = `Préparation... (1/${currentWorkoutPlan.length})`;
             } else if (currentItem) {
                 // Affichage pendant exercice ou repos
                 nameDisplay = `${currentItem.name || (currentItem.type === 'break' ? 'Repos' : 'Étape')}`;
                 progressText = `Étape ${currentItemIndex + 1} / ${currentWorkoutPlan.length}`;

                 if (currentItem.type === 'exercise') {
                     const repsText = currentItem.reps !== null ? `${currentItem.reps}` : '-';
                     const detailsText = currentItem.details || 'Aucun détail';
                     infoHtml = `
                        <div class="exercise-details">
                             <span><i class="fas fa-hashtag"></i> Reps: <strong>${repsText}</strong></span>
                             <span class="details-text"><i class="fas fa-info-circle"></i> ${detailsText}</span>
                        </div>`;
                 } else if (currentItem.type === 'break') {
                     infoHtml = `
                        <div class="break-info">
                             <i class="fas fa-coffee"></i>
                             <span>Pause: ${formatTime(currentItem.duration || 0)}</span>
                         </div>`;
                 }
             } else if (isWorkoutActive) {
                 // Cas où l'item courant est indéfini mais workout actif (ne devrait pas arriver)
                 nameDisplay = 'Chargement étape...';
                 infoHtml = '<p>Patientez...</p>';
                 progressText = `Étape ? / ${currentWorkoutPlan.length}`;
             }

            // Mettre à jour le DOM
            currentExerciseNameDisplay.textContent = nameDisplay;
            currentExerciseContainer.innerHTML = infoHtml;

             // Mettre à jour le tracker de progression/statut Drive
             const driveStatusContainer = progressTracker.querySelector('#drive-connection-status-main')?.closest('.progress-tracker');
             if (driveStatusContainer && document.body.classList.contains('logged-in')) {
                 // Si connecté, afficher le statut de l'étape ET le statut Drive
                 progressTracker.innerHTML = `${progressText} <span style="margin: 0 5px;">|</span> ${driveStatusContainer.innerHTML}`; // Combine les deux
             } else {
                  // Si déconnecté ou pas de progression, afficher juste la progression (qui sera vide si idle)
                  progressTracker.textContent = progressText;
             }
        }


        function setState(newState) {
            if (!startPauseBtn || !skipBtn || !finishBtn || !resetBtn || !timerStateDisplay || !workoutSection) {
                 console.error("setState: Elements DOM manquants.");
                 return;
            }
            const previousState = currentState;
            currentState = newState;
            console.log(`Transition État: ${previousState} -> ${newState}`);

            // Nettoyage générique avant de définir le nouvel état
            timerStateDisplay.classList.remove('visible', 'preparing');
            clearInterval(timerInterval);
            timerInterval = null;
            clearInterval(prepareCountdownInterval);
            prepareCountdownInterval = null;
            startPauseBtn.classList.remove('pause-btn');
            document.body.classList.toggle('workout-active', newState !== 'idle' && newState !== 'finished');

            // Gérer les états spécifiques
            switch (newState) {
                case 'idle':
                    isTimerRunning = false;
                    isWorkoutActive = false;
                    workoutFinished = false;
                    timeLeft = 0;
                    totalTime = 0;
                    workoutSection.classList.remove('finished-animation');
                    timerStateDisplay.textContent = ''; // Pas de texte d'état
                    break;

                case 'preparing':
                    isTimerRunning = false;
                    isWorkoutActive = true; // L'entraînement a commencé
                    workoutFinished = false;
                    timerStateDisplay.textContent = `${PREPARE_DURATION}`; // Le temps sera affiché ici
                    timerStateDisplay.classList.add('visible', 'preparing');
                    prepareTimeLeft = PREPARE_DURATION;
                    startPrepareCountdown(); // Lance le décompte
                    break;

                case 'exercise':
                    isTimerRunning = false; // Le timer n'est pas actif pour l'exo lui-même
                    isWorkoutActive = true;
                    workoutFinished = false;
                    timerStateDisplay.textContent = 'EXERCICE';
                    timerStateDisplay.classList.add('visible');
                    timeLeft = 0; // Pas de temps à décompter pour l'exercice
                    totalTime = 0;
                    break;

                case 'break':
                    isTimerRunning = true; // Le timer de pause est actif
                    isWorkoutActive = true;
                    workoutFinished = false;
                    timerStateDisplay.textContent = 'REPOS';
                    timerStateDisplay.classList.add('visible');
                    // totalTime et timeLeft sont définis avant d'appeler setState('break')
                    startBreakTimer(); // Lance le décompte de la pause
                    break;

                case 'paused':
                     isTimerRunning = false; // Le timer est arrêté
                     isWorkoutActive = true;
                     workoutFinished = false;
                     timerStateDisplay.textContent = 'EN PAUSE';
                     timerStateDisplay.classList.add('visible');
                    // timeLeft conserve sa valeur
                    break;

                case 'finished':
                    isTimerRunning = false;
                    isWorkoutActive = false; // L'entraînement n'est plus actif
                    workoutFinished = true; // Il est terminé
                    timerStateDisplay.textContent = 'FINI !';
                    timerStateDisplay.classList.add('visible');
                    timeLeft = 0;
                    totalTime = 0;
                    elapsedWorkoutEstimatedSeconds = totalWorkoutEstimatedSeconds; // Marquer comme 100% estimé
                    showMessage('Entraînement terminé ! 💪', 4000);
                    vibrate([200, 100, 200]);
                    if (endSound) endSound();
                    originalCompletedWorkoutPlan = JSON.parse(JSON.stringify(currentWorkoutPlan)); // Copie pour le résumé
                    saveWorkoutToHistory(); // Sauvegarder dans l'historique (local et Drive)
                    clearInProgressState(); // Nettoyer l'état sauvegardé localement
                    workoutSection.classList.add('finished-animation'); // Animation visuelle
                    setTimeout(() => {
                        populateAndShowSummary(); // Afficher le résumé après l'animation
                    }, FINISH_ANIMATION_DURATION);
                    break;

                default:
                    console.error("État inconnu demandé:", newState);
                    currentState = 'idle'; // Revenir à l'état idle par sécurité
                    break;
            }

            // Mettre à jour l'UI après avoir défini le nouvel état
            updateTimerDisplay(); // Met à jour l'affichage du temps et des cercles
            checkEnableStartButton(); // Met à jour l'état des boutons de contrôle
            updateWorkoutInfo(); // Met à jour les infos affichées sur l'exercice/repos
        }

        function startPrepareCountdown() {
             if (prepareCountdownInterval) clearInterval(prepareCountdownInterval);

             updateWorkoutInfo(); // Afficher "Préparez..."
             updateTimerDisplay(); // Afficher le décompte initial (ex: 00:03)
             timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`; // Texte explicite

             prepareCountdownInterval = setInterval(() => {
                 prepareTimeLeft--;
                 updateWorkoutInfo(); // Mettre à jour le message avec le temps restant
                 updateTimerDisplay(); // Mettre à jour l'affichage du temps
                 timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`;

                 if (prepareTimeLeft <= 0) {
                     clearInterval(prepareCountdownInterval);
                     prepareCountdownInterval = null;
                     if (endSound) endSound(); // Son pour démarrer
                     vibrate([50]); // Vibration courte

                     const firstItem = currentWorkoutPlan[0];
                     if (!firstItem) {
                         console.error("Plan d'entraînement vide après la préparation.");
                         resetCurrentWorkout();
                         return;
                     }
                     // Passer à la première étape (exercice ou repos)
                     if (firstItem.type === 'exercise') {
                         setState('exercise');
                     } else { // C'est une pause
                         totalTime = firstItem.duration || 0;
                         timeLeft = totalTime;
                         setState('break');
                     }
                     saveInProgressState(); // Sauvegarder l'état au début de la première vraie étape
                 }
             }, 1000);
        }

        function startBreakTimer() {
            if (timerInterval) clearInterval(timerInterval);

            updateTimerDisplay(); // Afficher le temps de pause initial

            timerInterval = setInterval(() => {
                if (timeLeft > 0) {
                    timeLeft--;
                    updateTimerDisplay(); // Mettre à jour l'affichage chaque seconde
                    saveInProgressState(); // Sauvegarder l'état en cours de pause
                } else {
                     // Temps de pause écoulé
                     clearInterval(timerInterval);
                     timerInterval = null;
                     handleItemCompletion(true); // Passer à l'étape suivante (true = fin naturelle)
                }
            }, 1000);
        }

        function handleItemCompletion(naturalCompletion = false) {
            if (currentState === 'finished' || currentState === 'preparing') return; // Ne rien faire si déjà fini ou en prépa

            const completedItemIndex = currentItemIndex;
            const completedItem = currentWorkoutPlan[completedItemIndex];

            // Mettre à jour la progression estimée
            if (completedItem && completedItem.estimatedDuration !== undefined) {
                elapsedWorkoutEstimatedSeconds += completedItem.estimatedDuration;
                // S'assurer de ne pas dépasser le total (peut arriver avec estimations)
                elapsedWorkoutEstimatedSeconds = Math.min(elapsedWorkoutEstimatedSeconds, totalWorkoutEstimatedSeconds);
                console.log(`Item ${completedItemIndex} (${completedItem.type}) terminé. Temps estimé écoulé: ${elapsedWorkoutEstimatedSeconds.toFixed(1)} / ${totalWorkoutEstimatedSeconds.toFixed(1)}`);
            } else {
                 console.warn(`Durée estimée non trouvée pour l'item ${completedItemIndex} lors de la complétion.`);
            }
            // Mettre à jour le cercle de progression totale immédiatement
             updateTotalProgressCircle();

            // Son et vibration si c'est la fin naturelle d'une pause
            if (naturalCompletion && currentState === 'break') {
                if (endSound) endSound();
                vibrate();
            }

             // Passer à l'item suivant
             currentItemIndex++;
             saveInProgressState(); // Sauvegarder l'état après avoir incrémenté l'index

             // Vérifier si l'entraînement est terminé
             if (currentItemIndex >= currentWorkoutPlan.length) {
                 setState('finished');
             } else {
                 // Passer à l'item suivant
                 const nextItem = currentWorkoutPlan[currentItemIndex];
                 if (!nextItem) {
                     console.error("Élément suivant invalide dans le plan d'entraînement.");
                     setState('finished'); // Terminer si le plan est corrompu
                     return;
                 }

                 // Définir l'état pour le nouvel item
                 if (nextItem.type === 'exercise') {
                     setState('exercise');
                 } else { // C'est une pause
                     totalTime = nextItem.duration || 0;
                     timeLeft = totalTime;
                     setState('break');
                 }
             }
        }

        function forceFinishWorkout() {
             if (!isWorkoutActive || workoutFinished || currentState === 'preparing') return; // Ne rien faire si pas en cours ou en prépa

             if (confirm("Êtes-vous sûr de vouloir terminer cet entraînement maintenant ?")) {
                 clearInterval(timerInterval);
                 clearInterval(prepareCountdownInterval);
                 timerInterval = null;
                 prepareCountdownInterval = null;
                 elapsedWorkoutEstimatedSeconds = totalWorkoutEstimatedSeconds; // Marquer comme 100%
                 setState('finished'); // Passer à l'état terminé
                 showMessage("Entraînement terminé manuellement.", 3000);
             }
        }

        function loadWorkout(type) {
            if (!googleAccessToken) {
                 showMessage("Connectez-vous à Google Drive pour charger un entraînement.", 4000);
                 setActiveWorkoutNav(null); // Désélectionner visuellement le bouton
                 return;
             }
             if (!programsLoaded) {
                 showMessage("Les programmes sont en cours de chargement ou une erreur est survenue. Veuillez patienter.", 4000);
                 setActiveWorkoutNav(null);
                 return;
            }

            // Vérifier si un autre entraînement est actif
             if (isWorkoutActive && !workoutFinished && currentWorkoutType !== type) {
                 if (!confirm(`Un entraînement "${currentWorkoutType || 'en cours'}" est actif. Voulez-vous l'arrêter et charger "${type}" ?`)) {
                    setActiveWorkoutNav(currentWorkoutType); // Resélectionner l'actuel
                    return; // Annuler le chargement
                 } else {
                     resetCurrentWorkout(); // Arrêter l'entraînement actuel avant de charger le nouveau
                 }
             } else if (currentWorkoutType === type && (isWorkoutActive || workoutFinished || currentState !== 'idle')) {
                 // Si on clique sur le même workout déjà chargé/actif/fini
                 showMessage(`L'entraînement "${type}" est déjà chargé. Cliquez sur Reset ou démarrez/reprenez.`, 3000);
                 showSection('workout'); // Assurer que la section workout est visible
                 setActiveWorkoutNav(type); // Garder sélectionné
                 return;
             }

             // Vérifier si le programme existe dans les données chargées
            if (!loadedWorkouts[type]) {
                 console.error(`Programme '${type}' introuvable dans loadedWorkouts.`);
                 showMessage(`Erreur: Programme ${type} non trouvé ou non chargé correctement.`, 4000);
                 setActiveWorkoutNav(null);
                 return;
            }

            console.log(`Chargement de l'entraînement: ${type}`);
            currentWorkoutType = type;
             // Créer une copie profonde pour éviter de modifier l'original dans loadedWorkouts
             currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[type]));
             originalCompletedWorkoutPlan = []; // Réinitialiser pour le résumé

            if (!currentWorkoutPlan || currentWorkoutPlan.length === 0) {
                 console.error(`Le programme ${type} chargé est vide ou invalide.`);
                 showMessage(`Erreur: Le programme "${type}" est vide. Vérifiez le fichier sur Drive.`, 5000);
                 currentWorkoutType = null; // Annuler la sélection
                 setActiveWorkoutNav(null);
                 return;
             }

            // Calculer le temps estimé et réinitialiser les variables d'état
            totalWorkoutEstimatedSeconds = calculateTotalEstimatedTime(currentWorkoutPlan); // Recalcule et stocke les durées estimées
            elapsedWorkoutEstimatedSeconds = 0;
            currentItemIndex = 0;
            workoutStartTime = null; // Sera défini au démarrage réel
            workoutFinished = false;
            isWorkoutActive = false;

            setActiveWorkoutNav(type); // Mettre en surbrillance le bouton de navigation
            showSection('workout'); // Afficher la section timer

            // Nettoyer les timers et passer à l'état 'idle' (prêt à démarrer)
            clearInterval(timerInterval);
            timerInterval = null;
            clearInterval(prepareCountdownInterval);
            prepareCountdownInterval = null;
            isTimerRunning = false;
            setState('idle'); // Important: appelle updateWorkoutInfo, updateTimerDisplay, checkEnableStartButton

            showMessage(`Programme "${type}" (${currentWorkoutPlan.length} étapes) chargé. Prêt à démarrer !`, 3500);
            // checkEnableStartButton a déjà été appelé par setState('idle')
        }

        function resetCurrentWorkout() {
            console.log("Réinitialisation de l'entraînement en cours...");
            clearInterval(timerInterval);
            timerInterval = null;
            clearInterval(prepareCountdownInterval);
            prepareCountdownInterval = null;

            const typeReset = currentWorkoutType; // Garder le type pour le message

            // Réinitialiser toutes les variables d'état liées à l'entraînement
            currentWorkoutType = null;
            currentWorkoutPlan = [];
            originalCompletedWorkoutPlan = [];
            currentItemIndex = 0;
            workoutStartTime = null;
            isTimerRunning = false;
            isWorkoutActive = false;
            workoutFinished = false;
            timeLeft = 0;
            totalTime = 0;
            prepareTimeLeft = 0;
            totalWorkoutEstimatedSeconds = 0;
            elapsedWorkoutEstimatedSeconds = 0;

            clearInProgressState(); // Supprimer la sauvegarde locale
            closeSummary(); // Fermer le résumé s'il est ouvert
            workoutSection.classList.remove('finished-animation'); // Enlever l'effet visuel de fin

            // Désélectionner les boutons de navigation
            setActiveWorkoutNav(null);
             showSection('workout'); // Rester sur la section workout

            // Passer à l'état 'idle' et mettre à jour l'UI
             setState('idle'); // Ceci mettra à jour l'affichage, les boutons, etc.

            if (typeReset) {
                showMessage(`Entraînement "${typeReset}" réinitialisé.`, 2500);
            } else {
                showMessage(`État réinitialisé.`, 2000);
            }

            // S'assurer que l'UI reflète correctement l'état connecté/déconnecté
            updateAuthUI(!!googleAccessToken);
        }

        function showMessage(msg, duration = 3500) {
            if (!messageArea) return;

            messageArea.textContent = msg;
            messageArea.classList.add('visible'); // Rendre visible

            // Effacer le timeout précédent s'il existe
            if (messageTimeoutId) {
                clearTimeout(messageTimeoutId);
            }

            // Créer un nouveau timeout pour masquer le message
            messageTimeoutId = setTimeout(() => {
                messageArea.classList.remove('visible');
                messageTimeoutId = null; // Réinitialiser l'ID du timeout
            }, duration);
        }

        // --- Gestion du Thème ---
        function applyTheme(theme) {
            const body = document.body;
            currentTheme = theme;
            const isDark = theme === 'dark';

            // Appliquer la classe principale au body
            body.classList.remove('light-theme', 'dark-theme');
            body.classList.add(theme + '-theme');

            // Mettre à jour l'icône du bouton
            if (themeToggleBtn) {
                themeToggleBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
            }

            // Sauvegarder la préférence
            try {
                 localStorage.setItem('theme', theme);
             } catch (e) {
                 console.warn("Impossible de sauvegarder le thème dans localStorage:", e);
             }

            // Mettre à jour le graphique si visible
             if (historyChart && historyChartCanvas && !historySection?.classList.contains('section-hidden')) {
                 updateChartTheme();
             }

            console.log(`Thème appliqué: ${theme}`);
        }

        // Fonction pour mettre à jour les couleurs du graphique selon le thème
        function updateChartTheme() {
            if (!historyChart) return;

            const bodyStyles = getComputedStyle(document.documentElement);
            const gridColor = bodyStyles.getPropertyValue('--border-color').trim();
            const textColor = bodyStyles.getPropertyValue('--primary-text-color').trim();
            const tooltipBg = bodyStyles.getPropertyValue('--secondary-bg-color').trim();
            const primaryColor = bodyStyles.getPropertyValue('--neon-blue').trim();
            const accentColor = bodyStyles.getPropertyValue('--neon-pink').trim();

             try {
                // Mettre à jour les couleurs des axes, grilles, légendes, tooltips
                const scales = historyChart.options.scales;
                if (scales) {
                     if (scales.x) {
                         scales.x.grid.color = gridColor;
                         scales.x.ticks.color = textColor;
                         if (scales.x.title) scales.x.title.color = textColor;
                     }
                     if (scales.y) {
                         scales.y.grid.color = gridColor;
                         scales.y.ticks.color = textColor;
                         if (scales.y.title) scales.y.title.color = textColor;
                     }
                 }

                const plugins = historyChart.options.plugins;
                 if (plugins) {
                     if (plugins.tooltip) {
                         plugins.tooltip.backgroundColor = tooltipBg;
                         plugins.tooltip.titleColor = textColor; // Utiliser textColor pour titres aussi
                         plugins.tooltip.bodyColor = textColor;
                     }
                     if (plugins.legend && plugins.legend.labels) {
                         plugins.legend.labels.color = textColor;
                     }
                 }

                 // Mettre à jour les couleurs du dataset (barres)
                 if (historyChart.data.datasets && historyChart.data.datasets[0]) {
                     historyChart.data.datasets[0].backgroundColor = primaryColor + '99'; // Ajouter transparence
                     historyChart.data.datasets[0].borderColor = primaryColor;
                     historyChart.data.datasets[0].hoverBackgroundColor = accentColor + 'CC';
                     historyChart.data.datasets[0].hoverBorderColor = accentColor;
                 }

                 // Appliquer les changements sans animation pour fluidité
                 historyChart.update('none');
                 console.log("Thème du graphique mis à jour.");

             } catch (e) {
                 console.error("Erreur lors de la mise à jour du thème du graphique:", e);
             }
        }


        // --- Gestion Affichage Sections ---
        function showSection(sectionName) {
            if (!workoutSection || !historySection || !navHistoryBtn || !navButtons) return;

             closeSummary(); // Toujours fermer le résumé en changeant de section

            const isHistory = sectionName === 'history';

            workoutSection.classList.toggle('section-hidden', isHistory);
            historySection.classList.toggle('section-hidden', !isHistory);

            navHistoryBtn.classList.toggle('active', isHistory);
            // Mettre à jour le bouton de nav actif pour les workouts SEULEMENT si on va vers la section workout
             if (!isHistory) {
                 setActiveWorkoutNav(currentWorkoutType); // Rétablir la sélection du workout en cours/chargé
             } else {
                 navButtons.forEach(btn => btn.classList.remove('active')); // Désactiver tous les boutons workout si on va vers historique
                 displayHistory(currentHistoryPeriod); // Charger/afficher l'historique quand la section devient visible
             }
        }

        function setActiveWorkoutNav(workoutType) {
            if (!navButtons) return;
             navButtons.forEach(btn => {
                 btn.classList.toggle('active', btn.dataset.workout === workoutType);
             });
             // Si aucun workoutType n'est fourni (ex: reset), tous seront désactivés
        }

        // --- Persistance Locale (État en Cours) ---
        function saveInProgressState() {
            // Ne pas sauvegarder si pas actif, fini, idle, ou preparing
             if (!isWorkoutActive || workoutFinished || currentState === 'idle' || currentState === 'preparing') {
                 clearInProgressState(); // Nettoyer si l'état n'est plus pertinent
                 return;
             }

            const stateToSave = {
                 type: currentWorkoutType,
                 index: currentItemIndex,
                 timeLeft: timeLeft, // Temps restant (pour pause)
                 totalTime: totalTime, // Durée totale de la pause en cours
                 currentState: currentState, // exercise, break, paused
                 startTime: workoutStartTime, // Timestamp de début
                 totalEstimated: totalWorkoutEstimatedSeconds,
                 elapsedEstimated: elapsedWorkoutEstimatedSeconds,
                 // Sauvegarder aussi le plan pour vérifier la cohérence? Peut être lourd.
             };

             try {
                 localStorage.setItem(IN_PROGRESS_KEY, JSON.stringify(stateToSave));
                 console.log("État local 'en cours' sauvegardé:", stateToSave);
             } catch (e) {
                 console.error("Sauvegarde de l'état local échouée:", e);
                 showMessage("Erreur lors de la sauvegarde locale de la progression.", 5000);
             }
        }

        function loadInProgressState() {
             console.log(`loadInProgressState: Recherche dans localStorage pour la clé: "${IN_PROGRESS_KEY}"`);
             const savedStateJSON = localStorage.getItem(IN_PROGRESS_KEY);

             if (!savedStateJSON) {
                 console.log("loadInProgressState: Aucun état sauvegardé trouvé.");
                 return false; // Pas d'état à reprendre
             }

            try {
                 const savedState = JSON.parse(savedStateJSON);
                 console.log("État local trouvé:", savedState);

                 // Validation robuste des données sauvegardées
                 if (
                    !savedState || typeof savedState !== 'object' ||
                    !savedState.type || !PROGRAM_TYPES.includes(savedState.type) || // Vérifier si le type est valide
                    typeof savedState.index !== 'number' || savedState.index < 0 ||
                    typeof savedState.currentState !== 'string' ||
                     !['exercise', 'break', 'paused'].includes(savedState.currentState) || // Seuls ces états sont reprenables
                    typeof savedState.totalEstimated !== 'number' ||
                    typeof savedState.elapsedEstimated !== 'number' ||
                    savedState.index >= (loadedWorkouts[savedState.type]?.length || 0) // Vérifier si l'index est valide pour le plan chargé
                 ) {
                     console.warn("État local trouvé mais invalide ou incomplet. Suppression.", savedState);
                     clearInProgressState();
                     return false;
                 }

                 // Proposer la reprise seulement si connecté et programmes chargés
                 if (googleAccessToken && programsLoaded) {
                     const timeAgo = savedState.startTime ? ` (commencé ${new Date(savedState.startTime).toLocaleString('fr-FR', { short: 'short' })})` : '';
                     if (confirm(`Un entraînement "${savedState.type}" était en cours${timeAgo}. Voulez-vous le reprendre à l'étape ${savedState.index + 1} (${savedState.currentState}) ?`)) {
                         console.log("Reprise de l'état local acceptée.");

                         // Appliquer l'état sauvegardé
                         currentWorkoutType = savedState.type;
                         currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[currentWorkoutType])); // Recharger depuis les données actuelles
                         totalWorkoutEstimatedSeconds = calculateTotalEstimatedTime(currentWorkoutPlan); // Recalculer temps total
                         elapsedWorkoutEstimatedSeconds = savedState.elapsedEstimated;
                         originalCompletedWorkoutPlan = []; // Pas de résumé pour une reprise
                         currentItemIndex = savedState.index;
                         timeLeft = savedState.timeLeft;
                         totalTime = savedState.totalTime;
                         workoutStartTime = savedState.startTime;
                         isWorkoutActive = true; // Marquer comme actif
                         workoutFinished = false;

                         setActiveWorkoutNav(currentWorkoutType);
                         showSection('workout');

                        // Restaurer l'état spécifique (exercise, break (-> paused), paused)
                        const stateToRestore = savedState.currentState;
                        if (stateToRestore === 'exercise') {
                            setState('exercise');
                        } else if (stateToRestore === 'break' || stateToRestore === 'paused') {
                             // Si l'état sauvegardé était 'break', on reprend en 'paused'
                             timeLeft = savedState.timeLeft; // Assurer que timeLeft est correct
                             totalTime = savedState.totalTime;
                             setState('paused');
                        }

                         console.log(`Reprise état: ${currentState}, Index: ${currentItemIndex}, Temps Restant: ${timeLeft}, Estimé: ${elapsedWorkoutEstimatedSeconds.toFixed(1)}/${totalWorkoutEstimatedSeconds.toFixed(1)}`);
                         showMessage(`Progression "${currentWorkoutType}" restaurée.`, 3500);
                         updateAuthUI(true); // Mettre à jour l'UI globale
                         return true; // Reprise réussie
                     } else {
                         console.log("Reprise de l'état local refusée par l'utilisateur.");
                         clearInProgressState(); // Nettoyer si refusé
                         return false;
                     }
                 } else {
                     console.log("État local trouvé, mais reprise impossible (non connecté ou programmes non chargés).");
                     // Ne pas nettoyer l'état ici, il pourrait être repris plus tard si l'utilisateur se connecte.
                     return false;
                 }
            } catch (e) {
                 console.error("Erreur lors du chargement ou parsing de l'état local:", e);
                 clearInProgressState(); // Nettoyer en cas d'erreur de parsing
                 return false;
            }
        }

        function clearInProgressState() {
            try {
                 localStorage.removeItem(IN_PROGRESS_KEY);
                 console.log("État local 'en cours' supprimé.");
             } catch (e) {
                 console.error("Erreur lors de la suppression de l'état local:", e);
             }
        }

        // --- Gestion de l'Historique ---

        function saveWorkoutToHistory() {
             const finalWorkoutType = currentWorkoutType;
             // Vérifier si un type et une date de début existent
             if (!finalWorkoutType || workoutStartTime === null) {
                 console.warn("Sauvegarde dans l'historique annulée: type d'entraînement ou heure de début manquants.");
                 return;
             }
              // Vérifier la connexion Google
              if (!googleAccessToken) {
                  showMessage("Connectez-vous à Google Drive pour sauvegarder l'historique.", 4000);
                  // On pourrait stocker localement temporairement, mais pour l'instant on ne sauvegarde pas sans connexion
                  return;
              }

              const endTime = Date.now();
              const durationSeconds = Math.round((endTime - workoutStartTime) / 1000);

              // Ne pas sauvegarder les entraînements très courts (moins de 10s)
              if (durationSeconds < 10) {
                  console.log(`Entraînement trop court (${durationSeconds}s), non sauvegardé dans l'historique.`);
                  return;
              }

              // Créer la nouvelle entrée d'historique
              const newEntry = {
                  id: endTime.toString(), // Utiliser timestamp de fin comme ID unique simple
                  date: new Date(endTime).toISOString(), // Format ISO 8601 pour la date/heure
                  type: finalWorkoutType,
                  duration: durationSeconds
              };

              console.log("Ajout à l'historique local:", newEntry);
              // Ajouter au début du tableau local (pour affichage immédiat)
              workoutHistory.unshift(newEntry);

             // Mettre à jour l'affichage si la section historique est visible
             if (historySection && !historySection.classList.contains('section-hidden')) {
                 displayHistory(currentHistoryPeriod);
             }

             // Sauvegarder l'historique complet sur Google Drive (de manière asynchrone)
             saveHistoryToDrive(); // Ne bloque pas l'UI
         }

         async function saveHistoryToDrive() {
            if (!googleAccessToken) {
                 console.warn("Tentative de sauvegarde Drive sans être connecté.");
                 return; // Ne rien faire si pas connecté
            }

            // S'assurer qu'on a l'ID du fichier historique
            if (!historyFileId) {
                 console.log("ID du fichier historique inconnu. Tentative de recherche/création...");
                 // Utiliser le contenu par défaut avec en-tête
                 const defaultHeader = "DateISO,WorkoutType,DurationSeconds,EntryID\n";
                 historyFileId = await findOrCreateFile(HISTORY_FILENAME, defaultHeader);
            }

             if (!historyFileId) {
                 showMessage("Impossible d'accéder ou de créer le fichier d'historique sur Drive.", 5000);
                 return; // Arrêter si on n'a toujours pas d'ID
             }

             // Préparer le contenu CSV à partir de l'historique local actuel
             let csvContent = "DateISO,WorkoutType,DurationSeconds,EntryID\n"; // En-tête
             // Trier l'historique par date décroissante avant de sauvegarder (même si déjà trié localement)
             const sortedHistory = [...workoutHistory].sort((a, b) => new Date(b.date) - new Date(a.date));
             sortedHistory.forEach(entry => {
                 // Nettoyer les données pour le CSV
                 const cleanType = (entry.type || '').replace(/,/g, ''); // Enlever les virgules du type
                 const date = entry.date || new Date().toISOString();
                 const duration = entry.duration || 0;
                 const id = entry.id || Date.now().toString(); // Assurer un ID
                 csvContent += `${date},${cleanType},${duration},${id}\n`;
             });

             // Mettre à jour le fichier sur Drive
             console.log(`Tentative de mise à jour du fichier historique (${historyFileId}) avec ${sortedHistory.length} entrées.`);
             const success = await updateFileContent(historyFileId, csvContent);

             if (success) {
                 console.log("Historique synchronisé avec Google Drive avec succès.");
                 if (historyDriveStatus) historyDriveStatus.textContent = 'Synchro OK';
             } else {
                 console.error("Échec de la synchronisation de l'historique avec Google Drive.");
                 showMessage("Erreur lors de la sauvegarde de l'historique sur Drive.", 4000);
                 if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Sync';
             }
         }

         async function loadHistoryFromDrive() {
            console.log("loadHistoryFromDrive: Démarrage du chargement...");
             if (!googleAccessToken) {
                 console.log("Non connecté, historique local vidé.");
                 workoutHistory = [];
                 // Afficher message dans l'UI historique si les éléments existent
                 if (historyList) historyList.innerHTML = `<li class="no-history">Connectez-vous pour voir l'historique.</li>`;
                 if (statsDisplay) displayStatsAndMotivation([], currentHistoryPeriod, false);
                 if (historyChartCanvas) renderHistoryChart([], currentHistoryPeriod);
                 return false; // Échec car non connecté
             }

             console.log("Chargement de l'historique depuis Google Drive...");
             if (historyDriveStatus) historyDriveStatus.textContent = 'Chargement Hist...';

             // Trouver ou créer le fichier historique
             if (!historyFileId) {
                 const defaultHeader = "DateISO,WorkoutType,DurationSeconds,EntryID\n";
                 historyFileId = await findOrCreateFile(HISTORY_FILENAME, defaultHeader);
             }

             if (!historyFileId) {
                 showMessage("Impossible d'accéder au fichier d'historique sur Drive.", 5000);
                 workoutHistory = []; // Vider l'historique local en cas d'échec
                 displayHistory(currentHistoryPeriod); // Mettre à jour l'UI (affichera "Aucune donnée")
                 if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Accès Hist.';
                 return false; // Échec
             }

             // Lire le contenu du fichier
             const csvContent = await readFileContent(historyFileId);

            if (csvContent === null) {
                 // Erreur lors de la lecture (gérée dans readFileContent, ex: auth expirée)
                 workoutHistory = [];
                 showMessage("Erreur lors de la lecture de l'historique Drive.", 4000);
                 if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Lecture Hist.';
                 // Afficher l'historique vide
                 displayHistory(currentHistoryPeriod);
                 return false; // Échec
             } else if (csvContent === "") {
                 // Fichier trouvé mais vide
                 workoutHistory = [];
                 console.log("Fichier d'historique Drive trouvé mais vide.");
                 if (historyDriveStatus) historyDriveStatus.textContent = 'Hist. Vide';
             } else {
                 // Parser le contenu CSV
                 parseAndLoadHistoryCsvData(csvContent);
                 console.log(`Historique chargé depuis Drive: ${workoutHistory.length} entrées trouvées.`);
                 if (historyDriveStatus) historyDriveStatus.textContent = 'Synchro OK';
             }

             // Mettre à jour l'affichage de l'historique (liste, stats, graphique)
             displayHistory(currentHistoryPeriod);
             return true; // Succès (même si vide)
         }

        function parseAndLoadHistoryCsvData(csvContent) {
            try {
                const lines = csvContent.trim().split(/\r?\n/); // Gérer fins de ligne Windows/Unix
                const newHistory = [];
                const existingIDs = new Set(); // Pour éviter les doublons si l'ID est présent

                if (lines.length <= 1) {
                    console.log("Fichier CSV d'historique vide ou ne contient que l'en-tête.");
                    workoutHistory = [];
                    return;
                }

                // Détecter l'en-tête (robuste)
                const headerLine = lines[0].trim().toLowerCase();
                const hasHeader = headerLine.includes("dateiso") && headerLine.includes("workouttype") && headerLine.includes("durationseconds");
                const startIndex = hasHeader ? 1 : 0; // Commencer après l'en-tête si présent

                console.log(`Parsing CSV: ${lines.length - startIndex} lignes de données potentielles.`);

                for (let i = startIndex; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue; // Ignorer lignes vides

                    // Split basique (peut échouer si virgules dans les champs non quotés)
                    const values = line.split(',');

                     // Validation simple du nombre de colonnes
                     if (values.length < 3) {
                         console.warn(`Ligne historique ignorée (format invalide, < 3 champs): ${line}`);
                         continue;
                     }

                    const dateStr = values[0]?.trim();
                     const typeStr = values[1]?.trim();
                     const durationStr = values[2]?.trim();
                     const idStr = (values.length > 3) ? values[3]?.trim() : null; // ID optionnel dans la 4ème colonne

                     // Validation des données
                     const date = new Date(dateStr);
                     const duration = parseInt(durationStr, 10);

                     if (isNaN(date.getTime())) {
                         console.warn(`Ligne historique ignorée (date invalide '${dateStr}'): ${line}`);
                         continue;
                     }
                     // Vérifier si le type est connu (PROGRAM_TYPES)
                     if (!PROGRAM_TYPES.includes(typeStr)) {
                         console.warn(`Ligne historique ignorée (type inconnu '${typeStr}'): ${line}`);
                         continue;
                     }
                      if (isNaN(duration) || duration < 0) {
                          console.warn(`Ligne historique ignorée (durée invalide '${durationStr}'): ${line}`);
                          continue;
                      }

                      // Utiliser l'ID du CSV si présent et valide, sinon générer un ID basé sur la date/index
                      const entryId = idStr || `${date.getTime()}-${i}`;

                      // Éviter les doublons basés sur l'ID
                      if (existingIDs.has(entryId)) {
                          console.warn(`ID d'historique dupliqué ignoré: ${entryId} (ligne: ${line})`);
                          continue;
                      }

                      // Ajouter l'entrée valide
                      newHistory.push({
                          id: entryId,
                          date: date.toISOString(), // Stocker en ISO pour cohérence
                          type: typeStr,
                          duration: duration
                      });
                      existingIDs.add(entryId); // Marquer l'ID comme utilisé
                 }

                 // Trier l'historique final par date (du plus récent au plus ancien)
                 newHistory.sort((a, b) => new Date(b.date) - new Date(a.date));

                 workoutHistory = newHistory; // Remplacer l'historique local
                 console.log(`Parsing CSV terminé. ${workoutHistory.length} entrées valides chargées.`);

             } catch (error) {
                 console.error("Erreur lors du parsing du CSV d'historique:", error);
                 showMessage(`Erreur parsing historique: ${error.message}`, 6000);
                 workoutHistory = []; // Réinitialiser en cas d'erreur majeure
             }
         }

        function displayHistory(period = currentHistoryPeriod) {
             // Vérifier si les éléments DOM existent
             if (!historyList || !statsDisplay || !historyFilterBtns || !historyChartCanvas) {
                 console.warn("displayHistory: Éléments DOM manquants pour afficher l'historique.");
                 return;
             }

             currentHistoryPeriod = period; // Mémoriser la période sélectionnée

             // Mettre à jour le bouton de filtre actif
             historyFilterBtns.forEach(btn => {
                 btn.classList.toggle('active', btn.dataset.period === period);
             });

             const isConnected = !!googleAccessToken; // Est-on connecté?
             const historyToDisplay = isConnected ? workoutHistory : []; // Utiliser l'historique si connecté

             // Filtrer l'historique selon la période
             const filteredHistory = filterHistoryByPeriod(historyToDisplay, period);
             console.log(`Affichage historique pour période '${period}'. ${filteredHistory.length} entrées filtrées.`);

             // Mettre à jour la liste
             historyList.innerHTML = ''; // Vider la liste précédente
             if (!isConnected) {
                 historyList.innerHTML = `<li class="no-history">Connectez-vous pour voir l'historique.</li>`;
             } else if (filteredHistory.length === 0) {
                 historyList.innerHTML = `<li class="no-history">Aucun entraînement enregistré pour cette période.</li>`;
             } else {
                 filteredHistory.forEach(entry => {
                     const li = document.createElement('li');
                     const entryDate = new Date(entry.date);
                     // Formatage dates/heures en français
                     const dateFormatted = entryDate.toLocaleDateString('fr-FR', { year: 'numeric', month: 'short', day: 'numeric' });
                     const timeFormatted = entryDate.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' });
                     const durationFormatted = formatTime(entry.duration);

                     li.innerHTML = `
                        <span class="history-item-date">${dateFormatted} <small>(${timeFormatted})</small></span>
                        <span class="history-item-type">${entry.type}</span>
                        <span class="history-item-duration">${durationFormatted}</span>
                    `;
                     historyList.appendChild(li);
                 });
             }

             // Mettre à jour les statistiques et le message de motivation
             displayStatsAndMotivation(filteredHistory, period, isConnected);

             // Mettre à jour le graphique
             renderHistoryChart(filteredHistory, period);
         }

         function filterHistoryByPeriod(history, period) {
            const now = new Date();
            // Pour les comparaisons de date, ignorer l'heure
             const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());

             return history.filter(entry => {
                const entryDate = new Date(entry.date);
                 if (isNaN(entryDate.getTime())) return false; // Ignorer dates invalides
                 // Comparer seulement les dates (année, mois, jour)
                 const entryDateStart = new Date(entryDate.getFullYear(), entryDate.getMonth(), entryDate.getDate());

                 switch (period) {
                     case 'week':
                          // Calculer le début de la semaine (Lundi)
                          const dayOfWeek = todayStart.getDay(); // Dimanche = 0, Lundi = 1, ...
                          const diffToMonday = todayStart.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); // Ajustement pour Lundi
                          const startOfWeek = new Date(now.getFullYear(), now.getMonth(), diffToMonday);
                          startOfWeek.setHours(0, 0, 0, 0); // Début de journée du Lundi
                         return entryDateStart >= startOfWeek;
                     case 'month':
                          const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                          return entryDateStart >= startOfMonth;
                     case 'year':
                          const startOfYear = new Date(now.getFullYear(), 0, 1); // 1er Janvier
                         return entryDateStart >= startOfYear;
                     case 'all':
                     default:
                          return true; // Inclure toutes les entrées
                 }
             });
         }

        function displayStatsAndMotivation(filteredHistory, period, isConnected) {
            if (!statsDisplay) return;

            const stats = calculateStats(filteredHistory); // Calculer les stats sur l'historique filtré

            let periodText = '';
            switch (period) {
                case 'week': periodText = 'Cette Semaine'; break;
                case 'month': periodText = 'Ce Mois'; break;
                case 'year': periodText = 'Cette Année'; break;
                case 'all': periodText = 'Total'; break;
            }

            // Mise à jour titre
            const statsTitleElement = statsDisplay.querySelector('h3');
            if (statsTitleElement) statsTitleElement.textContent = `Statistiques (${periodText})`;

            // Mise à jour contenu stats
            let statsHTML = "";
            if (!isConnected) {
                statsHTML = "<p>Connectez-vous pour voir vos statistiques.</p>";
            } else if (stats.count === 0) {
                statsHTML = "<p>Aucune donnée d'entraînement pour cette période.</p>";
            } else {
                // Générer le HTML pour les stats
                statsHTML = `
                    <p><i class="fas fa-calendar-check"></i> Nb séances: <strong>${stats.count}</strong></p>
                    <p><i class="fas fa-stopwatch"></i> Durée totale: <strong>${formatTime(stats.totalDuration)}</strong></p>
                    <p><i class="fas fa-hourglass-half"></i> Durée moy./séance: <strong>${formatTime(stats.avgDuration)}</strong></p>
                    <p><i class="fas fa-star"></i> Type + fréquent: <strong>${stats.mostFrequentType || 'N/A'}</strong> (${stats.frequency[stats.mostFrequentType] || 0}x)</p>
                `;
            }

             // Remplacer le contenu des stats (en gardant le titre s'il existe)
             statsDisplay.innerHTML = (statsTitleElement ? statsTitleElement.outerHTML : `<h3>Statistiques (${periodText})</h3>`) + statsHTML;

            // Mise à jour message motivationnel
            let msgElem = statsDisplay.querySelector('.motivational-message');
            if (!msgElem) { // Créer l'élément s'il n'existe pas
                 msgElem = document.createElement('p');
                 msgElem.className = 'motivational-message';
                 statsDisplay.appendChild(msgElem);
            }
             // Générer et afficher le message (ou "" si non connecté)
             msgElem.textContent = isConnected ? generateMotivationalMessage(stats, period) : "";
         }

        function calculateStats(history) {
            const count = history.length;
            let totalDuration = 0;
            const frequency = { Push: 0, Pull: 0, Legs: 0 }; // Initialiser pour tous les types

            history.forEach(entry => {
                 // S'assurer que duration est un nombre valide
                 const duration = Number(entry.duration);
                 if (!isNaN(duration)) {
                     totalDuration += duration;
                 }
                 // Incrémenter la fréquence si le type est connu
                 if (frequency.hasOwnProperty(entry.type)) {
                     frequency[entry.type]++;
                 }
             });

            const avgDuration = count > 0 ? Math.round(totalDuration / count) : 0;

            // Trouver le type le plus fréquent
            let mostFrequentType = null;
            let maxFrequency = -1; // Commencer à -1 pour gérer le cas où tout est à 0
            for (const type in frequency) {
                 if (frequency[type] > maxFrequency) {
                     maxFrequency = frequency[type];
                     mostFrequentType = type;
                 }
            }
             // Si maxFrequency est toujours 0 (ou -1), aucun n'est plus fréquent
             if (maxFrequency <= 0) {
                 mostFrequentType = null;
             }

             return {
                 count: count,
                 totalDuration: totalDuration,
                 avgDuration: avgDuration,
                 frequency: frequency, // Contient les comptes pour Push, Pull, Legs
                 mostFrequentType: mostFrequentType // Le nom du type le plus fréquent, ou null
             };
        }

        function generateMotivationalMessage(stats, period) {
            const { count } = stats;

             if (!googleAccessToken) return ""; // Pas de message si non connecté

            if (count === 0) {
                 switch (period) {
                     case 'week': return "Aucune séance cette semaine. Planifiez la prochaine ! 📅";
                     case 'month': return "Pas encore d'entraînement ce mois-ci. C'est le moment ! 🚀";
                     case 'year': return "Première séance de l'année à venir ? 🤔";
                     case 'all': return "Commencez votre parcours de fitness dès aujourd'hui ! 💪";
                     default: return "Prêt à démarrer ?";
                 }
             }

            // Messages basés sur le nombre de séances pour la période
             switch (period) {
                 case 'week':
                     if (count >= 5) return `Incroyable, ${count} séances cette semaine ! Vous êtes en feu ! 🔥`;
                     if (count >= 3) return `Super régularité avec ${count} séances cette semaine ! 👍`;
                     if (count >= 1) return `Bien joué pour votre ${count === 1 ? 'séance' : 'séances'} cette semaine ! Continuez ! ✨`;
                     break;
                 case 'month':
                     if (count >= 15) return `Quelle discipline ! ${count} séances ce mois-ci ! 🚀`;
                     if (count >= 10) return `Solide performance avec ${count} entraînements ce mois-ci ! 🎉`;
                     if (count >= 5) return `Belle progression ce mois (${count} séances) ! 😊`;
                     if (count >= 1) return `${count === 1 ? 'Première' : count + 'ème'} séance du mois enregistrée ! 🌱`;
                     break;
                 case 'year':
                 case 'all': // Utiliser les mêmes paliers pour Année et Tout
                     if (count >= 100) return `Légendaire ! Plus de ${count} séances enregistrées ! 🏆`;
                     if (count >= 50) return `Impressionnant ! Déjà ${count} séances au compteur ! 🏋️‍♂️`;
                     if (count >= 20) return `${count} séances, un beau parcours ! Continuez comme ça ! 🌟`;
                     if (count >= 1) return `Déjà ${count} entraînement${count > 1 ? 's' : ''} ! Chaque séance compte ! 🎯`;
                     break;
             }

             // Message par défaut si aucun palier n'est atteint (ne devrait pas arriver si count > 0)
             return "Continuez vos efforts, vous progressez ! 💯";
        }


        // --- Gestion des Programmes (CSV <-> Objet) ---

        function convertProgramToCsv(programArray) {
            const header = "Type,Name,Details,Reps,Duration\n";
            let csv = header;

            const escapeCsvField = (field) => {
                if (field === null || field === undefined) return '';
                const stringField = String(field);
                 // Si le champ contient une virgule, des guillemets ou un retour à la ligne,
                 // il faut l'entourer de guillemets et doubler les guillemets internes.
                 if (stringField.includes(',') || stringField.includes('"') || stringField.includes('\n')) {
                     return `"${stringField.replace(/"/g, '""')}"`;
                 }
                 return stringField;
            };

            programArray.forEach(item => {
                 if (item.type === 'exercise') {
                     // Utiliser nullish coalescing pour gérer reps/details absents ou null
                     const name = escapeCsvField(item.name ?? '');
                     const details = escapeCsvField(item.details ?? '');
                     // S'assurer que reps est un nombre ou vide
                     const reps = (item.reps !== null && Number.isFinite(item.reps)) ? item.reps : '';
                     csv += `${item.type},${name},${details},${reps},\n`; // Duration vide pour exercice
                 } else if (item.type === 'break') {
                     // S'assurer que duration est un nombre ou vide
                     const duration = (item.duration !== null && Number.isFinite(item.duration)) ? item.duration : '';
                     // Name et Details sont vides pour une pause, Reps aussi
                     csv += `${item.type},,,,${duration}\n`; // Utiliser 4 virgules pour les champs vides
                 }
                 // Ignorer les types inconnus
             });
             return csv;
        }

         function parseProgramCsvData(csvContent) {
            const program = [];
            if (!csvContent || typeof csvContent !== 'string') return program;

            const lines = csvContent.trim().split(/\r?\n/);
            if (lines.length <= 1) return program; // Vide ou juste header

             // Détection header plus simple
             const headerLine = lines[0].trim().toLowerCase();
             const hasHeader = headerLine.startsWith("type,name,details,reps,duration");
             const startIndex = hasHeader ? 1 : 0;

            // Fonction pour parser une ligne CSV en gérant les guillemets
             const parseCsvLine = (line) => {
                 const values = [];
                 let currentVal = '';
                 let inQuotes = false;
                 for (let i = 0; i < line.length; i++) {
                     const char = line[i];
                     // Gérer les guillemets doublés à l'intérieur d'un champ quoté
                     if (char === '"' && inQuotes && i + 1 < line.length && line[i+1] === '"') {
                         currentVal += '"';
                         i++; // Sauter le deuxième guillemet
                     } else if (char === '"') {
                         inQuotes = !inQuotes; // Basculer l'état inQuotes
                     } else if (char === ',' && !inQuotes) {
                         values.push(currentVal.trim()); // Ajouter la valeur (sans espaces superflus)
                         currentVal = ''; // Réinitialiser pour la prochaine valeur
                     } else {
                         currentVal += char; // Ajouter le caractère à la valeur courante
                     }
                 }
                 values.push(currentVal.trim()); // Ajouter la dernière valeur
                 return values;
             };

            for (let i = startIndex; i < lines.length; i++) {
                 const line = lines[i].trim();
                 if (!line) continue; // Ignorer lignes vides

                const values = parseCsvLine(line);
                 if (values.length < 5) { // Attendre au moins 5 champs (même vides)
                      console.warn(`Ligne programme ignorée (format CSV invalide, < 5 champs): ${line}`);
                      continue;
                  }

                 const type = values[0]?.toLowerCase() || '';
                 const name = values[1] || ''; // Peut être vide pour 'break'
                 const details = values[2] || ''; // Peut être vide
                 const repsStr = values[3] || ''; // Peut être vide
                 const durationStr = values[4] || ''; // Peut être vide

                 if (type === 'exercise') {
                     const reps = parseInt(repsStr, 10);
                     if (!name) { // Un nom est requis pour un exercice
                         console.warn(`Ligne programme (exercice) ignorée (nom manquant): ${line}`);
                         continue;
                     }
                     program.push({
                         type: 'exercise',
                         name: name,
                         details: details,
                         // Stocker null si reps n'est pas un nombre ou vide
                         reps: (!isNaN(reps) && repsStr !== '') ? reps : null
                     });
                 } else if (type === 'break') {
                     const duration = parseInt(durationStr, 10);
                     // Une durée valide est requise pour une pause
                     if (isNaN(duration) || duration <= 0) {
                         console.warn(`Ligne programme (break) ignorée (durée invalide '${durationStr}'): ${line}`);
                         continue;
                     }
                     program.push({
                         type: 'break',
                         duration: duration,
                         name: name || 'Repos' // Utiliser 'Repos' comme nom par défaut si vide
                         // details et reps sont ignorés pour 'break'
                     });
                 } else {
                     console.warn(`Ligne programme ignorée (type inconnu '${type}'): ${line}`);
                 }
             }
             console.log(`Parsing programme CSV terminé. ${program.length} étapes valides trouvées.`);
             return program;
         }


        async function loadProgramsFromDrive() {
            console.log("loadProgramsFromDrive: Démarrage chargement des programmes...");
            if (!googleAccessToken) {
                 console.warn("loadProgramsFromDrive: Non connecté. Utilisation des programmes par défaut.");
                 loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
                 programsLoaded = false; // Marquer comme non chargés depuis Drive
                 return false; // Échec
            }

            programsLoaded = false; // Réinitialiser avant de commencer
            let allLoadedSuccessfully = true; // Suivre si tous les fichiers ont été chargés

            if (driveStatusElement) {
                driveStatusElement.textContent = 'Chargement Progs...';
                driveStatusElement.classList.add('loading');
                driveStatusElement.classList.remove('error','success');
                 driveStatusElement.style.display = 'inline-block';
            }

             // Utiliser Promise.all pour charger tous les programmes en parallèle
             const loadPromises = PROGRAM_TYPES.map(async (type) => {
                 const filename = PROGRAM_FILENAMES[type];
                 const defaultProgram = defaultWorkouts[type] || []; // Programme par défaut pour ce type
                 const defaultCsv = convertProgramToCsv(defaultProgram); // CSV par défaut

                 console.log(`Chargement programme: ${type} (fichier: ${filename})`);
                 const fileId = await findOrCreateFile(filename, defaultCsv);
                 programFileIds[type] = fileId; // Stocker l'ID trouvé/créé

                 if (fileId) {
                     const csvContent = await readFileContent(fileId);
                     if (csvContent !== null) { // Vérifier si la lecture a réussi (null = erreur)
                         try {
                             const parsedProgram = parseProgramCsvData(csvContent);
                             if (parsedProgram.length > 0) {
                                 loadedWorkouts[type] = parsedProgram;
                                 console.log(`Programme ${type} chargé depuis Drive (${parsedProgram.length} étapes).`);
                                 return true; // Succès pour ce type
                             } else {
                                 // Fichier lu mais parsing a échoué ou fichier vide (autre que header)
                                 console.warn(`Programme ${type} lu depuis Drive mais parsing invalide ou vide. Utilisation du programme par défaut.`);
                                 loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram));
                                 if (csvContent !== defaultCsv && csvContent.trim() !== "" && csvContent.trim().toLowerCase() !== "type,name,details,reps,duration") {
                                     showMessage(`Format du fichier ${filename} invalide sur Drive. Programme par défaut chargé.`, 5000);
                                 }
                                 return true; // Considéré comme succès car on a un fallback
                             }
                         } catch (parseError) {
                             console.error(`Erreur critique lors du parsing du programme ${type}:`, parseError);
                             showMessage(`Erreur parsing ${filename}. Programme par défaut chargé.`, 5000);
                             loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram));
                             return false; // Échec pour ce type à cause de l'erreur de parsing
                         }
                     } else {
                         // Échec de lecture du fichier (readFileContent a retourné null)
                         console.error(`Échec de lecture du fichier ${filename} (ID: ${fileId}). Utilisation du programme par défaut.`);
                         loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram));
                         return false; // Échec pour ce type
                     }
                 } else {
                     // Échec de findOrCreateFile pour ce type
                     console.error(`Échec d'accès/création du fichier ${filename}. Utilisation du programme par défaut.`);
                     loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram));
                     return false; // Échec pour ce type
                 }
             });

            // Attendre que toutes les promesses de chargement se terminent
             try {
                 const results = await Promise.all(loadPromises);
                 // Vérifier si *tous* les chargements ont réussi (ou ont eu un fallback)
                 allLoadedSuccessfully = results.every(success => success === true);
             } catch (error) {
                 // Une erreur non gérée dans les promesses? Ne devrait pas arriver avec le try/catch interne.
                 console.error("Erreur inattendue pendant Promise.all de loadProgramsFromDrive:", error);
                 allLoadedSuccessfully = false;
             }

             programsLoaded = allLoadedSuccessfully; // Mettre à jour l'état global
             console.log(`Fin du chargement des programmes. État global 'programsLoaded': ${programsLoaded}`);

            // Mettre à jour l'UI (statut Drive, boutons)
             if (driveStatusElement) {
                 driveStatusElement.classList.remove('loading');
                 if (!allLoadedSuccessfully) {
                     driveStatusElement.textContent = 'Erreur Progs';
                     driveStatusElement.classList.add('error');
                     showMessage("Certains programmes n'ont pas pu être chargés correctement depuis Drive.", 5000);
                 } else {
                     driveStatusElement.textContent = 'Connecté';
                     driveStatusElement.classList.add('success');
                     driveStatusElement.classList.remove('error'); // Assurer que error est enlevé si succès
                     console.log("Tous les programmes chargés avec succès (ou fallback utilisé).");
                 }
             }

            // Activer/désactiver les boutons dépendant des programmes
             if (navButtons) navButtons.forEach(btn => btn.disabled = !programsLoaded);
             if (exportProgramsBtn) exportProgramsBtn.disabled = !programsLoaded;
             checkEnableStartButton(); // Mettre à jour état bouton Démarrer

            return programsLoaded; // Retourner l'état final du chargement
        }

        async function exportProgramsToDrive() {
            if (!googleAccessToken) {
                 showMessage("Connectez-vous à Google Drive pour exporter les programmes.", 4000);
                 return;
             }
             // Utiliser les programmes actuellement chargés (potentiellement modifiés par le résumé)
             if (!programsLoaded && !confirm("Les programmes n'ont pas tous été chargés correctement. Voulez-vous quand même tenter d'exporter les versions actuelles (potentiellement par défaut) ?")) {
                 showMessage("Exportation annulée.", 2000);
                 return;
             }
             if (!confirm("Exporter les programmes actuels vers Google Drive ? Cela écrasera les versions existantes sur Drive.")) {
                 showMessage("Exportation annulée.", 2000);
                 return;
             }

            console.log("Exportation des programmes vers Google Drive...");
            showMessage("Exportation en cours...", 5000);
            if (driveStatusElement) {
                 driveStatusElement.textContent = 'Export Progs...';
                 driveStatusElement.classList.add('loading');
                 driveStatusElement.classList.remove('error','success');
                 driveStatusElement.style.display = 'inline-block';
            }
            if (exportProgramsBtn) exportProgramsBtn.disabled = true; // Désactiver pendant l'export

            let successCount = 0;
             const exportPromises = PROGRAM_TYPES.map(async (type) => {
                const fileId = programFileIds[type]; // Utiliser l'ID stocké
                const filename = PROGRAM_FILENAMES[type];

                 if (!fileId) {
                     console.error(`ID de fichier manquant pour le programme ${type}. Impossible d'exporter.`);
                     showMessage(`Erreur: ID fichier pour ${type} manquant. Export échoué.`, 4000);
                     return false; // Échec pour ce type
                 }

                 try {
                     const currentProgramData = loadedWorkouts[type] || defaultWorkouts[type] || []; // Prendre le chargé, sinon défaut, sinon vide
                     const csvContent = convertProgramToCsv(currentProgramData); // Convertir en CSV
                     console.log(`Exportation de ${type} (ID: ${fileId}) avec ${currentProgramData.length} étapes.`);
                     const success = await updateFileContent(fileId, csvContent); // Mettre à jour sur Drive
                     if (success) {
                         console.log(`Programme ${type} exporté avec succès.`);
                         return true;
                     } else {
                         console.error(`Échec de l'exportation du programme ${type}.`);
                         return false;
                     }
                 } catch (error) {
                     console.error(`Erreur lors de l'exportation du programme ${type}:`, error);
                     showMessage(`Erreur export ${type}: ${error.message}`, 5000);
                     return false;
                 }
            });

             // Attendre la fin de toutes les exportations
             try {
                 const results = await Promise.all(exportPromises);
                 successCount = results.filter(success => success === true).length;
             } catch (error) {
                 console.error("Erreur inattendue pendant Promise.all de exportProgramsToDrive:", error);
                 successCount = 0; // Considérer comme échec total
             }

            // Mettre à jour l'UI après l'exportation
             if (driveStatusElement) driveStatusElement.classList.remove('loading');
             if (exportProgramsBtn) exportProgramsBtn.disabled = !programsLoaded; // Réactiver basé sur l'état de chargement

            if (successCount === PROGRAM_TYPES.length) {
                 showMessage("Tous les programmes ont été exportés avec succès !", 3000);
                 if (driveStatusElement) {
                     driveStatusElement.textContent = 'Export OK';
                     driveStatusElement.classList.add('success');
                     // Revenir à 'Connecté' après un court délai
                     setTimeout(() => {
                         if(googleAccessToken && driveStatusElement && driveStatusElement.textContent === 'Export OK') {
                            driveStatusElement.textContent = 'Connecté';
                            driveStatusElement.classList.add('success'); // Rester en succès
                         }
                     }, 2500);
                 }
             } else {
                 showMessage(`Exportation terminée avec ${PROGRAM_TYPES.length - successCount} erreur(s). Vérifiez la console.`, 6000);
                 if (driveStatusElement) {
                     driveStatusElement.textContent = 'Erreur Export';
                     driveStatusElement.classList.add('error');
                 }
             }
        }


        // --- Rendu du Graphique ---
        function renderHistoryChart(filteredHistory, period) {
            if (!historyChartCanvas) {
                 console.warn("Canvas pour le graphique d'historique introuvable.");
                 return;
            }
            const ctx = historyChartCanvas.getContext('2d');
            if (!ctx) {
                 console.error("Impossible d'obtenir le contexte 2D du canvas.");
                 return;
            }

            // Détruire le graphique précédent s'il existe
            if (historyChart) {
                historyChart.destroy();
                historyChart = null;
            }

            // Agréger les données pour le graphique
            const { labels, data } = aggregateChartData(filteredHistory, period);

            // Obtenir les couleurs du thème actuel
            const bodyStyles = getComputedStyle(document.documentElement);
            const primaryColor = bodyStyles.getPropertyValue('--neon-blue').trim() || '#00aeff';
            const accentColor = bodyStyles.getPropertyValue('--neon-pink').trim() || '#e54ac5';
            const gridColor = bodyStyles.getPropertyValue('--border-color').trim() || 'rgba(139,148,158,0.2)';
            const textColor = bodyStyles.getPropertyValue('--primary-text-color').trim() || '#c9d1d9';
            const tooltipBg = bodyStyles.getPropertyValue('--secondary-bg-color').trim() || '#161B22';

             // Si pas de données, afficher un message sur le canvas? Pour l'instant, graphique vide.
             if (labels.length === 0 || data.every(d => d === 0)) {
                 console.log("Aucune donnée à afficher dans le graphique pour cette période.");
                 // Optionnel: Afficher un message sur le canvas
                 // ctx.clearRect(0, 0, historyChartCanvas.width, historyChartCanvas.height);
                 // ctx.fillStyle = textColor;
                 // ctx.textAlign = 'center';
                 // ctx.fillText("Aucune donnée pour cette période", historyChartCanvas.width / 2, historyChartCanvas.height / 2);
                 return; // Ne pas créer le graphique s'il n'y a rien à montrer
             }

            try {
                 historyChart = new Chart(ctx, {
                     type: 'bar', // Type de graphique: barres
                     data: {
                         labels: labels, // Étiquettes pour l'axe X
                         datasets: [{
                             label: 'Durée totale (min)', // Légende du dataset
                             data: data.map(d => formatTimeForChart(d)), // Données converties en minutes
                             backgroundColor: primaryColor + '99', // Couleur de remplissage avec transparence
                             borderColor: primaryColor, // Couleur de bordure
                             borderWidth: 1,
                             hoverBackgroundColor: accentColor + 'CC', // Couleur au survol
                             hoverBorderColor: accentColor,
                             borderRadius: 4, // Coins arrondis pour les barres
                         }]
                     },
                     options: {
                         responsive: true, // S'adapte à la taille du conteneur
                         maintainAspectRatio: false, // Permet de définir la hauteur via CSS
                         scales: {
                             y: {
                                 beginAtZero: true, // Axe Y commence à 0
                                 title: {
                                     display: true,
                                     text: 'Durée (minutes)',
                                     color: textColor,
                                     font: { size: 13, family: 'Inter' }
                                 },
                                 grid: { color: gridColor }, // Couleur de la grille Y
                                 ticks: {
                                     color: textColor, // Couleur des labels Y
                                     callback: function(value) { return value + ' min'; } // Ajouter 'min' aux labels
                                 }
                             },
                             x: {
                                 title: {
                                     display: true,
                                     text: getChartXAxisTitle(period), // Titre dynamique de l'axe X
                                     color: textColor,
                                     font: { size: 13, family: 'Inter' }
                                 },
                                 grid: { display: false }, // Masquer la grille X verticale
                                 ticks: { color: textColor } // Couleur des labels X
                             }
                         },
                         plugins: {
                             legend: { display: false }, // Masquer la légende (une seule série de données)
                             tooltip: {
                                 backgroundColor: tooltipBg,
                                 titleColor: textColor,
                                 bodyColor: textColor,
                                 padding: 10,
                                 cornerRadius: 6,
                                 displayColors: false, // Masquer la petite boîte de couleur
                                 callbacks: {
                                     // Personnaliser le texte du tooltip
                                     label: function(context) {
                                         // Récupérer la durée originale en secondes depuis les données brutes 'data'
                                         const originalDurationSeconds = data[context.dataIndex] || 0;
                                         const formattedTime = formatTime(originalDurationSeconds); // Format HH:MM:SS
                                         return `Durée: ${formattedTime}`;
                                     }
                                 }
                             }
                         },
                         animation: {
                             duration: 500, // Animation douce à l'affichage
                             easing: 'easeOutCubic'
                         }
                     }
                 });
                 console.log("Graphique d'historique rendu avec succès.");
             } catch (e) {
                 console.error("Erreur lors de la création du graphique Chart.js:", e);
                 showMessage("Erreur lors de l'affichage du graphique.", 4000);
             }
        }


        function aggregateChartData(history, period) {
            const aggregated = new Map(); // Utiliser une Map pour stocker {label: totalDuration}

            // Fonction pour initialiser la Map avec les labels attendus et une durée de 0
             const initializeMap = (labels) => labels.forEach(label => aggregated.set(label, 0));

            switch (period) {
                case 'week':
                     const daysOfWeek = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim'];
                     initializeMap(daysOfWeek);
                     // Filtrer pour la semaine courante (déjà fait par filterHistoryByPeriod, mais double vérif)
                     const now = new Date();
                     const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                     const dayOfWeekNum = todayStart.getDay();
                     const diffToMonday = todayStart.getDate() - dayOfWeekNum + (dayOfWeekNum === 0 ? -6 : 1);
                     const startOfWeek = new Date(now.getFullYear(), now.getMonth(), diffToMonday);
                     startOfWeek.setHours(0,0,0,0);

                     history.forEach(entry => {
                         const entryDate = new Date(entry.date);
                         // Vérifier si l'entrée est bien dans la semaine courante
                         if (entryDate >= startOfWeek) {
                             let dayIndex = entryDate.getDay(); // Dimanche = 0, Lundi = 1, ...
                             dayIndex = dayIndex === 0 ? 6 : dayIndex - 1; // Ajuster pour Lundi = 0, ..., Dimanche = 6
                             const dayName = daysOfWeek[dayIndex];
                             aggregated.set(dayName, (aggregated.get(dayName) || 0) + (entry.duration || 0));
                         }
                     });
                     return { labels: daysOfWeek, data: daysOfWeek.map(day => aggregated.get(day)) };

                case 'month':
                     const weeksOfMonth = ['Sem 1', 'Sem 2', 'Sem 3', 'Sem 4', 'Sem 5+']; // Labels pour les semaines
                     initializeMap(weeksOfMonth);
                     const currentMonthNum = new Date().getMonth(); // Mois courant (0-11)
                     const currentYearNum = new Date().getFullYear();

                     history.forEach(entry => {
                         const entryDate = new Date(entry.date);
                         // Filtrer pour le mois et l'année courants
                         if (entryDate.getMonth() === currentMonthNum && entryDate.getFullYear() === currentYearNum) {
                             const dayOfMonth = entryDate.getDate(); // Jour du mois (1-31)
                             // Calculer l'index de la semaine (0-4)
                             const weekIndex = Math.min(Math.floor((dayOfMonth - 1) / 7), 4); // Sem 1 = Jours 1-7 -> index 0, ..., Sem 5+ = Jours 29+ -> index 4
                             const weekName = weeksOfMonth[weekIndex];
                             aggregated.set(weekName, (aggregated.get(weekName) || 0) + (entry.duration || 0));
                         }
                     });
                     return { labels: weeksOfMonth, data: weeksOfMonth.map(week => aggregated.get(week)) };

                case 'year':
                     const monthsOfYear = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc'];
                     initializeMap(monthsOfYear);
                     const currentYear = new Date().getFullYear(); // Année courante

                     history.forEach(entry => {
                         const entryDate = new Date(entry.date);
                         // Filtrer pour l'année courante
                         if (entryDate.getFullYear() === currentYear) {
                             const monthIndex = entryDate.getMonth(); // Mois (0-11)
                             const monthName = monthsOfYear[monthIndex];
                             aggregated.set(monthName, (aggregated.get(monthName) || 0) + (entry.duration || 0));
                         }
                     });
                     return { labels: monthsOfYear, data: monthsOfYear.map(month => aggregated.get(month)) };

                case 'all':
                default:
                     const yearData = {}; // Utiliser un objet pour agréger par année { '2023': totalDuration, '2024': totalDuration }
                     history.forEach(entry => {
                         const entryDate = new Date(entry.date);
                         const year = entryDate.getFullYear();
                         yearData[year] = (yearData[year] || 0) + (entry.duration || 0);
                     });
                     // Trier les années pour l'axe X
                     const sortedYears = Object.keys(yearData).map(Number).sort((a, b) => a - b);
                     const sortedLabels = sortedYears.map(String); // Labels = années en string
                     const sortedData = sortedYears.map(year => yearData[year]); // Données = durées correspondantes
                     return { labels: sortedLabels, data: sortedData };
            }
        }


        function getChartXAxisTitle(period) {
            switch (period) {
                case 'week': return 'Jour de la Semaine (Courante)';
                case 'month': return 'Semaine du Mois (Courant)';
                case 'year': return 'Mois (Année Courante)';
                case 'all': return 'Année';
                default: return '';
            }
        }


        // --- Gestion Résumé/Modification Post-Workout ---

        function populateAndShowSummary() {
            // Vérifier si les éléments nécessaires et les données existent
             if (!originalCompletedWorkoutPlan || originalCompletedWorkoutPlan.length === 0 || !summaryTitle || !summaryItemsList || !postWorkoutSummary || !saveSummaryBtn || !cancelSummaryBtn) {
                 console.error("Impossible d'afficher le résumé: éléments DOM ou données manquants.", {
                     hasPlan: !!originalCompletedWorkoutPlan,
                     planLength: originalCompletedWorkoutPlan?.length,
                     hasTitle: !!summaryTitle,
                     hasList: !!summaryItemsList,
                     hasModal: !!postWorkoutSummary
                 });
                 // Si l'état est 'finished', le remettre à 'idle' pour éviter blocage
                 if (currentState === 'finished') {
                    resetCurrentWorkout(); // Réinitialiser proprement
                 }
                 return;
             }

             const finalWorkoutType = currentWorkoutType; // Utiliser le type stocké lors de la fin
             summaryTitle.textContent = `Résumé Séance - ${finalWorkoutType || 'Inconnu'}`;
             summaryItemsList.innerHTML = ''; // Vider la liste précédente

            // Remplir la liste avec les items de l'entraînement terminé
             originalCompletedWorkoutPlan.forEach((item, index) => {
                 const li = document.createElement('li');
                 li.classList.add('summary-item');
                 li.dataset.index = index; // Stocker l'index original pour la sauvegarde

                 if (item.type === 'exercise') {
                     li.classList.add('item-type-exercise');
                     const repsValue = (item.reps !== null && Number.isFinite(item.reps)) ? item.reps : '';
                     const detailsValue = item.details || '';
                     li.innerHTML = `
                        <h4><i class="fas fa-dumbbell"></i> ${item.name || 'Exercice Inconnu'}</h4>
                         <label for="summary-reps-${index}">Reps:</label>
                         <div><input type="number" id="summary-reps-${index}" value="${repsValue}" min="0" step="1" placeholder="N/A"></div>
                         <label for="summary-details-${index}">Détails:</label>
                         <div><textarea id="summary-details-${index}" rows="2" placeholder="Aucun détail">${detailsValue}</textarea></div>
                    `;
                 } else if (item.type === 'break') {
                     li.classList.add('item-type-break');
                     li.innerHTML = `
                        <h4><i class="fas fa-coffee"></i> Repos</h4>
                        <p>Durée: ${formatTime(item.duration || 0)}</p>
                        <div></div> <!-- Placeholder pour aligner grid -->
                        <div></div> <!-- Placeholder pour aligner grid -->
                    `;
                     // Pas d'inputs pour les pauses
                 }
                 summaryItemsList.appendChild(li);
             });

             // Réinitialiser l'état du bouton de sauvegarde et afficher le modal
             isSavingSummary = false;
             saveSummaryBtn.disabled = false;
             saveSummaryBtn.innerHTML = '<i class="fas fa-save"></i> Sauvegarder & Fermer';
             postWorkoutSummary.classList.add('visible'); // Afficher le modal
        }

        function closeSummary() {
            if (!postWorkoutSummary) return;
            postWorkoutSummary.classList.remove('visible'); // Masquer le modal

            // Si l'état est 'finished', on le passe à 'idle' APRES fermeture du résumé
            // Cela permet de ne pas immédiatement réactiver le bouton "Démarrer" derrière le modal
             if (currentState === 'finished') {
                 console.log("Fermeture du résumé, passage de l'état 'finished' à 'idle'.");
                 resetCurrentWorkout(); // Réinitialise tout proprement
             }
            // Retirer l'animation de fin si elle est toujours là
             if (workoutSection) workoutSection.classList.remove('finished-animation');
        }

        async function saveSummaryChanges() {
            if (isSavingSummary || !saveSummaryBtn || !summaryItemsList || !currentWorkoutType) {
                 console.warn("Sauvegarde du résumé déjà en cours ou données manquantes.");
                 return;
             }
             const workoutTypeToSave = currentWorkoutType; // Sauvegarder le type avant opérations asynchrones

            // Vérifier la connexion et l'ID du fichier programme
             if (!googleAccessToken || !programFileIds[workoutTypeToSave]) {
                 showMessage("Erreur: Non connecté ou ID du fichier programme Drive manquant.", 5000);
                 return;
             }

            isSavingSummary = true;
            saveSummaryBtn.disabled = true;
            saveSummaryBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sauvegarde...';
            showMessage("Sauvegarde des modifications du programme...", 4000);

            // Créer une copie profonde du programme *actuellement chargé* pour y appliquer les modifs
             // Il est crucial de modifier `loadedWorkouts`, pas `originalCompletedWorkoutPlan`
            const updatedProgram = JSON.parse(JSON.stringify(loadedWorkouts[workoutTypeToSave]));
             let changesMade = false;

            // Parcourir les items du résumé affiché
             const summaryItems = summaryItemsList.querySelectorAll('.summary-item[data-index]');
             summaryItems.forEach(itemElement => {
                const index = parseInt(itemElement.dataset.index, 10);
                 // Trouver l'item correspondant dans le programme à mettre à jour
                 const programItemToUpdate = updatedProgram[index];

                 // Vérifier si c'est un exercice modifiable
                 if (programItemToUpdate && programItemToUpdate.type === 'exercise') {
                     const repsInput = itemElement.querySelector(`#summary-reps-${index}`);
                     const detailsInput = itemElement.querySelector(`#summary-details-${index}`);

                     if (!repsInput || !detailsInput) {
                         console.warn(`Inputs introuvables pour l'index ${index} dans le résumé.`);
                         return; // Passer à l'item suivant
                     }

                     // Récupérer et valider les nouvelles valeurs
                     const newRepsRaw = repsInput.value.trim();
                     const newReps = newRepsRaw === '' ? null : parseInt(newRepsRaw, 10);
                     const newDetails = detailsInput.value.trim();

                     // Validation simple des reps
                     if (newReps !== null && (isNaN(newReps) || newReps < 0)) {
                         console.warn(`Nombre de répétitions invalide ('${newRepsRaw}') pour l'index ${index}. Modification ignorée.`);
                         showMessage(`Reps invalides pour "${programItemToUpdate.name}". Non sauvegardé.`, 3000);
                         // On pourrait choisir de bloquer la sauvegarde ici ou juste ignorer cette modif
                     } else {
                         // Comparer avec les valeurs actuelles dans `updatedProgram`
                         if (programItemToUpdate.reps !== newReps || programItemToUpdate.details !== newDetails) {
                            programItemToUpdate.reps = newReps;
                            programItemToUpdate.details = newDetails;
                            changesMade = true;
                            console.log(`Modification programme ${workoutTypeToSave} à l'index ${index}: reps=${newReps}, details=${newDetails}`);
                         }
                     }
                 }
             });

            if (!changesMade) {
                 showMessage("Aucune modification détectée dans le programme.", 2000);
                 closeSummary(); // Fermer le résumé
                 // Réinitialiser le bouton (sera fait dans le finally)
             } else {
                 // Mettre à jour le programme dans `loadedWorkouts`
                 loadedWorkouts[workoutTypeToSave] = updatedProgram;

                 // Tenter de sauvegarder le programme modifié sur Drive
                 try {
                     const newCsvContent = convertProgramToCsv(updatedProgram);
                     const success = await updateFileContent(programFileIds[workoutTypeToSave], newCsvContent);

                     if (success) {
                         showMessage(`Programme "${workoutTypeToSave}" mis à jour sur Google Drive !`, 3500);
                         console.log(`Programme ${workoutTypeToSave} mis à jour avec succès sur Drive.`);
                         closeSummary(); // Fermer après succès
                     } else {
                         // updateFileContent gère déjà les messages d'erreur spécifiques
                         showMessage(`Échec de la sauvegarde du programme ${workoutTypeToSave} sur Drive.`, 5000);
                         // Ne pas fermer le résumé pour que l'utilisateur puisse réessayer ou annuler
                     }
                 } catch (error) {
                     console.error(`Erreur lors de la sauvegarde du résumé pour ${workoutTypeToSave}:`, error);
                     showMessage(`Erreur sauvegarde ${workoutTypeToSave}: ${error.message}`, 6000);
                     // Ne pas fermer
                 }
             }

            // Quoi qu'il arrive (sauf si bloqué avant), réinitialiser l'état de sauvegarde
             saveSummaryBtn.innerHTML = '<i class="fas fa-save"></i> Sauvegarder & Fermer';
             saveSummaryBtn.disabled = false;
             isSavingSummary = false;
         }


        // --- Initialisation ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Chargé. Initialisation ArmorWorkout.");

            // Assignation DOM Elements (vérifier existence)
            timeLeftDisplay = document.getElementById('time-left');
            timerCircle = document.getElementById('timer-circle');
            totalProgressCircle = document.getElementById('total-progress-circle');
            timerStateDisplay = document.getElementById('timer-state');
            currentExerciseContainer = document.getElementById('current-exercise-container');
            // nextExerciseContainer n'est plus utilisé, à nettoyer si confirmé
            progressTracker = document.getElementById('progress-tracker');
            startPauseBtn = document.getElementById('start-pause-btn');
            skipBtn = document.getElementById('skip-btn');
            finishBtn = document.getElementById('finish-btn');
            resetBtn = document.getElementById('reset-btn');
            navButtons = document.querySelectorAll('nav button[data-workout]');
            navHistoryBtn = document.getElementById('nav-history');
            themeToggleBtn = document.getElementById('theme-toggle-btn');
            messageArea = document.getElementById('message-area');
            workoutSection = document.getElementById('workout-section');
            historySection = document.getElementById('history-section');
            historyList = document.getElementById('history-list');
            statsDisplay = document.getElementById('stats-display');
            motivationalMessage = document.getElementById('motivational-message'); // Peut être null si statsDisplay est recréé
            historyFilterBtns = document.querySelectorAll('.history-filters button');
            historyChartCanvas = document.getElementById('history-chart-canvas');
            signInButton = document.getElementById('signin-button');
            signOutButton = document.getElementById('signout-button');
            driveStatusElement = document.getElementById('drive-status');
            exportProgramsBtn = document.getElementById('export-programs-btn');
            postWorkoutSummary = document.getElementById('post-workout-summary');
            summaryTitle = document.getElementById('summary-title');
            summaryItemsList = document.getElementById('summary-items-list');
            saveSummaryBtn = document.getElementById('save-summary-btn');
            cancelSummaryBtn = document.getElementById('cancel-summary-btn');
            historyDriveStatus = document.getElementById('history-drive-status');
            currentExerciseNameDisplay = document.getElementById('current-exercise-name-display');
            driveConnectionStatusMain = document.getElementById('drive-connection-status-main');

            // Vérification critique des éléments essentiels
            const essentialElements = { timeLeftDisplay, timerCircle, totalProgressCircle, timerStateDisplay, currentExerciseContainer, progressTracker, startPauseBtn, skipBtn, finishBtn, resetBtn, navHistoryBtn, themeToggleBtn, messageArea, workoutSection, historySection, historyList, statsDisplay, historyChartCanvas, signInButton, signOutButton, driveStatusElement, exportProgramsBtn, postWorkoutSummary, summaryTitle, summaryItemsList, saveSummaryBtn, cancelSummaryBtn, currentExerciseNameDisplay, driveConnectionStatusMain };
            let missingElement = false;
             for (const key in essentialElements) {
                 if (!essentialElements[key]) {
                     console.error(`ERREUR CRITIQUE : Élément DOM essentiel manquant: #${key}`);
                     missingElement = true;
                 }
             }
             if(navButtons.length !== 3) {
                 console.error(`ERREUR CRITIQUE : Nombre incorrect de boutons de navigation workout (${navButtons.length}).`);
                 missingElement = true;
             }
             if(historyFilterBtns.length !== 4) {
                 console.error(`ERREUR CRITIQUE : Nombre incorrect de boutons de filtre historique (${historyFilterBtns.length}).`);
                 missingElement = true;
             }

            if (missingElement) {
                document.body.innerHTML = "<h1 style='color:red; text-align:center; margin-top: 50px;'>Erreur critique lors de l'initialisation de l'application. Vérifiez la console du navigateur (F12) pour les détails.</h1>";
                return; // Bloquer l'initialisation
            }

            // --- Initialisation état et UI ---
            const savedTheme = localStorage.getItem('theme');
            // Appliquer 'dark' si rien n'est sauvegardé ou si la valeur est invalide
            applyTheme((savedTheme === 'light' || savedTheme === 'dark') ? savedTheme : 'dark');

            workoutHistory = []; // Historique vide au début
            loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Commencer avec défauts
            programsLoaded = false; // Programmes non chargés de Drive initialement

            updateAuthUI(false); // Mettre l'UI en état déconnecté par défaut
            setState('idle'); // Assurer l'état initial propre du timer/workout

            // --- Ajout des écouteurs d'événements ---
            signInButton.addEventListener('click', handleAuthClick);
            signOutButton.addEventListener('click', () => handleSignoutClick(true)); // Afficher message lors du clic

            navButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // loadWorkout gère la logique de confirmation si nécessaire
                    loadWorkout(button.dataset.workout);
                });
            });

            navHistoryBtn.addEventListener('click', () => {
                 // Si un entraînement est en cours (non fini et non en prépa)
                 if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') {
                     if (confirm("Un entraînement est en cours. Voulez-vous l'arrêter pour voir l'historique ?")) {
                         resetCurrentWorkout(); // Arrêter proprement
                         // Léger délai pour assurer que reset est fini avant de changer de section
                         setTimeout(() => showSection('history'), 100);
                     }
                     // Si l'utilisateur annule, ne rien faire (rester sur la section workout)
                 } else if (currentState === 'preparing') {
                     showMessage("Veuillez attendre la fin de la préparation avant de changer de section.", 2500);
                 } else {
                     // Si idle, finished, ou jamais démarré, aller directement à l'historique
                     showSection('history');
                 }
            });

            startPauseBtn.addEventListener('click', () => {
                initAudioContext(); // Init audio au premier clic Start/Pause/Reprendre
                 if (currentState === 'idle' && currentWorkoutPlan.length > 0 && currentWorkoutType) {
                    // Démarrer un nouvel entraînement
                    workoutStartTime = Date.now(); // Enregistrer l'heure de début exacte
                    elapsedWorkoutEstimatedSeconds = 0; // Réinitialiser temps écoulé estimé
                    setState('preparing'); // Lancer la phase de préparation
                 } else if (currentState === 'exercise') {
                    // Marquer l'exercice comme fait et passer à l'étape suivante
                    handleItemCompletion(false); // false = non naturel (clic)
                 } else if (currentState === 'break') {
                    // Mettre en pause le timer de repos
                    clearInterval(timerInterval); // Arrêter le décompte
                    timerInterval = null;
                    setState('paused');
                 } else if (currentState === 'paused') {
                    // Reprendre le timer (doit être une pause qui a été mise en pause)
                    if (currentWorkoutPlan[currentItemIndex]?.type === 'break') {
                         setState('break'); // Relance startBreakTimer
                    } else {
                        // Ne devrait pas arriver si on est en pause pendant un exercice
                         console.warn("Tentative de reprise alors que l'état n'est pas une pause.");
                         setState('exercise'); // Revenir à l'état exercice par sécurité
                    }
                 }
                 saveInProgressState(); // Sauvegarder l'état après l'action
            });

            skipBtn.addEventListener('click', () => {
                initAudioContext();
                 // Passer à l'étape suivante si un entraînement est actif (non fini, non prépa)
                 if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') {
                     showMessage("Passage à l'étape suivante.", 1500);
                     handleItemCompletion(false); // false = clic utilisateur
                 }
            });

            finishBtn.addEventListener('click', () => {
                initAudioContext();
                // Terminer l'entraînement prématurément si actif (non fini, non prépa)
                 if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') {
                     forceFinishWorkout(); // Demande confirmation interne
                 }
            });

            resetBtn.addEventListener('click', () => {
                initAudioContext();
                // Réinitialiser si un type est chargé ou si un entraînement est actif/fini
                 if (currentWorkoutType || isWorkoutActive || workoutFinished) {
                     if (confirm("Êtes-vous sûr de vouloir réinitialiser l'état actuel et désélectionner l'entraînement ?")) {
                         resetCurrentWorkout();
                     }
                 } else {
                      // Si déjà idle et rien de chargé, le reset ne fait rien de visible
                      showMessage("Aucun entraînement à réinitialiser.", 2000);
                      resetCurrentWorkout(); // Appeler au cas où pour nettoyer des états incohérents
                 }
            });

            themeToggleBtn.addEventListener('click', () => {
                initAudioContext();
                 applyTheme(currentTheme === 'dark' ? 'light' : 'dark');
            });

            historyFilterBtns.forEach(button => {
                 button.addEventListener('click', () => {
                     displayHistory(button.dataset.period); // Mettre à jour l'affichage historique avec la nouvelle période
                 });
             });

             exportProgramsBtn.addEventListener('click', () => {
                 initAudioContext();
                 exportProgramsToDrive(); // Lance l'exportation vers Drive
             });

             // Écouteurs pour le modal de résumé
             saveSummaryBtn.addEventListener('click', saveSummaryChanges);
             cancelSummaryBtn.addEventListener('click', closeSummary);

             console.log("Initialisation de l'application terminée. Attente du chargement de la bibliothèque Google Identity Services...");
             // Le callback gisLoadedCallback() sera appelé une fois la lib chargée.
        });

        // --- Fin du Script Principal ---
    </script>

    <!-- Chargement Asynchrone de Google Identity Services -->
    <!-- Le 'onload=gisLoadedCallback' est crucial -->
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoadedCallback()"></script>

</body>
</html>
