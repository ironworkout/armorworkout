<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Timer d'Entraînement</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- Google Identity Services (GIS) - chargé à la fin -->
    <style>
        /* --- Variables Globales & Thèmes --- */
        :root {
            /* Thème Sombre (Inspiré de l'image) */
            --bg-color-dark: #0D1117;
            --secondary-bg-color-dark: #161B22;
            --primary-text-color-dark: #c9d1d9;
            --secondary-text-color-dark: #8b949e;
            --border-color-dark: #30363d;
            --accent-border-color-dark: #8b949e;
            --neon-blue: #00aeff;
            --neon-pink: #e54ac5;
            --neon-red: #ff4d4d;
            --neon-yellow: #facc15;
            --neon-green: #2ecc71;
            --glow-blue: 0 0 15px rgba(0, 174, 255, 0.5);
            --glow-pink: 0 0 15px rgba(229, 74, 197, 0.5);
            --glow-red: 0 0 10px rgba(255, 77, 77, 0.5);
            --glow-yellow: 0 0 10px rgba(250, 204, 21, 0.4);
            --glow-green: 0 0 10px rgba(46, 204, 113, 0.4);
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius-lg: 12px;
            --border-radius-md: 8px;
            --border-radius-sm: 6px;
            --transition-speed: 0.25s;

            /* Initialisation Thème Sombre par Défaut */
            --bg-color: var(--bg-color-dark);
            --secondary-bg-color: var(--secondary-bg-color-dark);
            --primary-text-color: var(--primary-text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --border-color: var(--border-color-dark);
            --accent-border-color: var(--accent-border-color-dark);
            --current-step-color: var(--neon-blue);
            --current-step-glow: var(--glow-blue);
            --total-progress-gradient: conic-gradient(from 180deg, var(--neon-blue), var(--neon-pink) 60%, var(--neon-blue));
            --total-progress-bg: #2a2f36;
            --button-reset-color: var(--neon-red);
            --button-reset-glow: var(--glow-red);
            --button-next-color: var(--neon-pink);
            --button-next-glow: var(--glow-pink);
            --button-end-color: var(--secondary-text-color-dark);
            --button-end-glow: none;
            --button-start-color: var(--neon-blue);
            --button-start-glow: var(--glow-blue);
            --button-pause-color: var(--neon-yellow);
            --button-pause-glow: var(--glow-yellow);
            --button-connect-color: var(--neon-green);
            --button-connect-glow: var(--glow-green);
            --button-disconnect-color: var(--neon-red);
            --button-disconnect-glow: var(--glow-red);
            --link-color: var(--neon-blue);

            /* --- Variables RGBA Helper --- */
            --neon-blue-rgb: 0, 174, 255;
            --neon-pink-rgb: 229, 74, 197;
            --neon-red-rgb: 255, 77, 77;
            --neon-yellow-rgb: 250, 204, 21;
            --neon-green-rgb: 46, 204, 113;
            --secondary-text-color-dark-rgb: 139, 148, 158;
            --bg-color-dark-rgb: 13, 17, 23;
            --secondary-bg-color-dark-rgb: 22, 27, 34;
            --primary-text-color-dark-rgb: 201, 209, 217;
        }

        body.light-theme {
            /* Styles pour thème clair */
            --bg-color: #ffffff;
            --secondary-bg-color: #f6f8fa;
            --primary-text-color: #24292f;
            --secondary-text-color: #57606a;
            --border-color: #d0d7de;
            --accent-border-color: #8c959f;
            --total-progress-bg: #e1e4e8;
            --button-end-color: #57606a;
            --link-color: #0969da;

            /* Adapter les variables RGBA pour light theme */
            --bg-color-dark-rgb: 255, 255, 255;
            --secondary-bg-color-dark-rgb: 246, 248, 250;
            --primary-text-color-dark-rgb: 36, 41, 47;
            --secondary-text-color-dark-rgb: 87, 96, 106;
        }

        /* --- Styles de Base & Réinitialisation --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            line-height: 1.6;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }
        .container { max-width: 1100px; margin: 0 auto; padding: 30px 25px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }

        /* --- En-tête --- */
        header {
            padding: 20px 0;
            border-bottom: 1px solid var(--border-color);
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
            position: sticky; top: 0; z-index: 1000;
            background-color: rgba(var(--bg-color-dark-rgb), 0.8);
            backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
        }
        .header-content { display: flex; justify-content: space-between; align-items: center; max-width: 1100px; margin: 0 auto; padding: 0 25px; flex-wrap: wrap; gap: 15px 20px; }
        header h1 { font-size: 1.5em; color: var(--primary-text-color); margin: 0; font-weight: 700; display: flex; align-items: center; gap: 10px; }
        header h1 i { color: var(--neon-blue); animation: pulse 2s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.1); opacity: 1; } }

        /* --- Navigation Header --- */
        nav ul { list-style: none; display: flex; gap: 25px; flex-wrap: wrap; justify-content: center; align-items: center; }
        nav button {
            background: none; border: none; color: var(--secondary-text-color); font-size: 1em; font-weight: 500;
            padding: 5px 0; cursor: pointer; transition: color var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
            position: relative; border-bottom: 2px solid transparent;
        }
        nav button:disabled { color: rgba(var(--primary-text-color-dark-rgb), 0.3); cursor: not-allowed; border-bottom-color: transparent !important; box-shadow: none !important; }
        nav button:not(:disabled):hover { color: var(--primary-text-color); }
        nav button.active { color: var(--neon-blue); font-weight: 700; border-bottom-color: var(--neon-blue); box-shadow: 0 5px 15px -5px rgba(var(--neon-blue-rgb), 0.4); }
        #nav-history { color: var(--secondary-text-color); border-bottom-color: transparent; }
        #nav-history:hover { color: var(--neon-pink); }
        #nav-history.active { color: var(--neon-pink); border-bottom-color: var(--neon-pink); box-shadow: 0 5px 15px -5px rgba(var(--neon-pink-rgb), 0.4); }
        #nav-history i { margin-right: 5px; }

        /* --- Actions Header --- */
        .header-actions { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button, #export-programs-btn {
            background: none; border: 1px solid var(--accent-border-color); color: var(--secondary-text-color); padding: 6px 14px;
            border-radius: var(--border-radius-md); font-size: 0.85em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease;
            display: inline-flex; align-items: center; gap: 6px;
        }
        .auth-controls button:hover, #export-programs-btn:hover { border-color: var(--primary-text-color); color: var(--primary-text-color); }
        #signin-button { border-color: var(--button-connect-color); color: var(--button-connect-color); }
        #signin-button:hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--glow-green); border-color: var(--neon-green); }
        #signout-button { border-color: var(--button-disconnect-color); color: var(--button-disconnect-color); }
        #signout-button:hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--glow-red); border-color: var(--neon-red); }
        #export-programs-btn { border-color: var(--neon-pink); color: var(--neon-pink); }
        #export-programs-btn:hover { background-color: rgba(var(--neon-pink-rgb), 0.1); box-shadow: var(--glow-pink); border-color: var(--neon-pink); }
        #drive-status {
            font-size: 0.8em; color: var(--secondary-text-color); margin-left: 5px; transition: opacity 0.3s, color 0.3s, border-color 0.3s;
            min-width: fit-content; text-align: right; font-style: normal; padding: 4px 8px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5);
            border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); display: none; /* Initialement caché */
        }
        #drive-status.loading { color: var(--neon-yellow); border-color: var(--neon-yellow); }
        #drive-status.error { color: var(--neon-red); border-color: var(--neon-red); }
        #drive-status.success { color: var(--neon-green); border-color: var(--neon-green); }
        .theme-toggle button { background: none; border: none; color: var(--secondary-text-color); font-size: 1.2em; padding: 5px; cursor: pointer; transition: color var(--transition-speed) ease; }
        .theme-toggle button:hover { color: var(--neon-yellow); }

        /* Logique d'affichage connexion/déconnexion */
        body.logged-out #signin-button { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-out #drive-status { display: none; }
        body.logged-out #export-programs-btn { display: none; }
        body.logged-out .history-actions i.fab.fa-google-drive { display: none; }
        body.logged-out #history-drive-status { display: none; }
        body.logged-out #drive-connection-status-main { display: none; }

        body.logged-in #signin-button { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-in #drive-status { display: inline-block; }
        body.logged-in #export-programs-btn { display: inline-flex; }
        body.logged-in .history-actions i.fab.fa-google-drive { display: inline-block; }
        body.logged-in #history-drive-status { display: inline-block; }
        body.logged-in #drive-connection-status-main { display: flex; }


        /* --- Contenu Principal --- */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 50px; position: relative; }
        .workout-section {
            background-color: transparent; padding: 0; border: none; box-shadow: none; width: 100%; max-width: 600px; text-align: center;
            transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease; margin-bottom: 40px;
        }
        .history-section {
            background-color: var(--secondary-bg-color); padding: 35px; border-radius: var(--border-radius-lg); box-shadow: none; border: 1px solid var(--border-color);
            width: 100%; max-width: 850px; text-align: left; margin-bottom: 40px;
            transition: transform 0.5s ease, opacity 0.5s ease, max-height 0.5s ease;
        }
        .section-hidden {
            transform: scale(0.9) translateY(30px); opacity: 0; pointer-events: none; max-height: 0; padding-top: 0 !important; padding-bottom: 0 !important;
            margin-bottom: 0 !important; border: none !important; overflow: hidden;
        }

        /* --- Affichage Timer --- */
        .timer-display { margin-bottom: 50px; position: relative; display: flex; justify-content: center; align-items: center; width: 320px; height: 320px; margin-left: auto; margin-right: auto; }
        .timer-circle-container { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
        #total-progress-circle, .timer-circle {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; border-radius: 50%;
            display: flex; justify-content: center; align-items: center; border: 12px solid transparent;
            background-clip: padding-box; background-origin: border-box; box-sizing: border-box;
        }
        #total-progress-circle {
            border-color: var(--total-progress-bg); background-image: var(--total-progress-gradient); background-size: 100% 100%;
            box-shadow: 0 0 25px rgba(var(--neon-blue-rgb), 0.3), 0 0 35px rgba(var(--neon-pink-rgb), 0.2), inset 0 0 20px rgba(var(--bg-color-dark-rgb), 0.5);
            z-index: 1; transition: background 0.5s ease-out; background-repeat: no-repeat; background-position: center center;
        }
        .timer-circle {
            width: calc(100% - 48px); height: calc(100% - 48px); top: 24px; left: 24px; border-color: var(--border-color);
            background-image: conic-gradient(var(--current-step-color) 0%, transparent 0%); background-size: 100% 100%;
            box-shadow: var(--current-step-glow), inset 0 0 15px rgba(var(--bg-color-dark-rgb), 0.6);
            z-index: 3; transition: background-image 0.15s linear, box-shadow var(--transition-speed) ease; background-repeat: no-repeat; background-position: center center;
        }
        .timer-circle::before {
            content: ''; position: absolute; width: calc(100% - 24px); height: calc(100% - 24px);
            background-color: var(--bg-color); border-radius: 50%; z-index: 4; transition: background-color var(--transition-speed) ease;
        }
        .time-left {
            font-size: 5.5em; font-weight: 900; color: var(--primary-text-color); z-index: 5; transition: color var(--transition-speed) ease;
            font-variant-numeric: tabular-nums; position: relative; text-shadow: 0 0 10px rgba(var(--primary-text-color-dark-rgb), 0.3);
        }
        .timer-state {
            position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); font-size: 0.8em; letter-spacing: 0.1em;
            color: var(--secondary-text-color); font-weight: 500; text-transform: uppercase; opacity: 0; transition: opacity 0.3s ease;
            background-color: transparent; padding: 0; box-shadow: none; z-index: 6;
        }
        .timer-state.visible { opacity: 0.8; }
        .timer-state.preparing { color: var(--neon-yellow); font-size: 1em; animation: countdown-pulse 1s infinite; }
        @keyframes countdown-pulse { 0%, 100% { transform: translateX(-50%) scale(1); opacity: 1; } 50% { transform: translateX(-50%) scale(1.1); opacity: 0.8; } }

        /* --- Infos Exercice --- */
        .workout-info { margin-bottom: 40px; min-height: 100px; position: relative; text-align: center; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #current-exercise-name-display { display: block; font-size: 1.3em; font-weight: 700; color: var(--primary-text-color); margin-bottom: 5px; padding: 0 10px; min-height: 1.5em; }
        body:not(.workout-active) #current-exercise-name-display { display: none; } /* Masquer hors entraînement */
        #current-exercise-container { display: flex; flex-direction: column; align-items: center; gap: 5px; font-size: 1.1em; color: var(--secondary-text-color); min-height: 3em; }
        #current-exercise-container .exercise-details { display: flex; align-items: center; gap: 15px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3); padding: 8px 15px; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); }
        #current-exercise-container .exercise-details span { display: flex; align-items: center; gap: 5px; font-weight: 500; }
        #current-exercise-container .exercise-details span i { color: var(--neon-pink); }
        #current-exercise-container .exercise-details .details-text { font-size: 0.9em; opacity: 0.8; }
        #current-exercise-container .break-info { display: flex; align-items: center; gap: 8px; font-weight: 500; font-size: 1.1em; color: var(--neon-yellow); }
        body:not(.workout-active) #current-exercise-container p { color: var(--secondary-text-color); font-size: 1.1em; margin-top: 15px; }
        body:not(.workout-active) #current-exercise-container .exercise-details,
        body:not(.workout-active) #current-exercise-container .break-info { display: none; }

        /* --- Progress Tracker (Maintenant utilisé pour l'état général) --- */
        .progress-tracker {
            font-size: 0.9em; color: var(--secondary-text-color); margin-top: 30px; opacity: 0.8; font-weight: 500;
            display: flex; align-items: center; justify-content: center; gap: 8px; min-height: 1.2em;
        }
        .progress-tracker i.fa-google-drive { color: var(--neon-green); }


        /* --- Contrôles Timer --- */
        .controls { display: flex; justify-content: center; gap: 20px; margin-top: 40px; flex-wrap: wrap; }
        .controls button {
            background: transparent; border: 2px solid var(--accent-border-color); color: var(--primary-text-color); min-width: 120px;
            padding: 12px 25px; border-radius: var(--border-radius-lg); font-size: 1.1em; font-weight: 500; cursor: pointer;
            transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; justify-content: center; gap: 8px;
        }
        .controls button i { font-size: 0.9em; }
        .controls button:disabled { border-color: var(--border-color); color: var(--secondary-text-color); opacity: 0.5; cursor: not-allowed; box-shadow: none; transform: none; background-color: transparent !important; }
        .controls button:not(:disabled):hover { transform: translateY(-2px); }
        .controls button:not(:disabled):active { transform: scale(0.97); }
        #start-pause-btn { border-color: var(--button-start-color); color: var(--button-start-color); }
        #start-pause-btn:not(:disabled):hover { box-shadow: var(--glow-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); }
        #start-pause-btn.pause-btn { border-color: var(--button-pause-color); color: var(--button-pause-color); }
        #start-pause-btn.pause-btn:not(:disabled):hover { box-shadow: var(--glow-yellow); background-color: rgba(var(--neon-yellow-rgb), 0.1); }
        #skip-btn { border-color: var(--button-next-color); color: var(--button-next-color); }
        #skip-btn:not(:disabled):hover { box-shadow: var(--glow-pink); background-color: rgba(var(--neon-pink-rgb), 0.1); }
        #finish-btn { border-color: var(--button-end-color); color: var(--button-end-color); }
        #finish-btn:not(:disabled):hover { background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1); border-color: var(--primary-text-color); color: var(--primary-text-color); }
        #reset-btn { border-color: var(--button-reset-color); color: var(--button-reset-color); }
        #reset-btn:not(:disabled):hover { box-shadow: var(--glow-red); background-color: rgba(var(--neon-red-rgb), 0.1); }

        /* --- Section Historique --- */
        .history-section h2 { color: var(--primary-text-color); margin-bottom: 25px; text-align: center; }
        .history-controls { padding-bottom: 20px; margin-bottom: 25px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
        .history-filters { display: flex; gap: 10px; flex-wrap: wrap; }
        .history-filters button {
            background-color: transparent; border: 1px solid var(--accent-border-color); color: var(--secondary-text-color); opacity: 1; font-size: 0.85em;
            padding: 6px 12px; border-radius: var(--border-radius-md); cursor: pointer; transition: all var(--transition-speed) ease;
            display: inline-flex; align-items: center; gap: 5px;
        }
        .history-filters button:not(:disabled):hover { border-color: var(--primary-text-color); color: var(--primary-text-color); background-color: rgba(var(--secondary-text-color-dark-rgb), 0.1); }
        .history-filters button.active { border-color: var(--neon-blue); color: var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); font-weight: 500; box-shadow: var(--glow-blue); }
        .history-actions { display: flex; gap: 15px; align-items: center; color: var(--secondary-text-color); }
        .history-actions i.fab.fa-google-drive { color: var(--neon-green); }
        #history-drive-status { font-size: 0.8em; padding: 3px 6px; background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5); border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); }
        .chart-container { height: 350px; margin-bottom: 30px; background-color: transparent; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 15px; box-shadow: none; }
        .stats-display { margin-bottom: 30px; padding: 20px; background-color: transparent; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); box-shadow: none; }
        .stats-display h3 { color: var(--primary-text-color); margin-bottom: 15px; font-size: 1.15em;}
        .stats-display p { margin-bottom: 8px; display: flex; align-items: center; gap: 8px;}
        .stats-display p i { width: 16px; text-align: center; color: var(--neon-blue); opacity: 0.8;}
        .stats-display p strong { color: var(--primary-text-color); font-weight: 500; }
        .stats-display p:last-child { margin-bottom: 0; }
        .motivational-message {
            font-style: italic; font-weight: 500; margin-top: 15px !important;
            background: linear-gradient(90deg, var(--neon-green), var(--neon-blue));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; text-fill-color: transparent;
        }
        .history-list { list-style: none; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); background-color: transparent; box-shadow: none; max-height: 400px; overflow-y: auto; }
        .history-list li { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s ease; gap: 15px; }
        .history-list li:last-child { border-bottom: none; }
        .history-list li:nth-child(even) { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.3); }
        .history-list li:hover { background-color: rgba(var(--neon-blue-rgb), 0.08); transform: none; }
        .history-item-date { color: var(--primary-text-color); font-size: 0.9em; }
        .history-item-date small { color: var(--secondary-text-color); font-size: 0.9em;}
        .history-item-type { color: var(--neon-pink); background-color: rgba(var(--neon-pink-rgb), 0.1); border-radius: var(--border-radius-sm); padding: 3px 8px; font-size: 0.85em; font-weight: 500; text-align: center; min-width: 50px; }
        .history-item-duration { color: var(--neon-blue); font-weight: 500; font-variant-numeric: tabular-nums;}
        .history-list .no-history { color: var(--secondary-text-color); text-align: center; padding: 30px 15px; font-style: italic; border: none; background: none !important; }

        /* --- Résumé Post-Workout (MODAL) --- */
        .post-workout-summary {
            position: fixed; inset: 0; background-color: rgba(var(--bg-color-dark-rgb), 0.85); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            z-index: 2000; display: flex; align-items: center; justify-content: center; padding: 20px;
            opacity: 0; visibility: hidden; pointer-events: none; transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .post-workout-summary.visible { opacity: 1; visibility: visible; pointer-events: auto; }
        .post-workout-summary-content {
            background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-lg);
            box-shadow: 0 10px 30px rgba(0,0,0,0.3); width: 100%; max-width: 650px; max-height: 90vh;
            display: flex; flex-direction: column; overflow: hidden; transform: scale(0.95); transition: transform 0.3s ease;
        }
        .post-workout-summary.visible .post-workout-summary-content { transform: scale(1); }
        .post-workout-summary h2 { color: var(--primary-text-color); font-size: 1.4em; padding: 20px 25px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; text-align: center; }
        .summary-items-list { list-style: none; padding: 15px 25px; overflow-y: auto; flex-grow: 1; background: var(--bg-color); border-bottom: 1px solid var(--border-color); }
        .summary-item { border-bottom: 1px solid var(--border-color); padding: 15px 0; display: grid; grid-template-columns: auto 1fr; gap: 10px 20px; align-items: start; }
        .summary-item:last-child { border-bottom: none; }
        .summary-item h4 { grid-column: 1 / -1; color: var(--primary-text-color); font-size: 1.1em; margin-bottom: 8px; display: flex; align-items: center; gap: 8px; }
        .summary-item h4 i { color: var(--neon-blue); width: 18px; text-align: center;}
        .summary-item .item-type-break h4 { color: var(--neon-yellow); }
        .summary-item .item-type-break h4 i { color: var(--neon-yellow);}
        .summary-item label { color: var(--secondary-text-color); font-size: 0.9em; font-weight: 500; white-space: nowrap; padding-top: 6px; text-align: right; grid-column: 1 / 2; }
        .summary-item > div { grid-column: 2 / 3; }
        .summary-item input[type="number"], .summary-item input[type="text"], .summary-item textarea {
            background-color: var(--bg-color); border: 1px solid var(--border-color); color: var(--primary-text-color); border-radius: var(--border-radius-sm);
            padding: 6px 10px; font-size: 1em; width: 100%; transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
        }
        .summary-item input[type="number"] { width: 80px; }
        .summary-item input:focus, .summary-item textarea:focus { border-color: var(--neon-blue); background-color: var(--bg-color); outline: none; box-shadow: 0 0 0 2px rgba(var(--neon-blue-rgb), 0.3); }
        .summary-item textarea { min-height: 40px; resize: vertical; }
        .summary-item p { color: var(--secondary-text-color); padding-top: 6px; grid-column: 1 / -1; text-align: center; font-style: italic; }
        .summary-controls { padding: 20px 25px; display: flex; justify-content: space-between; gap: 15px; flex-shrink: 0; flex-wrap: wrap; }
        .summary-controls button { border-width: 2px; padding: 10px 20px; font-size: 1em; border-radius: var(--border-radius-md); flex-grow: 1; min-width: 150px; }
        .summary-controls .save-summary-btn { border-color: var(--neon-green); color: var(--neon-green); }
        .summary-controls .save-summary-btn:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--glow-green); }
        .summary-controls .cancel-summary-btn { border-color: var(--neon-red); color: var(--neon-red); }
        .summary-controls .cancel-summary-btn:not(:disabled):hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--glow-red); }

        /* --- Animation Fin Workout --- */
        .workout-section.finished-animation { animation: finish-glow 1.5s ease-out forwards; }
        @keyframes finish-glow { 0% { box-shadow: 0 0 0px 0px var(--neon-green); } 50% { box-shadow: 0 0 25px 10px rgba(var(--neon-green-rgb), 0.5); } 100% { box-shadow: 0 0 0px 0px rgba(var(--neon-green-rgb), 0); } }

        /* --- Zone de Messages Flottante --- */
        .message-area {
            position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%); background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.9);
            color: var(--primary-text-color); border: 1px solid var(--border-color); padding: 12px 25px; border-radius: var(--border-radius-md);
            z-index: 1001; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease; pointer-events: none;
            font-size: 0.95em; box-shadow: 0 4px 15px rgba(0,0,0,0.2); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            max-width: 90%; text-align: center;
        }
        .message-area.visible { opacity: 1; transform: translate(-50%, 0); bottom: 40px; pointer-events: auto; }

        /* --- Pied de Page --- */
        footer { color: var(--secondary-text-color); opacity: 0.7; border-top: 1px solid var(--border-color); margin-top: 60px; padding: 25px; text-align: center; }
        footer a { color: var(--link-color); text-decoration: none; }
        footer a:hover { color: var(--primary-text-color); text-decoration: underline; }
        footer .fab.fa-google-drive { color: #4CAF50; }

        /* --- Styles Responsives --- */
        @media (max-width: 992px) {
            .header-content { padding: 0 15px; }
            .container { padding: 30px 15px; }
        }
        @media (max-width: 768px) {
            header h1 { font-size: 1.3em; }
            nav ul { gap: 15px; }
            .header-actions { gap: 15px; }
            .timer-display { width: 280px; height: 280px; }
            .timer-circle { width: calc(100% - 40px); height: calc(100% - 40px); top: 20px; left: 20px; border-width: 10px; }
            .timer-circle::before { width: calc(100% - 20px); height: calc(100% - 20px); }
            .time-left { font-size: 4.5em; }
            #total-progress-circle { border-width: 10px; }
            .controls { gap: 15px; }
            .controls button { min-width: 100px; padding: 10px 20px; font-size: 1em; }
            .history-controls { flex-direction: column; align-items: stretch; gap: 15px; }
            .history-actions { justify-content: center; }
            .chart-container { height: 320px; padding: 10px; }
            .stats-display { padding: 15px; }
            .history-list li { padding: 10px; gap: 10px; font-size: 0.95em;}
            .post-workout-summary-content { padding: 0; max-width: 95%; max-height: 85vh; }
            .post-workout-summary h2 { padding: 15px 20px; font-size: 1.3em; }
            .summary-items-list { padding: 10px 20px; }
            .summary-item { grid-template-columns: 60px 1fr; gap: 8px 15px;}
            .summary-item label { font-size: 0.85em; text-align: left; padding-top: 8px;}
            .summary-item input[type="number"] { width: 60px; }
            .summary-controls { padding: 15px 20px; flex-direction: column; }
            .summary-controls button { width: 100%; }
        }
        @media (max-width: 480px) {
            header { padding: 15px 0;}
            header h1 { font-size: 1.2em; }
            nav ul { gap: 10px; }
            .header-actions { justify-content: center; }
            .auth-controls { flex-wrap: wrap; justify-content: center; gap: 8px;}
            .timer-display { width: 240px; height: 240px; margin-bottom: 40px; }
            .timer-circle { width: calc(100% - 32px); height: calc(100% - 32px); top: 16px; left: 16px; border-width: 8px; }
            .timer-circle::before { width: calc(100% - 16px); height: calc(100% - 16px); }
            .time-left { font-size: 3.8em; }
            #total-progress-circle { border-width: 8px; }
            .workout-info { min-height: 80px; }
            #current-exercise-name-display { font-size: 1.2em; }
            #current-exercise-container { font-size: 1em; }
            #current-exercise-container .exercise-details { padding: 6px 10px; gap: 10px;}
            .controls { gap: 10px; margin-top: 30px; }
            .controls button { width: 100%; min-width: 0; padding: 12px; font-size: 1em; }
            .progress-tracker { margin-top: 25px; font-size: 0.85em;}
            .history-section { padding: 20px; }
            .history-controls { padding-bottom: 15px; margin-bottom: 20px;}
            .history-filters button { font-size: 0.8em; padding: 5px 10px; }
            .chart-container { height: 280px; }
            .stats-display { padding: 12px; font-size: 0.9em;}
            .history-list li { font-size: 0.9em;}
            .history-item-type { font-size: 0.8em; padding: 2px 6px;}
            .post-workout-summary-content { max-width: 100%; max-height: 90vh; border-radius: var(--border-radius-md); }
            .post-workout-summary h2 { font-size: 1.2em; padding: 12px 15px;}
            .summary-items-list { padding: 8px 15px; }
            .summary-item { grid-template-columns: 50px 1fr; gap: 5px 10px; padding: 12px 0;}
            .summary-item h4 {font-size: 1em;}
            .summary-item label { font-size: 0.8em; }
            .summary-controls { padding: 12px 15px; }
        }
    </style>
</head>
<body class="logged-out dark-theme"> <!-- Initialement logged-out et thème sombre -->

    <header>
        <div class="header-content">
            <h1><i class="fas fa-shield-halved"></i> ArmorWorkout</h1>
            <nav>
                <ul>
                    <li><button id="nav-push" data-workout="Push" disabled>Push</button></li>
                    <li><button id="nav-pull" data-workout="Pull" disabled>Pull</button></li>
                    <li><button id="nav-legs" data-workout="Legs" disabled>Legs</button></li>
                    <li><button id="nav-history"><i class="fas fa-history"></i> Historique</button></li>
                </ul>
            </nav>
            <div class="header-actions">
                <div class="auth-controls">
                    <button id="signin-button"><i class="fab fa-google"></i> Connecter Drive</button>
                    <button id="signout-button"><i class="fas fa-sign-out-alt"></i> Déconnecter</button>
                </div>
                <span id="drive-status"></span>
                 <button id="export-programs-btn" disabled><i class="fas fa-upload"></i> Exporter Progs</button>
                <div class="theme-toggle">
                    <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <main>
            <!-- Section Entraînement -->
            <div class="workout-section" id="workout-section">
                <div class="timer-display">
                    <div class="timer-circle-container">
                        <div id="total-progress-circle"></div>
                        <div class="timer-circle" id="timer-circle">
                            <span class="time-left" id="time-left">00:00</span>
                        </div>
                    </div>
                    <div class="timer-state" id="timer-state"></div>
                </div>

                <div class="workout-info" id="workout-info">
                     <div id="current-exercise-name-display"></div>
                     <div id="current-exercise-container">
                         <p>Initialisation...</p> <!-- Message par défaut -->
                    </div>
                </div>

                <div class="controls">
                    <button id="start-pause-btn" disabled><i class="fas fa-play"></i> Démarrer</button>
                    <button id="skip-btn" disabled><i class="fas fa-forward-step"></i> Suivant</button>
                    <button id="finish-btn" disabled><i class="fas fa-flag-checkered"></i> Finir</button>
                    <button id="reset-btn" disabled><i class="fas fa-redo"></i> Reset</button>
                </div>

                <div class="progress-tracker" id="progress-tracker">
                    <!-- Statut étape ou connexion Drive affiché ici par JS -->
                    <i class="fab fa-google-drive"></i>
                    <span id="drive-connection-status-main">Connecté à Google Drive</span>
                </div>
            </div>

            <!-- Section Historique -->
            <div class="history-section section-hidden" id="history-section">
                <h2><i class="fas fa-chart-line"></i> Historique & Statistiques</h2>
                <div class="history-controls">
                    <div class="history-filters">
                        <button data-period="week" class="active"><i class="fas fa-calendar-week"></i> Semaine</button>
                        <button data-period="month"><i class="fas fa-calendar-alt"></i> Mois</button>
                        <button data-period="year"><i class="fas fa-calendar-check"></i> Année</button>
                        <button data-period="all"><i class="fas fa-infinity"></i> Tout</button>
                    </div>
                    <div class="history-actions">
                        <i class="fab fa-google-drive"></i>
                        <span id="history-drive-status">Synchro Drive</span>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="history-chart-canvas"></canvas>
                </div>
                <div class="stats-display" id="stats-display">
                    <h3>Statistiques</h3>
                    <p>Connectez-vous.</p>
                    <p class="motivational-message"></p> <!-- Placeholder for motivational message -->
                </div>
                <ul class="history-list" id="history-list">
                    <li class="no-history">Connectez-vous.</li>
                </ul>
            </div>
        </main>
    </div>

    <footer>
        <p>© 2024 ArmorWorkout. Intégré avec <i class="fab fa-google-drive"></i> Google Drive.</p>
        <p><a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github"></i> Voir sur GitHub</a></p>
    </footer>

    <!-- Zone de Message Flottante -->
    <div id="message-area" class="message-area"></div>

    <!-- Modal Résumé Post-Workout -->
    <div id="post-workout-summary" class="post-workout-summary">
        <div class="post-workout-summary-content">
            <h2 id="summary-title">Résumé de la Séance</h2>
            <ul id="summary-items-list" class="summary-items-list">
                <!-- Contenu généré par JS -->
            </ul>
            <div class="summary-controls">
                <button id="save-summary-btn" class="controls button save-summary-btn"><i class="fas fa-save"></i> Sauvegarder & Fermer</button>
                <button id="cancel-summary-btn" class="controls button cancel-summary-btn"><i class="fas fa-times"></i> Fermer sans Sauvegarder</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION & CONSTANTES ---
        const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
        const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const HISTORY_FILENAME = "armorworkout_history.csv";
        const PROGRAM_FILENAMES = {
            Push: "armorworkout_push_program.csv",
            Pull: "armorworkout_pull_program.csv",
            Legs: "armorworkout_legs_program.csv"
        };
        const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
        const PREPARE_DURATION = 3; // Secondes
        const FINISH_ANIMATION_DURATION = 1500; // ms
        const SECONDS_PER_REP = 2.5; // Estimation temps par rep
        const IN_PROGRESS_KEY = 'armorWorkoutStateInProgress';

        // --- DONNÉES PAR DÉFAUT ---
        // NOTE: Ces données sont conservées ici. Elles sont utilisées comme FALLBACK
        // si les fichiers CSV n'existent pas sur Google Drive (ils seront créés avec ce contenu)
        // ou si le chargement depuis Drive échoue. Elles ne sont PAS utilisées si les CSV
        // sont chargés avec succès depuis Drive.
        const defaultWorkouts = {
            Push: [
                { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 },
                { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 13 },
                { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Band Standing Chest Press', details: 'Élastique 15kg à porte', reps: 14 },
                { type: 'exercise', name: 'Band Bench Press', details: 'Élastique 25kg', reps: 15 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 },
                { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 },
                { type: 'break', duration: 60, name: 'Repos' },
                { type: 'exercise', name: 'Overhead Press', details: 'Élastique 15kg', reps: 12 },
                { type: 'exercise', name: 'Triceps Pushdown', details: 'Élastique 15kg', reps: 15 },
            ],
            Pull: [
                { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 },
                { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 12 },
                { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 14 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Band Bent-over Row', details: 'Élastique 25 kg', reps: 13 },
                { type: 'exercise', name: 'Band Face Pull', details: 'Élastique 15 kg', reps: 15 },
                { type: 'break', duration: 75, name: 'Repos' },
                { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 },
                { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 },
                { type: 'break', duration: 60, name: 'Repos' },
                { type: 'exercise', name: 'Bicep Curls', details: 'Élastique 15 kg', reps: 12 },
                { type: 'exercise', name: 'Lat Pulldown (Band)', details: 'Élastique 25 kg', reps: 12 },
            ],
            Legs: [
                 { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 },
                 { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 },
                 { type: 'break', duration: 90, name: 'Repos' },
                 { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 13 },
                 { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 10 },
                 { type: 'break', duration: 90, name: 'Repos' },
                 { type: 'exercise', name: 'Front squat', details: 'Élastique 15+25 kg + Haltère 5kg', reps: 14 },
                 { type: 'exercise', name: 'Fentes Arrière', details: 'Élastique 25 kg', reps: 11 },
                 { type: 'break', duration: 90, name: 'Repos' },
                 { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 },
                 { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 },
                 { type: 'break', duration: 60, name: 'Repos' },
                 { type: 'exercise', name: 'Romanian Deadlift (Band)', details: 'Élastique 25kg', reps: 15 },
                 { type: 'exercise', name: 'Calf Raises', details: 'Bodyweight or Band', reps: 20 },
             ]
        };

        // --- Éléments DOM (Déclaration) ---
        let timeLeftDisplay, timerCircle, timerStateDisplay, currentExerciseContainer, progressTracker, startPauseBtn, skipBtn, finishBtn, resetBtn, navButtons, navHistoryBtn, themeToggleBtn, messageArea, workoutSection, historySection, historyList, statsDisplay, historyFilterBtns, historyChartCanvas, signInButton, signOutButton, driveStatusElement, exportProgramsBtn, postWorkoutSummary, summaryTitle, summaryItemsList, saveSummaryBtn, cancelSummaryBtn, historyDriveStatus, totalProgressCircle, currentExerciseNameDisplay, driveConnectionStatusMain;

        // --- Variables d'État ---
        let currentWorkoutType = null;
        let currentWorkoutPlan = [];
        let originalCompletedWorkoutPlan = []; // Pour le résumé
        let currentItemIndex = 0;
        let timerInterval = null;
        let prepareCountdownInterval = null;
        let totalTime = 0; // Durée totale de l'étape courante (pause)
        let timeLeft = 0; // Temps restant pour l'étape courante (pause)
        let prepareTimeLeft = 0; // Temps restant pour la préparation
        let totalWorkoutEstimatedSeconds = 0;
        let elapsedWorkoutEstimatedSeconds = 0;
        let isTimerRunning = false;
        let isWorkoutActive = false;
        let workoutFinished = false;
        let currentState = 'idle'; // idle, preparing, exercise, break, paused, finished
        let workoutStartTime = null;
        let workoutHistory = [];
        let currentHistoryPeriod = 'week';
        let historyChart = null;
        let googleAccessToken = null;
        let tokenClient = null;
        let historyFileId = null;
        let programFileIds = { Push: null, Pull: null, Legs: null };
        let programsLoaded = false;
        let loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); // Commence avec défauts, sera écrasé par Drive
        let isSavingSummary = false;
        let currentTheme = 'dark';
        let messageTimeoutId = null;

        // --- Audio & Vibration ---
        let audioContext = null;
        let endSound = () => { console.log("Beep! (AudioContext non initialisé)"); };

        function initAudioContext() {
             if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log("AudioContext initialisé.");
                     if (audioContext.state === 'suspended') audioContext.resume();
                     const buffer = audioContext.createBuffer(1, 1, 22050);
                     const source = audioContext.createBufferSource();
                     source.buffer = buffer; source.connect(audioContext.destination); source.start(0); source.stop(audioContext.currentTime + 0.001);
                     endSound = () => {
                        if (!audioContext) return;
                        if (audioContext.state === 'suspended') { audioContext.resume().then(() => playActualSound()).catch(e => console.error("Erreur reprise AudioContext", e)); }
                        else { playActualSound(); }
                    };
                } catch (e) { console.warn("Initialisation AudioContext échouée:", e); audioContext = null; }
            }
             if (!audioContext) { endSound = () => console.log("Beep! (AudioContext indisponible)"); }
        }

        function playActualSound() {
            if (!audioContext) return;
            try {
                const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain();
                oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
                oscillator.type = 'triangle'; oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
                oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.5);
            } catch(e) { console.error("Erreur lecture son:", e); }
        }

        const vibrate = (pattern = [100, 50, 100]) => { if ('vibrate' in navigator) { try { navigator.vibrate(pattern); } catch (e) { console.warn("Vibration échouée:", e); } } };

        // --- Google Identity Services (GIS) & Drive API ---
        function gisLoadedCallback() {
            console.log("GIS Library Loaded Callback Executed");
            if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID === "VOTRE ID CLIENT ICI") {
                console.error("ERREUR CRITIQUE: GOOGLE_CLIENT_ID non configuré !");
                showMessage("Erreur critique : ID Client Google manquant.", 10000);
                if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Config ID'; driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; }
                 updateAuthUI(false); return;
            }
            try {
                tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID, scope: GOOGLE_DRIVE_SCOPES,
                    callback: (tokenResponse) => { console.log("GIS Callback: Réponse reçue, appel de tokenCallback..."); tokenCallback(tokenResponse); },
                    error_callback: (error) => { console.error("GIS Error Callback:", error); handleTokenError(error); },
                    prompt: ''
                });
                console.log("Token Client initialisé avec succès.");
            } catch (error) {
                console.error("Erreur initialisation Token Client:", error); showMessage("Erreur initialisation services Google.", 5000); updateAuthUI(false);
                if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Init Auth'; driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; }
            }
        }

        function handleTokenError(error) {
            console.error("Erreur Token Client:", error);
            let message = `Erreur Authentification Google: ${error.type || error.error || 'Inconnue'}`;
            let statusText = 'Erreur Auth';
            if (driveStatusElement) { driveStatusElement.classList.remove('loading','success'); driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; }
            if (error.type === 'popup_closed' || error.error === 'user_cancel' || error.error === 'popup_closed') { message = "Connexion Google annulée par l'utilisateur."; statusText = 'Annulé'; }
            else if (error.type === 'popup_failed_to_open' || error.error === 'popup_failed_to_open') { message = "La fenêtre pop-up Google a été bloquée. Vérifiez les paramètres de votre navigateur."; statusText = 'Popup Bloqué'; }
            else if (error.type === 'session_timed_out' || error.error === 'session_timed_out'){ message = "Session Google expirée. Veuillez vous reconnecter."; statusText = 'Expiré'; handleSignoutClick(false); }
            else if (error.type === 'unregistered_origin' || error.type === 'invalid_client' || error.type === 'redirect_uri_mismatch' || error.error === 'invalid_client') { message = "Erreur de configuration de l'application Google. Contactez le développeur."; statusText = 'Erreur Config App'; console.error("Détails erreur de configuration:", error); }
            else if (error.error === 'access_denied') { message = "Accès refusé. Vous devez autoriser l'accès à Google Drive."; statusText = 'Accès Refusé'; }
            else { console.error("Détails erreur d'authentification non gérée:", error); }
            showMessage(message, 7000); if (driveStatusElement) driveStatusElement.textContent = statusText; updateAuthUI(false);
        }

        async function tokenCallback(tokenResponse) {
            console.log("Logique tokenCallback en cours avec réponse:", tokenResponse);
            if (driveStatusElement) { driveStatusElement.classList.remove('loading', 'error', 'success'); driveStatusElement.style.display = 'inline-block'; }

            if (tokenResponse && tokenResponse.access_token) {
                console.log("Access Token reçu avec succès."); googleAccessToken = tokenResponse.access_token; updateAuthUI(true);
                showMessage("Connecté. Chargement des données...", 3000);
                if (driveStatusElement) { driveStatusElement.textContent = 'Chargement...'; driveStatusElement.classList.add('loading'); }

                try {
                    console.log("tokenCallback: Tentative de chargement parallèle historique & programmes...");
                    const [historyResult, programsResult] = await Promise.all([ loadHistoryFromDrive(), loadProgramsFromDrive() ]);
                    console.log(`tokenCallback: Promise.all terminé. History OK: ${historyResult}, Programs OK: ${programsResult}`);

                    if (programsResult) {
                        console.log("Données Drive chargées."); showMessage("Historique et programmes chargés.", 2500);
                        if (driveStatusElement) { driveStatusElement.textContent = 'Connecté'; driveStatusElement.classList.remove('loading'); driveStatusElement.classList.add('success'); }
                        const resumed = loadInProgressState(); if(!resumed) { checkEnableStartButton(); }
                    } else {
                        showMessage("Erreur critique lors du chargement des programmes depuis Drive. Programmes par défaut utilisés.", 6000);
                        if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Progs'; driveStatusElement.classList.remove('loading'); driveStatusElement.classList.add('error'); }
                        checkEnableStartButton();
                    }
                    if (navButtons) navButtons.forEach(btn => btn.disabled = !programsLoaded); if (exportProgramsBtn) exportProgramsBtn.disabled = !programsLoaded;

                } catch (error) {
                    console.error("tokenCallback: ERREUR CRITIQUE pendant le chargement parallèle des données:", error); console.error("Stack Trace:", error.stack);
                    showMessage("Erreur majeure lors du chargement des données depuis Drive.", 7000);
                    loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); workoutHistory = []; programsLoaded = false; updateAuthUI(true); // Toujours connecté, mais avec erreur
                    if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Données'; driveStatusElement.classList.remove('loading'); driveStatusElement.classList.add('error'); }
                    displayHistory(); if (navButtons) navButtons.forEach(btn => btn.disabled = true); if (exportProgramsBtn) exportProgramsBtn.disabled = true; checkEnableStartButton();
                }
            } else {
                console.error("Erreur dans la réponse Token ou access_token manquant:", tokenResponse);
                if (tokenResponse && tokenResponse.error) { handleTokenError(tokenResponse); }
                else { showMessage("Erreur: Jeton Google invalide reçu.", 5000); updateAuthUI(false); if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Jeton'; driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; } }
            }
        }

        function handleAuthClick() {
            console.log("Clic sur 'Connecter Drive'");
            if (!tokenClient) { showMessage("La bibliothèque Google n'est pas encore prête, veuillez patienter...", 3000); console.warn("Tentative de connexion avant l'initialisation complète du tokenClient."); if (driveStatusElement) { driveStatusElement.textContent = 'Non Prêt'; driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; } return; }
            initAudioContext(); console.log("Demande manuelle d'Access Token...");
            if (driveStatusElement) { driveStatusElement.textContent = 'Connexion...'; driveStatusElement.classList.add('loading'); driveStatusElement.classList.remove('error','success'); driveStatusElement.style.display = 'inline-block'; }
            tokenClient.requestAccessToken({ prompt: 'consent' });
        }

        function handleSignoutClick(showMsg = true) {
            console.log("Clic sur 'Déconnecter'"); const token = googleAccessToken;
             if (token) {
                 if (showMsg && driveStatusElement) { driveStatusElement.textContent = 'Déconnexion...'; driveStatusElement.classList.add('loading'); driveStatusElement.classList.remove('error','success'); driveStatusElement.style.display = 'inline-block'; }
                 google.accounts.oauth2.revoke(token, () => {
                     console.log('Token Google révoqué.'); googleAccessToken = null; historyFileId = null; programFileIds = { Push: null, Pull: null, Legs: null }; programsLoaded = false; workoutHistory = [];
                     loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts));
                     if (isWorkoutActive || currentState !== 'idle') { resetCurrentWorkout(); } else { updateAuthUI(false); }
                     if (showMsg) { showMessage("Déconnecté de Google Drive.", 2500); }
                      if (driveStatusElement) { driveStatusElement.textContent = ''; driveStatusElement.classList.remove('loading', 'error','success'); driveStatusElement.style.display = 'none'; }
                 });
             } else { console.log("Pas de token à révoquer, mise à jour UI."); updateAuthUI(false); if (driveStatusElement) { driveStatusElement.textContent = ''; driveStatusElement.style.display = 'none'; } }
        }

        function updateAuthUI(isLoggedIn) { updateAuthUIDetailed(isLoggedIn); } // Wrapper pour garder l'appel simple
        function updateAuthUIDetailed(isLoggedIn) {
             console.log(`Mise à jour UI - Connecté: ${isLoggedIn}, Programmes Chargés: ${programsLoaded}, État Timer: ${currentState}`);
             const body = document.body; body.classList.toggle('logged-in', isLoggedIn); body.classList.toggle('logged-out', !isLoggedIn);

             if (driveStatusElement) { driveStatusElement.style.display = isLoggedIn ? 'inline-block' : 'none'; if (!isLoggedIn) { driveStatusElement.textContent = ''; driveStatusElement.classList.remove('loading', 'error', 'success'); } }
             if(driveConnectionStatusMain) {
                 const statusContainer = driveConnectionStatusMain.closest('.progress-tracker'); if (statusContainer) { statusContainer.style.display = isLoggedIn ? 'flex' : 'none'; }
                 if(isLoggedIn) {
                     if (driveStatusElement?.classList.contains('loading')) { driveConnectionStatusMain.textContent = "Chargement Drive..."; if (statusContainer) statusContainer.querySelector('i')?.classList.add('fa-spin'); }
                     else if (driveStatusElement?.classList.contains('error')) { driveConnectionStatusMain.textContent = `Erreur Drive (${driveStatusElement.textContent || '?'})`; if (statusContainer) statusContainer.querySelector('i')?.classList.remove('fa-spin'); }
                     else { driveConnectionStatusMain.textContent = "Connecté à Google Drive"; if (statusContainer) statusContainer.querySelector('i')?.classList.remove('fa-spin'); }
                 }
             }
             if (historyDriveStatus?.parentElement) { historyDriveStatus.parentElement.style.display = isLoggedIn ? 'flex' : 'none'; if(isLoggedIn) { historyDriveStatus.textContent = driveStatusElement?.classList.contains('error') ? 'Erreur Sync' : 'Synchro Drive OK'; } }

             themeToggleBtn.disabled = false; navHistoryBtn.disabled = false;

             if (!isLoggedIn) {
                 loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); workoutHistory = []; programsLoaded = false; displayHistory(currentHistoryPeriod);
                 if (currentState !== 'idle') { resetCurrentWorkout(); } updateWorkoutInfo();
                 startPauseBtn.disabled = true; skipBtn.disabled = true; finishBtn.disabled = true; resetBtn.disabled = true;
                 navButtons.forEach(btn => btn.disabled = true); if (exportProgramsBtn) exportProgramsBtn.disabled = true;
             } else {
                 navButtons.forEach(btn => btn.disabled = !programsLoaded); if (exportProgramsBtn) exportProgramsBtn.disabled = !programsLoaded;
                 checkEnableStartButton();
                 if (currentState === 'idle' || currentState === 'finished' || currentState === 'preparing') { skipBtn.disabled = true; finishBtn.disabled = true; resetBtn.disabled = !currentWorkoutType || currentState === 'preparing'; }
                 else { skipBtn.disabled = !programsLoaded; finishBtn.disabled = !programsLoaded; resetBtn.disabled = !programsLoaded; }
                 updateWorkoutInfo(); displayHistory(currentHistoryPeriod);
             }
        }

        function checkEnableStartButton() {
            if (!startPauseBtn) return;
            if (currentState === 'idle') { startPauseBtn.disabled = !googleAccessToken || !programsLoaded || !currentWorkoutType; startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Démarrer'; startPauseBtn.classList.remove('pause-btn'); }
            else if (currentState === 'preparing') { startPauseBtn.disabled = true; startPauseBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Prêt...'; startPauseBtn.classList.remove('pause-btn'); }
            else if (currentState === 'exercise') { startPauseBtn.disabled = !programsLoaded; startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Fait'; startPauseBtn.classList.remove('pause-btn'); }
            else if (currentState === 'break') { startPauseBtn.disabled = !programsLoaded; startPauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause'; startPauseBtn.classList.add('pause-btn'); }
            else if (currentState === 'paused') { startPauseBtn.disabled = !programsLoaded; startPauseBtn.innerHTML = '<i class="fas fa-play"></i> Reprendre'; startPauseBtn.classList.add('pause-btn'); }
            else if (currentState === 'finished') { startPauseBtn.disabled = true; startPauseBtn.innerHTML = '<i class="fas fa-check"></i> Terminé'; startPauseBtn.classList.remove('pause-btn'); }
        }

        async function findOrCreateFile(filename, defaultCsvContent = "") {
            console.log(`findOrCreateFile: Recherche ou création de ${filename}`); if (!googleAccessToken) { console.warn("findOrCreateFile: Non connecté à Google Drive."); return null; }
            const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+mimeType='text/csv'+and+trashed=false&spaces=drive&fields=files(id,name)`;
            try {
                const searchRes = await fetch(searchUrl, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } });
                if (!searchRes.ok) { if (searchRes.status === 401 || searchRes.status === 403) { console.warn(`Erreur d'authentification (${searchRes.status}) lors de la recherche de ${filename}. Tentative de déconnexion.`); handleSignoutClick(false); showMessage("Session Google expirée ou invalide. Veuillez vous reconnecter.", 6000); return null; } throw new Error(`Erreur recherche fichier ${filename} (${searchRes.status} ${searchRes.statusText})`); }
                const searchData = await searchRes.json();
                if (searchData.files && searchData.files.length > 0) { console.log(`Fichier ${filename} trouvé avec l'ID: ${searchData.files[0].id}`); return searchData.files[0].id; }
                else {
                    console.log(`Fichier ${filename} non trouvé. Création...`); const createUrl = `https://www.googleapis.com/drive/v3/files`; const metadata = { name: filename, mimeType: 'text/csv' };
                    const createRes = await fetch(createUrl, { method: 'POST', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' }, body: JSON.stringify(metadata) });
                    if (!createRes.ok) { if (createRes.status === 401 || createRes.status === 403) { console.warn(`Erreur authentification (${createRes.status}) lors création ${filename}. Déconnexion.`); handleSignoutClick(false); showMessage("Session Google expirée ou invalide. Veuillez vous reconnecter.", 6000); return null; } throw new Error(`Erreur création fichier ${filename} (${createRes.status} ${createRes.statusText})`); }
                    const createData = await createRes.json(); const newFileId = createData.id; console.log(`Fichier ${filename} créé ID: ${newFileId}. Écriture contenu défaut...`);
                    const writeSuccess = await updateFileContent(newFileId, defaultCsvContent);
                    if (writeSuccess) { console.log(`Contenu défaut écrit dans ${filename}.`); return newFileId; }
                    else { console.error(`Échec écriture contenu défaut dans ${filename}. Création échouée.`); return null; }
                }
            } catch (error) { console.error(`findOrCreateFile: ERREUR pour ${filename}:`, error); showMessage(`Erreur Drive (${filename.substring(0, 20)}...): ${error.message}`, 7000); return null; }
        }

        async function readFileContent(fileId) {
            console.log(`readFileContent: Lecture ID ${fileId}`); if (!googleAccessToken || !fileId) { console.warn("readFileContent: Non connecté ou fileId manquant."); return null; }
            const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
            try {
                const response = await fetch(url, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } });
                if (!response.ok) {
                    if (response.status === 404) { console.warn(`Fichier ${fileId} non trouvé (404).`); return ""; }
                    if (response.status === 401 || response.status === 403) { console.warn(`Erreur auth (${response.status}) lecture ${fileId}. Déconnexion.`); handleSignoutClick(false); showMessage("Session Google expirée ou accès refusé. Reconnexion nécessaire.", 6000); return null; }
                    throw new Error(`Erreur lecture fichier ${fileId} (${response.status} ${response.statusText})`);
                }
                const content = await response.text(); console.log(`Lecture fichier ${fileId} réussie.`); return content;
            } catch (error) { console.error(`readFileContent: ERREUR pour ${fileId}:`, error); showMessage(`Erreur Drive Lecture: ${error.message}`, 6000); return null; }
        }

        async function updateFileContent(fileId, content) {
            console.log(`updateFileContent: Mise à jour ID ${fileId}`); if (!googleAccessToken || !fileId) { console.warn("updateFileContent: Non connecté ou fileId manquant."); return false; }
            const url = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`;
            try {
                const response = await fetch(url, { method: 'PATCH', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'text/csv' }, body: content });
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) { console.warn(`Erreur auth (${response.status}) écriture ${fileId}. Déconnexion.`); handleSignoutClick(false); showMessage("Session expirée ou accès refusé. Sauvegarde échouée.", 6000); return false; }
                    throw new Error(`Erreur écriture fichier ${fileId} (${response.status} ${response.statusText})`);
                }
                console.log(`Écriture fichier ${fileId} réussie.`); return true;
            } catch (error) { console.error(`updateFileContent: ERREUR pour ${fileId}:`, error); showMessage(`Erreur Drive Écriture: ${error.message}`, 6000); return false; }
        }

        // --- Fonctions Cœur du Timer ---
        function formatTime(seconds) { const absSeconds = Math.max(0, Math.round(seconds)); const minutes = Math.floor(absSeconds / 60); const remainingSeconds = absSeconds % 60; return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`; }
        function formatTimeForChart(seconds) { return parseFloat((Math.max(0, seconds) / 60).toFixed(1)); }

        function calculateTotalEstimatedTime(plan) {
             let totalSeconds = 0;
             plan.forEach(item => { let estimatedDuration = 0; if (item.type === 'break') { estimatedDuration = item.duration || 0; } else if (item.type === 'exercise') { estimatedDuration = (item.reps || 0) * SECONDS_PER_REP; } item.estimatedDuration = estimatedDuration; totalSeconds += estimatedDuration; });
             console.log(`Temps total estimé: ${totalSeconds.toFixed(1)}s (${formatTime(totalSeconds)})`); return totalSeconds;
        }

        function updateTotalProgressCircle() {
            if (!totalProgressCircle || totalWorkoutEstimatedSeconds <= 0) { if(totalProgressCircle) totalProgressCircle.style.background = `var(--total-progress-bg)`; return; }
             let currentTotalElapsed = 0; for (let i = 0; i < currentItemIndex; i++) { currentTotalElapsed += currentWorkoutPlan[i]?.estimatedDuration || 0; }
             if ((currentState === 'break' || currentState === 'paused') && currentWorkoutPlan[currentItemIndex]?.type === 'break' && totalTime > 0) { const progress = (totalTime - timeLeft); const estimated = currentWorkoutPlan[currentItemIndex]?.estimatedDuration || totalTime; currentTotalElapsed += Math.min(progress, estimated); }
            if (currentState === 'finished') { currentTotalElapsed = totalWorkoutEstimatedSeconds; }
             currentTotalElapsed = Math.min(currentTotalElapsed, totalWorkoutEstimatedSeconds);
             const progressPercent = totalWorkoutEstimatedSeconds > 0 ? (currentTotalElapsed / totalWorkoutEstimatedSeconds) * 100 : 0;
             totalProgressCircle.style.background = `conic-gradient(from 180deg, var(--neon-blue) ${progressPercent}%, var(--neon-pink) ${progressPercent + 30}%, var(--total-progress-bg) ${progressPercent}%)`;
        }

        function updateTimerDisplay() {
            if (!timeLeftDisplay || !timerCircle || !totalProgressCircle) return;
            let innerProgressPercent = 0; let displayTime = "00:00"; let stepColor = 'var(--secondary-text-color)'; let stepGlow = 'none';
            if ((currentState === 'break' || (currentState === 'paused' && currentWorkoutPlan[currentItemIndex]?.type === 'break')) && totalTime > 0) { innerProgressPercent = Math.max(0, Math.min(100, ((totalTime - timeLeft) / totalTime) * 100)); displayTime = formatTime(timeLeft); stepColor = 'var(--neon-yellow)'; stepGlow = 'var(--glow-yellow)'; }
            else if (currentState === 'preparing') { innerProgressPercent = Math.max(0, Math.min(100, ((PREPARE_DURATION - prepareTimeLeft) / PREPARE_DURATION) * 100)); displayTime = formatTime(prepareTimeLeft); stepColor = 'var(--neon-yellow)'; stepGlow = 'var(--glow-yellow)'; }
            else if (currentState === 'finished') { innerProgressPercent = 100; displayTime = "FINI"; stepColor = 'var(--neon-green)'; stepGlow = 'var(--glow-green)'; }
            else if (currentState === 'exercise') { innerProgressPercent = 0; displayTime = "GO!"; stepColor = 'var(--neon-pink)'; stepGlow = 'var(--glow-pink)'; }
            else { innerProgressPercent = 0; displayTime = formatTime(0); }
             timeLeftDisplay.textContent = displayTime; timerCircle.style.setProperty('--current-step-color', stepColor); timerCircle.style.setProperty('--current-step-glow', stepGlow); timerCircle.style.backgroundImage = `conic-gradient(${stepColor} ${innerProgressPercent}%, transparent ${innerProgressPercent}%)`; updateTotalProgressCircle();
        }

        function updateWorkoutInfo() {
            if (!currentExerciseContainer || !currentExerciseNameDisplay || !progressTracker) return;
            const currentItem = currentWorkoutPlan[currentItemIndex]; let infoHtml = ''; let nameDisplay = ''; let progressText = '';
            if (currentState === 'idle') { infoHtml = `<p>${googleAccessToken ? (programsLoaded ? `Sélectionnez un entraînement.` : `Chargement...`) : `Connectez-vous...`}</p>`; }
            else if (currentState === 'finished') { const duration = workoutStartTime ? formatTime((Date.now() - workoutStartTime) / 1000) : 'N/A'; nameDisplay = 'Terminé !'; infoHtml = `<h2><i class="fas fa-check-circle" style="color: var(--neon-green)"></i> Bravo !</h2><p>Temps: <strong>${duration}</strong></p>`; progressText = `Terminé (${originalCompletedWorkoutPlan.length}/${originalCompletedWorkoutPlan.length})`; }
            else if (currentState === 'preparing') { const nextItem = currentWorkoutPlan[0]; nameDisplay = `Préparez : ${nextItem?.name || 'Étape'}`; infoHtml = `<p style="color: var(--neon-yellow); font-weight: 500;">Prêt dans ${prepareTimeLeft}s...</p>`; progressText = `Préparation... (1/${currentWorkoutPlan.length})`; }
            else if (currentItem) { nameDisplay = `${currentItem.name || (currentItem.type === 'break' ? 'Repos' : 'Étape')}`; progressText = `Étape ${currentItemIndex + 1} / ${currentWorkoutPlan.length}`; if (currentItem.type === 'exercise') { const reps = currentItem.reps !== null ? `${currentItem.reps}` : '-'; const details = currentItem.details || 'Aucun détail'; infoHtml = `<div class="exercise-details"><span><i class="fas fa-hashtag"></i> Reps: <strong>${reps}</strong></span><span class="details-text"><i class="fas fa-info-circle"></i> ${details}</span></div>`; } else if (currentItem.type === 'break') { infoHtml = `<div class="break-info"><i class="fas fa-coffee"></i><span>Pause: ${formatTime(currentItem.duration || 0)}</span></div>`; } }
            else if (isWorkoutActive) { nameDisplay = 'Chargement...'; infoHtml = '<p>Patientez...</p>'; progressText = `Étape ? / ${currentWorkoutPlan.length}`; }
            currentExerciseNameDisplay.textContent = nameDisplay; currentExerciseContainer.innerHTML = infoHtml;
             const driveStatusContainer = progressTracker.querySelector('#drive-connection-status-main')?.closest('.progress-tracker');
             if (driveStatusContainer && document.body.classList.contains('logged-in')) { progressTracker.innerHTML = `${progressText} <span style="margin: 0 5px;">|</span> ${driveStatusContainer.innerHTML}`; }
             else { progressTracker.textContent = progressText; }
        }

        function setState(newState) {
            if (!startPauseBtn || !skipBtn || !finishBtn || !resetBtn || !timerStateDisplay || !workoutSection) { console.error("setState: Elements DOM manquants."); return; }
            const previousState = currentState; currentState = newState; console.log(`Transition État: ${previousState} -> ${newState}`);
            timerStateDisplay.classList.remove('visible', 'preparing'); clearInterval(timerInterval); timerInterval = null; clearInterval(prepareCountdownInterval); prepareCountdownInterval = null; startPauseBtn.classList.remove('pause-btn'); document.body.classList.toggle('workout-active', newState !== 'idle' && newState !== 'finished');
            switch (newState) {
                case 'idle': isTimerRunning = false; isWorkoutActive = false; workoutFinished = false; timeLeft = 0; totalTime = 0; workoutSection.classList.remove('finished-animation'); timerStateDisplay.textContent = ''; break;
                case 'preparing': isTimerRunning = false; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = `${PREPARE_DURATION}`; timerStateDisplay.classList.add('visible', 'preparing'); prepareTimeLeft = PREPARE_DURATION; startPrepareCountdown(); break;
                case 'exercise': isTimerRunning = false; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'EXERCICE'; timerStateDisplay.classList.add('visible'); timeLeft = 0; totalTime = 0; break;
                case 'break': isTimerRunning = true; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'REPOS'; timerStateDisplay.classList.add('visible'); startBreakTimer(); break;
                case 'paused': isTimerRunning = false; isWorkoutActive = true; workoutFinished = false; timerStateDisplay.textContent = 'EN PAUSE'; timerStateDisplay.classList.add('visible'); break;
                case 'finished':
                    isTimerRunning = false; isWorkoutActive = false; workoutFinished = true; timerStateDisplay.textContent = 'FINI !'; timerStateDisplay.classList.add('visible'); timeLeft = 0; totalTime = 0;
                    elapsedWorkoutEstimatedSeconds = totalWorkoutEstimatedSeconds; showMessage('Entraînement terminé ! 💪', 4000); vibrate([200, 100, 200]); if (endSound) endSound();
                    originalCompletedWorkoutPlan = JSON.parse(JSON.stringify(currentWorkoutPlan)); saveWorkoutToHistory(); clearInProgressState(); workoutSection.classList.add('finished-animation');
                    setTimeout(populateAndShowSummary, FINISH_ANIMATION_DURATION); break;
                default: console.error("État inconnu demandé:", newState); currentState = 'idle'; break;
            }
            updateTimerDisplay(); checkEnableStartButton(); updateWorkoutInfo();
        }

        function startPrepareCountdown() {
             if (prepareCountdownInterval) clearInterval(prepareCountdownInterval); updateWorkoutInfo(); updateTimerDisplay(); timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`;
             prepareCountdownInterval = setInterval(() => {
                 prepareTimeLeft--; updateWorkoutInfo(); updateTimerDisplay(); timerStateDisplay.textContent = `PRÊT DANS ${prepareTimeLeft}`;
                 if (prepareTimeLeft <= 0) {
                     clearInterval(prepareCountdownInterval); prepareCountdownInterval = null; if (endSound) endSound(); vibrate([50]); const firstItem = currentWorkoutPlan[0];
                     if (!firstItem) { console.error("Plan vide après prépa."); resetCurrentWorkout(); return; }
                     if (firstItem.type === 'exercise') { setState('exercise'); } else { totalTime = firstItem.duration || 0; timeLeft = totalTime; setState('break'); } saveInProgressState();
                 }
             }, 1000);
        }

        function startBreakTimer() {
            if (timerInterval) clearInterval(timerInterval); updateTimerDisplay();
            timerInterval = setInterval(() => {
                if (timeLeft > 0) { timeLeft--; updateTimerDisplay(); saveInProgressState(); }
                else { clearInterval(timerInterval); timerInterval = null; handleItemCompletion(true); }
            }, 1000);
        }

        function handleItemCompletion(naturalCompletion = false) {
            if (currentState === 'finished' || currentState === 'preparing') return;
            const completedItemIndex = currentItemIndex; const completedItem = currentWorkoutPlan[completedItemIndex];
            if (completedItem && completedItem.estimatedDuration !== undefined) { elapsedWorkoutEstimatedSeconds += completedItem.estimatedDuration; elapsedWorkoutEstimatedSeconds = Math.min(elapsedWorkoutEstimatedSeconds, totalWorkoutEstimatedSeconds); console.log(`Item ${completedItemIndex} terminé. Estimé: ${elapsedWorkoutEstimatedSeconds.toFixed(1)}/${totalWorkoutEstimatedSeconds.toFixed(1)}`); }
            else { console.warn(`Durée estimée non trouvée pour item ${completedItemIndex}.`); }
            updateTotalProgressCircle();
            if (naturalCompletion && currentState === 'break') { if (endSound) endSound(); vibrate(); }
             currentItemIndex++; saveInProgressState();
             if (currentItemIndex >= currentWorkoutPlan.length) { setState('finished'); }
             else {
                 const nextItem = currentWorkoutPlan[currentItemIndex]; if (!nextItem) { console.error("Élément suivant invalide."); setState('finished'); return; }
                 if (nextItem.type === 'exercise') { setState('exercise'); } else { totalTime = nextItem.duration || 0; timeLeft = totalTime; setState('break'); }
             }
        }

        function forceFinishWorkout() {
             if (!isWorkoutActive || workoutFinished || currentState === 'preparing') return;
             if (confirm("Terminer cet entraînement maintenant ?")) { clearInterval(timerInterval); clearInterval(prepareCountdownInterval); timerInterval = null; prepareCountdownInterval = null; elapsedWorkoutEstimatedSeconds = totalWorkoutEstimatedSeconds; setState('finished'); showMessage("Entraînement terminé manuellement.", 3000); }
        }

        function loadWorkout(type) {
            if (!googleAccessToken) { showMessage("Connectez-vous pour charger un entraînement.", 4000); setActiveWorkoutNav(null); return; }
            if (!programsLoaded) { showMessage("Programmes en cours de chargement ou erreur. Patientez.", 4000); setActiveWorkoutNav(null); return; }
             if (isWorkoutActive && !workoutFinished && currentWorkoutType !== type) { if (!confirm(`Entraînement "${currentWorkoutType || 'en cours'}" actif. Arrêter et charger "${type}" ?`)) { setActiveWorkoutNav(currentWorkoutType); return; } else { resetCurrentWorkout(); } }
             else if (currentWorkoutType === type && (isWorkoutActive || workoutFinished || currentState !== 'idle')) { showMessage(`"${type}" déjà chargé. Cliquez sur Reset ou démarrez/reprenez.`, 3000); showSection('workout'); setActiveWorkoutNav(type); return; }
            if (!loadedWorkouts[type]) { console.error(`Programme '${type}' introuvable.`); showMessage(`Erreur: Programme ${type} non trouvé.`, 4000); setActiveWorkoutNav(null); return; }
            console.log(`Chargement: ${type}`); currentWorkoutType = type; currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[type])); originalCompletedWorkoutPlan = [];
            if (!currentWorkoutPlan || currentWorkoutPlan.length === 0) { console.error(`Programme ${type} vide/invalide.`); showMessage(`Erreur: Programme "${type}" vide. Vérifiez le fichier Drive.`, 5000); currentWorkoutType = null; setActiveWorkoutNav(null); return; }
            totalWorkoutEstimatedSeconds = calculateTotalEstimatedTime(currentWorkoutPlan); elapsedWorkoutEstimatedSeconds = 0; currentItemIndex = 0; workoutStartTime = null; workoutFinished = false; isWorkoutActive = false;
            setActiveWorkoutNav(type); showSection('workout'); clearInterval(timerInterval); timerInterval = null; clearInterval(prepareCountdownInterval); prepareCountdownInterval = null; isTimerRunning = false; setState('idle');
            showMessage(`Programme "${type}" (${currentWorkoutPlan.length} étapes) chargé. Prêt !`, 3500);
        }

        function resetCurrentWorkout() {
            console.log("Réinitialisation..."); clearInterval(timerInterval); timerInterval = null; clearInterval(prepareCountdownInterval); prepareCountdownInterval = null; const typeReset = currentWorkoutType;
            currentWorkoutType = null; currentWorkoutPlan = []; originalCompletedWorkoutPlan = []; currentItemIndex = 0; workoutStartTime = null; isTimerRunning = false; isWorkoutActive = false; workoutFinished = false;
            timeLeft = 0; totalTime = 0; prepareTimeLeft = 0; totalWorkoutEstimatedSeconds = 0; elapsedWorkoutEstimatedSeconds = 0;
            clearInProgressState(); closeSummary(); workoutSection.classList.remove('finished-animation'); setActiveWorkoutNav(null); showSection('workout'); setState('idle');
            if (typeReset) { showMessage(`"${typeReset}" réinitialisé.`, 2500); } else { showMessage(`État réinitialisé.`, 2000); }
            updateAuthUI(!!googleAccessToken);
        }

        function showMessage(msg, duration = 3500) {
            if (!messageArea) return; messageArea.textContent = msg; messageArea.classList.add('visible');
            if (messageTimeoutId) { clearTimeout(messageTimeoutId); }
            messageTimeoutId = setTimeout(() => { messageArea.classList.remove('visible'); messageTimeoutId = null; }, duration);
        }

        // --- Gestion du Thème ---
        function applyTheme(theme) {
            const body = document.body; currentTheme = theme; const isDark = theme === 'dark';
            body.classList.remove('light-theme', 'dark-theme'); body.classList.add(theme + '-theme');
            if (themeToggleBtn) { themeToggleBtn.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>'; }
            try { localStorage.setItem('theme', theme); } catch (e) { console.warn("Impossible de sauvegarder le thème:", e); }
            if (historyChart && historyChartCanvas && !historySection?.classList.contains('section-hidden')) { updateChartTheme(); }
            console.log(`Thème appliqué: ${theme}`);
        }

        function updateChartTheme() {
            if (!historyChart) return;
            const bodyStyles = getComputedStyle(document.documentElement);
            const gridColor = bodyStyles.getPropertyValue('--border-color').trim(); const textColor = bodyStyles.getPropertyValue('--primary-text-color').trim();
            const tooltipBg = bodyStyles.getPropertyValue('--secondary-bg-color').trim(); const primaryColor = bodyStyles.getPropertyValue('--neon-blue').trim();
            const accentColor = bodyStyles.getPropertyValue('--neon-pink').trim();
             try {
                const scales = historyChart.options.scales; if (scales) { if (scales.x) { scales.x.grid.color = gridColor; scales.x.ticks.color = textColor; if (scales.x.title) scales.x.title.color = textColor; } if (scales.y) { scales.y.grid.color = gridColor; scales.y.ticks.color = textColor; if (scales.y.title) scales.y.title.color = textColor; } }
                const plugins = historyChart.options.plugins; if (plugins) { if (plugins.tooltip) { plugins.tooltip.backgroundColor = tooltipBg; plugins.tooltip.titleColor = textColor; plugins.tooltip.bodyColor = textColor; } if (plugins.legend && plugins.legend.labels) { plugins.legend.labels.color = textColor; } }
                if (historyChart.data.datasets && historyChart.data.datasets[0]) { historyChart.data.datasets[0].backgroundColor = primaryColor + '99'; historyChart.data.datasets[0].borderColor = primaryColor; historyChart.data.datasets[0].hoverBackgroundColor = accentColor + 'CC'; historyChart.data.datasets[0].hoverBorderColor = accentColor; }
                historyChart.update('none'); console.log("Thème du graphique mis à jour.");
             } catch (e) { console.error("Erreur mise à jour thème graphique:", e); }
        }

        // --- Gestion Affichage Sections ---
        function showSection(sectionName) {
            if (!workoutSection || !historySection || !navHistoryBtn || !navButtons) return;
            closeSummary(); const isHistory = sectionName === 'history';
            workoutSection.classList.toggle('section-hidden', isHistory); historySection.classList.toggle('section-hidden', !isHistory);
            navHistoryBtn.classList.toggle('active', isHistory);
             if (!isHistory) { setActiveWorkoutNav(currentWorkoutType); }
             else { navButtons.forEach(btn => btn.classList.remove('active')); displayHistory(currentHistoryPeriod); }
        }

        function setActiveWorkoutNav(workoutType) { if (!navButtons) return; navButtons.forEach(btn => { btn.classList.toggle('active', btn.dataset.workout === workoutType); }); }

        // --- Persistance Locale (État en Cours) ---
        function saveInProgressState() {
             if (!isWorkoutActive || workoutFinished || currentState === 'idle' || currentState === 'preparing') { clearInProgressState(); return; }
            const stateToSave = { type: currentWorkoutType, index: currentItemIndex, timeLeft: timeLeft, totalTime: totalTime, currentState: currentState, startTime: workoutStartTime, totalEstimated: totalWorkoutEstimatedSeconds, elapsedEstimated: elapsedWorkoutEstimatedSeconds };
             try { localStorage.setItem(IN_PROGRESS_KEY, JSON.stringify(stateToSave)); console.log("État local sauvegardé:", stateToSave); } catch (e) { console.error("Sauvegarde état local échouée:", e); showMessage("Erreur sauvegarde locale progression.", 5000); }
        }

        function loadInProgressState() {
             console.log(`loadInProgressState: Recherche: "${IN_PROGRESS_KEY}"`); const savedStateJSON = localStorage.getItem(IN_PROGRESS_KEY);
             if (!savedStateJSON) { console.log("loadInProgressState: Aucun état sauvegardé."); return false; }
            try {
                 const savedState = JSON.parse(savedStateJSON); console.log("État local trouvé:", savedState);
                 if ( !savedState || typeof savedState !== 'object' || !savedState.type || !PROGRAM_TYPES.includes(savedState.type) || typeof savedState.index !== 'number' || savedState.index < 0 || typeof savedState.currentState !== 'string' || !['exercise', 'break', 'paused'].includes(savedState.currentState) || typeof savedState.totalEstimated !== 'number' || typeof savedState.elapsedEstimated !== 'number' || savedState.index >= (loadedWorkouts[savedState.type]?.length || 0) ) { console.warn("État local invalide/incomplet. Suppression.", savedState); clearInProgressState(); return false; }
                 if (googleAccessToken && programsLoaded) {
                     const timeAgo = savedState.startTime ? ` (commencé ${new Date(savedState.startTime).toLocaleString('fr-FR', { short: 'short' })})` : '';
                     if (confirm(`Entraînement "${savedState.type}" en cours${timeAgo}. Reprendre à l'étape ${savedState.index + 1} (${savedState.currentState}) ?`)) {
                         console.log("Reprise état local acceptée.");
                         currentWorkoutType = savedState.type; currentWorkoutPlan = JSON.parse(JSON.stringify(loadedWorkouts[currentWorkoutType])); totalWorkoutEstimatedSeconds = calculateTotalEstimatedTime(currentWorkoutPlan);
                         elapsedWorkoutEstimatedSeconds = savedState.elapsedEstimated; originalCompletedWorkoutPlan = []; currentItemIndex = savedState.index; timeLeft = savedState.timeLeft; totalTime = savedState.totalTime; workoutStartTime = savedState.startTime; isWorkoutActive = true; workoutFinished = false;
                         setActiveWorkoutNav(currentWorkoutType); showSection('workout');
                        const stateToRestore = savedState.currentState;
                        if (stateToRestore === 'exercise') { setState('exercise'); }
                        else if (stateToRestore === 'break' || stateToRestore === 'paused') { timeLeft = savedState.timeLeft; totalTime = savedState.totalTime; setState('paused'); }
                         console.log(`Reprise état: ${currentState}, Index: ${currentItemIndex}, Temps Restant: ${timeLeft}, Estimé: ${elapsedWorkoutEstimatedSeconds.toFixed(1)}/${totalWorkoutEstimatedSeconds.toFixed(1)}`); showMessage(`Progression "${currentWorkoutType}" restaurée.`, 3500); updateAuthUI(true); return true;
                     } else { console.log("Reprise état local refusée."); clearInProgressState(); return false; }
                 } else { console.log("État local trouvé, mais reprise impossible (non connecté ou programmes non chargés)."); return false; }
            } catch (e) { console.error("Erreur chargement/parsing état local:", e); clearInProgressState(); return false; }
        }

        function clearInProgressState() { try { localStorage.removeItem(IN_PROGRESS_KEY); console.log("État local supprimé."); } catch (e) { console.error("Erreur suppression état local:", e); } }

        // --- Gestion de l'Historique ---
        function saveWorkoutToHistory() {
             const finalWorkoutType = currentWorkoutType; if (!finalWorkoutType || workoutStartTime === null) { console.warn("Sauvegarde historique annulée: type/heure début manquants."); return; }
              if (!googleAccessToken) { showMessage("Connectez-vous pour sauvegarder l'historique.", 4000); return; }
              const endTime = Date.now(); const durationSeconds = Math.round((endTime - workoutStartTime) / 1000);
              if (durationSeconds < 10) { console.log(`Entraînement trop court (${durationSeconds}s), non sauvegardé.`); return; }
              const newEntry = { id: endTime.toString(), date: new Date(endTime).toISOString(), type: finalWorkoutType, duration: durationSeconds };
              console.log("Ajout historique local:", newEntry); workoutHistory.unshift(newEntry);
             if (historySection && !historySection.classList.contains('section-hidden')) { displayHistory(currentHistoryPeriod); } saveHistoryToDrive();
         }

         async function saveHistoryToDrive() {
            if (!googleAccessToken) { console.warn("Tentative sauvegarde Drive sans connexion."); return; }
            if (!historyFileId) { console.log("ID fichier historique inconnu. Recherche/création..."); const defaultHeader = "DateISO,WorkoutType,DurationSeconds,EntryID\n"; historyFileId = await findOrCreateFile(HISTORY_FILENAME, defaultHeader); }
             if (!historyFileId) { showMessage("Impossible accéder/créer fichier historique Drive.", 5000); return; }
             let csvContent = "DateISO,WorkoutType,DurationSeconds,EntryID\n";
             const sortedHistory = [...workoutHistory].sort((a, b) => new Date(b.date) - new Date(a.date));
             sortedHistory.forEach(entry => { const cleanType = (entry.type || '').replace(/,/g, ''); const date = entry.date || new Date().toISOString(); const duration = entry.duration || 0; const id = entry.id || Date.now().toString(); csvContent += `${date},${cleanType},${duration},${id}\n`; });
             console.log(`Tentative maj historique Drive (${historyFileId}) avec ${sortedHistory.length} entrées.`); const success = await updateFileContent(historyFileId, csvContent);
             if (success) { console.log("Historique synchronisé avec Drive."); if (historyDriveStatus) historyDriveStatus.textContent = 'Synchro OK'; }
             else { console.error("Échec synchro historique Drive."); showMessage("Erreur sauvegarde historique Drive.", 4000); if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Sync'; }
         }

         async function loadHistoryFromDrive() {
            console.log("loadHistoryFromDrive: Démarrage...");
             if (!googleAccessToken) { console.log("Non connecté, historique vidé."); workoutHistory = []; if (historyList) historyList.innerHTML = `<li class="no-history">Connectez-vous.</li>`; if (statsDisplay) displayStatsAndMotivation([], currentHistoryPeriod, false); if (historyChartCanvas) renderHistoryChart([], currentHistoryPeriod); return false; }
             console.log("Chargement historique Drive..."); if (historyDriveStatus) historyDriveStatus.textContent = 'Chargement Hist...';
             if (!historyFileId) { const defaultHeader = "DateISO,WorkoutType,DurationSeconds,EntryID\n"; historyFileId = await findOrCreateFile(HISTORY_FILENAME, defaultHeader); }
             if (!historyFileId) { showMessage("Impossible accéder fichier historique Drive.", 5000); workoutHistory = []; displayHistory(currentHistoryPeriod); if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Accès Hist.'; return false; }
             const csvContent = await readFileContent(historyFileId);
            if (csvContent === null) { workoutHistory = []; showMessage("Erreur lecture historique Drive.", 4000); if (historyDriveStatus) historyDriveStatus.textContent = 'Erreur Lecture Hist.'; displayHistory(currentHistoryPeriod); return false; }
            else if (csvContent === "") { workoutHistory = []; console.log("Fichier historique Drive vide."); if (historyDriveStatus) historyDriveStatus.textContent = 'Hist. Vide'; }
            else { parseAndLoadHistoryCsvData(csvContent); console.log(`Historique chargé: ${workoutHistory.length} entrées.`); if (historyDriveStatus) historyDriveStatus.textContent = 'Synchro OK'; }
             displayHistory(currentHistoryPeriod); return true;
         }

        function parseAndLoadHistoryCsvData(csvContent) {
            try {
                const lines = csvContent.trim().split(/\r?\n/); const newHistory = []; const existingIDs = new Set(); if (lines.length <= 1) { console.log("CSV historique vide/header seul."); workoutHistory = []; return; }
                const headerLine = lines[0].trim().toLowerCase(); const hasHeader = headerLine.includes("dateiso") && headerLine.includes("workouttype") && headerLine.includes("durationseconds"); const startIndex = hasHeader ? 1 : 0;
                console.log(`Parsing CSV: ${lines.length - startIndex} lignes potentielles.`);
                for (let i = startIndex; i < lines.length; i++) {
                    const line = lines[i].trim(); if (!line) continue; const values = line.split(','); if (values.length < 3) { console.warn(`Ligne historique ignorée (< 3 champs): ${line}`); continue; }
                    const dateStr = values[0]?.trim(); const typeStr = values[1]?.trim(); const durationStr = values[2]?.trim(); const idStr = (values.length > 3) ? values[3]?.trim() : null;
                    const date = new Date(dateStr); const duration = parseInt(durationStr, 10);
                    if (isNaN(date.getTime())) { console.warn(`Ligne historique ignorée (date invalide '${dateStr}'): ${line}`); continue; }
                    if (!PROGRAM_TYPES.includes(typeStr)) { console.warn(`Ligne historique ignorée (type inconnu '${typeStr}'): ${line}`); continue; }
                    if (isNaN(duration) || duration < 0) { console.warn(`Ligne historique ignorée (durée invalide '${durationStr}'): ${line}`); continue; }
                    const entryId = idStr || `${date.getTime()}-${i}`; if (existingIDs.has(entryId)) { console.warn(`ID historique dupliqué ignoré: ${entryId} (ligne: ${line})`); continue; }
                    newHistory.push({ id: entryId, date: date.toISOString(), type: typeStr, duration: duration }); existingIDs.add(entryId);
                 }
                 newHistory.sort((a, b) => new Date(b.date) - new Date(a.date)); workoutHistory = newHistory; console.log(`Parsing CSV terminé. ${workoutHistory.length} entrées valides.`);
             } catch (error) { console.error("Erreur parsing CSV historique:", error); showMessage(`Erreur parsing historique: ${error.message}`, 6000); workoutHistory = []; }
         }

        function displayHistory(period = currentHistoryPeriod) {
             if (!historyList || !statsDisplay || !historyFilterBtns || !historyChartCanvas) { console.warn("displayHistory: Éléments DOM manquants."); return; }
             currentHistoryPeriod = period; historyFilterBtns.forEach(btn => { btn.classList.toggle('active', btn.dataset.period === period); });
             const isConnected = !!googleAccessToken; const historyToDisplay = isConnected ? workoutHistory : [];
             const filteredHistory = filterHistoryByPeriod(historyToDisplay, period); console.log(`Affichage historique '${period}'. ${filteredHistory.length} entrées.`);
             historyList.innerHTML = '';
             if (!isConnected) { historyList.innerHTML = `<li class="no-history">Connectez-vous.</li>`; }
             else if (filteredHistory.length === 0) { historyList.innerHTML = `<li class="no-history">Aucun entraînement pour cette période.</li>`; }
             else { filteredHistory.forEach(entry => { const li = document.createElement('li'); const entryDate = new Date(entry.date); const dateFormatted = entryDate.toLocaleDateString('fr-FR', { year: 'numeric', month: 'short', day: 'numeric' }); const timeFormatted = entryDate.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }); const durationFormatted = formatTime(entry.duration); li.innerHTML = `<span class="history-item-date">${dateFormatted} <small>(${timeFormatted})</small></span><span class="history-item-type">${entry.type}</span><span class="history-item-duration">${durationFormatted}</span>`; historyList.appendChild(li); }); }
             displayStatsAndMotivation(filteredHistory, period, isConnected); renderHistoryChart(filteredHistory, period);
         }

         function filterHistoryByPeriod(history, period) {
            const now = new Date(); const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
             return history.filter(entry => {
                const entryDate = new Date(entry.date); if (isNaN(entryDate.getTime())) return false; const entryDateStart = new Date(entryDate.getFullYear(), entryDate.getMonth(), entryDate.getDate());
                 switch (period) {
                     case 'week': const dayOfWeek = todayStart.getDay(); const diffToMonday = todayStart.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1); const startOfWeek = new Date(now.getFullYear(), now.getMonth(), diffToMonday); startOfWeek.setHours(0, 0, 0, 0); return entryDateStart >= startOfWeek;
                     case 'month': const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1); return entryDateStart >= startOfMonth;
                     case 'year': const startOfYear = new Date(now.getFullYear(), 0, 1); return entryDateStart >= startOfYear;
                     case 'all': default: return true;
                 }
             });
         }

        function displayStatsAndMotivation(filteredHistory, period, isConnected) {
            if (!statsDisplay) return;
            const stats = calculateStats(filteredHistory); let periodText = '';
            switch (period) { case 'week': periodText = 'Semaine'; break; case 'month': periodText = 'Mois'; break; case 'year': periodText = 'Année'; break; case 'all': periodText = 'Total'; break; }
            const statsTitleElement = statsDisplay.querySelector('h3'); if (statsTitleElement) statsTitleElement.textContent = `Statistiques (${periodText})`;
            let statsHTML = "";
            if (!isConnected) { statsHTML = "<p>Connectez-vous pour voir vos stats.</p>"; }
            else if (stats.count === 0) { statsHTML = "<p>Aucune donnée pour cette période.</p>"; }
            else { statsHTML = `<p><i class="fas fa-calendar-check"></i> Nb séances: <strong>${stats.count}</strong></p><p><i class="fas fa-stopwatch"></i> Durée totale: <strong>${formatTime(stats.totalDuration)}</strong></p><p><i class="fas fa-hourglass-half"></i> Durée moy./séance: <strong>${formatTime(stats.avgDuration)}</strong></p><p><i class="fas fa-star"></i> Type + fréquent: <strong>${stats.mostFrequentType || 'N/A'}</strong> (${stats.frequency[stats.mostFrequentType] || 0}x)</p>`; }
            statsDisplay.innerHTML = (statsTitleElement ? statsTitleElement.outerHTML : `<h3>Statistiques (${periodText})</h3>`) + statsHTML;
            // Récupérer ou créer l'élément pour le message motivationnel
            let msgElem = statsDisplay.querySelector('.motivational-message');
            if (!msgElem) { msgElem = document.createElement('p'); msgElem.className = 'motivational-message'; statsDisplay.appendChild(msgElem); }
            msgElem.textContent = isConnected ? generateMotivationalMessage(stats, period) : "";
         }

        function calculateStats(history) {
            const count = history.length; let totalDuration = 0; const frequency = { Push: 0, Pull: 0, Legs: 0 };
            history.forEach(entry => { const duration = Number(entry.duration); if (!isNaN(duration)) { totalDuration += duration; } if (frequency.hasOwnProperty(entry.type)) { frequency[entry.type]++; } });
            const avgDuration = count > 0 ? Math.round(totalDuration / count) : 0; let mostFrequentType = null; let maxFrequency = -1;
            for (const type in frequency) { if (frequency[type] > maxFrequency) { maxFrequency = frequency[type]; mostFrequentType = type; } } if (maxFrequency <= 0) { mostFrequentType = null; }
             return { count, totalDuration, avgDuration, frequency, mostFrequentType };
        }

        function generateMotivationalMessage(stats, period) {
            const { count } = stats; if (!googleAccessToken) return "";
            if (count === 0) { switch (period) { case 'week': return "Aucune séance cette semaine. Planifiez ! 📅"; case 'month': return "Pas d'entraînement ce mois-ci. Go ! 🚀"; case 'year': return "Première séance de l'année à venir ? 🤔"; case 'all': return "Commencez votre parcours fitness ! 💪"; default: return "Prêt ?"; } }
            switch (period) {
                 case 'week': if (count >= 5) return `Incroyable, ${count} séances / semaine ! 🔥`; if (count >= 3) return `Super régularité (${count} séances) ! 👍`; if (count >= 1) return `Bien joué (${count} séance${count > 1 ? 's' : ''}) ! Continuez ! ✨`; break;
                 case 'month': if (count >= 15) return `Discipline ! ${count} séances ce mois ! 🚀`; if (count >= 10) return `Solide perf (${count} entraînements) ! 🎉`; if (count >= 5) return `Belle progression (${count} séances) ! 😊`; if (count >= 1) return `${count} séance${count > 1 ? 's' : ''} ce mois ! 🌱`; break;
                 case 'year': case 'all': if (count >= 100) return `Légendaire ! ${count}+ séances ! 🏆`; if (count >= 50) return `Impressionnant ! ${count} séances ! 🏋️‍♂️`; if (count >= 20) return `${count} séances, beau parcours ! 🌟`; if (count >= 1) return `Déjà ${count} entraînement${count > 1 ? 's' : ''} ! 🎯`; break;
             }
             return "Continuez vos efforts, vous progressez ! 💯";
        }

        // --- Gestion des Programmes (CSV <-> Objet) ---
        function convertProgramToCsv(programArray) {
            const header = "Type,Name,Details,Reps,Duration\n"; let csv = header;
            const escapeCsvField = (field) => { if (field === null || field === undefined) return ''; const stringField = String(field); if (stringField.includes(',') || stringField.includes('"') || stringField.includes('\n')) { return `"${stringField.replace(/"/g, '""')}"`; } return stringField; };
            programArray.forEach(item => {
                 if (item.type === 'exercise') { const name = escapeCsvField(item.name ?? ''); const details = escapeCsvField(item.details ?? ''); const reps = (item.reps !== null && Number.isFinite(item.reps)) ? item.reps : ''; csv += `${item.type},${name},${details},${reps},\n`; }
                 else if (item.type === 'break') { const duration = (item.duration !== null && Number.isFinite(item.duration)) ? item.duration : ''; csv += `${item.type},,,,${duration}\n`; }
             }); return csv;
        }

         function parseProgramCsvData(csvContent) {
            const program = []; if (!csvContent || typeof csvContent !== 'string') return program; const lines = csvContent.trim().split(/\r?\n/); if (lines.length <= 1) return program;
             const headerLine = lines[0].trim().toLowerCase(); const hasHeader = headerLine.startsWith("type,name,details,reps,duration"); const startIndex = hasHeader ? 1 : 0;
             const parseCsvLine = (line) => { const values = []; let currentVal = ''; let inQuotes = false; for (let i = 0; i < line.length; i++) { const char = line[i]; if (char === '"' && inQuotes && i + 1 < line.length && line[i+1] === '"') { currentVal += '"'; i++; } else if (char === '"') { inQuotes = !inQuotes; } else if (char === ',' && !inQuotes) { values.push(currentVal.trim()); currentVal = ''; } else { currentVal += char; } } values.push(currentVal.trim()); return values; };
            for (let i = startIndex; i < lines.length; i++) {
                 const line = lines[i].trim(); if (!line) continue; const values = parseCsvLine(line); if (values.length < 5) { console.warn(`Ligne programme ignorée (< 5 champs): ${line}`); continue; }
                 const type = values[0]?.toLowerCase() || ''; const name = values[1] || ''; const details = values[2] || ''; const repsStr = values[3] || ''; const durationStr = values[4] || '';
                 if (type === 'exercise') { const reps = parseInt(repsStr, 10); if (!name) { console.warn(`Ligne exo ignorée (nom manquant): ${line}`); continue; } program.push({ type: 'exercise', name: name, details: details, reps: (!isNaN(reps) && repsStr !== '') ? reps : null }); }
                 else if (type === 'break') { const duration = parseInt(durationStr, 10); if (isNaN(duration) || duration <= 0) { console.warn(`Ligne break ignorée (durée invalide '${durationStr}'): ${line}`); continue; } program.push({ type: 'break', duration: duration, name: name || 'Repos' }); }
                 else { console.warn(`Ligne programme ignorée (type inconnu '${type}'): ${line}`); }
             } console.log(`Parsing programme CSV terminé. ${program.length} étapes.`); return program;
         }

        async function loadProgramsFromDrive() {
            console.log("loadProgramsFromDrive: Démarrage..."); if (!googleAccessToken) { console.warn("loadProgramsFromDrive: Non connecté. Utilisation défauts."); loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); programsLoaded = false; return false; }
            programsLoaded = false; let allLoadedSuccessfully = true;
            if (driveStatusElement) { driveStatusElement.textContent = 'Chargement Progs...'; driveStatusElement.classList.add('loading'); driveStatusElement.classList.remove('error','success'); driveStatusElement.style.display = 'inline-block'; }
             const loadPromises = PROGRAM_TYPES.map(async (type) => {
                 const filename = PROGRAM_FILENAMES[type]; const defaultProgram = defaultWorkouts[type] || []; const defaultCsv = convertProgramToCsv(defaultProgram);
                 console.log(`Chargement programme: ${type} (${filename})`); const fileId = await findOrCreateFile(filename, defaultCsv); programFileIds[type] = fileId;
                 if (fileId) {
                     const csvContent = await readFileContent(fileId);
                     if (csvContent !== null) {
                         try { const parsedProgram = parseProgramCsvData(csvContent); if (parsedProgram.length > 0) { loadedWorkouts[type] = parsedProgram; console.log(`Programme ${type} chargé (${parsedProgram.length} étapes).`); return true; } else { console.warn(`Programme ${type} lu mais parsing invalide/vide. Utilisation défaut.`); loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram)); if (csvContent !== defaultCsv && csvContent.trim() !== "" && csvContent.trim().toLowerCase() !== "type,name,details,reps,duration") { showMessage(`Format ${filename} invalide sur Drive. Défaut chargé.`, 5000); } return true; } }
                         catch (parseError) { console.error(`Erreur parsing programme ${type}:`, parseError); showMessage(`Erreur parsing ${filename}. Défaut chargé.`, 5000); loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram)); return false; }
                     } else { console.error(`Échec lecture ${filename} (ID: ${fileId}). Utilisation défaut.`); loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram)); return false; }
                 } else { console.error(`Échec accès/création ${filename}. Utilisation défaut.`); loadedWorkouts[type] = JSON.parse(JSON.stringify(defaultProgram)); return false; }
             });
             try { const results = await Promise.all(loadPromises); allLoadedSuccessfully = results.every(success => success === true); } catch (error) { console.error("Erreur inattendue pendant Promise.all loadPrograms:", error); allLoadedSuccessfully = false; }
             programsLoaded = allLoadedSuccessfully; console.log(`Fin chargement programmes. 'programsLoaded': ${programsLoaded}`);
             if (driveStatusElement) { driveStatusElement.classList.remove('loading'); if (!allLoadedSuccessfully) { driveStatusElement.textContent = 'Erreur Progs'; driveStatusElement.classList.add('error'); showMessage("Certains programmes n'ont pu être chargés.", 5000); } else { driveStatusElement.textContent = 'Connecté'; driveStatusElement.classList.add('success'); driveStatusElement.classList.remove('error'); console.log("Programmes chargés OK (ou fallback)."); } }
             if (navButtons) navButtons.forEach(btn => btn.disabled = !programsLoaded); if (exportProgramsBtn) exportProgramsBtn.disabled = !programsLoaded; checkEnableStartButton(); return programsLoaded;
        }

        async function exportProgramsToDrive() {
            if (!googleAccessToken) { showMessage("Connectez-vous pour exporter.", 4000); return; }
            if (!programsLoaded && !confirm("Programmes non chargés correctement. Exporter quand même les versions actuelles (défaut) ?")) { showMessage("Export annulé.", 2000); return; }
            if (!confirm("Exporter les programmes actuels vers Drive ? (Écrase les versions Drive)")) { showMessage("Export annulé.", 2000); return; }
            console.log("Exportation programmes Drive..."); showMessage("Exportation...", 5000);
            if (driveStatusElement) { driveStatusElement.textContent = 'Export Progs...'; driveStatusElement.classList.add('loading'); driveStatusElement.classList.remove('error','success'); driveStatusElement.style.display = 'inline-block'; }
            if (exportProgramsBtn) exportProgramsBtn.disabled = true; let successCount = 0;
             const exportPromises = PROGRAM_TYPES.map(async (type) => {
                const fileId = programFileIds[type]; const filename = PROGRAM_FILENAMES[type]; if (!fileId) { console.error(`ID manquant pour ${type}. Export impossible.`); showMessage(`Erreur: ID fichier ${type} manquant.`, 4000); return false; }
                 try { const currentProgramData = loadedWorkouts[type] || defaultWorkouts[type] || []; const csvContent = convertProgramToCsv(currentProgramData); console.log(`Export ${type} (ID: ${fileId}) ${currentProgramData.length} étapes.`); const success = await updateFileContent(fileId, csvContent); if (success) { console.log(`Programme ${type} exporté.`); return true; } else { console.error(`Échec export ${type}.`); return false; } }
                 catch (error) { console.error(`Erreur export ${type}:`, error); showMessage(`Erreur export ${type}: ${error.message}`, 5000); return false; }
            });
             try { const results = await Promise.all(exportPromises); successCount = results.filter(success => success === true).length; } catch (error) { console.error("Erreur inattendue pendant Promise.all exportPrograms:", error); successCount = 0; }
             if (driveStatusElement) driveStatusElement.classList.remove('loading'); if (exportProgramsBtn) exportProgramsBtn.disabled = !programsLoaded;
            if (successCount === PROGRAM_TYPES.length) { showMessage("Programmes exportés avec succès !", 3000); if (driveStatusElement) { driveStatusElement.textContent = 'Export OK'; driveStatusElement.classList.add('success'); setTimeout(() => { if(googleAccessToken && driveStatusElement && driveStatusElement.textContent === 'Export OK') { driveStatusElement.textContent = 'Connecté'; driveStatusElement.classList.add('success'); } }, 2500); } }
            else { showMessage(`Export terminé avec ${PROGRAM_TYPES.length - successCount} erreur(s).`, 6000); if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Export'; driveStatusElement.classList.add('error'); } }
        }

        // --- Rendu du Graphique ---
        function renderHistoryChart(filteredHistory, period) {
            if (!historyChartCanvas) { console.warn("Canvas graphique historique introuvable."); return; } const ctx = historyChartCanvas.getContext('2d'); if (!ctx) { console.error("Impossible d'obtenir contexte 2D canvas."); return; }
            if (historyChart) { historyChart.destroy(); historyChart = null; }
            const { labels, data } = aggregateChartData(filteredHistory, period);
            const bodyStyles = getComputedStyle(document.documentElement);
            const primaryColor = bodyStyles.getPropertyValue('--neon-blue').trim() || '#00aeff'; const accentColor = bodyStyles.getPropertyValue('--neon-pink').trim() || '#e54ac5'; const gridColor = bodyStyles.getPropertyValue('--border-color').trim() || 'rgba(139,148,158,0.2)'; const textColor = bodyStyles.getPropertyValue('--primary-text-color').trim() || '#c9d1d9'; const tooltipBg = bodyStyles.getPropertyValue('--secondary-bg-color').trim() || '#161B22';
             if (labels.length === 0 || data.every(d => d === 0)) { console.log("Aucune donnée graphique pour cette période."); return; }
            try {
                 historyChart = new Chart(ctx, { type: 'bar', data: { labels: labels, datasets: [{ label: 'Durée totale (min)', data: data.map(d => formatTimeForChart(d)), backgroundColor: primaryColor + '99', borderColor: primaryColor, borderWidth: 1, hoverBackgroundColor: accentColor + 'CC', hoverBorderColor: accentColor, borderRadius: 4 }] },
                     options: { responsive: true, maintainAspectRatio: false,
                         scales: { y: { beginAtZero: true, title: { display: true, text: 'Durée (minutes)', color: textColor, font: { size: 13, family: 'Inter' } }, grid: { color: gridColor }, ticks: { color: textColor, callback: function(value) { return value + ' min'; } } }, x: { title: { display: true, text: getChartXAxisTitle(period), color: textColor, font: { size: 13, family: 'Inter' } }, grid: { display: false }, ticks: { color: textColor } } },
                         plugins: { legend: { display: false }, tooltip: { backgroundColor: tooltipBg, titleColor: textColor, bodyColor: textColor, padding: 10, cornerRadius: 6, displayColors: false, callbacks: { label: function(context) { const originalDurationSeconds = data[context.dataIndex] || 0; const formattedTime = formatTime(originalDurationSeconds); return `Durée: ${formattedTime}`; } } } },
                         animation: { duration: 500, easing: 'easeOutCubic' }
                     }
                 }); console.log("Graphique historique rendu.");
             } catch (e) { console.error("Erreur création Chart.js:", e); showMessage("Erreur affichage graphique.", 4000); }
        }

        function aggregateChartData(history, period) {
            const aggregated = new Map(); const initializeMap = (labels) => labels.forEach(label => aggregated.set(label, 0));
            switch (period) {
                case 'week': const daysOfWeek = ['Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam', 'Dim']; initializeMap(daysOfWeek); const nowW = new Date(); const todayStartW = new Date(nowW.getFullYear(), nowW.getMonth(), nowW.getDate()); const dayOfWeekNum = todayStartW.getDay(); const diffToMonday = todayStartW.getDate() - dayOfWeekNum + (dayOfWeekNum === 0 ? -6 : 1); const startOfWeek = new Date(nowW.getFullYear(), nowW.getMonth(), diffToMonday); startOfWeek.setHours(0,0,0,0); history.forEach(entry => { const entryDate = new Date(entry.date); if (entryDate >= startOfWeek) { let dayIndex = entryDate.getDay(); dayIndex = dayIndex === 0 ? 6 : dayIndex - 1; const dayName = daysOfWeek[dayIndex]; aggregated.set(dayName, (aggregated.get(dayName) || 0) + (entry.duration || 0)); } }); return { labels: daysOfWeek, data: daysOfWeek.map(day => aggregated.get(day)) };
                case 'month': const weeksOfMonth = ['Sem 1', 'Sem 2', 'Sem 3', 'Sem 4', 'Sem 5+']; initializeMap(weeksOfMonth); const currentMonthNum = new Date().getMonth(); const currentYearNum = new Date().getFullYear(); history.forEach(entry => { const entryDate = new Date(entry.date); if (entryDate.getMonth() === currentMonthNum && entryDate.getFullYear() === currentYearNum) { const dayOfMonth = entryDate.getDate(); const weekIndex = Math.min(Math.floor((dayOfMonth - 1) / 7), 4); const weekName = weeksOfMonth[weekIndex]; aggregated.set(weekName, (aggregated.get(weekName) || 0) + (entry.duration || 0)); } }); return { labels: weeksOfMonth, data: weeksOfMonth.map(week => aggregated.get(week)) };
                case 'year': const monthsOfYear = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc']; initializeMap(monthsOfYear); const currentYear = new Date().getFullYear(); history.forEach(entry => { const entryDate = new Date(entry.date); if (entryDate.getFullYear() === currentYear) { const monthIndex = entryDate.getMonth(); const monthName = monthsOfYear[monthIndex]; aggregated.set(monthName, (aggregated.get(monthName) || 0) + (entry.duration || 0)); } }); return { labels: monthsOfYear, data: monthsOfYear.map(month => aggregated.get(month)) };
                case 'all': default: const yearData = {}; history.forEach(entry => { const year = new Date(entry.date).getFullYear(); yearData[year] = (yearData[year] || 0) + (entry.duration || 0); }); const sortedYears = Object.keys(yearData).map(Number).sort((a, b) => a - b); return { labels: sortedYears.map(String), data: sortedYears.map(year => yearData[year]) };
            }
        }

        function getChartXAxisTitle(period) { switch (period) { case 'week': return 'Jour (Semaine Courante)'; case 'month': return 'Semaine (Mois Courant)'; case 'year': return 'Mois (Année Courante)'; case 'all': return 'Année'; default: return ''; } }

        // --- Gestion Résumé/Modification Post-Workout ---
        function populateAndShowSummary() {
             if (!originalCompletedWorkoutPlan || originalCompletedWorkoutPlan.length === 0 || !summaryTitle || !summaryItemsList || !postWorkoutSummary || !saveSummaryBtn || !cancelSummaryBtn) { console.error("Impossible afficher résumé: DOM/données manquants."); if (currentState === 'finished') { resetCurrentWorkout(); } return; }
             const finalWorkoutType = currentWorkoutType; summaryTitle.textContent = `Résumé Séance - ${finalWorkoutType || 'Inconnu'}`; summaryItemsList.innerHTML = '';
             originalCompletedWorkoutPlan.forEach((item, index) => {
                 const li = document.createElement('li'); li.classList.add('summary-item'); li.dataset.index = index;
                 if (item.type === 'exercise') {
                     li.classList.add('item-type-exercise'); const repsValue = (item.reps !== null && Number.isFinite(item.reps)) ? item.reps : ''; const detailsValue = item.details || '';
                     li.innerHTML = `<h4><i class="fas fa-dumbbell"></i> ${item.name || 'Exercice'}</h4><label for="summary-reps-${index}">Reps:</label><div><input type="number" id="summary-reps-${index}" value="${repsValue}" min="0" step="1" placeholder="N/A"></div><label for="summary-details-${index}">Détails:</label><div><textarea id="summary-details-${index}" rows="2" placeholder="Aucun détail">${detailsValue}</textarea></div>`;
                 } else if (item.type === 'break') { li.classList.add('item-type-break'); li.innerHTML = `<h4><i class="fas fa-coffee"></i> Repos</h4><p>Durée: ${formatTime(item.duration || 0)}</p><div></div><div></div>`; } summaryItemsList.appendChild(li);
             });
             isSavingSummary = false; saveSummaryBtn.disabled = false; saveSummaryBtn.innerHTML = '<i class="fas fa-save"></i> Sauvegarder & Fermer'; postWorkoutSummary.classList.add('visible');
        }

        function closeSummary() {
            if (!postWorkoutSummary) return; postWorkoutSummary.classList.remove('visible');
             if (currentState === 'finished') { console.log("Fermeture résumé, passage 'finished' -> 'idle'."); resetCurrentWorkout(); }
             if (workoutSection) workoutSection.classList.remove('finished-animation');
        }

        async function saveSummaryChanges() {
            if (isSavingSummary || !saveSummaryBtn || !summaryItemsList || !currentWorkoutType) { console.warn("Sauvegarde résumé en cours ou données manquantes."); return; }
            const workoutTypeToSave = currentWorkoutType;
            if (!googleAccessToken || !programFileIds[workoutTypeToSave]) { showMessage("Erreur: Non connecté ou ID fichier programme Drive manquant.", 5000); return; }
            isSavingSummary = true; saveSummaryBtn.disabled = true; saveSummaryBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sauvegarde...'; showMessage("Sauvegarde modifs programme...", 4000);
            const updatedProgram = JSON.parse(JSON.stringify(loadedWorkouts[workoutTypeToSave])); let changesMade = false;
             const summaryItems = summaryItemsList.querySelectorAll('.summary-item[data-index]');
             summaryItems.forEach(itemElement => {
                const index = parseInt(itemElement.dataset.index, 10); const programItemToUpdate = updatedProgram[index];
                 if (programItemToUpdate && programItemToUpdate.type === 'exercise') {
                     const repsInput = itemElement.querySelector(`#summary-reps-${index}`); const detailsInput = itemElement.querySelector(`#summary-details-${index}`); if (!repsInput || !detailsInput) { console.warn(`Inputs introuvables index ${index}.`); return; }
                     const newRepsRaw = repsInput.value.trim(); const newReps = newRepsRaw === '' ? null : parseInt(newRepsRaw, 10); const newDetails = detailsInput.value.trim();
                     if (newReps !== null && (isNaN(newReps) || newReps < 0)) { console.warn(`Reps invalides ('${newRepsRaw}') index ${index}. Modif ignorée.`); showMessage(`Reps invalides pour "${programItemToUpdate.name}". Non sauvegardé.`, 3000); }
                     else { if (programItemToUpdate.reps !== newReps || programItemToUpdate.details !== newDetails) { programItemToUpdate.reps = newReps; programItemToUpdate.details = newDetails; changesMade = true; console.log(`Modif ${workoutTypeToSave} index ${index}: reps=${newReps}, details=${newDetails}`); } }
                 }
             });
            if (!changesMade) { showMessage("Aucune modification détectée.", 2000); closeSummary(); }
            else {
                 loadedWorkouts[workoutTypeToSave] = updatedProgram;
                 try {
                     const newCsvContent = convertProgramToCsv(updatedProgram); const success = await updateFileContent(programFileIds[workoutTypeToSave], newCsvContent);
                     if (success) { showMessage(`Programme "${workoutTypeToSave}" mis à jour sur Drive !`, 3500); console.log(`Programme ${workoutTypeToSave} màj Drive.`); closeSummary(); }
                     else { showMessage(`Échec sauvegarde ${workoutTypeToSave} sur Drive.`, 5000); }
                 } catch (error) { console.error(`Erreur sauvegarde résumé ${workoutTypeToSave}:`, error); showMessage(`Erreur sauvegarde ${workoutTypeToSave}: ${error.message}`, 6000); }
             }
             saveSummaryBtn.innerHTML = '<i class="fas fa-save"></i> Sauvegarder & Fermer'; saveSummaryBtn.disabled = false; isSavingSummary = false;
         }

        // --- Initialisation ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Chargé. Initialisation ArmorWorkout.");
            // Assignation DOM (all checked for existence)
            timeLeftDisplay = document.getElementById('time-left'); timerCircle = document.getElementById('timer-circle'); totalProgressCircle = document.getElementById('total-progress-circle'); timerStateDisplay = document.getElementById('timer-state'); currentExerciseContainer = document.getElementById('current-exercise-container'); progressTracker = document.getElementById('progress-tracker'); startPauseBtn = document.getElementById('start-pause-btn'); skipBtn = document.getElementById('skip-btn'); finishBtn = document.getElementById('finish-btn'); resetBtn = document.getElementById('reset-btn'); navButtons = document.querySelectorAll('nav button[data-workout]'); navHistoryBtn = document.getElementById('nav-history'); themeToggleBtn = document.getElementById('theme-toggle-btn'); messageArea = document.getElementById('message-area'); workoutSection = document.getElementById('workout-section'); historySection = document.getElementById('history-section'); historyList = document.getElementById('history-list'); statsDisplay = document.getElementById('stats-display'); historyFilterBtns = document.querySelectorAll('.history-filters button'); historyChartCanvas = document.getElementById('history-chart-canvas'); signInButton = document.getElementById('signin-button'); signOutButton = document.getElementById('signout-button'); driveStatusElement = document.getElementById('drive-status'); exportProgramsBtn = document.getElementById('export-programs-btn'); postWorkoutSummary = document.getElementById('post-workout-summary'); summaryTitle = document.getElementById('summary-title'); summaryItemsList = document.getElementById('summary-items-list'); saveSummaryBtn = document.getElementById('save-summary-btn'); cancelSummaryBtn = document.getElementById('cancel-summary-btn'); historyDriveStatus = document.getElementById('history-drive-status'); currentExerciseNameDisplay = document.getElementById('current-exercise-name-display'); driveConnectionStatusMain = document.getElementById('drive-connection-status-main');

            // --- Init état & UI ---
            const savedTheme = localStorage.getItem('theme'); applyTheme((savedTheme === 'light' || savedTheme === 'dark') ? savedTheme : 'dark');
            workoutHistory = []; loadedWorkouts = JSON.parse(JSON.stringify(defaultWorkouts)); programsLoaded = false;
            updateAuthUI(false); setState('idle');

            // --- Event Listeners ---
            signInButton.addEventListener('click', handleAuthClick);
            signOutButton.addEventListener('click', () => handleSignoutClick(true));
            navButtons.forEach(button => button.addEventListener('click', () => loadWorkout(button.dataset.workout)));
            navHistoryBtn.addEventListener('click', () => { if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') { if (confirm("Entraînement en cours. Arrêter pour voir l'historique ?")) { resetCurrentWorkout(); setTimeout(() => showSection('history'), 100); } } else if (currentState === 'preparing') { showMessage("Attendre fin préparation.", 2500); } else { showSection('history'); } });
            startPauseBtn.addEventListener('click', () => { initAudioContext(); if (currentState === 'idle' && currentWorkoutPlan.length > 0 && currentWorkoutType) { workoutStartTime = Date.now(); elapsedWorkoutEstimatedSeconds = 0; setState('preparing'); } else if (currentState === 'exercise') { handleItemCompletion(false); } else if (currentState === 'break') { clearInterval(timerInterval); timerInterval = null; setState('paused'); } else if (currentState === 'paused') { if (currentWorkoutPlan[currentItemIndex]?.type === 'break') { setState('break'); } else { console.warn("Tentative reprise hors pause."); setState('exercise'); } } saveInProgressState(); });
            skipBtn.addEventListener('click', () => { initAudioContext(); if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') { showMessage("Passage étape suivante.", 1500); handleItemCompletion(false); } });
            finishBtn.addEventListener('click', () => { initAudioContext(); if (isWorkoutActive && !workoutFinished && currentState !== 'preparing') { forceFinishWorkout(); } });
            resetBtn.addEventListener('click', () => { initAudioContext(); if (currentWorkoutType || isWorkoutActive || workoutFinished) { if (confirm("Réinitialiser l'état actuel ?")) { resetCurrentWorkout(); } } else { showMessage("Aucun entraînement à réinitialiser.", 2000); resetCurrentWorkout(); } });
            themeToggleBtn.addEventListener('click', () => { initAudioContext(); applyTheme(currentTheme === 'dark' ? 'light' : 'dark'); });
            historyFilterBtns.forEach(button => button.addEventListener('click', () => displayHistory(button.dataset.period)));
            exportProgramsBtn.addEventListener('click', () => { initAudioContext(); exportProgramsToDrive(); });
            saveSummaryBtn.addEventListener('click', saveSummaryChanges);
            cancelSummaryBtn.addEventListener('click', closeSummary);

            console.log("Initialisation terminée. Attente Google Identity Services...");
        });
    </script>

    <!-- Chargement Asynchrone de Google Identity Services -->
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoadedCallback()"></script>

</body>
</html>
