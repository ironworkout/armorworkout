<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Évolution HPS (v7 Armor UI)</title>
    <!-- Font Awesome & Google Fonts -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        /* --- Variables CSS & Thèmes (Armor Energized Blue v7) --- */
        :root {
            /* Thème Sombre "Armor Blue" */
            --bg-color-dark: #050810;                     /* Bleu très sombre, presque noir */
            --secondary-bg-color-dark: #101528;           /* Bleu nuit pour les cartes */
            --primary-text-color-dark: #E8F0FF;           /* Cyan très pâle/Blanc cassé */
            --secondary-text-color-dark: #7080B0;         /* Gris bleuté moyen */
            --border-color-dark: #202848;                 /* Version + claire du fond secondaire */
            --accent-border-color-dark: #40E0FF80;        /* Cyan électrique transparent pour accents */
            --input-bg-dark: var(--bg-color-dark);        /* Fond des inputs = fond principal */

            /* Couleurs Énergie & Gradient */
            --neon-blue: #40E0FF;                         /* Cyan électrique vif principal */
            --neon-blue-darker: #00A8CC;                  /* Variante plus sombre pour nuances */
            --neon-purple: #7850FF;                       /* Violet bleuté pour début gradient */
            --gradient-start: var(--neon-purple);         /* Début gradient score/barres */
            --gradient-end: var(--neon-blue);             /* Fin gradient score/barres */
            --neon-green: #50FFAF;                        /* Vert Néon pour Succès/Positif */
            --neon-red: #FF5F77;                          /* Rouge Froid pour Erreur/Négatif */
            --neon-orange: #FFAC5F;                       /* Orange Néon pour Avertissement */
            --neon-yellow: #F0E050;                       /* Jaune pour Infos (moins utilisé) */

            /* Couleurs Niveaux (Inchangées, mais peuvent être adaptées si besoin) */
            --level-bronze-color: #cd7f32;   --level-bronze-bg: rgba(205, 127, 50, 0.1);
            --level-silver-color: #c0c0c0;   --level-silver-bg: rgba(192, 192, 192, 0.1);
            --level-gold-color: #ffd700;     --level-gold-bg: rgba(255, 215, 0, 0.1);
            --level-crystal-color: #a7d8de;  --level-crystal-bg: rgba(167, 216, 222, 0.1);
            --level-master-color: #e384f1;   --level-master-bg: rgba(227, 132, 241, 0.1);
            --level-champion-color: #ff7b72; --level-champion-bg: rgba(255, 123, 114, 0.1);
            --level-titan-color: #aa99ff;    --level-titan-bg: rgba(170, 153, 255, 0.1);
            --level-legende-color: #fff7a3;  --level-legende-bg: rgba(255, 247, 163, 0.15);
            --level-marvel-color: #e62429;   --level-marvel-bg: rgba(230, 36, 41, 0.1); /* Couleur spécifique Marvel */

            /* Lueurs (Glows) */
            --glow-gradient: 0 0 15px var(--neon-purple), 0 0 25px var(--neon-blue); /* Pour HPS */
            --glow-blue: 0 0 12px rgba(64, 224, 255, 0.7); /* Lueur cyan standard */
            --glow-level-reached: 0 0 15px var(--neon-green);
            --glow-connect: 0 0 10px var(--neon-green);
            --glow-disconnect: 0 0 10px var(--neon-red);
            --glow-marvel: 0 0 15px var(--level-marvel-color);

            /* Autres */
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius-lg: 16px; --border-radius-md: 10px; --border-radius-sm: 6px;
            --transition-speed: 0.25s; --transition-speed-fast: 0.15s;

            /* RGBA */
            --bg-color-dark-rgb: 5, 8, 16; --secondary-bg-color-dark-rgb: 16, 21, 40;
            --primary-text-color-dark-rgb: 232, 240, 255; --secondary-text-color-dark-rgb: 112, 128, 176;
            --border-color-dark-rgb: 32, 40, 72; --neon-blue-rgb: 64, 224, 255;
            --neon-purple-rgb: 120, 80, 255; --neon-green-rgb: 80, 255, 175; --neon-red-rgb: 255, 95, 119;
            --neon-orange-rgb: 255, 172, 95;

            /* Thème Actif */
            --bg-color: var(--bg-color-dark); --secondary-bg-color: var(--secondary-bg-color-dark); --primary-text-color: var(--primary-text-color-dark); --secondary-text-color: var(--secondary-text-color-dark); --border-color: var(--border-color-dark); --accent-border-color: var(--accent-border-color-dark); --input-bg: var(--input-bg-dark); --bg-color-rgb: var(--bg-color-dark-rgb); --secondary-bg-color-rgb: var(--secondary-bg-color-dark-rgb);

            /* Styles Spécifiques Armor Theme */
            --link-color: var(--neon-blue);
            --button-connect-color: var(--neon-green); --button-connect-glow: var(--glow-connect);
            --button-disconnect-color: var(--neon-red); --button-disconnect-glow: var(--glow-disconnect);
            /* Barres Progression */
            --progress-bar-bg: rgba(var(--primary-text-color-dark-rgb), 0.07);
            --progress-bar-fill: linear-gradient(90deg, var(--gradient-start), var(--gradient-end));
            /* Scrollbar */
            --scrollbar-track-bg: rgba(var(--secondary-bg-color-dark-rgb), 0.5);
            --scrollbar-thumb-bg: var(--accent-border-color-dark);
            --scrollbar-thumb-hover-bg: var(--neon-blue);
        }

        /* --- Styles CSS Généraux --- */
        * { box-sizing: border-box; margin: 0; padding: 0; scrollbar-color: var(--scrollbar-thumb-bg) var(--scrollbar-track-bg); scrollbar-width: thin; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            line-height: 1.6;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            display: flex; flex-direction: column; min-height: 100vh;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
            padding-top: 135px; /* Espace pour header fixe */
            position: relative; /* Pour le pseudo-élément animé */
        }
        /* Animation Fond Energie Subtile */
        body::before {
            content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at 70% 80%, rgba(var(--neon-blue-rgb), 0.05) 0%, transparent 50%),
                        radial-gradient(ellipse at 30% 20%, rgba(var(--neon-purple-rgb), 0.04) 0%, transparent 40%);
            background-blend-mode: screen;
            z-index: -1; pointer-events: none;
            animation: backgroundEnergyPulse 20s infinite alternate ease-in-out;
            opacity: 0.7;
        }
        @keyframes backgroundEnergyPulse {
            0% { transform: scale(1) rotate(0deg); opacity: 0.6; }
            50% { opacity: 0.9; }
            100% { transform: scale(1.1) rotate(10deg); opacity: 0.7; }
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb-bg); border-radius: 4px; border: 2px solid var(--scrollbar-track-bg); transition: background-color var(--transition-speed-fast); }
        ::-webkit-scrollbar-thumb:hover { background-color: var(--scrollbar-thumb-hover-bg); }
        .container { max-width: 450px; margin: 0 auto; padding: 20px 15px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }

        /* --- Header Armor --- */
        #app-header { background-color: rgba(5, 8, 16, 0.7); /* --bg-color-dark avec opacité */ backdrop-filter: blur(15px) saturate(120%); -webkit-backdrop-filter: blur(15px) saturate(120%); border-bottom: 1px solid rgba(var(--neon-blue-rgb), 0.2); }
        .header-content { gap: 5px; /* Réduire gap */ }
        .header-top-row { margin-bottom: 5px; }
        header .title-container i.header-icon { color: var(--neon-blue); text-shadow: 0 0 8px var(--neon-blue); animation: iconPulse 4s infinite ease-in-out; }
        @keyframes iconPulse { 50% { text-shadow: 0 0 12px var(--neon-blue), 0 0 4px var(--neon-blue); } }
        header h1 { font-weight: 700; text-shadow: 0 0 2px rgba(var(--primary-text-color-dark-rgb), 0.5); }
        .page-nav-buttons a button { border-color: var(--accent-border-color); background: rgba(var(--secondary-bg-color-dark-rgb), 0.4); padding: 5px 8px; }
        .page-nav-buttons a button:hover { border-color: var(--neon-blue); color: var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.15); box-shadow: inset 0 0 8px rgba(var(--neon-blue-rgb), 0.3); }
        .auth-controls button { border-color: var(--border-color); }
        #signin-button, #signin-button-prompt { border-color: var(--button-connect-color); }
        #signin-button:not(:disabled):hover, #signin-button-prompt:not(:disabled):hover { box-shadow: var(--button-connect-glow), inset 0 0 8px rgba(var(--neon-green-rgb), 0.2); background-color: rgba(var(--neon-green-rgb), 0.1); border-color: var(--neon-green); }
        #signout-button { border-color: var(--button-disconnect-color); }
        #signout-button:not(:disabled):hover { box-shadow: var(--button-disconnect-glow), inset 0 0 8px rgba(var(--neon-red-rgb), 0.2); background-color: rgba(var(--neon-red-rgb), 0.1); border-color: var(--neon-red); }
        #app-nav { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.7); border-top-color: rgba(var(--neon-blue-rgb), 0.2); }
        .nav-button:hover { background-color: rgba(var(--neon-blue-rgb), 0.1); color: var(--neon-blue); }
        .nav-button.active { border: 1px solid var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.15); box-shadow: var(--glow-blue), inset 0 0 10px rgba(var(--neon-blue-rgb), 0.2); }
        .nav-button:disabled { filter: grayscale(80%) opacity(0.5); }
        /* --- Fin Header Armor --- */

        /* Main & Prompt */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 20px; }
        #connection-prompt { border-color: var(--accent-border-color); background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5); backdrop-filter: blur(2px); }
        #connection-prompt button { background: var(--button-connect-color); color: var(--bg-color); border:none; box-shadow: var(--button-connect-glow); }
        #connection-prompt button:hover:not(:disabled) { background: var(--neon-green); filter: brightness(1.1); }

        /* --- Section Évolution (HPS Armor) --- */
        #evolution-tracker-area { display: flex; flex-direction: column; gap: 20px; }
        .global-stats-card {
             background: linear-gradient(145deg, rgba(var(--secondary-bg-color-dark-rgb), 0.8), rgba(var(--bg-color-dark-rgb), 0.9));
             border: 1px solid rgba(var(--neon-blue-rgb), 0.2);
             box-shadow: 0 15px 35px rgba(0,0,0, 0.3), inset 0 1px 0 rgba(var(--neon-blue-rgb), 0.1);
        }
        .global-stats-card::before { /* Supprimer ou modifier l'effet de rotation */ content: none; }
        .global-stats-card::after { /* Ajouter un motif subtil ? */
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background-image: linear-gradient(rgba(var(--neon-blue-rgb), 0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(var(--neon-blue-rgb), 0.03) 1px, transparent 1px);
            background-size: 20px 20px; opacity: 0.5; z-index: 0; pointer-events: none;
        }
        #overall-hps-display { position: relative; z-index: 1;}
        #overall-hps-display .value { animation: pulse-text 2s infinite ease-in-out; text-shadow: 0 0 10px rgba(var(--neon-purple-rgb), 0.5), 0 0 20px rgba(var(--neon-blue-rgb), 0.4); }
        @keyframes pulse-text { 50% { text-shadow: 0 0 15px rgba(var(--neon-purple-rgb), 0.6), 0 0 30px rgba(var(--neon-blue-rgb), 0.5); opacity: 0.95; } }
        #level-badge {
            background-color: rgba(var(--bg-color-dark-rgb), 0.5);
            border-width: 2px; /* Bordure plus épaisse */
            box-shadow: inset 0 0 8px rgba(var(--primary-text-color-dark-rgb), 0.1);
            padding: 8px 18px;
        }
        #level-badge:hover { transform: scale(1.05); box-shadow: 0 0 15px; /* Couleur mise via JS/CSS */ }
        .target-info-container strong { color: var(--neon-blue); }
        .target-info-container .marvel-target { color: var(--level-marvel-color); text-shadow: 0 0 5px var(--level-marvel-color); }
        #muscle-groups-container { }
        .muscle-group-card {
            background: linear-gradient(160deg, var(--secondary-bg-color), rgba(var(--bg-color-rgb), 0.8));
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 20px rgba(0,0,0, 0.25);
            transition: all var(--transition-speed-fast) ease-out;
        }
        .muscle-group-card:hover { border-color: var(--neon-blue); box-shadow: 0 10px 25px rgba(0,0,0, 0.3), 0 0 15px rgba(var(--neon-blue-rgb), 0.3); transform: translateY(-3px); }
        .muscle-group-card .icon-container { color: var(--neon-blue); opacity: 1; text-shadow: 0 0 6px var(--neon-blue); }
        .muscle-group-card .group-level-name {
            background-color: transparent; /* Fond transparent */
             border-width: 1px; /* Bordure fine colorée */
             box-shadow: 0 0 5px; /* Lueur de la couleur du niveau */
        }
        .muscle-level-progression::before { background: linear-gradient(90deg, rgba(var(--border-color-dark-rgb), 0.5) 0%, var(--border-color-dark) 50%, rgba(var(--border-color-dark-rgb), 0.5) 100%); }
        .level-indicator { border-width: 1px; }
        .level-indicator.current { border-width: 2px; transform: translate(-50%, -50%) scale(1.4); box-shadow: 0 0 15px; animation: currentIndicatorPulse 2s infinite; }
        @keyframes currentIndicatorPulse { 50% { box-shadow: 0 0 20px; } }
        .current-level-fill { background: linear-gradient(90deg, var(--neon-blue-darker), var(--neon-blue)); box-shadow: 0 0 8px var(--neon-blue); }
        /* Scan line animation pour la barre de pourcentage */
        .percentage-bar-container { position: relative; overflow: hidden; }
        .percentage-bar-fill::after {
            content: ''; position: absolute; top: 0; left: -20px; width: 10px; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            filter: blur(1px);
            animation: scanLine 2.5s linear infinite;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .percentage-bar-fill:not([style*="width: 0%;"])::after { opacity: 1; } /* Afficher si la barre n'est pas vide */
        @keyframes scanLine { 0% { left: -20px; } 100% { left: 100%; } }

        /* --- Section Config Équipement Armor --- */
        #program-config-area h2 { border-bottom-color: var(--neon-purple); }
        .program-config-section h3 { color: var(--neon-purple); border-bottom-color: rgba(var(--neon-purple-rgb), 0.3); }
        .config-exercise-item { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.5); border-color: var(--border-color); }
        .config-exercise-item .exercise-name { border-bottom-color: var(--accent-border-color); }
        .config-equipment-options label { border-color: var(--border-color); }
        .config-equipment-options label:hover { background-color: rgba(var(--neon-blue-rgb), 0.1); border-color: var(--neon-blue); }
        .config-equipment-options input[type="checkbox"] { filter: hue-rotate(180deg) brightness(1.5); /* Pour rendre le bleu cyan */ }
        #save-config-button { background: linear-gradient(90deg, var(--neon-blue-darker), var(--neon-blue)); text-shadow: 0 0 5px rgba(0,0,0,0.5); }
        #save-config-button:hover:not(:disabled) { box-shadow: 0 0 15px var(--neon-blue); filter: brightness(1.1); }
        #save-config-button.saving .spinner { color: var(--bg-color); }

        /* --- Section Historique Armor --- */
        #history-area h2 { border-bottom-color: var(--neon-green); }
        .history-controls select, .history-controls button { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.7); border-color: var(--accent-border-color); backdrop-filter: blur(2px); }
        .history-controls select:hover, .history-controls button:hover { border-color: var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); }
        .history-controls button.active { background-color: var(--neon-green); color: var(--bg-color); border-color: var(--neon-green); box-shadow: 0 0 8px var(--neon-green);}
        #history-display { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.6); border-color: var(--accent-border-color); }
        #history-display .trend-positive { text-shadow: 0 0 5px var(--neon-green); }
        #history-display .trend-negative { text-shadow: 0 0 5px var(--neon-red); }

        /* --- Modal Armor --- */
        .modal-overlay { background-color: rgba(var(--bg-color-dark-rgb), 0.7); }
        .modal-content { background-color: #0E1326; border-color: var(--accent-border-color); box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
        .modal-header { border-bottom-color: var(--accent-border-color); }
        .modal-close-btn:hover { color: var(--neon-red); }

        /* --- Footer, Messages, Placeholders --- */
        footer { border-top-color: rgba(var(--neon-blue-rgb), 0.1); }
        .message-area { backdrop-filter: blur(8px) saturate(120%); -webkit-backdrop-filter: blur(8px) saturate(120%); }
        .message-area.error { background-color: rgba(var(--neon-red-rgb), 0.8); border-color: var(--neon-red); text-shadow: 0 0 3px #000;}
        .message-area.success { background-color: rgba(var(--neon-green-rgb), 0.8); border-color: var(--neon-green); text-shadow: 0 0 3px #000; }
        .message-area.warning { background-color: rgba(var(--neon-orange-rgb), 0.8); border-color: var(--neon-orange); text-shadow: 0 0 3px #000; }
        .message-area.info { background-color: rgba(var(--neon-blue-rgb), 0.8); border-color: var(--neon-blue); text-shadow: 0 0 3px #000; }
        .loading-placeholder, .error-placeholder { background-color: rgba(var(--secondary-bg-color-dark-rgb), 0.6); border-color: var(--accent-border-color); backdrop-filter: blur(2px); }

        /* Responsive */
        @media (min-width: 768px) { .container { max-width: 600px; } }

    </style>
</head>
<body class="logged-out dark-theme">

<header id="app-header">
    <div class="header-content">
        <div class="header-top-row">
             <div class="title-container"> <i class="fas fa-shield header-icon"></i> <h1>ArmorWorkout</h1> </div>
             <div class="page-nav-buttons">
                 <a href="https://ironworkout.github.io/armorworkout/index.html" style="text-decoration: none;" title="Retour au Timer">
                     <button id="index-page-btn"><i class="fas fa-home"></i></button>
                 </a>
                 <a href="https://ironworkout.github.io/armorworkout/program-editor.html" style="text-decoration: none;" title="Aller à l'Éditeur de Programme">
                     <button id="program-editor-page-btn"><i class="fas fa-edit"></i></button>
                 </a>
             </div>
        </div>
        <div class="header-actions">
            <div class="auth-controls"> <button id="signin-button" disabled><i class="fab fa-google"></i> Connexion</button> <button id="signout-button" disabled><i class="fas fa-sign-out-alt"></i> Déconnexion</button> </div>
             <span id="drive-status" aria-live="polite"></span>
            <div class="theme-toggle"> <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button> </div>
        </div>
    </div>
    <nav id="app-nav">
        <button class="nav-button active" data-section="evolution-tracker-area" disabled><i class="fas fa-chart-line"></i> Évolution</button>
        <button class="nav-button" data-section="program-config-area" disabled><i class="fas fa-cogs"></i> Équipement</button>
        <button class="nav-button" data-section="history-area" disabled><i class="fas fa-history"></i> Historique</button>
    </nav>
</header>

<div class="container">
    <main>
        <div id="connection-prompt">
            <p>Connectez-vous via Google pour suivre votre potentiel d'hypertrophie et configurer votre équipement.</p>
            <button id="signin-button-prompt" disabled><i class="fab fa-google"></i> Se connecter</button>
        </div>

        <!-- Section Évolution (HPS) -->
        <div id="evolution-tracker-area" class="app-section" style="display: none;">
            <div class="global-stats-card">
                 <div class="card-title">Score HPS Global</div>
                 <div id="overall-hps-display"> <span class="value">--</span> </div>
                 <div id="level-badge-container" title="Cliquez pour voir la description du niveau">
                     <div id="level-badge" class="level-unknown" data-level-key="L1_Bronze">
                        <i class="fas fa-shield-halved"></i>
                        <span>Bronze</span>
                        <span class="sub-level"></span> <!-- Span pour sous-niveau -->
                     </div>
                     <!-- Icône Marvel ajoutée par JS si nécessaire -->
                 </div>
                 <div class="target-info-container">
                      <span id="target-hps-info">Objectif Niv. Suivant: <strong>-- HPS</strong></span>
                      <span id="marvel-target-info" style="display: none;"> | Benchmark <strong class="marvel-target">Marvel: -- HPS</strong></span>
                 </div>
            </div>
            <div id="muscle-groups-container" aria-live="polite">
                 <p class="loading-placeholder">Connectez-vous pour charger vos données...</p>
                 <!-- Cartes groupes musculaires ajoutées par JS -->
            </div>
        </div>

        <!-- Section Config Équipement -->
        <div id="program-config-area" class="app-section" style="display: none;">
             <h2><i class="fas fa-dumbbell"></i> Configuration Équipement Additionnel</h2>
             <div id="program-config-content">
                 <p class="loading-placeholder">Chargez vos programmes pour configurer...</p>
                 <!-- Contenu config ajouté par JS -->
             </div>
             <button id="save-config-button" disabled>
                 <span><i class="fas fa-save"></i> Sauvegarder Équipement</span>
                 <i class="fas fa-spinner fa-spin spinner"></i>
             </button>
        </div>

         <!-- Section Historique -->
         <div id="history-area" class="app-section" style="display: none;">
            <h2><i class="fas fa-history"></i> Historique HPS</h2>
            <div class="history-controls">
                <select id="history-muscle-group-select">
                    <option value="global">Global</option>
                    <!-- Options ajoutées par JS -->
                </select>
                <button data-period="week" class="history-period-btn active">7j</button>
                <button data-period="month" class="history-period-btn">30j</button>
                <button data-period="year" class="history-period-btn">1 an</button>
            </div>
            <div id="history-display">
                <p>Calcul de la tendance...</p>
                <!-- Tendance ajoutée par JS -->
            </div>
         </div>

    </main>
</div>

<footer>
     <p>© 2024 ArmorWorkout | <a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></p>
</footer>

<!-- Modal Détails Niveaux -->
<div id="level-info-modal" class="modal-overlay"> <div class="modal-content"> <div class="modal-header"> <h3 id="modal-title" class="modal-title"> <i id="modal-icon" class="fas fa-info-circle"></i> <span id="modal-level-name"></span> </h3> <button id="modal-close-btn" class="modal-close-btn">×</button> </div> <div id="modal-body" class="modal-body"> <!-- Contenu ajouté par JS --> </div> </div> </div>

<!-- Zone Message -->
<div id="message-area" class="message-area" role="status" aria-live="polite"></div>

<!-- Scripts -->
<script async defer src="https://accounts.google.com/gsi/client"></script>
<script>
    // --- CONFIGURATION & CONSTANTES GLOBALES ---
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const PROGRAM_FILENAMES = { Push: "armorworkout_push_program.json", Pull: "armorworkout_pull_program.json", Legs: "armorworkout_legs_program.json" };
    const EQUIPMENT_CONFIG_FILENAME = "armorworkout_exercise_config.json";
    const LOCALSTORAGE_HPS_VALUES_KEY = "armorHPS_lastValues_v7"; // Clé unique pour v7
    const LOCALSTORAGE_HPS_GLOBAL_KEY = "armorHPS_lastGlobal_v7"; // Clé unique pour v7
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const GIS_CHECK_INTERVAL = 100;
    const GIS_MAX_RETRIES = 50;

    // --- PARAMÈTRES HPS (v7) ---
    console.log("HPS Algorithm Version: v7 - Intermediate Levels + History Fix");
    const HPS_BASE = 0;
    const HP_REFERENCE_GLOBAL = 2500;
    const K_LOG = 500;
    const EXERCISE_EFFICACY = { 'Pompes (Push-ups)': 1.15, 'Band Standing Chest Press': 0.80, 'Band Floor Press': 0.70, 'Overhead Press (Haltères)': 1.05, 'New Overhead Press (Haltères)': 1.05, 'Dumbbell Lateral Raises': 1.05, 'Overhead Triceps Extension (Band)': 1.15, 'Band Bent-over Row': 1.1, 'Band Kneeling Lat Pulldown': 1.10, 'Band Face Pull': 1.05, 'Curl Marteau (Hammer Curl)': 0.9, 'Concentration Curl (Band)': 1.0, 'Front Squat Combo': 1.20, 'Fentes Arrière (Alternées)': 1.1, 'Calf Raises (sur livre/marche)': 0.9, 'Hollow Body Hold': 0.7, 'Band Sit-up': 0.9, 'Leg Raises (Relevé de jambes)': 0.85, 'DEFAULT': 1.0 };
    const EFFECTIVE_LOAD = { 'Bodyweight': 50, 'Poids de corps': 50, 'Élastique 15kg': 30, 'Élastique 25kg': 50, 'Élastique 25kg ': 50, 'Élastique 15kg doublé': 45, 'Élastique 15+25kg': 65, 'Élastique 15+25kg + 1 haltère 5kg': 70, 'Élastique 15+25kg + 2x5kg haltères': 75, 'Haltères 5kg': 10, '1 haltère 5kg': 5, 'DEFAULT': 10 };
    const AVAILABLE_EQUIPMENT_CONFIG = [ 'Élastique 15kg', 'Élastique 25kg', '1 haltère 5kg' ];
    const EFFORT_FACTORS = { MID: 1.0, TARGET_MET: 1.2 };
    const WEIGHTS_GLOBAL_HPS = { Pectoraux: 0.15, Dos: 0.20, Épaules: 0.12, Biceps: 0.08, Triceps: 0.08, Abdos: 0.15, Legs: 0.22 };
    const TARGET_LEVELS = { 'L1_Bronze':  { name: "Bronze",   minHPS: 1,   description: "Point de départ validé : un stimulus régulier est appliqué...", celebrity_example: "Débutant Sérieux", colorVar: '--level-bronze-color',   bgVar: '--level-bronze-bg',   iconClass: 'fa-shield-halved' }, 'L2_Silver':  { name: "Argent",   minHPS: 150, description: "Physique athlétique naissant...", celebrity_example: "Sportif Amateur", colorVar: '--level-silver-color',   bgVar: '--level-silver-bg',   iconClass: 'fa-shield' }, 'L3_Gold':    { name: "Or",       minHPS: 300, description: "Force confirmée et solide...", celebrity_example: "Ryan Reynolds (Deadpool)", colorVar: '--level-gold-color',     bgVar: '--level-gold-bg',     iconClass: 'fa-trophy' }, 'L_Marvel':   { name: "Marvel",   targetHPS: 550, description: "Benchmark : Esthétique équilibrée...", celebrity_example: "Chris Hemsworth (Thor)", colorVar: '--level-marvel-color', bgVar: '--level-marvel-bg', iconClass: 'fa-bolt-lightning' }, 'L4_Crystal': { name: "Crystal",  minHPS: 450, description: "Niveau avancé...", celebrity_example: "Michael B. Jordan (Creed)", colorVar: '--level-crystal-color',  bgVar: '--level-crystal-bg',  iconClass: 'fa-gem' }, 'L5_Master':  { name: "Master",   minHPS: 600, description: "Maîtrise physique...", celebrity_example: "Henry Cavill (Superman)", colorVar: '--level-master-color',   bgVar: '--level-master-bg',   iconClass: 'fa-chess-king' }, 'L6_Champion':{ name: "Champion", minHPS: 750, description: "Physique d'élite...", celebrity_example: "Dwayne Johnson (The Rock)", colorVar: '--level-champion-color', bgVar: '--level-champion-bg', iconClass: 'fa-crown' }, 'L7_Titan':   { name: "Titan",    minHPS: 900, description: "Force et masse colossales...", celebrity_example: "Hafþór Björnsson (The Mountain)", colorVar: '--level-titan-color',   bgVar: '--level-titan-bg',    iconClass: 'fa-mountain-sun' }, 'L8_Legende': { name: "Legende",  minHPS: 1100, description: "Statut quasi-mythique...", celebrity_example: "Arnold Schwarzenegger (Apogée)", colorVar: '--level-legende-color',  bgVar: '--level-legende-bg',  iconClass: 'fa-meteor' } };
    const LEVEL_ORDER = ['L1_Bronze', 'L2_Silver', 'L3_Gold', 'L4_Crystal', 'L5_Master', 'L6_Champion', 'L7_Titan', 'L8_Legende'];
    const MARVEL_BENCHMARK_KEY = 'L_Marvel';
    const NUM_SUB_LEVELS = 3;

    // --- Mapping Muscles V6 (inchangé) ---
    const MUSCLE_GROUPS_DISPLAY_CONFIG = { "Pectoraux": { subtitle: "Poitrine", icon: 'fa-dot-circle' }, "Dos": { subtitle: "Dorsaux/Trapèzes", icon: 'fa-bars-staggered' }, "Épaules":{ subtitle: "Deltoïdes", icon: 'fa-atom' }, "Biceps": { subtitle: "Bras (Flex.)", icon: 'fa-link' }, "Triceps": { subtitle: "Bras (Ext.)", icon: 'fa-diamond' }, "Abdos": { subtitle: "Abdominaux", icon: 'fa-grip-lines' }, "Legs": { subtitle: "Jambes/Mollets", icon: 'fa-shoe-prints'} };
    const LOGIC_TO_DISPLAY_MAP = { Pectoraux: "Pectoraux", Dos: "Dos", Épaules: "Épaules", Biceps: "Biceps", Triceps: "Triceps", Abdos: "Abdos", Legs: "Legs" };
    const ALL_MUSCLE_GROUPS_CALCULATED = Object.keys(LOGIC_TO_DISPLAY_MAP);
    const MUSCLE_GROUPS_FOR_GLOBAL_HPS = Object.keys(WEIGHTS_GLOBAL_HPS);

    // --- Éléments DOM ---
    let signInButton, signOutButton, driveStatusElement, themeToggleBtn, signInButtonPrompt, connectionPrompt, evolutionTrackerArea, overallHPSDisplayValue, levelBadgeContainer, levelBadge, levelBadgeIcon, levelBadgeText, targetHPSInfoStrong, marvelTargetInfoSpan, muscleGroupsContainer, messageArea, levelInfoModal, modalTitle, modalIcon, modalLevelName, modalBody, modalCloseBtn, appNav, navButtons, appSections, programConfigArea, programConfigContent, saveConfigButton, historyArea, historyMuscleGroupSelect, historyPeriodBtns, historyDisplay;

    // --- Variables d'État ---
    let googleAccessToken = null; let tokenClient = null; let programFileIds = { Push: null, Pull: null, Legs: null }; let equipmentConfigFileId = null; let loadedPrograms = { Push: [], Pull: [], Legs: [] }; let exerciseConfig = {}; let programsAnalysisStatus = 'pending'; let configLoadStatus = 'pending'; let currentHPSValues = {}; let previousHPSValues = {}; let overallAvgHPS = HPS_BASE; let currentGlobalLevelKey = LEVEL_ORDER[0]; let currentTheme = 'dark'; let messageTimeoutId = null; let gisCheckRetries = 0; let previousOverallAvgHPS = null; let currentHistoryMuscleGroup = 'global'; let currentHistoryPeriod = 'week'; let isSavingConfig = false;

    // --- Audio ---
    let audioContext = null; function initAudioContext() { if (!audioContext && typeof AudioContext !== 'undefined') { try { audioContext = new AudioContext(); } catch (e) { console.warn("AudioContext non supporté.", e); } } }
    function playSound(type = 'confirm', volume = 0.15) { /* ... (code audio inchangé) ... */ }

    // --- Google Identity Services & Drive API ---
    async function gisInitInternal() { try { tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CLIENT_ID, scope: GOOGLE_DRIVE_SCOPES, callback: tokenCallback, error_callback: handleTokenError, }); console.log("GIS Client init."); updateAuthUI(googleAccessToken !== null); } catch (error) { console.error("Erreur init GIS:", error); showMessage("Init Google impossible.", 5000, 'error'); if (signInButton) signInButton.disabled = true; if (signInButtonPrompt) signInButtonPrompt.disabled = true; } }
    function checkAndInitGis() { if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) { console.log("GIS prêt, init..."); gisInitInternal(); } else if (gisCheckRetries < GIS_MAX_RETRIES) { gisCheckRetries++; console.log(`GIS non prêt, retry ${gisCheckRetries}/${GIS_MAX_RETRIES}...`); setTimeout(checkAndInitGis, GIS_CHECK_INTERVAL); } else { console.error("Échec chargement GIS."); showMessage("Service Auth Google indispo.", 6000, 'error'); if (signInButton) signInButton.disabled = true; if (signInButtonPrompt) signInButtonPrompt.disabled = true;} }
    function handleTokenError(error) { console.error("Erreur Auth Google:", error); let msg = "Erreur connexion Google."; if (error?.type === 'popup_closed_by_user' || error?.error === 'user_cancel') msg = "Connexion annulée."; else if (error?.type === 'access_denied') msg = "Accès Drive refusé."; else if (error?.error === 'popup_blocked_by_browser') msg = "Popup connexion bloqué."; else if (error?.error === 'popup_failed_to_open') msg = "Échec ouverture Popup."; else if (error?.details) msg += ` Détails: ${error.details}`; showMessage(msg, 5000, 'error'); playSound('error'); googleAccessToken = null; updateAuthUI(false); resetProgressionDisplay(); resetConfigUI(); resetHistoryUI(); } // Ne reset plus previousHPSValues ici
    async function tokenCallback(tokenResponse) { if (tokenResponse.error) { handleTokenError(tokenResponse); return; } if (tokenResponse && tokenResponse.access_token) { console.log("Access Token reçu."); googleAccessToken = tokenResponse.access_token; loadPreviousHPSFromLocalStorage(); console.log("Valeurs HPS précédentes chargées depuis localStorage:", previousHPSValues, previousOverallAvgHPS); playSound('confirm'); showMessage("Connecté ! Chargement données...", 2500, 'info'); if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; if (programConfigContent) programConfigContent.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; if (historyDisplay) historyDisplay.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; resetProgressionDisplay(); try { const [programsStatus, configStatus] = await Promise.all([ loadProgramsFromDrive(), loadExerciseConfigFromDrive() ]); programsAnalysisStatus = programsStatus; configLoadStatus = configStatus; console.log("Statut chargement progs:", programsAnalysisStatus); console.log("Statut chargement config:", configLoadStatus); if (programsAnalysisStatus === 'error' || configLoadStatus === 'error' ) { showMessage("Erreur chargement données (progs/config). Vérifiez fichiers sur Drive.", 6000, 'error'); playSound('error'); } else if (programsAnalysisStatus === 'partial' || configLoadStatus === 'partial' ) { showMessage("Données partielles chargées (certains fichiers manquaient?).", 5000, 'warning'); } else { showMessage("Données chargées. Calcul potentiel hypertrophie...", 3000, 'success'); } calculateAndDisplayProgression(); renderProgramConfigUI(); renderHistoryUI(); } catch (error) { console.error("Erreur CRITIQUE chargement/analyse:", error); showMessage("Erreur majeure chargement.", 6000, 'error'); playSound('error'); programsAnalysisStatus = 'error'; configLoadStatus = 'error'; if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; if (programConfigContent) programConfigContent.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; if (historyDisplay) historyDisplay.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; resetProgressionDisplay(); } finally { updateAuthUI(true); } } else { handleTokenError({ error: "invalid_response", details: "Réponse Google invalide." }); } }
    function handleAuthClick() { initAudioContext(); if (tokenClient) { console.log("Demande token Google..."); showMessage("Ouverture connexion Google...", 2000, 'info'); tokenClient.requestAccessToken({ prompt: '' }); } else { console.error("Auth sans tokenClient."); showMessage("Erreur : Service connexion non prêt.", 4000, 'error'); checkAndInitGis(); } }
    function handleSignoutClick(showMessages = true) { const token = googleAccessToken; if (!token) { console.log("Déjà déconnecté."); updateAuthUI(false); return; } initAudioContext(); if (showMessages) showMessage("Déconnexion...", 1500, 'info'); google.accounts.oauth2.revoke(token, () => { console.log('Token Google révoqué.'); googleAccessToken = null; programFileIds = { Push: null, Pull: null, Legs: null }; equipmentConfigFileId = null; programsAnalysisStatus = 'pending'; configLoadStatus = 'pending'; loadedPrograms = { Push: [], Pull: [], Legs: [] }; exerciseConfig = {}; currentHPSValues = {}; previousHPSValues = {}; overallAvgHPS = HPS_BASE; currentGlobalLevelKey = LEVEL_ORDER[0]; previousOverallAvgHPS = null; clearHPSLocalStorage(); if (showMessages) { showMessage("Déconnecté.", 3000, 'info'); playSound('confirm'); } resetProgressionDisplay(); resetConfigUI(); resetHistoryUI(); updateAuthUI(false); }); }
    async function findFileId(filename) { if (!googleAccessToken) return null; console.log(`Recherche ID pour: ${filename}`); try { const r = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+trashed=false&spaces=drive&fields=files(id,name)`, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!r.ok) { if (r.status === 401 || r.status === 403) { console.warn(`Auth expirée (find ${filename}). Déco.`); handleSignoutClick(false); return null; } else { console.error(`Erreur Drive (find ${filename}): ${r.status} ${r.statusText}`); throw new Error(`Erreur Drive ${r.status}`); } } const d = await r.json(); if (d.files && d.files.length > 0) { console.log(`ID trouvé pour ${filename}: ${d.files[0].id}`); return d.files[0].id; } console.log(`Fichier ${filename} non trouvé sur Drive.`); return null; } catch (e) { console.error(`Erreur recherche ${filename}:`, e); return null; } }
    async function readFileContent(fileId) { if (!googleAccessToken || !fileId) return null; console.log(`Lecture contenu ID: ${fileId}`); try { const r = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!r.ok) { if (r.status === 401 || r.status === 403) { console.warn(`Auth expirée (read ${fileId}). Déco.`); handleSignoutClick(false); return null; } else if (r.status === 404) { console.warn(`Fichier ${fileId} non trouvé (404) lors lecture.`); return null; } else { console.error(`Erreur Drive (read ${fileId}): ${r.status} ${r.statusText}`); throw new Error(`Erreur Drive ${r.status}`); } } return await r.text(); } catch (e) { console.error(`Erreur lecture ${fileId}:`, e); return null; } }
    async function loadProgramsFromDrive() { if (!googleAccessToken) return 'error'; console.log("Chargement programmes Drive..."); let allOk = true, anyOk = false; const tmp = { Push: [], Pull: [], Legs: [] }; for (const type of PROGRAM_TYPES) { programFileIds[type] = await findFileId(PROGRAM_FILENAMES[type]); let fileOk = false; if (programFileIds[type]) { const content = await readFileContent(programFileIds[type]); if (content !== null) { try { const p = JSON.parse(content || '[]'); if (Array.isArray(p)) { tmp[type] = p; fileOk = true; anyOk = true; if (p.length === 0) console.warn(`Prog ${type} vide.`); } else { console.error(`Contenu ${type} non-Array.`); showMessage(`Format invalide ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning'); allOk = false; } } catch (e) { console.error(`Erreur parsing JSON ${type}:`, e); showMessage(`Erreur format JSON ${PROGRAM_FILENAMES[type]}.`, 4000, 'error'); playSound('error'); allOk = false; } } else { console.warn(`Lecture ${type} échouée.`); showMessage(`Impossible lire ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning'); allOk = false; } } else { console.warn(`Fichier ${PROGRAM_FILENAMES[type]} introuvable. Créez-le via l'éditeur ou le timer.`); showMessage(`Fichier programme ${type} manquant.`, 4000, 'warning'); allOk = false; } } loadedPrograms = tmp; console.log(`Fin chargement progs. Global: ${allOk}, Partiel: ${anyOk}`); if (allOk) return 'success'; if (anyOk) return 'partial'; return 'error'; }
    async function loadExerciseConfigFromDrive() { if (!googleAccessToken) return 'error'; console.log("Chargement config équipement..."); equipmentConfigFileId = await findFileId(EQUIPMENT_CONFIG_FILENAME); if (equipmentConfigFileId) { const content = await readFileContent(equipmentConfigFileId); if (content !== null) { try { const parsedConfig = JSON.parse(content || '{}'); exerciseConfig = typeof parsedConfig === 'object' && parsedConfig !== null ? parsedConfig : {}; console.log("Config équipement chargée depuis Drive:", exerciseConfig); return 'success'; } catch (e) { console.error("Erreur parsing JSON config:", e); showMessage("Erreur format JSON config équipement.", 4000, 'error'); playSound('error'); exerciseConfig = {}; return 'error'; } } else { console.warn("Lecture config échouée (contenu null)."); showMessage("Impossible lire config équipement (contenu null).", 4000, 'warning'); exerciseConfig = {}; return 'error'; } } else { console.warn(`Fichier config "${EQUIPMENT_CONFIG_FILENAME}" introuvable. Utilisation config vide.`); exerciseConfig = {}; return 'partial'; } }
    async function saveExerciseConfigToDrive() { if (!googleAccessToken || !saveConfigButton || isSavingConfig) return; console.log("Sauvegarde config équipement..."); isSavingConfig = true; saveConfigButton.disabled = true; saveConfigButton.classList.add('saving'); const currentConfig = {}; const checkboxes = programConfigContent.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(cb => { const exerciseName = cb.dataset.exerciseName; const equipmentName = cb.value; if (!exerciseName || !equipmentName) return; if (!currentConfig[exerciseName]) { currentConfig[exerciseName] = { added_equipment: [] }; } if (cb.checked) { currentConfig[exerciseName].added_equipment.push(equipmentName); } }); for (const exo in currentConfig) { if (currentConfig[exo].added_equipment.length === 0) { delete currentConfig[exo]; } } console.log("Config à sauvegarder:", currentConfig); const configJson = JSON.stringify(currentConfig, null, 2); try { let method = 'PATCH'; let url = `https://www.googleapis.com/upload/drive/v3/files/${equipmentConfigFileId}?uploadType=media`; let body = configJson; let headers = { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json; charset=UTF-8' }; if (!equipmentConfigFileId) { console.log("Aucun ID config, tentative création..."); method = 'POST'; url = 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart'; const metadata = { name: EQUIPMENT_CONFIG_FILENAME, mimeType: 'application/json' }; const form = new FormData(); form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json; charset=UTF-8' })); form.append('file', new Blob([configJson], { type: 'application/json; charset=UTF-8' })); body = form; headers = { 'Authorization': `Bearer ${googleAccessToken}` }; } const response = await fetch(url, { method: method, headers: headers, body: body }); if (!response.ok) { if (response.status === 401 || response.status === 403) { handleSignoutClick(false); } const errorBody = await response.text(); console.error("Erreur sauvegarde fichier:", response.status, errorBody); throw new Error(`Erreur Drive ${response.status} (${method === 'POST' ? 'Création' : 'MàJ'})`); } const result = await response.json(); if (method === 'POST' && result.id) { equipmentConfigFileId = result.id; console.log("Fichier config créé avec ID:", equipmentConfigFileId); } console.log("Config équipement sauvegardée sur Drive."); exerciseConfig = currentConfig; showMessage("Configuration équipement sauvegardée !", 3000, 'success'); playSound('confirm'); calculateAndDisplayProgression(); } catch (error) { console.error("Erreur sauvegarde config:", error); showMessage(`Erreur sauvegarde config: ${error.message}`, 5000, 'error'); playSound('error'); } finally { saveConfigButton.disabled = false; saveConfigButton.classList.remove('saving'); isSavingConfig = false; } }

    // --- Logique de Calcul HPS (v7) ---
    function getExerciseEfficacy(exerciseName) { if (!exerciseName) return EXERCISE_EFFICACY['DEFAULT'] || 1.0; if (EXERCISE_EFFICACY[exerciseName]) return EXERCISE_EFFICACY[exerciseName]; const cleanedName = exerciseName.replace(/\s*\([\s\S]*?\)\s*$/i, '').trim(); if (EXERCISE_EFFICACY[cleanedName]) return EXERCISE_EFFICACY[cleanedName]; return EXERCISE_EFFICACY['DEFAULT'] || 1.0; }
    function getEffectiveLoad(baseEquipment, addedEquipmentList) { let normalizedBase = baseEquipment ? baseEquipment.trim() : 'DEFAULT'; let baseLoad = EFFECTIVE_LOAD[normalizedBase] ?? EFFECTIVE_LOAD['DEFAULT'] ?? 0; let addedLoad = 0; if (addedEquipmentList && addedEquipmentList.length > 0) { addedEquipmentList.forEach(equipKey => { let normalizedAdd = equipKey ? equipKey.trim() : ''; addedLoad += EFFECTIVE_LOAD[normalizedAdd] ?? 0; }); } return baseLoad + addedLoad; }
    function getEffortFactor(step) { const isDuration = step.duration && parseInt(step.duration, 10) > 0; const currentValStr = isDuration ? step.duration : step.reps; const targetMaxStr = isDuration ? step.duration_target_max : step.reps_target_max; const currentVal = parseInt(currentValStr, 10); const targetMax = parseInt(targetMaxStr, 10); if (!isNaN(currentVal) && !isNaN(targetMax) && targetMax > 0 && currentVal >= targetMax) { return EFFORT_FACTORS.TARGET_MET; } return EFFORT_FACTORS.MID; }
    function calculateHPPerSet(step) { if (!step || step.type !== 'exercise') return 0; const isDurationBased = step.duration && parseInt(step.duration, 10) > 0; const currentValueStr = isDurationBased ? step.duration : step.reps; const currentValue = parseInt(currentValueStr, 10); if (isNaN(currentValue) || currentValue <= 0) { return 0; } const exerciseName = step.name; const baseEquipment = step.equipment; const configForThisExo = exerciseConfig[exerciseName]; const addedEquipment = configForThisExo?.added_equipment || []; const efficacy = getExerciseEfficacy(exerciseName); const effectiveLoad = getEffectiveLoad(baseEquipment, addedEquipment); const effortFactor = getEffortFactor(step); let volumeFactor = 0; if (isDurationBased) { volumeFactor = Math.sqrt(currentValue); } else { volumeFactor = currentValue; } if (efficacy <= 0 || effectiveLoad <= 0 || volumeFactor <= 0 || effortFactor <= 0) { return 0; } const hp = efficacy * effectiveLoad * volumeFactor * effortFactor; return hp; }
    function mapExerciseToMuscleGroup(name) { if (!name) return []; const cleanedName = name.replace(/\s*\([\s\S]*?\)\s*$/i, '').trim(); const l = cleanedName.toLowerCase(); if (l.includes('squat') || l.includes('fentes') || l.includes('calf raises') || l.includes('mollets')) return [ { group: 'Legs', weight: 1.0 } ]; if (l.includes('pompes') || l.includes('push up') || l.includes('floor press') || l.includes('chest press') || l.includes('écarté')) return [ { group: 'Pectoraux', weight: 0.60 }, { group: 'Triceps', weight: 0.25 }, { group: 'Épaules', weight: 0.15 } ]; if (l.includes('overhead press') || l.includes('développé militaire') || l.includes('shoulder press') || l.includes('new overhead press')) return [ { group: 'Épaules', weight: 0.65 }, { group: 'Triceps', weight: 0.30 }, { group: 'Pectoraux', weight: 0.05 } ]; if (l.includes('lateral raises') || l.includes('élévations latérales')) return [{ group: 'Épaules', weight: 1.0 }]; if (l.includes('overhead triceps extension') || l.includes('triceps extension')) return [{ group: 'Triceps', weight: 1.0 }]; if (l.includes('rowing') || l.includes('bent-over row') || l.includes('tirage horizontal')) return [ { group: 'Dos', weight: 0.65 }, { group: 'Biceps', weight: 0.20 }, { group: 'Épaules', weight: 0.15 } ]; if (l.includes('lat pulldown') || l.includes('tirage vertical') || l.includes('tractions') || l.includes('pull up') || l.includes('chin up')) return [ { group: 'Dos', weight: 0.70 }, { group: 'Biceps', weight: 0.25 }, { group: 'Épaules', weight: 0.05 } ]; if (l.includes('face pull')) return [ { group: 'Épaules', weight: 0.60 }, { group: 'Dos', weight: 0.40 } ]; if (l.includes('curl') || l.includes('biceps')) return [{ group: 'Biceps', weight: 1.0 }]; if (l.includes('hollow body') || l.includes('gainage') || l.includes('planche')) return [{ group: 'Abdos', weight: 1.0 }]; if (l.includes('sit-up') || l.includes('crunch') || l.includes('abdos')) return [{ group: 'Abdos', weight: 1.0 }]; if (l.includes('leg raises') || l.includes('relevé de jambes')) return [{ group: 'Abdos', weight: 1.0 }]; console.warn(`Mapping muscle PONDÉRÉ v6 non trouvé pour: "${name}" (nettoyé en "${cleanedName}"). Aucun HP attribué.`); return []; }
    function analyzeProgramsAndCalculateHPS() {
        console.log("Analyse programmes & calcul HPS (v7)...");
        // previousHPSValues & previousOverallAvgHPS sont chargés via loadPreviousHPSFromLocalStorage() avant cet appel
        const groupData = {};
        ALL_MUSCLE_GROUPS_CALCULATED.forEach(g => { groupData[g] = { totalHP: 0 }; });
        currentHPSValues = {}; // Reset pour ce calcul

        if (programsAnalysisStatus === 'error' || programsAnalysisStatus === 'pending' || configLoadStatus === 'error' || !loadedPrograms) {
            console.warn("Analyse HPS annulée - Données non prêtes.");
            ALL_MUSCLE_GROUPS_CALCULATED.forEach(g => { currentHPSValues[g] = HPS_BASE; });
            overallAvgHPS = HPS_BASE;
            saveCurrentHPSToLocalStorage();
            return;
        }
        console.log("Starting HP calculation loops...");

        PROGRAM_TYPES.forEach(type => {
            const program = loadedPrograms[type];
            if (!program || !Array.isArray(program) || program.length === 0) return;
            let currentBlock = { stepRef: null, setCount: 0 };
            function processCurrentBlock() {
                if (currentBlock.stepRef && currentBlock.setCount > 0) {
                    const hpPerSet = calculateHPPerSet(currentBlock.stepRef);
                    if (hpPerSet > 0) {
                        const muscleContributions = mapExerciseToMuscleGroup(currentBlock.stepRef.name);
                        if (muscleContributions.length > 0) {
                            muscleContributions.forEach(contribution => {
                                const groupName = contribution.group; const weight = contribution.weight;
                                if (groupData[groupName] && weight > 0) {
                                    const weightedHpContribution = hpPerSet * weight;
                                    groupData[groupName].totalHP += weightedHpContribution * currentBlock.setCount;
                                }
                            });
                        }
                    }
                }
                currentBlock = { stepRef: null, setCount: 0 };
            }
            program.forEach((step, index) => {
                 if (step.type === 'exercise' && step.name) {
                     const simpleName = step.name.split('(')[0].trim();
                     const blockSimpleName = currentBlock.stepRef?.name?.split('(')[0].trim();
                     if (simpleName === blockSimpleName && currentBlock.stepRef) {
                         currentBlock.setCount++;
                         currentBlock.stepRef = step;
                     } else {
                         processCurrentBlock();
                         currentBlock.stepRef = step;
                         currentBlock.setCount = 1;
                     }
                 } else {
                     processCurrentBlock();
                 }
                 if(index === program.length - 1) { processCurrentBlock(); }
             });
        });
        console.log("HP calculation loops finished. Finalizing scores...");

        let totalWeightedHPSOverall = 0; let totalWeightOverall = 0;
        console.log("Final groupData before HPS calculation:", JSON.parse(JSON.stringify(groupData)));

        ALL_MUSCLE_GROUPS_CALCULATED.forEach(g => {
            const totalHP = groupData[g]?.totalHP || 0; let hps = HPS_BASE;
            const referenceHP = HP_REFERENCE_GLOBAL; const kLogFactor = K_LOG;
            if (totalHP > 0 && referenceHP > 0 && kLogFactor > 0) {
                const ratioFactor = totalHP / referenceHP;
                hps = kLogFactor * Math.log10(1 + ratioFactor);
            }
            currentHPSValues[g] = Math.round(Math.max(0, hps));
            console.log(` -> HPS Calcul FINAL [${g}]: TotalHP=${totalHP.toFixed(1)}, HPS=${currentHPSValues[g]}`);
             if (MUSCLE_GROUPS_FOR_GLOBAL_HPS.includes(g)) {
                 const weight = WEIGHTS_GLOBAL_HPS[g] || 0;
                 if (weight > 0) {
                     totalWeightedHPSOverall += currentHPSValues[g] * weight;
                     totalWeightOverall += weight;
                 }
             }
        });
        overallAvgHPS = totalWeightOverall > 0 ? Math.round(totalWeightedHPSOverall / totalWeightOverall) : HPS_BASE;
        overallAvgHPS = Math.max(0, overallAvgHPS);
        console.log(`HPS Global V7: ${overallAvgHPS} (Préc localStorage: ${previousOverallAvgHPS ?? 'N/A'})`);
        console.log("HPS Groupes V7 Actuels:", currentHPSValues);
        console.log("HPS Groupes Précédents (avant ce calcul):", previousHPSValues);
        saveCurrentHPSToLocalStorage(); // Sauvegarde des nouvelles valeurs
    }
    function getHPSLevelKey(hpsScore) { for (let i = LEVEL_ORDER.length - 1; i >= 0; i--) { const key = LEVEL_ORDER[i]; if (TARGET_LEVELS[key] && hpsScore >= TARGET_LEVELS[key].minHPS) { return key; } } return LEVEL_ORDER[0]; }
    function getHPSLevelAndSubLevel(hpsScore) { const levelKey = getHPSLevelKey(hpsScore); const level = TARGET_LEVELS[levelKey]; const levelIndex = LEVEL_ORDER.indexOf(levelKey); let subLevelNumeral = ''; if (levelIndex < LEVEL_ORDER.length - 1) { const nextLevelKey = LEVEL_ORDER[levelIndex + 1]; const nextLevel = TARGET_LEVELS[nextLevelKey]; const minHPSCurrent = level.minHPS; const minHPSNext = nextLevel.minHPS; const range = minHPSNext - minHPSCurrent; if (range > 0) { const subLevelStep = range / NUM_SUB_LEVELS; const thresholdII = minHPSCurrent + subLevelStep; const thresholdIII = minHPSCurrent + 2 * subLevelStep; if (hpsScore >= thresholdIII) { subLevelNumeral = 'III'; } else if (hpsScore >= thresholdII) { subLevelNumeral = 'II'; } else { subLevelNumeral = 'I'; } } else { subLevelNumeral = 'I'; } } else { subLevelNumeral = ''; } return { levelKey, level, subLevelNumeral }; }

    // --- Logique Affichage ---
    function calculateAndDisplayProgression() { console.log("Mise à jour affichage progression (HPS V7 - SubLevels)..."); if (!evolutionTrackerArea || !overallHPSDisplayValue || !levelBadge || !targetHPSInfoStrong || !muscleGroupsContainer || !levelBadgeContainer || !marvelTargetInfoSpan) { console.error("DOM manquant affichage HPS."); if(muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p class="error-placeholder">Erreur interne: DOM affichage manquant.</p>'; return; } if (programsAnalysisStatus !== 'pending' && configLoadStatus !== 'pending') { analyzeProgramsAndCalculateHPS(); } else { console.log("Attente chargement pour calcul HPS."); overallAvgHPS = previousOverallAvgHPS ?? HPS_BASE; currentHPSValues = previousHPSValues ?? {}; } const oldGlobalLevelKey = currentGlobalLevelKey; const { levelKey: newGlobalLevelKey, level: currentGlobalLevel, subLevelNumeral: globalSubLevelNumeral } = getHPSLevelAndSubLevel(overallAvgHPS); currentGlobalLevelKey = newGlobalLevelKey; const currentGlobalLevelIndex = LEVEL_ORDER.indexOf(currentGlobalLevelKey); const nextGlobalLevelKey = currentGlobalLevelIndex < LEVEL_ORDER.length - 1 ? LEVEL_ORDER[currentGlobalLevelIndex + 1] : null; const nextGlobalLevel = nextGlobalLevelKey ? TARGET_LEVELS[nextGlobalLevelKey] : null; const marvelBenchmark = TARGET_LEVELS[MARVEL_BENCHMARK_KEY]; const currentDisplayedHPS = parseFloat(overallHPSDisplayValue.textContent.replace(/[^0-9.]/g, '')) || HPS_BASE; animateValue(overallHPSDisplayValue, currentDisplayedHPS, overallAvgHPS, 700); levelBadgeIcon.className = `fas ${currentGlobalLevel.iconClass}`; levelBadgeText.innerHTML = `${currentGlobalLevel.name} <span class="sub-level">${globalSubLevelNumeral}</span>`; levelBadge.style.color = `var(${currentGlobalLevel.colorVar})`; levelBadge.style.backgroundColor = `var(${currentGlobalLevel.bgVar})`; levelBadge.style.borderColor = `var(${currentGlobalLevel.colorVar})`; levelBadge.setAttribute('data-level-key', currentGlobalLevelKey); targetHPSInfoStrong.textContent = nextGlobalLevel ? `${nextGlobalLevel.minHPS} HPS` : "MAX"; if (marvelBenchmark) { marvelTargetInfoSpan.innerHTML = ` | Benchmark <strong class="marvel-target">Marvel: ${marvelBenchmark.targetHPS} HPS</strong>`; marvelTargetInfoSpan.style.display = 'inline-block'; const isMarvelAchieved = overallAvgHPS >= marvelBenchmark.targetHPS; const existingMarvelIcon = document.getElementById('marvel-icon'); if (isMarvelAchieved) { if (!existingMarvelIcon) { const mI = document.createElement('i'); mI.id = 'marvel-icon'; mI.className = `fas ${marvelBenchmark.iconClass} marvel-achieved-icon`; mI.setAttribute('title', `Benchmark "${marvelBenchmark.name}" (${marvelBenchmark.targetHPS} HPS) atteint !`); levelBadgeContainer.appendChild(mI); } } else { if (existingMarvelIcon) existingMarvelIcon.remove(); } } else { marvelTargetInfoSpan.style.display = 'none'; } if (previousOverallAvgHPS !== null && currentGlobalLevelKey !== oldGlobalLevelKey) { const currentLevelThreshold = TARGET_LEVELS[currentGlobalLevelKey].minHPS; if (overallAvgHPS >= currentLevelThreshold && previousOverallAvgHPS < currentLevelThreshold) { console.log(`NIVEAU GLOBAL ATTEINT ! ${oldGlobalLevelKey} -> ${currentGlobalLevelKey}`); showMessage(`Félicitations ! Niveau Global ${currentGlobalLevel.name} atteint !`, 5000, 'success'); playSound('level_up', 0.2); const card = document.querySelector('.global-stats-card'); if (card) { card.style.animation = 'levelUpGlow 1.5s ease-out'; setTimeout(() => { card.style.animation = ''; }, 1500); } } } muscleGroupsContainer.innerHTML = ''; let hasData = false; const displayOrder = ["Pectoraux", "Dos", "Épaules", "Biceps", "Triceps", "Legs", "Abdos"]; displayOrder.forEach(displayGroup => { const logicGroup = ALL_MUSCLE_GROUPS_CALCULATED.find(key => LOGIC_TO_DISPLAY_MAP[key] === displayGroup); if (!logicGroup || currentHPSValues[logicGroup] === undefined || !MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup]) { console.warn(`Données manquantes ou config pour groupe affiché: ${displayGroup} (logique: ${logicGroup})`); return; } hasData = true; const config = MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup]; const currentHPS = currentHPSValues[logicGroup]; const { levelKey: muscleLevelKey, level: muscleLevel, subLevelNumeral: muscleSubLevelNumeral } = getHPSLevelAndSubLevel(currentHPS); const muscleLevelIndex = LEVEL_ORDER.indexOf(muscleLevelKey); const nextMuscleLevelKey = muscleLevelIndex < LEVEL_ORDER.length - 1 ? LEVEL_ORDER[muscleLevelIndex + 1] : null; const nextMuscleLevel = nextMuscleLevelKey ? TARGET_LEVELS[nextMuscleLevelKey] : null; const minHPSCurrent = muscleLevel.minHPS; const minHPSNext = nextMuscleLevel ? nextMuscleLevel.minHPS : minHPSCurrent; const range = minHPSNext - minHPSCurrent; let progress = 0; if (range > 0) { progress = ((currentHPS - minHPSCurrent) / range) * 100; } else if (currentHPS >= minHPSCurrent) { progress = 100; } const displayPercent = Math.max(0, Math.min(100, Math.round(progress))); const targetDisplay = nextMuscleLevel ? minHPSNext : "MAX"; const card = renderMuscleGroupCard( logicGroup, displayGroup, config.subtitle, config.icon, currentHPS, targetDisplay, displayPercent, muscleLevelKey, muscleLevel.name, muscleSubLevelNumeral, muscleLevel.colorVar, muscleLevel.bgVar ); muscleGroupsContainer.appendChild(card); }); if (!hasData && (programsAnalysisStatus !== 'pending' || configLoadStatus !== 'pending')) { const msg = (programsAnalysisStatus === 'error' || configLoadStatus === 'error') ? 'Erreur chargement données.' : 'Aucune donnée progression.'; muscleGroupsContainer.innerHTML = `<p class="${(programsAnalysisStatus === 'error' || configLoadStatus === 'error') ? 'error' : 'loading'}-placeholder">${msg}</p>`; } console.log("Affichage progression V7 mis à jour."); }
    function renderMuscleGroupCard(logicGroupKey, title, subtitle, iconClass, currentHPS, targetHPSNextMin, displayPercent, currentLevelKey, currentLevelName, currentSubLevelNumeral, currentLevelColorVar, currentLevelBgVar ) { const card = document.createElement('div'); card.className = 'muscle-group-card'; card.setAttribute('title', `${title} (${subtitle}) - Niveau: ${currentLevelName} ${currentSubLevelNumeral} - HPS: ${currentHPS} / ${targetHPSNextMin}. Progression: ${displayPercent}%.`); let levelProgressionHtml = '<div class="muscle-level-progression">'; let currentLevelFillWidth = '0%'; let currentLevelPosition = 0; LEVEL_ORDER.forEach((levelKey, index) => { const level = TARGET_LEVELS[levelKey]; if (!level) return; const basePosition = (index / (LEVEL_ORDER.length -1)) * 100; const adjustedPosition = 5 + (basePosition * 0.9); let indicatorClass = 'level-indicator'; let indicatorStyle = `left: ${adjustedPosition}%; border-color: var(${level.colorVar});`; let boxShadowStyle = `box-shadow: 0 0 10px var(${level.colorVar});`; if (levelKey === currentLevelKey) { indicatorClass += ' current'; indicatorStyle += boxShadowStyle; currentLevelPosition = adjustedPosition; const nextLevelIndex = index + 1; let endPos = 100; if (nextLevelIndex < LEVEL_ORDER.length) { const nextBasePos = (nextLevelIndex / (LEVEL_ORDER.length -1)) * 100; endPos = 5 + (nextBasePos * 0.9); } const segmentWidthPercent = endPos - currentLevelPosition; const fillWidthFromStart = currentLevelPosition + (segmentWidthPercent * (displayPercent / 100)); currentLevelFillWidth = `${fillWidthFromStart}%`; } levelProgressionHtml += `<div class="${indicatorClass}" style="${indicatorStyle}" data-level-key="${levelKey}" title="${level.name} (Min: ${level.minHPS} HPS)"><i class="fas ${level.iconClass}"></i></div>`; }); levelProgressionHtml = `<div class="current-level-fill" style="width: ${currentLevelFillWidth}; background-color: var(${currentLevelColorVar}); left: 0;"></div>` + levelProgressionHtml; levelProgressionHtml += '</div>'; const percentageBarHtml = ` <div class="percentage-progress-section"> <div class="percentage-bar-container" title="Progression vers ${targetHPSNextMin} HPS: ${displayPercent}%"> <div class="percentage-bar-fill" style="width: 0%;"></div> </div> <span class="percentage-value-text">${displayPercent}%</span> </div>`; card.innerHTML = ` <div class="card-header"> <div class="icon-container"><i class="fas ${iconClass}" aria-hidden="true"></i></div> <div class="title-container"> <div class="group-title">${title}</div> <div class="group-subtitle">${subtitle}</div> <div class="group-level-name" style="color: var(${currentLevelColorVar}); background-color: var(${currentLevelBgVar}); border-color: var(${currentLevelColorVar});"> ${currentLevelName} <span class="sub-level">${currentSubLevelNumeral}</span> </div> </div> <div class="hps-details" title="HPS Actuel / Seuil HPS Niveau Suivant"> <span class="current">${currentHPS}</span> / <span class="target">${targetHPSNextMin}</span> </div> </div> ${levelProgressionHtml} ${percentageBarHtml} `; requestAnimationFrame(() => { setTimeout(() => { const pbFill = card.querySelector('.percentage-bar-fill'); if (pbFill) { pbFill.style.width = `${displayPercent}%`; } }, 50); }); const indicators = card.querySelectorAll('.level-indicator'); indicators.forEach(indicator => { indicator.addEventListener('click', (e) => { e.stopPropagation(); const key = indicator.getAttribute('data-level-key'); if (key) openLevelInfoModal(key, title); }); }); return card; }
    function resetProgressionDisplay() { console.log("Réinitialisation affichage HPS..."); if (muscleGroupsContainer) { muscleGroupsContainer.innerHTML = `<p class="loading-placeholder">${googleAccessToken ? 'Analyse...' : 'Connectez-vous...'}</p>`; } if (overallHPSDisplayValue) overallHPSDisplayValue.textContent = '--'; const firstLevelKey = LEVEL_ORDER[0]; const baseLevel = TARGET_LEVELS[firstLevelKey]; if (levelBadge && baseLevel) { levelBadgeIcon.className = `fas ${baseLevel.iconClass}`; levelBadgeText.innerHTML = `${baseLevel.name}`; levelBadge.style.color = `var(${baseLevel.colorVar})`; levelBadge.style.backgroundColor = `var(${baseLevel.bgVar})`; levelBadge.style.borderColor = `var(${baseLevel.colorVar})`; levelBadge.setAttribute('data-level-key', firstLevelKey); } const secondLevelKey = LEVEL_ORDER.length > 1 ? LEVEL_ORDER[1] : null; const firstRealLevel = secondLevelKey ? TARGET_LEVELS[secondLevelKey] : null; if (targetHPSInfoStrong) targetHPSInfoStrong.textContent = firstRealLevel ? `${firstRealLevel.minHPS} HPS` : '-- HPS'; const marvelBenchmark = TARGET_LEVELS[MARVEL_BENCHMARK_KEY]; if (marvelTargetInfoSpan && marvelBenchmark) { marvelTargetInfoSpan.innerHTML = ` | Benchmark <strong class="marvel-target">Marvel: ${marvelBenchmark.targetHPS} HPS</strong>`; marvelTargetInfoSpan.style.display = 'inline-block'; } else if (marvelTargetInfoSpan) { marvelTargetInfoSpan.style.display = 'none'; } const existingMarvelIcon = document.getElementById('marvel-icon'); if (existingMarvelIcon) { existingMarvelIcon.remove(); } currentGlobalLevelKey = LEVEL_ORDER[0]; /* Ne reset pas HPS values ici */ }

    // --- Rendu UI Config Équipement ---
    function renderProgramConfigUI() { if (!programConfigContent) return; if (programsAnalysisStatus === 'pending' || programsAnalysisStatus === 'error') { programConfigContent.innerHTML = '<p class="loading-placeholder">Chargez d\'abord vos programmes.</p>'; if(saveConfigButton) saveConfigButton.disabled = true; return; } let html = ''; const uniqueExercises = new Set(); PROGRAM_TYPES.forEach(type => { const program = loadedPrograms[type]; if (program && program.length > 0) { program.forEach(step => { if (step.type === 'exercise' && step.name) { uniqueExercises.add(step.name); } }); } }); if (uniqueExercises.size === 0) { programConfigContent.innerHTML = '<p class="loading-placeholder">Aucun exercice trouvé dans les programmes.</p>'; if(saveConfigButton) saveConfigButton.disabled = true; return; } html += `<div class="program-config-section"><h3>Équipement Additionnel par Exercice</h3>`; [...uniqueExercises].sort().forEach(exerciseName => { html += `<div class="config-exercise-item"><span class="exercise-name">${exerciseName}</span><div class="config-equipment-options">`; AVAILABLE_EQUIPMENT_CONFIG.forEach(equipKey => { const isChecked = exerciseConfig[exerciseName]?.added_equipment?.includes(equipKey) || false; html += `<label><input type="checkbox" value="${equipKey}" data-exercise-name="${exerciseName}" ${isChecked ? 'checked' : ''}> ${equipKey}</label>`; }); html += `</div></div>`; }); html += `</div>`; if(saveConfigButton) saveConfigButton.disabled = !googleAccessToken; programConfigContent.innerHTML = html; }
    function resetConfigUI() { if (programConfigContent) { programConfigContent.innerHTML = '<p class="loading-placeholder">Connectez-vous.</p>'; } if(saveConfigButton) saveConfigButton.disabled = true; exerciseConfig = {}; }

    // --- Logique Historique (Utilise previousHPSValues chargé depuis localStorage) ---
    function renderHistoryUI() { if (!historyMuscleGroupSelect || !historyDisplay) return; historyMuscleGroupSelect.innerHTML = '<option value="global">Global</option>'; const displayOrder = ["Pectoraux", "Dos", "Épaules", "Biceps", "Triceps", "Legs", "Abdos"]; displayOrder.forEach(displayGroup => { const logicGroup = ALL_MUSCLE_GROUPS_CALCULATED.find(key => LOGIC_TO_DISPLAY_MAP[key] === displayGroup); if (logicGroup && MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup]) { const option = document.createElement('option'); option.value = logicGroup; option.textContent = MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup].subtitle || displayGroup; historyMuscleGroupSelect.appendChild(option); } }); historyMuscleGroupSelect.value = currentHistoryMuscleGroup; historyPeriodBtns.forEach(btn => { btn.classList.toggle('active', btn.dataset.period === currentHistoryPeriod); }); displayHistoryTrend(); }
    function displayHistoryTrend() { if (!historyDisplay) return; console.log(`Affichage historique V7 pour: ${currentHistoryMuscleGroup}, Période: ${currentHistoryPeriod}`); const muscleName = currentHistoryMuscleGroup === 'global' ? 'Global' : (MUSCLE_GROUPS_DISPLAY_CONFIG[currentHistoryMuscleGroup]?.subtitle || currentHistoryMuscleGroup); let periodText = 'depuis dernier calcul'; const currentVal = currentHistoryMuscleGroup === 'global' ? overallAvgHPS : currentHPSValues[currentHistoryMuscleGroup]; const previousVal = currentHistoryMuscleGroup === 'global' ? previousOverallAvgHPS : previousHPSValues[currentHistoryMuscleGroup]; if (previousVal === undefined || previousVal === null || currentVal === undefined) { historyDisplay.innerHTML = `<p>Tendance HPS pour <strong>${muscleName}</strong> (${periodText}) :</p><p style="margin-top: 10px;"><span class="trend-value trend-neutral">N/A</span></p><p style="font-size: 0.8em; margin-top: 15px;">(Calcul initial ou pas de données précédentes)</p>`; return; } const diffAbs = currentVal - previousVal; const diffPerc = previousVal !== 0 ? (diffAbs / previousVal) * 100 : (currentVal > 0 ? Infinity : 0); const trendClass = diffAbs > 0.5 ? 'trend-positive' : (diffAbs < -0.5 ? 'trend-negative' : 'trend-neutral'); const sign = diffAbs > 0.5 ? '+' : ''; const formattedDiffPerc = diffPerc === Infinity ? '∞' : diffPerc.toFixed(1); historyDisplay.innerHTML = ` <p>Tendance HPS pour <strong>${muscleName}</strong> (${periodText}) :</p> <p style="margin-top: 10px;"> <span class="trend-value ${trendClass}">${sign}${diffAbs.toFixed(0)} HPS</span> ${previousVal !== 0 ? `(<span class="trend-value ${trendClass}">${sign}${formattedDiffPerc}%</span>)` : ''} </p> <p style="font-size: 0.8em; margin-top: 15px;">(${previousVal ?? 'N/A'} HPS -> ${currentVal} HPS)</p> `; }
    function handleHistorySelectionChange() { currentHistoryMuscleGroup = historyMuscleGroupSelect.value; displayHistoryTrend(); }
    function handleHistoryPeriodChange(event) { const targetButton = event.target.closest('.history-period-btn'); if (!targetButton) return; currentHistoryPeriod = targetButton.dataset.period; historyPeriodBtns.forEach(btn => btn.classList.remove('active')); targetButton.classList.add('active'); displayHistoryTrend(); }
    function resetHistoryUI() { if(historyDisplay) historyDisplay.innerHTML = '<p>Connectez-vous pour voir l\'historique.</p>'; if(historyMuscleGroupSelect) historyMuscleGroupSelect.innerHTML = '<option value="global">Global</option>'; currentHistoryMuscleGroup = 'global'; currentHistoryPeriod = 'week'; if(historyPeriodBtns) historyPeriodBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.period === currentHistoryPeriod)); }

    // --- Fonctions Modal ---
    function getMuscleSpecificContext(levelKey, muscleGroup) { const levelName = TARGET_LEVELS[levelKey]?.name || 'ce niveau'; switch (muscleGroup) { case 'Pectoraux': return `Pour les pectoraux...`; case 'Dos': return `Pour le dos...`; case 'Épaules': return `Pour les épaules...`; case 'Biceps': return `Pour les biceps...`; case 'Triceps': return `Pour les triceps...`; case 'Legs': return `Pour les jambes...`; case 'Abdos': return `Pour les abdominaux...`; default: return ''; } } // Descriptions complètes omises pour brièveté
    function openLevelInfoModal(levelKey, muscleGroupName = null) { if (!levelInfoModal || !TARGET_LEVELS[levelKey]) return; const levelData = TARGET_LEVELS[levelKey]; modalIcon.className = `fas ${levelData.iconClass}`; modalLevelName.textContent = levelData.name; let bodyHtml = `<p>${levelData.description?.replace(/\n/g, '<br>') || '...'}</p>`; if (muscleGroupName) { const context = getMuscleSpecificContext(levelKey, muscleGroupName); if (context) { bodyHtml += `<p class="muscle-context">${context}</p>`; } } if(levelData.minHPS !== undefined) { bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Seuil HPS Minimum : <strong>${levelData.minHPS}</strong></p>`; } else if (levelData.targetHPS !== undefined) { bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Objectif HPS Benchmark : <strong>${levelData.targetHPS}</strong></p>`; } bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Exemple Physique: <i>${levelData.celebrity_example || 'N/A'}</i></p>`; modalBody.innerHTML = bodyHtml; modalTitle.style.color = `var(${levelData.colorVar})`; levelInfoModal.classList.add('visible'); }
    function closeLevelInfoModal() { if (levelInfoModal) levelInfoModal.classList.remove('visible'); }

    // --- Persistance Historique HPS (localStorage) ---
    function saveCurrentHPSToLocalStorage() { try { localStorage.setItem(LOCALSTORAGE_HPS_VALUES_KEY, JSON.stringify(currentHPSValues)); localStorage.setItem(LOCALSTORAGE_HPS_GLOBAL_KEY, overallAvgHPS.toString()); console.log("Scores HPS actuels sauvegardés dans localStorage."); } catch (e) { console.warn("Erreur sauvegarde HPS dans localStorage:", e); } }
    function loadPreviousHPSFromLocalStorage() { try { const savedValues = localStorage.getItem(LOCALSTORAGE_HPS_VALUES_KEY); const savedGlobal = localStorage.getItem(LOCALSTORAGE_HPS_GLOBAL_KEY); previousHPSValues = savedValues ? JSON.parse(savedValues) : {}; previousOverallAvgHPS = savedGlobal ? parseFloat(savedGlobal) : null; if(isNaN(previousOverallAvgHPS)) previousOverallAvgHPS = null; } catch (e) { console.error("Erreur lecture HPS depuis localStorage:", e); previousHPSValues = {}; previousOverallAvgHPS = null; } }
    function clearHPSLocalStorage() { try { localStorage.removeItem(LOCALSTORAGE_HPS_VALUES_KEY); localStorage.removeItem(LOCALSTORAGE_HPS_GLOBAL_KEY); console.log("Scores HPS supprimés de localStorage."); } catch (e) { console.warn("Erreur suppression HPS de localStorage:", e); } }

    // --- Animation & UI Update & Thème & Message ---
    function animateValue(el, start, end, duration) { if (!el) return; const fixedEnd = Math.round(end); const fixedStart = Math.round(start); if (fixedStart === fixedEnd) { el.textContent = fixedEnd; return; } const range = fixedEnd - fixedStart; if (range === 0) { el.textContent = fixedEnd; return; } let current = fixedStart; const increment = fixedEnd > fixedStart ? 1 : -1; const stepTime = Math.max(1, Math.min(50, Math.abs(Math.floor(duration / range)))); const timer = setInterval(() => { current += increment * Math.max(1, Math.round(Math.abs(fixedEnd - current) / 10)); if ((increment > 0 && current >= fixedEnd) || (increment < 0 && current <= fixedEnd)) { current = fixedEnd; clearInterval(timer); } el.textContent = current; }, stepTime); }
    function updateAuthUI(isLoggedIn) { console.log(`Update UI - Connecté: ${isLoggedIn}, GIS prêt: ${!!tokenClient}`); const b = document.body; b.classList.toggle('logged-in', isLoggedIn); b.classList.toggle('logged-out', !isLoggedIn); if(signInButton) signInButton.disabled = isLoggedIn || !tokenClient; if(signInButtonPrompt) signInButtonPrompt.disabled = isLoggedIn || !tokenClient; if(signOutButton) signOutButton.disabled = !isLoggedIn; if(themeToggleBtn) themeToggleBtn.disabled = false; if (connectionPrompt) connectionPrompt.style.display = isLoggedIn ? 'none' : 'block'; navButtons.forEach(btn => { btn.disabled = !isLoggedIn; if (isLoggedIn) { btn.style.display = 'inline-flex'; } else { btn.style.display = 'none'; }}); if (isLoggedIn) { switchTab(document.querySelector('.nav-button.active')?.dataset.section || 'evolution-tracker-area'); } else { appSections.forEach(sec => sec.style.display = 'none'); } if (!isLoggedIn) { programsAnalysisStatus = 'pending'; configLoadStatus = 'pending'; resetProgressionDisplay(); resetConfigUI(); resetHistoryUI(); } }
    function applyTheme(theme) { document.body.classList.remove('light-theme', 'dark-theme'); document.body.classList.add(theme + '-theme'); currentTheme = theme; localStorage.setItem('armorWorkoutTheme', theme); if (themeToggleBtn) { const i = themeToggleBtn.querySelector('i'); if (i) i.className = `fas fa-${theme === 'dark' ? 'sun' : 'moon'}`; themeToggleBtn.setAttribute('aria-label', `Passer au thème ${theme === 'dark' ? 'clair' : 'sombre'}`); } console.log(`Thème appliqué: ${theme}`); }
    function toggleTheme() { showMessage("Thème clair non disponible.", 2000, 'info'); playSound('confirm'); } function loadSavedTheme() { applyTheme('dark'); }
    function showMessage(msg, duration = 3000, type = 'info') { if (!messageArea) return; messageArea.textContent = msg; messageArea.className = `message-area ${type} visible`; if (messageTimeoutId) clearTimeout(messageTimeoutId); messageTimeoutId = setTimeout(() => { messageArea.classList.remove('visible'); setTimeout(() => { if (!messageArea.classList.contains('visible')) { messageArea.className = 'message-area'; } }, 500); }, duration); }

    // --- Gestion Navigation ---
    function switchTab(targetSectionId) { if (!targetSectionId) return; console.log("Switch tab to:", targetSectionId); appSections.forEach(section => { section.style.display = 'none'; }); const targetSection = document.getElementById(targetSectionId); if (targetSection) { targetSection.style.display = 'flex'; targetSection.style.flexDirection = 'column'; } else { console.error("Section cible non trouvée:", targetSectionId); } navButtons.forEach(btn => { btn.classList.toggle('active', btn.dataset.section === targetSectionId); }); if (targetSectionId === 'program-config-area') { renderProgramConfigUI(); } else if (targetSectionId === 'history-area') { renderHistoryUI(); } }

    // --- Initialisation ---
    function initializeDOMReferences() { console.log("Init DOM Refs..."); signInButton = document.getElementById('signin-button'); signOutButton = document.getElementById('signout-button'); driveStatusElement = document.getElementById('drive-status'); themeToggleBtn = document.getElementById('theme-toggle-btn'); signInButtonPrompt = document.getElementById('signin-button-prompt'); connectionPrompt = document.getElementById('connection-prompt'); evolutionTrackerArea = document.getElementById('evolution-tracker-area'); overallHPSDisplayValue = document.querySelector('#overall-hps-display .value'); levelBadgeContainer = document.getElementById('level-badge-container'); levelBadge = document.getElementById('level-badge'); if (levelBadge) { levelBadgeIcon = levelBadge.querySelector('i'); levelBadgeText = levelBadge.querySelector('span'); } targetHPSInfoStrong = document.querySelector('#target-hps-info strong'); marvelTargetInfoSpan = document.querySelector('#marvel-target-info'); muscleGroupsContainer = document.getElementById('muscle-groups-container'); programConfigArea = document.getElementById('program-config-area'); programConfigContent = document.getElementById('program-config-content'); saveConfigButton = document.getElementById('save-config-button'); historyArea = document.getElementById('history-area'); historyMuscleGroupSelect = document.getElementById('history-muscle-group-select'); historyPeriodBtns = document.querySelectorAll('.history-period-btn'); historyDisplay = document.getElementById('history-display'); messageArea = document.getElementById('message-area'); levelInfoModal = document.getElementById('level-info-modal'); modalTitle = document.getElementById('modal-title'); modalIcon = document.getElementById('modal-icon'); modalLevelName = document.getElementById('modal-level-name'); modalBody = document.getElementById('modal-body'); modalCloseBtn = document.getElementById('modal-close-btn'); appNav = document.getElementById('app-nav'); navButtons = document.querySelectorAll('.nav-button'); appSections = document.querySelectorAll('.app-section'); const critical = [signInButton, signOutButton, themeToggleBtn, signInButtonPrompt, connectionPrompt, evolutionTrackerArea, overallHPSDisplayValue, levelBadgeContainer, levelBadge, levelBadgeIcon, levelBadgeText, targetHPSInfoStrong, marvelTargetInfoSpan, muscleGroupsContainer, programConfigArea, programConfigContent, saveConfigButton, historyArea, historyMuscleGroupSelect, historyPeriodBtns, historyDisplay, messageArea, levelInfoModal, modalTitle, modalIcon, modalLevelName, modalBody, modalCloseBtn, appNav, navButtons, appSections]; if (critical.some(el => !el || (NodeList.prototype.isPrototypeOf(el) && el.length === 0))) { console.error("DOM CRITIQUES MANQUANTS!", critical.map((el, i) => el ? `OK_${i}` : `FAIL_${i}`)); showMessage("Erreur critique: UI incomplète.", 10000, 'error'); document.body.innerHTML = '<p style="color:red; padding: 20px;">Erreur critique interface. Vérifiez la console.</p>'; return false; } console.log("DOM Refs OK."); return true; }
    function addEventListeners() { if(signInButton) signInButton.addEventListener('click', handleAuthClick); if(signInButtonPrompt) signInButtonPrompt.addEventListener('click', handleAuthClick); if(signOutButton) signOutButton.addEventListener('click', () => handleSignoutClick(true)); if(themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme); document.body.addEventListener('click', initAudioContext, { once: true }); document.body.addEventListener('keydown', initAudioContext, { once: true }); if (levelBadge) levelBadge.addEventListener('click', () => { const key = levelBadge.getAttribute('data-level-key'); if(key) openLevelInfoModal(key); }); if (muscleGroupsContainer) { muscleGroupsContainer.addEventListener('click', (event) => { const indicator = event.target.closest('.level-indicator'); if (indicator) { const key = indicator.getAttribute('data-level-key'); const card = indicator.closest('.muscle-group-card'); const muscleName = card?.querySelector('.group-title')?.textContent; if (key) openLevelInfoModal(key, muscleName); } }); } if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeLevelInfoModal); if (levelInfoModal) levelInfoModal.addEventListener('click', (event) => { if (event.target === levelInfoModal) closeLevelInfoModal(); }); navButtons.forEach(button => { button.addEventListener('click', () => switchTab(button.dataset.section)); }); if (saveConfigButton) saveConfigButton.addEventListener('click', saveExerciseConfigToDrive); if(historyMuscleGroupSelect) historyMuscleGroupSelect.addEventListener('change', handleHistorySelectionChange); if(historyPeriodBtns) historyPeriodBtns.forEach(btn => btn.addEventListener('click', handleHistoryPeriodChange)); console.log("Écouteurs OK."); }

    // --- Point d'entrée ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Chargé. Init HPS System v7...");
        try {
            if (!initializeDOMReferences()) return;
            addEventListeners();
            loadSavedTheme();
            // Charger les valeurs précédentes pour l'historique AVANT l'UI initiale
            loadPreviousHPSFromLocalStorage();
            updateAuthUI(false); // Afficher état déconnecté initial
            resetProgressionDisplay(); // Afficher les valeurs chargées (ou --)
            resetConfigUI();
            resetHistoryUI(); // Afficher N/A au début car pas de *nouveau* calcul
            checkAndInitGis();
            console.log("Init terminée. Attente API Google & utilisateur...");
        } catch (error) {
            console.error("Erreur Init DOMContentLoaded:", error);
            showMessage("Erreur critique chargement.", 10000, 'error');
            const b = document.querySelector('body');
            if(b) b.innerHTML = '<p style="color:red; padding: 20px;">Erreur critique chargement. Voir console.</p>';
        }
    });

</script>

</body>
</html>
