<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Suivi Évolution Musculaire</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        /* --- Variables Globales & Thèmes --- */
        :root {
            /* Thème Sombre (Défaut) */
            --bg-color-dark: #0D1117;
            --secondary-bg-color-dark: #161B22;
            --primary-text-color-dark: #c9d1d9;
            --secondary-text-color-dark: #8b949e;
            --border-color-dark: #30363d;
            --accent-border-color-dark: #58a6ff33;
            --input-bg-dark: #0d1117;

            /* Couleurs Néon */
            --neon-blue: #58a6ff;
            --neon-pink: #f778ba;
            --neon-red: #ff7b72;
            --neon-yellow: #facc15;
            --neon-green: #3fb950;
            --neon-purple: #bc8cff;
            --neon-orange: #f9a825;

            /* Glows */
            --glow-blue: 0 0 12px rgba(88, 166, 255, 0.6);
            --glow-pink: 0 0 12px rgba(247, 120, 186, 0.6);
            --glow-red: 0 0 10px rgba(255, 123, 114, 0.6);
            --glow-yellow: 0 0 10px rgba(250, 204, 21, 0.5);
            --glow-green: 0 0 10px rgba(63, 185, 80, 0.6);
            --glow-purple: 0 0 12px rgba(188, 140, 255, 0.6);
            --glow-orange: 0 0 10px rgba(249, 168, 37, 0.6);

             /* Couleurs Niveaux (Style Clash of Clans) */
             --level-beginner-color: var(--secondary-text-color-dark); /* Grisâtre pour débutant */
             --level-bronze-color: #cd7f32; /* Bronze */
             --level-silver-color: #c0c0c0; /* Argent */
             --level-gold-color: #ffd700;   /* Or */
             --level-crystal-color: #a7d8de; /* Crystal (bleu pâle) */
             --level-master-color: #e384f1;  /* Master (violet/rose) */
             --level-champion-color: var(--neon-red); /* Champion (rouge néon) */

            /* Autres */
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius-lg: 12px;
            --border-radius-md: 8px;
            --border-radius-sm: 6px;
            --transition-speed: 0.25s;

            /* RGBA pour transparences */
            --bg-color-dark-rgb: 13, 17, 23;
            --secondary-bg-color-dark-rgb: 22, 27, 34;
            --primary-text-color-dark-rgb: 201, 209, 217;
            --secondary-text-color-dark-rgb: 139, 148, 158;
            --border-color-dark-rgb: 48, 54, 61;
            --neon-blue-rgb: 88, 166, 255;
            --neon-pink-rgb: 247, 120, 186;
            --neon-red-rgb: 255, 123, 114;
            --neon-yellow-rgb: 250, 204, 21;
            --neon-green-rgb: 63, 185, 80;
            --neon-purple-rgb: 188, 140, 255;
            --neon-orange-rgb: 249, 168, 37;

            /* Application Thème Sombre par défaut */
            --bg-color: var(--bg-color-dark);
            --secondary-bg-color: var(--secondary-bg-color-dark);
            --primary-text-color: var(--primary-text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --border-color: var(--border-color-dark);
            --accent-border-color: var(--accent-border-color-dark);
            --input-bg: var(--input-bg-dark);
            --bg-color-rgb: var(--bg-color-dark-rgb);
            --secondary-bg-color-rgb: var(--secondary-bg-color-dark-rgb);
            --primary-text-color-rgb: var(--primary-text-color-dark-rgb);
            --secondary-text-color-rgb: var(--secondary-text-color-dark-rgb);
            --border-color-rgb: var(--border-color-dark-rgb);

             /* Styles spécifiques */
             --link-color: var(--neon-blue);
             --button-connect-color: var(--neon-green);
             --button-connect-glow: var(--glow-green);
             --button-disconnect-color: var(--neon-red);
             --button-disconnect-glow: var(--glow-red);

             /* Barres de progression */
             --progress-bar-bg: rgba(var(--primary-text-color-rgb), 0.1);
             --progress-bar-fill: linear-gradient(90deg, var(--neon-blue), var(--neon-purple));
             --global-progress-bar-fill: linear-gradient(90deg, var(--neon-green), var(--neon-yellow)); /* Gradient pour barre globale */
        }

        body.light-theme {
            /* Thème Clair */
            --bg-color-dark: #ffffff; /* Renommé pour cohérence var() */
            --secondary-bg-color-dark: #f6f8fa;
            --primary-text-color-dark: #24292f;
            --secondary-text-color-dark: #57606a;
            --border-color-dark: #d0d7de;
            --accent-border-color-dark: #0969da33;
            --input-bg-dark: #f6f8fa;

            /* Couleurs (moins néon en clair) */
            --neon-blue: #0969da;
            --neon-pink: #bf3989;
            --neon-red: #d73a49;
            --neon-yellow: #dbab09;
            --neon-green: #2da44e;
            --neon-purple: #8250df;
            --neon-orange: #f66a0a;

            /* Glows (plus subtils) */
            --glow-blue: 0 0 8px rgba(9, 105, 218, 0.3);
            --glow-pink: 0 0 8px rgba(191, 57, 137, 0.3);
            --glow-red: 0 0 8px rgba(215, 58, 73, 0.3);
            --glow-yellow: 0 0 8px rgba(219, 171, 9, 0.3);
            --glow-green: 0 0 8px rgba(45, 164, 78, 0.3);
            --glow-purple: 0 0 8px rgba(130, 80, 223, 0.3);
            --glow-orange: 0 0 8px rgba(246, 106, 10, 0.3);

            /* Couleurs Niveaux (versions claires si nécessaire, sinon garder les mêmes) */
             /* --level-bronze-color: #a0522d; etc. si on veut ajuster pour thème clair */

            /* RGBA pour transparences */
            --bg-color-dark-rgb: 255, 255, 255;
            --secondary-bg-color-dark-rgb: 246, 248, 250;
            --primary-text-color-dark-rgb: 36, 41, 47;
            --secondary-text-color-dark-rgb: 87, 96, 106;
            --border-color-dark-rgb: 208, 215, 222;
            --neon-blue-rgb: 9, 105, 218;
            --neon-pink-rgb: 191, 57, 137;
            --neon-red-rgb: 215, 58, 73;
            --neon-yellow-rgb: 219, 171, 9;
            --neon-green-rgb: 45, 164, 78;
            --neon-purple-rgb: 130, 80, 223;
            --neon-orange-rgb: 246, 106, 10;

            /* Application Thème Clair */
            --bg-color: var(--bg-color-dark);
            --secondary-bg-color: var(--secondary-bg-color-dark);
            --primary-text-color: var(--primary-text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --border-color: var(--border-color-dark);
            --accent-border-color: var(--accent-border-color-dark);
            --input-bg: var(--input-bg-dark);
            --bg-color-rgb: var(--bg-color-dark-rgb);
            --secondary-bg-color-rgb: var(--secondary-bg-color-dark-rgb);
            --primary-text-color-rgb: var(--primary-text-color-dark-rgb);
            --secondary-text-color-rgb: var(--secondary-text-color-dark-rgb);
            --border-color-rgb: var(--border-color-dark-rgb);

            /* Styles spécifiques */
             --link-color: #0969da;
             --progress-bar-bg: #e1e4e8;
        }

        /* --- Styles de Base & Réinitialisation --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--primary-text-color); line-height: 1.6; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; display: flex; flex-direction: column; min-height: 100vh; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; }
        .container { max-width: 950px; margin: 0 auto; padding: 30px 20px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }

        /* --- En-tête --- */
        header { padding: 15px 0; border-bottom: 1px solid var(--border-color); transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease; position: sticky; top: 0; z-index: 1000; background-color: rgba(var(--bg-color-rgb), 0.8); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }
        .header-content { display: flex; justify-content: space-between; align-items: center; max-width: 1100px; margin: 0 auto; padding: 0 25px; flex-wrap: wrap; gap: 15px 20px; }
        header h1 { font-size: 1.5em; color: var(--primary-text-color); margin: 0; font-weight: 700; display: flex; align-items: center; gap: 10px; }
        header h1 i { color: var(--neon-blue); animation: pulse 2s infinite ease-in-out; }
        @keyframes pulse { 0%, 100% { transform: scale(1); opacity: 0.8; } 50% { transform: scale(1.1); opacity: 1; } }
        .header-link { color: var(--secondary-text-color); font-size: 0.9em; text-decoration: none; display: inline-flex; align-items: center; gap: 5px; transition: color var(--transition-speed) ease; }
        .header-link:hover { color: var(--link-color); }
        .header-actions { display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button, #connection-prompt button { background: none; border: 1px solid var(--accent-border-color); color: var(--secondary-text-color); padding: 6px 14px; border-radius: var(--border-radius-md); font-size: 0.85em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 6px; }
        .auth-controls button:disabled, #connection-prompt button:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; border-color: var(--border-color) !important; color: var(--secondary-text-color) !important; box-shadow: none !important; background-color: transparent !important; }
        .auth-controls button:not(:disabled):hover { border-color: var(--primary-text-color); color: var(--primary-text-color); }
        #signin-button, #signin-button-prompt { border-color: var(--button-connect-color); color: var(--button-connect-color); }
        #signin-button:not(:disabled):hover, #signin-button-prompt:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--glow-green); border-color: var(--neon-green); }
        #signout-button { border-color: var(--button-disconnect-color); color: var(--button-disconnect-color); }
        #signout-button:not(:disabled):hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--glow-red); border-color: var(--neon-red); }
        #drive-status { font-size: 0.8em; color: var(--secondary-text-color); margin-left: 5px; transition: opacity 0.3s, color 0.3s, border-color 0.3s; min-width: fit-content; text-align: right; font-style: normal; padding: 4px 8px; background-color: rgba(var(--secondary-bg-color-rgb), 0.5); border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); display: none; } /* Utilise var(--secondary-bg-color-rgb) */
        #drive-status.loading { color: var(--neon-yellow); border-color: var(--neon-yellow); animation: blink-border 1.5s infinite ease-in-out; }
        #drive-status.error { color: var(--neon-red); border-color: var(--neon-red); }
        #drive-status.success { color: var(--neon-green); border-color: var(--neon-green); }
        #drive-status.warning { color: var(--neon-orange); border-color: var(--neon-orange); } /* Ajout pour état warning */
        @keyframes blink-border { 50% { border-color: rgba(var(--neon-yellow-rgb), 0.4); } }
        .theme-toggle button { background: none; border: none; color: var(--secondary-text-color); font-size: 1.2em; padding: 5px; cursor: pointer; transition: color var(--transition-speed) ease; }
        .theme-toggle button:hover { color: var(--neon-yellow); }
        body.logged-out #signin-button, body.logged-out #signin-button-prompt { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-out #drive-status { display: none; }
        body.logged-in #signin-button, body.logged-in #signin-button-prompt { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-in #drive-status { display: inline-block; }
        body.logged-out #connection-prompt { display: block; }
        body.logged-in #connection-prompt { display: none; }
        body.logged-out #evolution-tracker-area { display: none; }
        body.logged-in #evolution-tracker-area { display: flex; } /* Changé de block à flex */

        /* --- Contenu Principal --- */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 40px; }
        main h2 { font-size: 1.6em; font-weight: 700; margin-bottom: 15px; text-align: center; color: var(--primary-text-color); display: flex; align-items: center; gap: 10px; justify-content: center; }
        main h2 i { color: var(--neon-purple); }

        /* Message si non connecté */
        #connection-prompt { text-align: center; padding: 40px 20px; background-color: var(--secondary-bg-color); border-radius: var(--border-radius-lg); border: 1px dashed var(--border-color); margin: 20px auto; max-width: 600px; }
        #connection-prompt p { margin-bottom: 15px; color: var(--secondary-text-color); }
        #connection-prompt button { padding: 8px 18px; font-size: 0.9em; }

        /* Zone principale d'affichage */
        #evolution-tracker-area { width: 100%; background-color: var(--secondary-bg-color); border-radius: var(--border-radius-lg); border: 1px solid var(--border-color); padding: 30px 25px; flex-direction: column; gap: 35px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); margin-top: 20px; }

        /* Section Statistiques Globales */
        .global-stats { text-align: center; margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--border-color); }
        #overall-elo-display { font-size: 2.2em; font-weight: 900; color: var(--neon-purple); margin-bottom: 5px; line-height: 1.1; transition: color 0.5s ease; cursor: default; }
        #overall-elo-display .value { display: inline-block; /* Pour animation */ }
        #overall-elo-display .label { font-size: 0.5em; font-weight: 500; color: var(--secondary-text-color); display: block; }
        #goal-info { font-size: 1.1em; color: var(--primary-text-color); font-weight: 500; margin-top: 15px; }
        /* Style du niveau actuel */
        #goal-info .target-level {
            font-weight: 700;
            display: inline-flex; /* Pour aligner icône et texte */
            align-items: center;
            gap: 8px;
            padding: 4px 10px;
            border-radius: var(--border-radius-sm);
            background-color: rgba(var(--secondary-text-color-rgb), 0.1); /* Fond léger */
            border: 1px solid transparent; /* Pour transition */
            transition: color 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
            cursor: help; /* Indique qu'il y a une info au survol */
            margin: 0 5px; /* Espacement autour */
            vertical-align: middle; /* Alignement vertical */
        }
        #goal-info .target-level i { /* Icône du niveau */
             font-size: 1.1em;
             opacity: 0.9;
             width: 1.2em; /* Largeur fixe pour alignement */
             text-align: center;
        }
        /* La couleur est appliquée par JS via la variable --level-xxx-color */
        #goal-info .target-level:hover {
             background-color: rgba(var(--secondary-text-color-rgb), 0.2);
             border-color: currentColor; /* Utilise la couleur définie par JS */
        }
        #goal-info .target-elo-value { font-weight: 700; }
        #goal-description { font-size: 0.9em; color: var(--secondary-text-color); font-style: italic; margin-top: 12px; max-width: 600px; margin-left: auto; margin-right: auto; line-height: 1.5; }

        /* Conteneur des catégories et groupes */
        #muscle-groups-container { display: flex; flex-direction: column; gap: 30px; }
        .muscle-category {}
        .muscle-category-header { font-size: 1.3em; font-weight: 700; color: var(--neon-orange); margin-bottom: 15px; padding-bottom: 5px; border-bottom: 2px solid var(--neon-orange); display: inline-block; }
        .muscle-group-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }

        /* Carte pour un groupe musculaire */
        .muscle-group-card { background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 20px; display: flex; flex-direction: column; gap: 12px; transition: all var(--transition-speed) ease; cursor: default; position: relative; overflow: hidden; }
        .muscle-group-card::before { /* Effet de lueur subtil */
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(var(--neon-blue-rgb), 0.05) 0%, rgba(var(--neon-blue-rgb), 0) 70%);
            opacity: 0; transition: opacity 0.4s ease; pointer-events: none;
        }
        .muscle-group-card:hover { border-color: var(--accent-border-color); box-shadow: 0 4px 15px rgba(0,0,0,0.1); transform: translateY(-2px); }
        .muscle-group-card:hover::before { opacity: 1; }
        .muscle-group-header { display: flex; align-items: center; gap: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 5px; }
        .muscle-group-header i { font-size: 1.4em; width: 25px; text-align: center; color: var(--neon-blue); transition: color 0.3s ease; }
        .muscle-group-card:hover .muscle-group-header i { color: var(--neon-purple); transform: scale(1.1); }
        .muscle-group-title { font-size: 1.15em; font-weight: 700; color: var(--primary-text-color); }
        .elo-info { display: flex; justify-content: space-between; align-items: baseline; font-size: 0.9em; color: var(--secondary-text-color); }
        .current-elo { font-weight: 700; font-size: 1.1em; color: var(--neon-purple); }
        .target-elo { font-weight: 500; }
        .target-elo strong { color: var(--neon-green); font-weight: 700; }

        /* Barre de progression */
        .progress-bar-container { width: 100%; height: 12px; background-color: var(--progress-bar-bg); border-radius: 6px; overflow: hidden; margin-top: 5px; border: 1px solid var(--border-color); position: relative; }
        .progress-bar { height: 100%; width: 0%; background: var(--progress-bar-fill); border-radius: 6px; transition: width 0.7s cubic-bezier(0.25, 1, 0.5, 1); position: relative; display: flex; align-items: center; justify-content: flex-end; overflow: hidden; }
        .progress-bar::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%); opacity: 0.5; pointer-events: none; }
        .progress-percentage { font-size: 0.8em; font-weight: 700; color: white; margin-right: 8px; text-shadow: 0 0 3px rgba(0,0,0,0.5); z-index: 1; line-height: 12px; opacity: 0; transition: opacity 0.3s ease; white-space: nowrap; }
         .progress-bar:not([style*="width: 0%"]) .progress-percentage { opacity: 1; }

        /* Barre Globale "Objectif Final" */
        .global-goal-progress { margin-top: 40px; padding: 20px; background-color: rgba(var(--secondary-bg-color-rgb), 0.3); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); } /* Utilise var(--secondary-bg-color-rgb) */
        .global-goal-progress h3 { font-size: 1.2em; font-weight: 700; color: var(--primary-text-color); margin-bottom: 15px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 8px; }
        .global-goal-progress h3 i { /* color: var(--neon-green); */ transition: color 0.3s ease; } /* Couleur définie dynamiquement par JS */
        .global-progress-bar-container { width: 100%; height: 18px; background-color: var(--progress-bar-bg); border-radius: 9px; overflow: hidden; border: 1px solid var(--border-color); position: relative; cursor: help; }
        .global-progress-bar { height: 100%; width: 0%; background: var(--global-progress-bar-fill); border-radius: 9px; transition: width 1s cubic-bezier(0.25, 1, 0.5, 1); display: flex; align-items: center; justify-content: center; }
        .global-progress-percentage { font-size: 0.9em; font-weight: 700; color: rgba(0,0,0,0.7); text-shadow: 0 0 2px rgba(255,255,255,0.5); z-index: 1; line-height: 18px; opacity: 0; transition: opacity 0.5s ease; white-space: nowrap; }
         .global-progress-bar:not([style*="width: 0%"]) .global-progress-percentage { opacity: 1; }

        /* --- Zone de Messages Flottante --- */
        .message-area { position: fixed; bottom: 25px; left: 50%; transform: translateX(-50%); background-color: rgba(var(--secondary-bg-color-rgb), 0.9); color: var(--primary-text-color); border: 1px solid var(--border-color); padding: 12px 25px; border-radius: var(--border-radius-md); z-index: 3000; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease, background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease; pointer-events: none; font-size: 0.95em; box-shadow: 0 4px 15px rgba(0,0,0,0.2); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); max-width: 90%; text-align: center; } /* Utilise var(--secondary-bg-color-rgb) */
        .message-area.visible { opacity: 1; transform: translate(-50%, 0); bottom: 40px; pointer-events: auto; }
        .message-area.error { background-color: rgba(var(--neon-red-rgb), 0.9); color: #ffffff; border-color: var(--neon-red); text-shadow: 1px 1px 1px rgba(0,0,0,0.2); }
        .message-area.success { background-color: rgba(var(--neon-green-rgb), 0.9); color: #ffffff; border-color: var(--neon-green); }
        .message-area.warning { background-color: rgba(var(--neon-orange-rgb), 0.9); color: #ffffff; border-color: var(--neon-orange); } /* Style pour warning */
        .message-area.info { background-color: rgba(var(--neon-blue-rgb), 0.9); color: #ffffff; border-color: var(--neon-blue); } /* Style pour info */

        /* --- Pied de Page --- */
        footer { color: var(--secondary-text-color); opacity: 0.7; border-top: 1px solid var(--border-color); margin-top: 60px; padding: 25px; text-align: center; transition: border-color var(--transition-speed) ease, color var(--transition-speed) ease; }
        footer a { color: var(--link-color); text-decoration: none; transition: color var(--transition-speed) ease; }
        footer a:hover { color: var(--primary-text-color); text-decoration: underline; }
        footer .fab.fa-google-drive { color: #4CAF50; } /* Conservé pour potentiel usage */

        /* --- Responsive Design --- */
        @media (max-width: 768px) {
            .container { padding: 20px 15px; }
            main h2 { font-size: 1.4em; }
            .global-stats { margin-bottom: 15px; padding-bottom: 15px; }
            #overall-elo-display { font-size: 1.8em; }
            #goal-info { font-size: 1em; }
            #goal-info .target-level { flex-direction: column; gap: 4px; text-align: center; padding: 6px 8px; } /* Icône au-dessus sur mobile */
            .muscle-category-header { font-size: 1.2em; }
            .muscle-group-grid { grid-template-columns: 1fr; gap: 15px; }
            .muscle-group-card { padding: 15px; }
            .muscle-group-title { font-size: 1.1em; }
            .global-goal-progress h3 { font-size: 1.1em; }
            .header-content { justify-content: center; text-align: center; }
            header h1 { order: -1; width: 100%; justify-content: center; margin-bottom: 10px; }
        }
        @media (max-width: 480px) {
            html { font-size: 15px; }
            .header-content { padding: 0 15px; }
            .header-actions { gap: 10px; justify-content: center; width: 100%; }
            .auth-controls button { padding: 5px 10px; font-size: 0.8em; }
            main h2 { font-size: 1.3em; }
            #overall-elo-display { font-size: 1.6em; }
            #goal-info { font-size: 0.95em; }
            #goal-description { font-size: 0.85em; }
            .global-goal-progress h3 { font-size: 1em; }
            .global-progress-bar-container { height: 16px; }
            .global-progress-percentage { font-size: 0.8em; }
            .progress-percentage { font-size: 0.75em; margin-right: 5px;}
        }

        /* Style pour indicateur de chargement/erreur dans le conteneur */
        #muscle-groups-container .loading-placeholder,
        #muscle-groups-container .error-placeholder {
            text-align: center;
            color: var(--secondary-text-color);
            grid-column: 1 / -1; /* S'étend sur toute la grille */
            padding: 30px;
            font-style: italic;
        }
        #muscle-groups-container .error-placeholder {
            color: var(--neon-red);
            font-weight: 500;
        }

    </style>
</head>
<body class="logged-out dark-theme"> <!-- Start with dark theme, logged-out state -->

<header>
    <div class="header-content">
         <div>
             <a href="timer.html" class="header-link" style="margin-right: 15px;"><i class="fas fa-stopwatch"></i> Timer</a>
             <a href="program-editor.html" class="header-link"><i class="fas fa-edit"></i> Éditeur</a>
         </div>
        <h1><i class="fas fa-shield-halved"></i> ArmorWorkout</h1>
        <div class="header-actions">
            <div class="auth-controls">
                <button id="signin-button" disabled><i class="fab fa-google"></i> Connecter Drive</button>
                <button id="signout-button" disabled><i class="fas fa-sign-out-alt"></i> Déconnecter</button>
            </div>
            <span id="drive-status" aria-live="polite"></span>
            <div class="theme-toggle">
                <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button>
            </div>
        </div>
    </div>
</header>

<div class="container">
    <main>
        <h2><i class="fas fa-chart-line"></i> Suivi d'Évolution</h2>

        <div id="connection-prompt">
            <p>Connectez-vous à Google Drive pour analyser vos programmes et suivre votre évolution.</p>
            <button id="signin-button-prompt" disabled><i class="fab fa-google"></i> Connecter Drive</button>
        </div>

        <div id="evolution-tracker-area">
            <!-- Section Stats Globales -->
            <div class="global-stats">
                <div id="overall-elo-display" title="ELO moyen pondéré des groupes musculaires du haut du corps">
                    <span class="value">--</span>
                    <span class="label">ELO Moyen (Haut du Corps)</span>
                </div>
                <div id="goal-info">
                    Objectif Actuel : <span class="target-level" title="Connectez-vous pour voir votre niveau"> <!-- Tooltip mis à jour par JS -->
                        <i class="fas fa-spinner fa-spin" aria-hidden="true"></i> <!-- Icône chargement -->
                        Chargement...
                    </span> (ELO Cible <span class="target-elo-value">--</span>)
                </div>
                <div id="goal-description">
                    <!-- Description chargée par JS -->
                </div>
            </div>

            <!-- Section Groupes Musculaires -->
            <div id="muscle-groups-container" aria-live="polite">
                 <p class="loading-placeholder">Connectez-vous pour charger vos données...</p>
            </div>

             <!-- Section Barre de Progression Globale -->
             <div class="global-goal-progress" id="global-goal-progress-section">
                 <h3 id="global-goal-title"><i class="fas fa-trophy"></i> Progression vers l'Objectif Ultime</h3> <!-- Titre mis à jour par JS -->
                 <div class="global-progress-bar-container" title="Progression globale vers l'objectif final" aria-label="Progression globale vers l'objectif final">
                     <div class="global-progress-bar" id="global-progress-bar" style="width: 0%;" role="progressbar" aria-valuenow="0" aria-valuemin="800" aria-valuemax="1400"> <!-- Valeurs mises à jour par JS -->
                         <span class="global-progress-percentage" id="global-progress-percentage">0%</span>
                     </div>
                 </div>
             </div>

        </div>

    </main>
</div>

<footer>
    <p>© 2024 ArmorWorkout Evolution Tracker. Analyse basée sur vos programmes <i class="fab fa-google-drive" aria-hidden="true" style="color: #4CAF50;"></i> Drive.</p>
     <p><a href="timer.html">Timer</a> | <a href="program-editor.html">Éditeur</a> | <a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></p>
</footer>

<!-- Zone de Message Flottante -->
<div id="message-area" class="message-area" role="status" aria-live="polite"></div>

<!-- Google Identity Services Script -->
<script async defer src="https://accounts.google.com/gsi/client"></script>

<script>
    // --- CONFIGURATION & CONSTANTES ---
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const PROGRAM_FILENAMES = { Push: "armorworkout_push_program.json", Pull: "armorworkout_pull_program.json", Legs: "armorworkout_legs_program.json" };
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const GIS_CHECK_INTERVAL = 100;
    const GIS_MAX_RETRIES = 50;

    // --- PARAMÈTRES ELO & NIVEAUX ---
    const ELO_BASE = 800; // Point de départ
    const INTENSITY_TECHNIQUE_BONUS_MULTIPLIER = 1.05;
    const POLYARTICULAR_WEIGHT = 1.2;
    const ISOLATION_WEIGHT = 1.0;
    const RESISTANCE_BONUS = { 'Bodyweight': 75, 'Haltères 5kg': 50, 'Élastique 15kg': 50, 'Élastique 15kg doublé': 100, 'Élastique 25kg': 125, 'Élastique 15+25kg': 200, 'Élastique 15+25kg + 1 haltère 5kg': 225, 'Élastique 15+25kg + 2x5kg haltères': 250 };
    const REPS_FACTORS = { 8: 0.9, 12: 1.0, 18: 1.2, 25: 1.3, Infinity: 1.4 };

    // Niveaux d'objectifs (Style Clash of Clans)
    const TARGET_ELO_LEVELS = {
        'L0_Base':    { name: "Débutant",      targetELO: ELO_BASE, description: "Le commencement du voyage. Chaque répétition compte !", colorVar: '--level-beginner-color', iconClass: 'fa-seedling',           groups: {} }, // Niveau 0 sert de base
        'L1_Bronze':  { name: "Physique Bronze", targetELO: 950,  description: "Fondations solides établies. Physique athlétique naissant, endurance en hausse.", colorVar: '--level-bronze-color', iconClass: 'fa-shield-halved',  groups: { Pectoraux: 900,  Dos: 920,  Épaules: 880,  Biceps: 900,  Triceps: 880,  Core: 850 } },
        'L2_Silver':  { name: "Force Argent",    targetELO: 1050, description: "Force notablement accrue, muscles plus définis. Gère des résistances modérées.", colorVar: '--level-silver-color', iconClass: 'fa-shield',           groups: { Pectoraux: 1025, Dos: 1025, Épaules: 1000, Biceps: 1000, Triceps: 1000, Core: 900 } },
        'L3_Gold':    { name: "Puissance Or",    targetELO: 1150, description: "Niveau avancé ! Muscles bien développés, force impressionnante.", colorVar: '--level-gold-color',   iconClass: 'fa-shield-heart',   groups: { Pectoraux: 1150, Dos: 1150, Épaules: 1120, Biceps: 1100, Triceps: 1100, Core: 950 } },
        'L4_Crystal': { name: "Guerrier Crystal",targetELO: 1250, description: "Performance d'élite. Force et définition musculaire exceptionnelles.", colorVar: '--level-crystal-color',iconClass: 'fa-gem',              groups: { Pectoraux: 1250, Dos: 1250, Épaules: 1250, Biceps: 1200, Triceps: 1200, Core: 1000 } },
        'L5_Master':  { name: "Maître Combattant",targetELO: 1350, description: "Maîtrise quasi totale. Votre physique est une armure, votre force est légendaire.", colorVar: '--level-master-color', iconClass: 'fa-crown',            groups: { Pectoraux: 1350, Dos: 1350, Épaules: 1350, Biceps: 1300, Triceps: 1300, Core: 1050 } },
        'L6_Champion':{ name: "Champion Ultime", targetELO: 1400, description: "Le summum. Vous avez transcendé les limites, une véritable force de la nature.", colorVar: '--level-champion-color',iconClass: 'fa-skull-crossbones', groups: { Pectoraux: 1400, Dos: 1400, Épaules: 1400, Biceps: 1350, Triceps: 1350, Core: 1100 } }
    };
    const LEVEL_ORDER = ['L0_Base', 'L1_Bronze', 'L2_Silver', 'L3_Gold', 'L4_Crystal', 'L5_Master', 'L6_Champion']; // Ordre défini
    const FINAL_TARGET_ELO = TARGET_ELO_LEVELS[LEVEL_ORDER[LEVEL_ORDER.length - 1]].targetELO; // ELO cible du dernier niveau

    // Ordre et icônes pour l'affichage des groupes musculaires
    const MUSCLE_GROUPS_DISPLAY_ORDER = { "Torse": ["Pectoraux", "Dos"], "Épaules": ["Épaules"], "Bras": ["Biceps", "Triceps"], "Core": ["Core"] };
    const MUSCLE_GROUP_ICONS = { Pectoraux: 'fa-heart-pulse', Dos: 'fa-circle-nodes', Épaules: 'fa-person-burst', Biceps: 'fa-dumbbell', Triceps: 'fa-hand-back-fist', Core: 'fa-fire', Legs: 'fa-shoe-prints' };
    const ALL_MUSCLE_GROUPS = [...new Set(Object.values(MUSCLE_GROUPS_DISPLAY_ORDER).flat().concat(Object.keys(MUSCLE_GROUP_ICONS)))]; // Inclut 'Legs' pour l'analyse

    // --- Éléments DOM ---
    let signInButton, signOutButton, driveStatusElement, themeToggleBtn,
        signInButtonPrompt, connectionPrompt, evolutionTrackerArea,
        overallEloDisplay, overallEloValueElement, overallEloLabelElement,
        goalInfo, targetLevelElement, targetEloValueElement, // Séparé pour clarté
        goalDescriptionElement,
        muscleGroupsContainer, messageArea,
        globalProgressBar, globalProgressPercentage, globalGoalTitleElement,
        globalProgressBarContainer; // Ajout du conteneur pour le tooltip

    // --- Variables d'État ---
    let googleAccessToken = null; let tokenClient = null; let programFileIds = { Push: null, Pull: null, Legs: null };
    let loadedPrograms = { Push: [], Pull: [], Legs: [] }; let programsAnalysisStatus = 'pending'; // 'pending', 'success', 'partial', 'error'
    let currentELOValues = {}; let overallAvgELO = ELO_BASE; // Initialisé à ELO_BASE
    let currentGoalLevelKey = LEVEL_ORDER[1]; // Clé du niveau objectif actuel (commence à L1)
    let currentTheme = 'dark'; let messageTimeoutId = null; let gisCheckRetries = 0;

    // --- Audio ---
    let audioContext = null;
    function initAudioContext() { if (!audioContext && typeof AudioContext !== 'undefined') { try { audioContext = new AudioContext(); } catch (e) { console.warn("AudioContext non supporté ou bloqué.", e); } } }
    function playSound(type = 'confirm') {
        if (!audioContext) return;
        try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.01); // Fade in rapide

            if (type === 'confirm') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4
                oscillator.frequency.linearRampToValueAtTime(660, audioContext.currentTime + 0.1); // E5
            } else if (type === 'error') {
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
                oscillator.frequency.linearRampToValueAtTime(110, audioContext.currentTime + 0.15); // A2
            } else { // Default / other
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(330, audioContext.currentTime); // E4
            }

            oscillator.start(audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.2); // Fade out plus long
            oscillator.stop(audioContext.currentTime + 0.2);
        } catch (e) {
            console.warn("Erreur lors de la lecture du son:", e);
        }
    }


    // --- Google Identity Services & Drive API ---
    async function gisInitInternal() {
        try {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CLIENT_ID,
                scope: GOOGLE_DRIVE_SCOPES,
                callback: tokenCallback, // Fonction appelée après l'obtention (ou l'échec) du token
                error_callback: handleTokenError, // Fonction spécifique pour les erreurs d'init ou de flux
            });
            console.log("GIS Token Client initialisé (Evolution).");
            // Les boutons sont activés dans updateAuthUI après vérification de tokenClient
            updateAuthUI(googleAccessToken !== null);
        } catch (error) {
            console.error("Erreur majeure lors de l'initialisation de GIS (Evolution):", error);
            showMessage("Impossible d'initialiser la connexion Google.", 5000, 'error');
            if (signInButton) signInButton.disabled = true;
            if (signInButtonPrompt) signInButtonPrompt.disabled = true;
            if (driveStatusElement) driveStatusElement.textContent = 'Erreur Init GIS'; driveStatusElement.className = 'error'; driveStatusElement.style.display = 'inline-block';
        }
    }
    function checkAndInitGis() {
        if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) {
            console.log("GIS prêt, initialisation... (Evolution)");
            gisInitInternal();
        } else if (gisCheckRetries < GIS_MAX_RETRIES) {
            gisCheckRetries++;
            console.log(`GIS non prêt, tentative ${gisCheckRetries}/${GIS_MAX_RETRIES}... (Evolution)`);
            setTimeout(checkAndInitGis, GIS_CHECK_INTERVAL);
        } else {
            console.error("Échec du chargement de Google Identity Services après plusieurs tentatives (Evolution).");
            showMessage("Le service d'authentification Google n'a pas pu charger.", 6000, 'error');
            if (signInButton) signInButton.disabled = true;
            if (signInButtonPrompt) signInButtonPrompt.disabled = true;
            if (driveStatusElement) driveStatusElement.textContent = 'Erreur GIS'; driveStatusElement.className = 'error'; driveStatusElement.style.display = 'inline-block';
        }
    }
    function handleTokenError(error) {
        console.error("Erreur d'authentification Google (Evolution):", error);
        let message = "Erreur de connexion Google.";
        if (error && error.type === 'popup_closed_by_user') { message = "Connexion annulée par l'utilisateur."; }
        else if (error && error.type === 'access_denied') { message = "Accès refusé. Autorisation Drive nécessaire."; }
        else if (error && error.error === 'popup_blocked_by_browser') { message = "Le popup de connexion a été bloqué par le navigateur."; }
        else if (error && error.details) { message += ` Détails: ${error.details}`; }
        showMessage(message, 5000, 'error');
        playSound('error');
        googleAccessToken = null; // Assurer la déconnexion interne
        updateAuthUI(false); // Mettre à jour l'UI à l'état déconnecté
        if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Auth'; driveStatusElement.className = 'error'; driveStatusElement.style.display = 'inline-block'; }
        resetEvolutionDisplay(); // Réinitialiser l'affichage ELO
    }
    async function tokenCallback(tokenResponse) {
         if (driveStatusElement) { driveStatusElement.className = ''; driveStatusElement.style.display = 'inline-block'; } // Afficher l'indicateur
         if (tokenResponse.error) { handleTokenError(tokenResponse); return; } // Gérer les erreurs spécifiques de tokenResponse

         if (tokenResponse && tokenResponse.access_token) {
             console.log("Access Token reçu (Evolution).");
             googleAccessToken = tokenResponse.access_token;
             playSound('confirm');
             showMessage("Connecté ! Analyse des programmes...", 2500, 'info'); // Changé en info
             if (driveStatusElement) { driveStatusElement.textContent = 'Chargement...'; driveStatusElement.className = 'loading'; }
             if (muscleGroupsContainer) { muscleGroupsContainer.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Analyse des programmes depuis Google Drive...</p>'; }
             resetEvolutionDisplay(); // Prépare l'affichage pour les nouvelles données

             try {
                 programsAnalysisStatus = await loadProgramsFromDrive(); // Met à jour l'état global
                 console.log("Statut analyse programmes:", programsAnalysisStatus);

                 if (programsAnalysisStatus === 'success') {
                     showMessage("Programmes analysés. Calcul de l'évolution...", 3000, 'success');
                     if (driveStatusElement) { driveStatusElement.textContent = 'Connecté'; driveStatusElement.className = 'success'; }
                 } else if (programsAnalysisStatus === 'partial') {
                     showMessage("Certains programmes manquants ou invalides. L'évolution peut être incomplète.", 5000, 'warning');
                     if (driveStatusElement) { driveStatusElement.textContent = 'Données Partielles'; driveStatusElement.className = 'warning'; }
                 } else { // 'error' ou autre cas inattendu
                      showMessage("Erreur critique lors du chargement/analyse des programmes.", 6000, 'error');
                      playSound('error');
                      if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Analyse'; driveStatusElement.className = 'error'; }
                 }
                 // On calcule et affiche toujours, même avec des données partielles ou en erreur (pour montrer ELO base)
                 calculateAndDisplayEvolution();

             } catch (error) { // Erreur non gérée dans loadProgramsFromDrive
                 console.error("Erreur CRITIQUE pendant le chargement/analyse des programmes (Evolution):", error);
                 showMessage("Erreur majeure lors de l'analyse des programmes.", 6000, 'error');
                 playSound('error');
                 if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Inattendue'; driveStatusElement.className = 'error'; }
                 programsAnalysisStatus = 'error';
                 if (muscleGroupsContainer) { muscleGroupsContainer.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; }
                 resetEvolutionDisplay(); // Réinitialise complètement en cas d'erreur fatale
             } finally {
                 updateAuthUI(true); // Met à jour l'UI à l'état connecté
             }
         } else {
             // Cas où tokenResponse n'est pas formé comme attendu mais sans 'error' explicite
             handleTokenError({ error: "invalid_response", details: "Réponse inattendue du serveur Google (Evolution)." });
         }
     }
    function handleAuthClick() {
        initAudioContext(); // Assure que l'AudioContext est prêt
        if (tokenClient) {
             // Demander le token. Le callback (tokenCallback ou handleTokenError) gèrera la suite.
             console.log("Demande de token Google... (Evolution)");
             showMessage("Ouverture de la fenêtre de connexion Google...", 2000, 'info');
             tokenClient.requestAccessToken({ prompt: '' }); // Utiliser '' pour le prompt standard
             if (driveStatusElement) { driveStatusElement.textContent = 'Connexion...'; driveStatusElement.className = 'loading'; driveStatusElement.style.display = 'inline-block'; }
        } else {
             console.error("Tentative d'authentification mais tokenClient n'est pas initialisé (Evolution).");
             showMessage("Erreur : Le service de connexion n'est pas prêt.", 4000, 'error');
             checkAndInitGis(); // Tenter de réinitialiser GIS
        }
    }
    function handleSignoutClick(showMessages = true) {
        const token = googleAccessToken;
        if (!token) { console.log("Déjà déconnecté (Evolution)."); updateAuthUI(false); return; }

        initAudioContext(); // Pour le son de déconnexion
        if (showMessages && driveStatusElement) { driveStatusElement.textContent = 'Déconnexion...'; driveStatusElement.className = 'loading'; driveStatusElement.style.display = 'inline-block'; }

        google.accounts.oauth2.revoke(token, () => {
            console.log('Token Google révoqué (Evolution).');
            googleAccessToken = null;
            programFileIds = { Push: null, Pull: null, Legs: null };
            programsAnalysisStatus = 'pending';
            loadedPrograms = { Push: [], Pull: [], Legs: [] };
            currentELOValues = {};
            overallAvgELO = ELO_BASE; // Réinitialise à la base
            currentGoalLevelKey = LEVEL_ORDER[1]; // Réinitialise au premier vrai niveau

            if (showMessages) { showMessage("Déconnecté de Google Drive.", 3000, 'info'); playSound('confirm'); }
            if (driveStatusElement) { driveStatusElement.textContent = ''; driveStatusElement.style.display = 'none'; }

            resetEvolutionDisplay();
            updateAuthUI(false);
        });
    }
    async function findFileId(filename) {
        if (!googleAccessToken) return null;
        console.log(`Recherche du fichier : ${filename}`);
        try {
            const response = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${filename}' and trashed=false&fields=files(id, name)`, {
                headers: { 'Authorization': `Bearer ${googleAccessToken}` }
            });
            if (!response.ok) {
                if (response.status === 401 || response.status === 403) {
                    console.warn(`Autorisation expirée ou invalide pour chercher ${filename}. Tentative de déconnexion.`);
                    handleSignoutClick(false); // Déconnexion silencieuse
                } else {
                    console.error(`Erreur API Drive (findFileId ${filename}): ${response.status} ${response.statusText}`);
                }
                throw new Error(`Erreur API Drive ${response.status}`);
            }
            const data = await response.json();
            if (data.files && data.files.length > 0) {
                console.log(`Fichier trouvé : ${filename} (ID: ${data.files[0].id})`);
                return data.files[0].id;
            } else {
                console.log(`Fichier non trouvé : ${filename}`);
                return null;
            }
        } catch (error) {
            console.error(`Erreur lors de la recherche du fichier ${filename}:`, error);
            return null;
        }
    }
    async function readFileContent(fileId) {
        if (!googleAccessToken || !fileId) return null;
        console.log(`Lecture du contenu du fichier ID: ${fileId}`);
        try {
            const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
                headers: { 'Authorization': `Bearer ${googleAccessToken}` }
            });
            if (!response.ok) {
                if (response.status === 401 || response.status === 403) {
                     console.warn(`Autorisation expirée ou invalide pour lire ${fileId}. Tentative de déconnexion.`);
                     handleSignoutClick(false); // Déconnexion silencieuse
                 } else {
                     console.error(`Erreur API Drive (readFileContent ${fileId}): ${response.status} ${response.statusText}`);
                 }
                throw new Error(`Erreur API Drive ${response.status}`);
            }
            const content = await response.text();
            console.log(`Contenu fichier ID ${fileId} lu.`);
            return content;
        } catch (error) {
            console.error(`Erreur lors de la lecture du fichier ${fileId}:`, error);
            return null; // Retourne null pour indiquer l'échec de lecture
        }
    }

    // --- Chargement des Programmes ---
    async function loadProgramsFromDrive() {
        if (!googleAccessToken) return 'error'; // Impossible de charger sans token
        console.log("Chargement des programmes depuis Drive (Evolution)...");
        let allSuccess = true; // Tous les fichiers trouvés, lus ET parsés
        let anySuccess = false; // Au moins un fichier trouvé, lu ET parsé
        const tempLoadedPrograms = { Push: [], Pull: [], Legs: [] };

        for (const type of PROGRAM_TYPES) {
            console.log(`--- Traitement programme: ${type} ---`);
            programFileIds[type] = await findFileId(PROGRAM_FILENAMES[type]);
            let fileSuccess = false;

            if (programFileIds[type]) {
                const content = await readFileContent(programFileIds[type]);
                if (content !== null) { // Lecture réussie
                    try {
                        const parsedContent = JSON.parse(content || '[]'); // Gère contenu vide
                        if (Array.isArray(parsedContent)) {
                            tempLoadedPrograms[type] = parsedContent;
                            fileSuccess = true; // Trouvé, lu, parsé
                            anySuccess = true;
                             if (tempLoadedPrograms[type].length === 0) console.warn(`Programme ${type} (ID: ${programFileIds[type]}) chargé mais vide.`);
                             else console.log(`Programme ${type} (ID: ${programFileIds[type]}) chargé (${tempLoadedPrograms[type].length} étapes).`);
                        } else {
                             console.error(`Contenu du programme ${type} (ID: ${programFileIds[type]}) n'est pas un tableau JSON.`);
                             showMessage(`Format invalide pour ${PROGRAM_FILENAMES[type]}. Ignoré.`, 4000, 'warning');
                             allSuccess = false;
                        }
                    } catch (e) {
                        console.error(`Erreur parsing JSON programme ${type} (ID: ${programFileIds[type]}):`, e);
                        showMessage(`Erreur format JSON ${PROGRAM_FILENAMES[type]}. Ignoré.`, 4000, 'error');
                        playSound('error');
                        allSuccess = false;
                    }
                } else { // Erreur lecture
                    console.warn(`Lecture programme ${type} (ID: ${programFileIds[type]}) échouée.`);
                    showMessage(`Impossible de lire ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning');
                    allSuccess = false;
                }
            } else { // Fichier non trouvé
                console.error(`Fichier ${PROGRAM_FILENAMES[type]} introuvable sur Drive. Ignoré.`);
                showMessage(`Fichier ${PROGRAM_FILENAMES[type]} introuvable.`, 4000, 'warning');
                allSuccess = false;
            }
             console.log(`--- Fin traitement ${type}. Succès fichier: ${fileSuccess} ---`);
        }

        loadedPrograms = tempLoadedPrograms; // Met à jour même si partiel

        console.log(`Fin chargement programmes (Evolution). Succès global: ${allSuccess}, Au moins un succès: ${anySuccess}`);

        if (allSuccess) return 'success';
        if (anySuccess) return 'partial';
        return 'error'; // Aucun fichier n'a pu être chargé/parsé correctement
    }


    // --- Logique de Calcul et Affichage ELO ---
    function getRepsFactor(reps) {
        const numericReps = parseInt(reps, 10);
        if (isNaN(numericReps) || reps === 'AMRAP' || reps === 'MAX') return REPS_FACTORS[Infinity]; // 'Infinity' pour AMRAP/MAX
        if (numericReps <= 8) return REPS_FACTORS[8];
        if (numericReps <= 12) return REPS_FACTORS[12];
        if (numericReps <= 18) return REPS_FACTORS[18];
        if (numericReps <= 25) return REPS_FACTORS[25];
        return REPS_FACTORS[Infinity]; // Plus de 25 reps => facteur max
    }
    function isPolyarticular(exerciseName) {
        const nameLower = exerciseName.toLowerCase();
        // Liste (non exhaustive) d'exercices polyarticulaires courants
        const polyKeywords = ['pompes', 'push up', 'dips', 'tractions', 'pull up', 'chin up', 'rowing', 'tirage', 'squat', 'fentes', 'soulevé', 'deadlift', 'développé', 'press', 'overhead press'];
        return polyKeywords.some(keyword => nameLower.includes(keyword));
    }
    function calculateExerciseELO(step) {
        if (!step || step.type !== 'exercise' || !step.details) return 0;

        const details = step.details;
        const baseResistance = RESISTANCE_BONUS[details.resistance] || 0;
        const repsFactor = getRepsFactor(details.reps);
        const techniqueBonus = (details.intensityTechnique && details.intensityTechnique !== 'Aucune') ? INTENSITY_TECHNIQUE_BONUS_MULTIPLIER : 1.0;

        // Calcul simple : (Résistance de base + ajustement reps) * bonus technique
        // On pourrait complexifier, mais gardons simple pour commencer
        // Ajout d'une base pour éviter ELO de 0 si Bodyweight et peu de reps
        const calculatedELO = ELO_BASE/10 + (baseResistance * repsFactor * techniqueBonus);

        //console.log(`ELO pour ${step.name} (${details.reps} reps, ${details.resistance}, Tech: ${details.intensityTechnique || 'Aucune'}) = ${Math.round(calculatedELO)} (BaseRes: ${baseResistance}, RepsFact: ${repsFactor}, TechBonus: ${techniqueBonus})`);
        return calculatedELO; // Retourne la valeur brute (pondération et moyenne faites ailleurs)
    }
    function mapExerciseToMuscleGroup(exerciseName) {
         const nameLower = exerciseName.toLowerCase();
         // Simplifié : mapper chaque exercice à un ou plusieurs groupes
         // TODO: Améliorer ce mapping, le rendre plus précis/configurable
         if (nameLower.includes('pompes') || nameLower.includes('push up') || nameLower.includes('dips') || nameLower.includes('développé couché') || nameLower.includes('chest press')) return ['Pectoraux', 'Triceps', 'Épaules'];
         if (nameLower.includes('tractions') || nameLower.includes('pull up') || nameLower.includes('chin up') || nameLower.includes('rowing') || nameLower.includes('tirage')) return ['Dos', 'Biceps'];
         if (nameLower.includes('développé militaire') || nameLower.includes('overhead press') || nameLower.includes('élévations latérales') || nameLower.includes('shoulder press')) return ['Épaules', 'Triceps'];
         if (nameLower.includes('curl') || nameLower.includes('biceps')) return ['Biceps'];
         if (nameLower.includes('extension triceps') || nameLower.includes('triceps pushdown') || nameLower.includes('skullcrusher')) return ['Triceps'];
         if (nameLower.includes('gainage') || nameLower.includes('planche') || nameLower.includes('crunch') || nameLower.includes('abdos') || nameLower.includes('core')) return ['Core'];
         if (nameLower.includes('squat') || nameLower.includes('fentes') || nameLower.includes('leg press') || nameLower.includes('leg extension') || nameLower.includes('leg curl') || nameLower.includes('mollets')) return ['Legs']; // Mappe aux jambes
         // Cas par défaut ou exercices inconnus
         console.warn(`Mapping musculaire non défini pour : ${exerciseName}`);
         return []; // Ne pas attribuer si inconnu
     }
    function analyzeProgramsAndCalculateELO() {
         console.log("Analyse des programmes et calcul ELO...");
         const groupData = {};
         // Initialise tous les groupes (y compris 'Legs') pour l'analyse
         ALL_MUSCLE_GROUPS.forEach(group => {
             groupData[group] = { totalWeightedElo: 0, totalWeight: 0 };
         });
         currentELOValues = {}; // Réinitialise les ELO actuels

         // Si le chargement a échoué complètement
         if (programsAnalysisStatus === 'error' || programsAnalysisStatus === 'pending') {
             console.warn("Analyse ELO annulée car aucun programme n'a pu être chargé correctement.");
             ALL_MUSCLE_GROUPS.forEach(group => { currentELOValues[group] = ELO_BASE; });
             overallAvgELO = ELO_BASE;
             return; // Sortir si pas de données
         }

         // Parcourt chaque type de programme (Push, Pull, Legs)
         PROGRAM_TYPES.forEach(type => {
             const program = loadedPrograms[type];
             if (!program || program.length === 0) {
                 console.log(`Programme ${type} vide ou non chargé, ignoré pour analyse ELO.`);
                 return;
             }
             console.log(`Analyse ELO pour programme: ${type} (${program.length} étapes)`);

             let currentExerciseName = null;
             let currentExerciseSets = 0;
             let lastExerciseStep = null;

             // Traite chaque étape du programme
             program.forEach((step, index) => {
                 if (step.type === 'exercise') {
                     // Si c'est le même exercice que le précédent, incrémente le compteur de séries
                     if (step.name === currentExerciseName && lastExerciseStep) {
                         currentExerciseSets++;
                     } else {
                         // Si un exercice précédent existait, le traiter avant de commencer le nouveau
                         if (lastExerciseStep) {
                             processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData);
                         }
                         // Réinitialiser pour le nouvel exercice
                         currentExerciseName = step.name;
                         currentExerciseSets = 1; // Première série de cet exercice
                     }
                     lastExerciseStep = step; // Mémorise la dernière étape d'exercice vue

                     // Si c'est la dernière étape du programme, traiter l'exercice en cours
                     if (index === program.length - 1) {
                         processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData);
                     }
                 } else if (step.type === 'break' || step.type === 'info') {
                     // Si une pause ou une info est rencontrée, traiter l'exercice précédent s'il existe
                     if (lastExerciseStep) {
                         processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData);
                     }
                     // Réinitialiser l'exercice en cours
                     currentExerciseName = null;
                     currentExerciseSets = 0;
                     lastExerciseStep = null;
                 }
             });
         });

         // Calcule l'ELO moyen pondéré pour chaque groupe
         let totalOverallEloSum = 0;
         let totalOverallWeight = 0;

         ALL_MUSCLE_GROUPS.forEach(group => {
             const data = groupData[group];
             if (data.totalWeight > 0) {
                 // Calcule l'ELO moyen pour le groupe
                 currentELOValues[group] = ELO_BASE + Math.round(data.totalWeightedElo / data.totalWeight);
             } else {
                 // Si aucune donnée pour ce groupe, ELO = Base
                 currentELOValues[group] = ELO_BASE;
             }

             // Contribue à la moyenne globale UNIQUEMENT si ce n'est pas les jambes et qu'il y a des données
             if (group !== 'Legs' && data.totalWeight > 0) {
                 // Utilise l'ELO relatif (au-dessus de la base) pour la somme pondérée
                 totalOverallEloSum += (currentELOValues[group] - ELO_BASE) * data.totalWeight;
                 totalOverallWeight += data.totalWeight;
             }
         });

         // Calcule l'ELO moyen global PONDÉRÉ (Haut du corps)
         overallAvgELO = totalOverallWeight > 0 ? ELO_BASE + Math.round(totalOverallEloSum / totalOverallWeight) : ELO_BASE;

         console.log("--- Résultats Analyse ELO ---");
         console.log("ELO Moyen Global Pondéré (Haut Corps):", overallAvgELO);
         console.log("ELO Moyen Pondéré par Groupe:", currentELOValues);
     }
    function processExerciseBlock(exerciseStep, numSets, groupData) {
        // Calcule l'ELO de base pour UNE série de cet exercice
        const eloPerSet = calculateExerciseELO(exerciseStep);

        if (eloPerSet > 0 && numSets > 0) {
            const isPoly = isPolyarticular(exerciseStep.name);
            // Pondération selon le type d'exercice (Polyarticulaire vs Isolation)
            const weightFactor = isPoly ? POLYARTICULAR_WEIGHT : ISOLATION_WEIGHT;
            // Groupes musculaires ciblés par cet exercice
            const targetGroups = mapExerciseToMuscleGroup(exerciseStep.name);

            //console.log(`Processing Block: ${exerciseStep.name} (${numSets} sets) - ELO/set: ${Math.round(eloPerSet)}, Poly: ${isPoly}, Weight: ${weightFactor.toFixed(1)}, Groups: ${targetGroups.join(', ')}`);

            targetGroups.forEach(group => {
                if (groupData[group]) {
                    // Ajoute l'ELO * le nombre de séries * le facteur de pondération
                    groupData[group].totalWeightedElo += eloPerSet * numSets * weightFactor;
                    // Ajoute le poids total (nombre de séries * facteur de pondération)
                    groupData[group].totalWeight += numSets * weightFactor;
                } else {
                    console.warn(`Groupe musculaire inconnu : ${group} pour ${exerciseStep.name}`);
                }
            });
        } else {
             //console.log(`Skipping Block Processing for ${exerciseStep.name}: ELO/set=${eloPerSet}, numSets=${numSets}`);
        }
    }


    // Détermine la CLÉ du niveau objectif actuel basé sur l'ELO global moyen
    function determineCurrentGoalLevelKey() {
        // Parcours les niveaux DANS L'ORDRE défini, en commençant par le premier VRAI niveau (L1)
        for (let i = 1; i < LEVEL_ORDER.length; i++) {
            const levelKey = LEVEL_ORDER[i];
            if (overallAvgELO < TARGET_ELO_LEVELS[levelKey].targetELO) {
                return levelKey; // C'est le premier niveau dont l'objectif ELO global n'est PAS atteint
            }
        }
        // Si tous les objectifs ELO globaux sont atteints, on retourne le dernier niveau
        return LEVEL_ORDER[LEVEL_ORDER.length - 1];
    }

    // Retourne la CLÉ du niveau précédent
    function getPreviousLevelKey(currentLevelKey) {
         const currentIndex = LEVEL_ORDER.indexOf(currentLevelKey);
         // Si c'est le premier vrai niveau (L1 ou plus), le précédent est l'index - 1
         // Si c'est L0 ou index invalide, retourne L0
         return currentIndex > 0 ? LEVEL_ORDER[currentIndex - 1] : LEVEL_ORDER[0];
    }

    // Fonction principale pour calculer et mettre à jour l'affichage
    function calculateAndDisplayEvolution() {
        console.log("Mise à jour de l'affichage de l'évolution...");
        if (!evolutionTrackerArea || !overallEloValueElement || !goalInfo || !targetLevelElement || !targetEloValueElement || !goalDescriptionElement || !muscleGroupsContainer || !globalProgressBar || !globalProgressPercentage || !globalGoalTitleElement || !globalProgressBarContainer) {
            console.error("Éléments DOM manquants pour afficher l'évolution.");
            if(muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p class="error-placeholder">Erreur interne: Impossible d\'afficher l\'évolution (DOM manquant).</p>';
            return;
        }

        // 1. Analyse et calcule les ELO (si les programmes ont été chargés au moins partiellement)
        // Cette fonction met à jour currentELOValues et overallAvgELO
        if (programsAnalysisStatus !== 'pending') {
            analyzeProgramsAndCalculateELO();
        } else {
            // Si on est ici sans avoir chargé (ex: erreur avant tokenCallback), réinitialiser les valeurs ELO
            ALL_MUSCLE_GROUPS.forEach(group => { currentELOValues[group] = ELO_BASE; });
            overallAvgELO = ELO_BASE;
        }


        // 2. Détermine le niveau objectif actuel et précédent basé sur overallAvgELO
        currentGoalLevelKey = determineCurrentGoalLevelKey();
        const currentGoal = TARGET_ELO_LEVELS[currentGoalLevelKey];
        const previousLevelKey = getPreviousLevelKey(currentGoalLevelKey);
        const previousGoal = TARGET_ELO_LEVELS[previousLevelKey];
        console.log(`Niveau Actuel: ${currentGoal.name} (Clé: ${currentGoalLevelKey}), Précédent: ${previousGoal.name} (Clé: ${previousLevelKey})`);

        // 3. Met à jour les statistiques globales
        animateValue(overallEloValueElement, parseFloat(overallEloValueElement.textContent.replace(/[^0-9.]/g, '')) || ELO_BASE, overallAvgELO, 700);
        overallEloLabelElement.textContent = "ELO Moyen (Haut du Corps)";

        // Met à jour le nom, l'icône, la couleur et le tooltip du niveau actuel
        targetLevelElement.innerHTML = `<i class="fas ${currentGoal.iconClass}" aria-hidden="true"></i> ${currentGoal.name}`;
        targetLevelElement.style.color = `var(${currentGoal.colorVar})`;
        targetLevelElement.setAttribute('title', currentGoal.description); // Description au survol

        targetEloValueElement.textContent = currentGoal.targetELO;
        goalDescriptionElement.textContent = currentGoal.description || "Description non disponible."; // Affiche aussi la description en dessous

        // 4. Génère les cartes des groupes musculaires (ceux définis dans MUSCLE_GROUPS_DISPLAY_ORDER)
        muscleGroupsContainer.innerHTML = ''; // Vide le conteneur
        let hasDataToShow = false;

        for (const category in MUSCLE_GROUPS_DISPLAY_ORDER) {
             const categoryDiv = document.createElement('div'); categoryDiv.className = 'muscle-category';
             const categoryHeader = document.createElement('h3'); categoryHeader.className = 'muscle-category-header'; categoryHeader.textContent = category; categoryDiv.appendChild(categoryHeader);
             const groupGridDiv = document.createElement('div'); groupGridDiv.className = 'muscle-group-grid';

             MUSCLE_GROUPS_DISPLAY_ORDER[category].forEach(group => {
                 hasDataToShow = true; // On a au moins une carte à afficher
                 const currentAvgELO = currentELOValues[group] || ELO_BASE;

                 // Cible ELO pour ce groupe DANS le niveau actuel
                 // Fallback : ELO global du niveau si non défini spécifiquement pour le groupe
                 const targetELO = currentGoal.groups[group] ?? currentGoal.targetELO;

                 // ELO de départ pour la progression DANS ce niveau
                 // C'est l'ELO cible (pour ce groupe) du niveau précédent.
                 // Fallback : ELO global du niveau précédent si non défini spécifiquement.
                 const stageStartELO = previousGoal.groups[group] ?? previousGoal.targetELO;

                 let progressPercent = 0;
                 const range = targetELO - stageStartELO;
                 if (range > 0) { // Évite division par zéro
                    // Calcul de la progression dans la plage [stageStartELO, targetELO]
                    progressPercent = ((currentAvgELO - stageStartELO) / range) * 100;
                 } else if (currentAvgELO >= targetELO) {
                     // Si l'objectif est atteint ou dépassé (ou si la plage est nulle/négative), progression = 100%
                     progressPercent = 100;
                 }
                 // Limite la progression entre 0 et 100%
                 progressPercent = Math.max(0, Math.min(100, Math.round(progressPercent)));

                 console.log(`Carte ${group}: ELO=${currentAvgELO}, Start=${stageStartELO}, Target=${targetELO}, Range=${range}, Prog%=${progressPercent}`);

                 const card = renderMuscleGroupCard(group, currentAvgELO, targetELO, progressPercent);
                 groupGridDiv.appendChild(card);
             });
             categoryDiv.appendChild(groupGridDiv);
             muscleGroupsContainer.appendChild(categoryDiv);
        }

        // Affiche un message si aucune donnée n'a pu être affichée
        if (!hasDataToShow && programsAnalysisStatus !== 'pending') {
             if (programsAnalysisStatus === 'error') {
                 muscleGroupsContainer.innerHTML = '<p class="error-placeholder">Aucune donnée de programme valide n\'a pu être analysée pour calculer l\'évolution.</p>';
             } else { // partial ou success mais sans groupe à afficher ? (ne devrait pas arriver avec la structure actuelle)
                  muscleGroupsContainer.innerHTML = '<p class="loading-placeholder">Aucune donnée d\'évolution à afficher pour les groupes musculaires sélectionnés.</p>';
             }
        }


        // 5. Met à jour la Barre de Progression Globale vers l'Objectif ULTIME
        const finalGoal = TARGET_ELO_LEVELS[LEVEL_ORDER[LEVEL_ORDER.length - 1]];
        globalGoalTitleElement.innerHTML = `<i class="fas ${finalGoal.iconClass}" style="color: var(${finalGoal.colorVar});"></i> Progression vers Objectif "${finalGoal.name}"`;
        let globalProgressPercent = 0;
        const globalRange = FINAL_TARGET_ELO - ELO_BASE;
        if (globalRange > 0) {
            globalProgressPercent = ((overallAvgELO - ELO_BASE) / globalRange) * 100;
        } else if (overallAvgELO >= FINAL_TARGET_ELO) {
            globalProgressPercent = 100;
        }
        globalProgressPercent = Math.max(0, Math.min(100, Math.round(globalProgressPercent)));

        globalProgressPercentage.textContent = `${globalProgressPercent}%`;
        globalProgressBar.style.width = `0%`; // Reset pour animation
        globalProgressBar.setAttribute('aria-valuenow', overallAvgELO); // Valeur actuelle
        globalProgressBar.setAttribute('aria-valuemin', ELO_BASE);      // Valeur minimale
        globalProgressBar.setAttribute('aria-valuemax', FINAL_TARGET_ELO); // Valeur maximale (objectif final)
        globalProgressBarContainer.setAttribute('title', `Progression globale (${globalProgressPercent}%) : ${overallAvgELO} / ${FINAL_TARGET_ELO} ELO vers l'objectif "${finalGoal.name}"`); // Tooltip détaillé
        // Déclenche l'animation de la barre après un court délai
        requestAnimationFrame(() => { setTimeout(() => { globalProgressBar.style.width = `${globalProgressPercent}%`; }, 50); });

        console.log("Affichage de l'évolution mis à jour.");
    }


    // Crée le HTML pour une carte de groupe musculaire
    function renderMuscleGroupCard(groupName, currentElo, targetElo, progressPercent) {
         const card = document.createElement('div');
         card.className = 'muscle-group-card';
         const iconClass = MUSCLE_GROUP_ICONS[groupName] || 'fa-question-circle'; // Icône par défaut
         const currentGoalName = TARGET_ELO_LEVELS[currentGoalLevelKey].name; // Nom du niveau actuel

         // Tooltip principal de la carte
         card.setAttribute('title', `${groupName} - ELO Actuel: ${currentElo}. Objectif (${currentGoalName}): ${targetElo}. Progression vers cet objectif: ${progressPercent}%.`);

         card.innerHTML = `
             <div class="muscle-group-header">
                 <i class="fas ${iconClass}" aria-hidden="true"></i>
                 <h4 class="muscle-group-title">${groupName}</h4>
             </div>
             <div class="elo-info">
                 <span class="current-elo" title="ELO actuel calculé pour ${groupName}">${currentElo}</span>
                 <span class="target-elo" title="ELO cible pour ${groupName} dans l'objectif '${currentGoalName}'">Objectif: <strong title="ELO cible ${targetElo}">${targetElo}</strong></span>
             </div>
             <div class="progress-bar-container" title="Progression (${progressPercent}%) vers l'objectif ELO ${targetElo} pour ${groupName}" aria-label="Progression pour ${groupName}: ${progressPercent}%">
                 <div class="progress-bar" style="width: 0%;" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                     <span class="progress-percentage">${progressPercent}%</span>
                 </div>
             </div>
         `;

         // Animation de la barre de progression spécifique à la carte
         requestAnimationFrame(() => {
             // Petit délai pour s'assurer que l'élément est dans le DOM et que le reset width:0% a été appliqué
             setTimeout(() => {
                 const progressBar = card.querySelector('.progress-bar');
                 if (progressBar) {
                     progressBar.style.width = `${progressPercent}%`;
                     progressBar.setAttribute('aria-valuenow', progressPercent); // Met à jour la valeur ARIA
                 }
             }, 50); // 50ms délai
         });

         return card;
     }

    // Réinitialise l'affichage ELO à l'état initial ou de chargement
    function resetEvolutionDisplay() {
        console.log("Réinitialisation de l'affichage de l'évolution...");
        // Vide le conteneur des groupes musculaires et affiche un message d'attente
        if (muscleGroupsContainer) {
             if(googleAccessToken) { muscleGroupsContainer.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Analyse des programmes...</p>'; }
             else { muscleGroupsContainer.innerHTML = '<p class="loading-placeholder">Connectez-vous pour charger vos données...</p>'; }
         }

        // Réinitialise les stats globales
        if (overallEloValueElement) overallEloValueElement.textContent = '--';
        if (overallEloLabelElement) overallEloLabelElement.textContent = 'ELO Moyen (Haut du Corps)';

        // Réinitialise l'info de l'objectif actuel
        if (targetLevelElement) {
            targetLevelElement.innerHTML = `<i class="fas fa-question-circle" aria-hidden="true"></i> Indéfini`;
            targetLevelElement.style.color = ''; // Reset couleur
            targetLevelElement.setAttribute('title', 'Connectez-vous pour déterminer votre niveau objectif');
        }
        if (targetEloValueElement) targetEloValueElement.textContent = '--';
        if (goalDescriptionElement) goalDescriptionElement.textContent = 'Connectez-vous et chargez vos programmes pour voir la description de votre objectif.';

        // Réinitialise la barre de progression globale
        if (globalProgressBar) {
             globalProgressBar.style.width = '0%';
             globalProgressBar.setAttribute('aria-valuenow', ELO_BASE); // Retourne à la base pour aria
             globalProgressBar.setAttribute('aria-valuemin', ELO_BASE); // Min est ELO_BASE
             globalProgressBar.setAttribute('aria-valuemax', FINAL_TARGET_ELO); // Max est l'objectif final
        }
        if (globalProgressPercentage) globalProgressPercentage.textContent = '0%';
        if (globalGoalTitleElement) {
             const finalGoal = TARGET_ELO_LEVELS[LEVEL_ORDER[LEVEL_ORDER.length - 1]];
             globalGoalTitleElement.innerHTML = `<i class="fas ${finalGoal.iconClass}" style="color: var(${finalGoal.colorVar});"></i> Progression vers Objectif "${finalGoal.name}"`;
         }
        if (globalProgressBarContainer) { globalProgressBarContainer.setAttribute('title', `Progression globale (0%) vers l'objectif final (ELO ${FINAL_TARGET_ELO})`); }
     }


    // --- Animation de Chiffre Simple ---
    function animateValue(element, start, end, duration) {
        if (!element) return;
        if (start === end) { element.textContent = Math.round(end); return; }

        const range = end - start;
        let current = start;
        const increment = end > start ? 1 : -1;
        const stepTime = Math.abs(Math.floor(duration / range));
        // Limite le stepTime pour éviter des animations trop lentes/rapides sur de grandes/petites différences
        const effectiveStepTime = Math.max(1, Math.min(stepTime, 50));

        const timer = setInterval(() => {
            current += increment * Math.max(1, Math.round(Math.abs(end - current) / 10)); // Accélère vers la fin
            if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                current = end;
                clearInterval(timer);
            }
            element.textContent = Math.round(current);
        }, effectiveStepTime);
    }

    // --- UI Update ---
    function updateAuthUI(isLoggedIn) {
         console.log(`Update UI (Evolution) - Connecté: ${isLoggedIn}, GIS prêt: ${!!tokenClient}`);
         const body = document.body;
         body.classList.toggle('logged-in', isLoggedIn);
         body.classList.toggle('logged-out', !isLoggedIn);

         // Activer/désactiver les boutons en fonction de l'état et de la disponibilité de GIS
         if(signInButton) signInButton.disabled = isLoggedIn || !tokenClient;
         if(signInButtonPrompt) signInButtonPrompt.disabled = isLoggedIn || !tokenClient;
         if(signOutButton) signOutButton.disabled = !isLoggedIn;
         if(themeToggleBtn) themeToggleBtn.disabled = false; // Le thème est toujours dispo

         // Afficher/masquer l'état Drive uniquement si connecté
         if(driveStatusElement) { driveStatusElement.style.display = isLoggedIn ? 'inline-block' : 'none'; if (!isLoggedIn) { driveStatusElement.textContent = ''; driveStatusElement.className = ''; } }

         // Afficher/masquer les sections principales
         if (connectionPrompt) connectionPrompt.style.display = isLoggedIn ? 'none' : 'block';
         if (evolutionTrackerArea) evolutionTrackerArea.style.display = isLoggedIn ? 'flex' : 'none';

         // Si déconnecté, réinitialiser l'affichage et l'état des programmes
         if (!isLoggedIn) {
             programsAnalysisStatus = 'pending';
             resetEvolutionDisplay();
         }
     }

    // --- Gestion Thème ---
    function applyTheme(theme) {
        document.body.classList.remove('light-theme', 'dark-theme');
        document.body.classList.add(theme + '-theme');
        currentTheme = theme;
        localStorage.setItem('armorWorkoutTheme', theme);
        // Mettre à jour l'icône du bouton
        if (themeToggleBtn) {
            const icon = themeToggleBtn.querySelector('i');
            if (icon) {
                icon.className = `fas fa-${theme === 'dark' ? 'sun' : 'moon'}`;
            }
            themeToggleBtn.setAttribute('aria-label', `Passer au thème ${theme === 'dark' ? 'clair' : 'sombre'}`);
        }
        console.log(`Thème appliqué: ${theme}`);
    }
    function toggleTheme() {
        const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
        applyTheme(newTheme);
        playSound('confirm'); // Petit son pour le changement de thème
    }
    function loadSavedTheme() {
        const savedTheme = localStorage.getItem('armorWorkoutTheme') || 'dark'; // Défaut sombre
        applyTheme(savedTheme);
    }

    // --- Message Area ---
    function showMessage(msg, duration = 3000, type = 'info') { // types: 'info', 'success', 'error', 'warning'
         if (!messageArea) return;
         messageArea.textContent = msg;
         // Applique les classes : base + type + visible
         messageArea.className = `message-area ${type} visible`;

         // Efface le timeout précédent s'il existe
         if (messageTimeoutId) clearTimeout(messageTimeoutId);

         // Cache le message après la durée spécifiée
         messageTimeoutId = setTimeout(() => {
             messageArea.classList.remove('visible');
             // Optionnel : Reset complètement les classes après la transition de disparition
             // pour éviter des styles résiduels si un autre message arrive très vite.
              setTimeout(() => {
                  if (!messageArea.classList.contains('visible')) {
                       messageArea.className = 'message-area';
                  }
             }, 500); // Doit être >= durée de la transition CSS pour 'opacity' et 'transform'
         }, duration);
     }

    // --- Initialisation ---
    function initializeDOMReferences() {
         console.log("Init DOM Refs (Evolution)...");
         signInButton = document.getElementById('signin-button');
         signOutButton = document.getElementById('signout-button');
         driveStatusElement = document.getElementById('drive-status');
         themeToggleBtn = document.getElementById('theme-toggle-btn');
         signInButtonPrompt = document.getElementById('signin-button-prompt');
         connectionPrompt = document.getElementById('connection-prompt');
         evolutionTrackerArea = document.getElementById('evolution-tracker-area');
         overallEloDisplay = document.getElementById('overall-elo-display');
         if (overallEloDisplay) {
             overallEloValueElement = overallEloDisplay.querySelector('.value');
             overallEloLabelElement = overallEloDisplay.querySelector('.label');
         }
         goalInfo = document.getElementById('goal-info');
         if (goalInfo) {
            targetLevelElement = goalInfo.querySelector('.target-level');
            targetEloValueElement = goalInfo.querySelector('.target-elo-value');
         }
         goalDescriptionElement = document.getElementById('goal-description');
         muscleGroupsContainer = document.getElementById('muscle-groups-container');
         messageArea = document.getElementById('message-area');
         globalProgressBar = document.getElementById('global-progress-bar');
         globalProgressPercentage = document.getElementById('global-progress-percentage');
         globalGoalTitleElement = document.getElementById('global-goal-title');
         globalProgressBarContainer = document.getElementById('global-goal-progress-section')?.querySelector('.global-progress-bar-container'); // Sélection plus précise

         // Vérification critique
         const criticalElements = [signInButton, signOutButton, driveStatusElement, themeToggleBtn, signInButtonPrompt, connectionPrompt, evolutionTrackerArea, overallEloDisplay, overallEloValueElement, overallEloLabelElement, goalInfo, targetLevelElement, targetEloValueElement, goalDescriptionElement, muscleGroupsContainer, messageArea, globalProgressBar, globalProgressPercentage, globalGoalTitleElement, globalProgressBarContainer];
         if (criticalElements.some(el => !el)) {
              console.error("Éléments DOM CRITIQUES manquants ! Vérifiez les IDs HTML.", criticalElements);
              showMessage("Erreur critique: Interface utilisateur incomplète.", 10000, 'error');
              // Peut-être désactiver toute l'application ici ou afficher un message persistant
              document.body.innerHTML = '<p style="color:red; padding: 20px; text-align: center;">Erreur critique: L\'application ne peut pas démarrer car des éléments essentiels de l\'interface sont manquants. Vérifiez la console pour plus de détails.</p>';
              return false; // Indique un échec
         }
         console.log("DOM Refs initialisées (Evolution).");
         return true; // Indique le succès
     }
    function addEventListeners() {
        if(signInButton) signInButton.addEventListener('click', handleAuthClick);
        if(signInButtonPrompt) signInButtonPrompt.addEventListener('click', handleAuthClick);
        if(signOutButton) signOutButton.addEventListener('click', () => handleSignoutClick(true)); // true pour showMessages
        if(themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme);
        // Initialise l'AudioContext sur la première interaction utilisateur (bonne pratique)
        document.body.addEventListener('click', initAudioContext, { once: true });
        document.body.addEventListener('keydown', initAudioContext, { once: true });
        console.log("Écouteurs d'événements ajoutés (Evolution).");
    }

    // --- Point d'entrée ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Chargé (Evolution). Initialisation...");
        try {
            if (!initializeDOMReferences()) return; // Arrête si les refs DOM échouent
            addEventListeners();
            loadSavedTheme();
            updateAuthUI(false); // État initial déconnecté
            resetEvolutionDisplay(); // Assure un état propre initial
            checkAndInitGis(); // Lance l'initialisation de Google Sign-In
            console.log("Initialisation Evolution terminée. Attente API Google et action utilisateur...");
        } catch (error) {
            console.error("Erreur majeure lors de l'initialisation DOMContentLoaded (Evolution):", error);
             showMessage("Erreur critique au chargement du suivi.", 10000, 'error');
             const body = document.querySelector('body');
             if(body) {
                body.innerHTML = '<p style="color:red; padding: 20px; text-align: center; font-family: sans-serif;">Une erreur critique est survenue lors du chargement de la page. Veuillez vérifier la console du navigateur pour les détails techniques et réessayer plus tard.</p>';
             }
        }
    });

</script>

</body>
</html>
