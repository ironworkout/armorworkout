
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Évolution HPS (v7.2 - JSON Sync)</title>
    <!-- Font Awesome & Google Fonts -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        /* --- Variables CSS & Thèmes --- */
        :root {
            /* Thème Sombre */
            --bg-color-dark: #0a0f1e; --secondary-bg-color-dark: #141a30; --primary-text-color-dark: #e0e0ff; --secondary-text-color-dark: #8a94c1; --border-color-dark: #2a3150; --accent-border-color-dark: #4b558a; --input-bg-dark: #0a0f1e;
            /* Couleurs Néon/Gradient */
            --neon-blue: #6fa8ff; --neon-purple: #b18cff; --gradient-start: var(--neon-purple); --gradient-end: var(--neon-blue); --neon-green: #3fb950; --neon-red: #ff7b72; --neon-orange: #f9a825; --neon-yellow: #facc15;
            /* Couleurs Niveaux */
            --level-bronze-color: #cd7f32;   --level-bronze-bg: rgba(205, 127, 50, 0.15);
            --level-silver-color: #c0c0c0;   --level-silver-bg: rgba(192, 192, 192, 0.15);
            --level-gold-color: #ffd700;     --level-gold-bg: rgba(255, 215, 0, 0.15);
            --level-crystal-color: #a7d8de;  --level-crystal-bg: rgba(167, 216, 222, 0.15);
            --level-master-color: #e384f1;   --level-master-bg: rgba(227, 132, 241, 0.15);
            --level-champion-color: #ff7b72; --level-champion-bg: rgba(255, 123, 114, 0.15);
            --level-titan-color: #aa99ff;    --level-titan-bg: rgba(170, 153, 255, 0.15);
            --level-legende-color: #fff7a3;  --level-legende-bg: rgba(255, 247, 163, 0.2);
            --level-marvel-color: #e62429;   --level-marvel-bg: rgba(230, 36, 41, 0.1);
            /* Glows */
            --glow-gradient: 0 0 20px rgba(177, 140, 255, 0.4), 0 0 30px rgba(111, 168, 255, 0.3); --glow-level-reached: 0 0 15px rgba(63, 185, 80, 0.7); --glow-connect: 0 0 10px rgba(63, 185, 80, 0.6); --glow-disconnect: 0 0 10px rgba(255, 123, 114, 0.6); --glow-marvel: 0 0 15px rgba(230, 36, 41, 0.6);
            /* Autres */
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --border-radius-lg: 18px; --border-radius-md: 12px; --border-radius-sm: 8px; --transition-speed: 0.3s;
            /* RGBA */
            --bg-color-dark-rgb: 10, 15, 30; --secondary-bg-color-dark-rgb: 20, 26, 48; --primary-text-color-dark-rgb: 224, 224, 255; --secondary-text-color-dark-rgb: 138, 148, 193; --border-color-dark-rgb: 42, 49, 80; --neon-blue-rgb: 111, 168, 255; --neon-purple-rgb: 177, 140, 255; --neon-green-rgb: 63, 185, 80; --neon-red-rgb: 255, 123, 114; --neon-orange-rgb: 249, 168, 37;
            /* Thème Sombre (Actif) */
            --bg-color: var(--bg-color-dark); --secondary-bg-color: var(--secondary-bg-color-dark); --primary-text-color: var(--primary-text-color-dark); --secondary-text-color: var(--secondary-text-color-dark); --border-color: var(--border-color-dark); --accent-border-color: var(--accent-border-color-dark); --input-bg: var(--input-bg-dark); --bg-color-rgb: var(--bg-color-dark-rgb); --secondary-bg-color-rgb: var(--secondary-bg-color-dark-rgb);
            /* Styles Spécifiques */
            --link-color: var(--neon-blue); --button-connect-color: var(--neon-green); --button-connect-glow: var(--glow-connect); --button-disconnect-color: var(--neon-red); --button-disconnect-glow: var(--glow-disconnect);
            /* Barres Progression */
            --progress-bar-bg: rgba(var(--primary-text-color-rgb), 0.1);
            --progress-bar-fill: linear-gradient(90deg, var(--gradient-start), var(--gradient-end));
            /* Scrollbar */
            --scrollbar-track-bg: rgba(var(--primary-text-color-rgb), 0.05);
            --scrollbar-thumb-bg: var(--accent-border-color);
            --scrollbar-thumb-hover-bg: var(--neon-blue);
        }

        /* --- Styles CSS Généraux --- */
        * { box-sizing: border-box; margin: 0; padding: 0; scrollbar-color: var(--scrollbar-thumb-bg) var(--scrollbar-track-bg); scrollbar-width: thin; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--primary-text-color); line-height: 1.6; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; display: flex; flex-direction: column; min-height: 100vh; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; padding-top: 135px; /* Ajusté pour le nouveau header */ }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb-bg); border-radius: 4px; border: 2px solid var(--scrollbar-track-bg); }
        ::-webkit-scrollbar-thumb:hover { background-color: var(--scrollbar-thumb-hover-bg); }
        .container { max-width: 450px; margin: 0 auto; padding: 20px 15px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }
        #app-header { position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; background-color: rgba(var(--bg-color-rgb), 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-bottom: 1px solid var(--border-color); transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease; }
        .header-content { display: flex; flex-direction: column; align-items: center; max-width: 450px; margin: 0 auto; padding: 10px 15px 5px; gap: 8px; }

        /* Groupement titre + boutons navigation pages */
        .header-top-row { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 8px; }
        header .title-container { display: flex; flex-direction: column; align-items: center; gap: 5px; flex-grow: 1; text-align: center; }
        header .title-container i.header-icon { font-size: 1.8em; color: var(--primary-text-color); opacity: 0.8; }
        header h1 { font-size: 1.1em; color: var(--primary-text-color); margin: 0; font-weight: 500; letter-spacing: 0.1em; text-transform: uppercase; }
        .page-nav-buttons { display: flex; gap: 10px; flex-shrink: 0; }
        .page-nav-buttons a button { background: none; border: 1px solid var(--accent-border-color); color: var(--secondary-text-color); padding: 6px 10px; border-radius: var(--border-radius-md); font-size: 0.8em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 5px; }
        .page-nav-buttons a button:hover { border-color: var(--neon-blue); color: var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); }
        .page-nav-buttons a button i { font-size: 0.9em; }

        /* Actions connexion / thème restent en dessous */
        .header-actions { display: flex; gap: 15px; align-items: center; justify-content: space-between; width: 100%; margin-top: 5px; }
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button { background: none; border: 1px solid var(--border-color); color: var(--secondary-text-color); padding: 5px 12px; border-radius: var(--border-radius-md); font-size: 0.8em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 5px; }
        .auth-controls button:disabled { opacity: 0.4; cursor: not-allowed; background: transparent !important; border-color: var(--border-color) !important; color: var(--secondary-text-color) !important; box-shadow: none !important; }
        .auth-controls button:not(:disabled):hover { border-color: var(--accent-border-color); color: var(--primary-text-color); background-color: rgba(var(--primary-text-color-rgb), 0.05); }
        #signin-button, #signin-button-prompt { border-color: var(--button-connect-color); color: var(--button-connect-color); }
        #signin-button:not(:disabled):hover, #signin-button-prompt:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--button-connect-glow); }
        #signout-button { border-color: var(--button-disconnect-color); color: var(--button-disconnect-color); }
        #signout-button:not(:disabled):hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--button-disconnect-glow); }
        #drive-status { display: none; }
        .theme-toggle button { background: none; border: none; color: var(--secondary-text-color); font-size: 1.1em; padding: 5px; cursor: pointer; transition: color var(--transition-speed) ease; }
        .theme-toggle button:hover { color: var(--neon-purple); }
        #app-nav { display: flex; justify-content: center; gap: 5px; padding: 8px 10px; border-top: 1px solid var(--border-color); background-color: rgba(var(--secondary-bg-color-rgb), 0.5); }
        .nav-button { background: none; border: none; color: var(--secondary-text-color); font-size: 0.8em; font-weight: 500; padding: 5px 10px; border-radius: var(--border-radius-md); cursor: pointer; transition: all 0.2s ease; border: 1px solid transparent; display: inline-flex; align-items: center; gap: 5px;}
        .nav-button i { font-size: 1.0em; width: 1.1em; text-align: center;}
        .nav-button:hover { color: var(--primary-text-color); background-color: rgba(var(--primary-text-color-rgb), 0.05); }
        .nav-button.active { color: var(--neon-blue); border-color: var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); font-weight: 700; }
        .nav-button:disabled { opacity: 0.5; cursor: not-allowed; color: var(--secondary-text-color) !important; background: none !important; border-color: transparent !important;}
        /* Affichage Conditionnel */
        body.logged-out .nav-button { display: none; }
        body.logged-out #signin-button, body.logged-out #signin-button-prompt { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-in #signin-button, body.logged-in #signin-button-prompt { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-out #connection-prompt { display: block; }
        body.logged-in #connection-prompt { display: none; }
        body.logged-out .app-section { display: none; }
        body.logged-in .app-section { display: none; }
        /* Main & Prompt */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 20px; }
        #connection-prompt { text-align: center; padding: 30px 20px; background-color: var(--secondary-bg-color); border-radius: var(--border-radius-lg); border: 1px dashed var(--border-color); margin: 20px auto; max-width: 90%; }
        #connection-prompt p { margin-bottom: 15px; color: var(--secondary-text-color); font-size: 0.9em;}
        #connection-prompt button { padding: 8px 18px; font-size: 0.9em; }
        .app-section { width: 100%; }

        /* Section Évolution (HPS) */
        #evolution-tracker-area { display: flex; flex-direction: column; gap: 20px; }
        .global-stats-card { background-color: var(--secondary-bg-color); border-radius: var(--border-radius-lg); padding: 25px 20px; text-align: center; border: 1px solid var(--border-color); box-shadow: 0 10px 30px rgba(0,0,0, 0.2); position: relative; overflow: hidden; }
        .global-stats-card::before { content: ''; position: absolute; top: -30%; left: -30%; width: 160%; height: 160%; background: radial-gradient(circle, rgba(var(--neon-blue-rgb), 0.08) 0%, rgba(var(--neon-blue-rgb), 0) 60%); animation: rotateGlow 15s linear infinite; pointer-events: none; opacity: 0.7; }
        @keyframes rotateGlow { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .global-stats-card .card-title { font-size: 0.9em; color: var(--secondary-text-color); margin-bottom: 10px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
        #overall-hps-display .value { font-size: 4.5em; font-weight: 900; line-height: 1; margin-bottom: 15px; display: block; background: linear-gradient(90deg, var(--gradient-start), var(--gradient-end)); -webkit-background-clip: text; background-clip: text; color: transparent; text-shadow: var(--glow-gradient); animation: pulse-text 3s infinite ease-in-out; }
        @keyframes pulse-text { 0%, 100% { text-shadow: var(--glow-gradient); opacity: 1; } 50% { text-shadow: 0 0 15px rgba(177, 140, 255, 0.3), 0 0 25px rgba(111, 168, 255, 0.2); opacity: 0.95; } }
        #level-badge-container { display: inline-flex; align-items: center; gap: 10px; position: relative; cursor: default; }
        #level-badge { display: inline-flex; align-items: center; gap: 8px; padding: 6px 15px; border-radius: var(--border-radius-md); font-size: 0.9em; font-weight: 700; border: 1px solid transparent; transition: all var(--transition-speed) ease; cursor: pointer; }
        #level-badge i { font-size: 1.2em; width: 1.2em; text-align: center;}
        #level-badge .sub-level { font-size: 0.9em; font-weight: 500; margin-left: 4px; opacity: 0.9; }
        .marvel-achieved-icon { font-size: 1.1em; color: var(--level-marvel-color); vertical-align: middle; cursor: help; text-shadow: var(--glow-marvel); animation: marvelIconPulse 2s infinite ease-in-out; }
        @keyframes marvelIconPulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.8; } }
        .target-info-container { margin-top: 10px; font-size: 0.85em; color: var(--secondary-text-color); display: flex; flex-wrap: wrap; justify-content: center; gap: 5px 10px; }
        .target-info-container span { margin: 0; } .target-info-container strong { font-weight: 700; color: var(--primary-text-color); } .target-info-container .marvel-target { color: var(--level-marvel-color); font-weight: 700;}
        @keyframes levelUpGlow { 0% { box-shadow: 0 10px 30px rgba(0,0,0, 0.2), 0 0 0px rgba(var(--neon-green-rgb), 0); border-color: var(--border-color);} 50% { box-shadow: 0 10px 30px rgba(0,0,0, 0.1), 0 0 30px rgba(var(--neon-green-rgb), 0.7); border-color: var(--neon-green);} 100% { box-shadow: 0 10px 30px rgba(0,0,0, 0.2), 0 0 0px rgba(var(--neon-green-rgb), 0); border-color: var(--border-color);} }
        #muscle-groups-container { display: flex; flex-direction: column; gap: 15px; }
        .muscle-group-card { background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 15px; display: flex; flex-direction: column; gap: 10px; transition: all var(--transition-speed) ease; position: relative; overflow: hidden; }
        .muscle-group-card:hover { border-color: var(--accent-border-color); transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0, 0.15); }
        .muscle-group-card .card-header { display: flex; align-items: center; gap: 12px; margin-bottom: 10px; }
        .muscle-group-card .icon-container { flex-shrink: 0; color: var(--secondary-text-color); font-size: 1.8em; width: 35px; text-align: center; opacity: 0.7; }
        .muscle-group-card .title-container { flex-grow: 1; } .muscle-group-card .group-title { font-size: 1.05em; font-weight: 700; color: var(--primary-text-color); line-height: 1.2; } .muscle-group-card .group-subtitle { font-size: 0.85em; color: var(--secondary-text-color); font-weight: 400; line-height: 1.2; margin-bottom: 2px; }
        .muscle-group-card .group-level-name { font-size: 0.8em; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; line-height: 1; padding: 2px 6px; border-radius: var(--border-radius-sm); display: inline-block; margin-top: 4px; border: 1px solid; cursor: default; }
        .muscle-group-card .group-level-name .sub-level { font-size: 0.9em; font-weight: 500; margin-left: 4px; opacity: 0.9; }
        .muscle-group-card .hps-details { font-size: 0.9em; font-weight: 500; color: var(--secondary-text-color); text-align: right; white-space: nowrap; line-height: 1.2; }
        .muscle-group-card .hps-details .current { color: var(--primary-text-color); font-weight: 700; }
        .muscle-group-card .hps-details .target { }
        .muscle-group-card .hps-details .percentage-in-details { display: block; font-size: 0.8em; margin-top: 2px; color: var(--secondary-text-color); }

        /* Vue niveaux dans carte muscle */
        .muscle-level-progression { margin-top: 10px; position: relative; height: 25px; display: flex; align-items: center; padding: 0 5px; }
        .muscle-level-progression::before { content: ''; position: absolute; left: 15px; right: 15px; top: 50%; transform: translateY(-50%); height: 3px; background-color: var(--border-color); border-radius: 1.5px; z-index: 0; }
        .level-indicator { position: absolute; top: 50%; transform: translate(-50%, -50%); width: 18px; height: 18px; border-radius: 50%; background-color: var(--secondary-bg-color); border: 2px solid; z-index: 1; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
        .level-indicator i { font-size: 0.6em; color: inherit; }
        .level-indicator:hover { transform: translate(-50%, -50%) scale(1.2); }
        .level-indicator.current { transform: translate(-50%, -50%) scale(1.3); box-shadow: 0 0 10px; /* Couleur via style */ }
        .current-level-fill { position: absolute; left: 0; top: 50%; transform: translateY(-50%); height: 3px; background: var(--gradient-end); border-radius: 1.5px; z-index: 0; width: 0%; transition: width 0.8s cubic-bezier(0.25, 1, 0.5, 1); }

        /* Barre de pourcentage SOUS la vue niveaux */
        .percentage-progress-section { display: flex; align-items: center; gap: 8px; margin-top: 8px; padding: 0 5px;}
        .percentage-bar-container { flex-grow: 1; height: 6px; background-color: var(--progress-bar-bg); border-radius: 3px; overflow: hidden; }
        .percentage-bar-fill { height: 100%; width: 0%; background: var(--progress-bar-fill); border-radius: 3px; transition: width 0.8s cubic-bezier(0.25, 1, 0.5, 1); }
        .percentage-value-text { font-size: 0.85em; font-weight: 600; color: var(--secondary-text-color); flex-shrink: 0; width: 35px; text-align: right; }

        /* Section Config Équipement */
        #program-config-area { background-color: transparent; border-radius: 0; padding: 15px 5px; border: none; margin-top: 10px; display: flex; flex-direction: column; }
        #program-config-area h2 { font-size: 1.4em; color: var(--primary-text-color); border-bottom: 2px solid var(--neon-blue); padding-bottom: 10px; margin-bottom: 25px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 10px;}
        #program-config-content { flex-grow: 1; overflow-y: auto; max-height: 65vh; padding-right: 5px; }
        .program-config-section { margin-bottom: 30px; background-color: var(--secondary-bg-color); border-radius: var(--border-radius-md); padding: 15px; border: 1px solid var(--border-color); }
        .program-config-section h3 { font-size: 1.2em; color: var(--neon-purple); margin-bottom: 15px; font-weight: 700; text-align: center; border-bottom: 1px dashed var(--border-color); padding-bottom: 8px;}
        .config-exercise-item { margin-bottom: 20px; padding: 15px; background-color: rgba(var(--bg-color-rgb), 0.5); border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); }
        .config-exercise-item .exercise-name { font-weight: 700; display: block; margin-bottom: 10px; color: var(--primary-text-color); font-size: 1.05em; border-bottom: 1px solid var(--accent-border-color); padding-bottom: 5px;}
        .config-equipment-options { display: grid; grid-template-columns: 1fr; gap: 10px; }
        @media (min-width: 400px) { .config-equipment-options { grid-template-columns: 1fr 1fr; } }
        .config-equipment-options label { display: flex; align-items: center; gap: 8px; font-size: 0.95em; cursor: pointer; padding: 8px 10px; border-radius: var(--border-radius-sm); transition: background-color 0.2s ease; border: 1px solid var(--border-color);}
        .config-equipment-options label:hover { background-color: rgba(var(--primary-text-color-rgb), 0.1); }
        .config-equipment-options input[type="checkbox"] { accent-color: var(--neon-blue); cursor: pointer; width: 16px; height: 16px; flex-shrink: 0; }
        #save-config-button { display: block; width: 100%; background-color: var(--neon-blue); color: #fff; border: none; padding: 12px 15px; border-radius: var(--border-radius-md); font-size: 1.1em; font-weight: 700; cursor: pointer; transition: background-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease; text-align: center; margin-top: 25px; flex-shrink: 0; }
        #save-config-button:hover:not(:disabled) { background-color: var(--gradient-end); box-shadow: 0 0 10px rgba(var(--neon-blue-rgb), 0.5); }
        #save-config-button:disabled { background-color: var(--secondary-text-color); cursor: not-allowed; box-shadow: none; opacity: 0.6; }
        #save-config-button .spinner { display: none; margin-left: 10px; } #save-config-button.saving .spinner { display: inline-block; } #save-config-button.saving span { display: none; }


        /* Section Historique */
        #history-area { background-color: transparent; border: none; padding: 15px 5px; margin-top: 10px; display: flex; flex-direction: column; }
        #history-area h2 { font-size: 1.4em; color: var(--primary-text-color); border-bottom: 2px solid var(--neon-green); padding-bottom: 10px; margin: 0 10px 25px 10px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 10px;}
        .history-controls { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin: 0 10px 20px 10px; }
        .history-controls select, .history-controls button { padding: 6px 12px; background-color: var(--secondary-bg-color); color: var(--primary-text-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); font-size: 0.9em; cursor: pointer; transition: all 0.2s ease; }
        .history-controls select:hover, .history-controls button:hover { border-color: var(--accent-border-color); background-color: rgba(var(--primary-text-color-rgb), 0.05); }
        .history-controls button.active { background-color: var(--neon-green); color: var(--bg-color); border-color: var(--neon-green); font-weight: bold; }
        #history-display { margin: 0 10px; padding: 20px; background-color: var(--secondary-bg-color); border-radius: var(--border-radius-md); border: 1px solid var(--border-color); text-align: center; color: var(--secondary-text-color); min-height: 100px; }
        #history-display .trend-value { font-weight: bold; font-size: 1.2em; display: inline-block; margin: 0 5px; }
        #history-display .trend-positive { color: var(--neon-green); }
        #history-display .trend-negative { color: var(--neon-red); }
        #history-display .trend-neutral { color: var(--secondary-text-color); }

        /* Modal */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); display: flex; justify-content: center; align-items: center; z-index: 5000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--secondary-bg-color); padding: 25px; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); max-width: 90%; width: 400px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); position: relative; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .modal-title { font-size: 1.2em; font-weight: 700; display: flex; align-items: center; gap: 10px; } .modal-title i { font-size: 1.1em; width: 1.2em; text-align: center;}
        .modal-close-btn { background: none; border: none; color: var(--secondary-text-color); font-size: 1.5em; cursor: pointer; padding: 5px; line-height: 1; transition: color 0.2s ease; }
        .modal-close-btn:hover { color: var(--primary-text-color); } .modal-body { font-size: 0.95em; line-height: 1.6; color: var(--primary-text-color); max-height: 60vh; overflow-y: auto; padding-right: 10px; }
        .modal-body p { margin-bottom: 1em; }
        .modal-body .muscle-context { font-style: italic; color: var(--secondary-text-color); border-left: 3px solid var(--accent-border-color); padding-left: 10px; margin-top: 1em;}
        .modal-body::-webkit-scrollbar { width: 6px; } .modal-body::-webkit-scrollbar-track { background: rgba(var(--primary-text-color-rgb), 0.05); border-radius: 3px;} .modal-body::-webkit-scrollbar-thumb { background-color: var(--accent-border-color); border-radius: 3px; } .modal-body::-webkit-scrollbar-thumb:hover { background-color: var(--neon-blue); }

        /* Footer, Messages, Placeholders */
        footer { color: var(--secondary-text-color); opacity: 0.6; border-top: 1px solid var(--border-color); margin-top: 40px; padding: 20px 15px; text-align: center; font-size: 0.8em; transition: border-color var(--transition-speed) ease, color var(--transition-speed) ease; }
        footer a { color: var(--link-color); text-decoration: none; } footer a:hover { color: var(--primary-text-color); }
        .message-area { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(var(--secondary-bg-color-rgb), 0.9); color: var(--primary-text-color); border: 1px solid var(--border-color); padding: 10px 20px; border-radius: var(--border-radius-md); z-index: 6000; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease; pointer-events: none; font-size: 0.9em; box-shadow: 0 4px 15px rgba(0,0,0,0.2); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); max-width: 90%; text-align: center; }
        .message-area.visible { opacity: 1; transform: translate(-50%, 0); bottom: 30px; pointer-events: auto; }
        .message-area.error { background-color: rgba(var(--neon-red-rgb), 0.9); color: #fff; border-color: var(--neon-red); } .message-area.success { background-color: rgba(var(--neon-green-rgb), 0.9); color: #fff; border-color: var(--neon-green); } .message-area.warning { background-color: rgba(var(--neon-orange-rgb), 0.9); color: #fff; border-color: var(--neon-orange); } .message-area.info { background-color: rgba(var(--neon-blue-rgb), 0.9); color: #fff; border-color: var(--neon-blue); }
        .loading-placeholder, .error-placeholder { background-color: var(--secondary-bg-color); border-radius: var(--border-radius-md); padding: 30px 20px; text-align: center; color: var(--secondary-text-color); font-style: italic; border: 1px dashed var(--border-color); margin: 10px 0; }
        .error-placeholder { color: var(--neon-red); border-color: var(--neon-red); }

        /* Responsive */
        @media (min-width: 768px) { .container { max-width: 600px; } .header-content { flex-direction: column; max-width: 600px;} .header-top-row { max-width: 100%;} .header-actions { width: 100%; } body { padding-top: 135px; } }

    </style>
</head>
<body class="logged-out dark-theme">

<header id="app-header">
    <div class="header-content">
        <div class="header-top-row">
             <div class="title-container"> <i class="fas fa-shield header-icon"></i> <h1>ArmorWorkout</h1> </div>
             <div class="page-nav-buttons">
                 <a href="https://ironworkout.github.io/armorworkout/index.html" style="text-decoration: none;" title="Retour au Timer">
                     <button id="index-page-btn"><i class="fas fa-home"></i></button>
                 </a>
                 <a href="https://ironworkout.github.io/armorworkout/program-editor.html" style="text-decoration: none;" title="Aller à l'Éditeur de Programme">
                     <button id="program-editor-page-btn"><i class="fas fa-edit"></i></button>
                 </a>
             </div>
        </div>
        <div class="header-actions">
            <div class="auth-controls"> <button id="signin-button" disabled><i class="fab fa-google"></i> Connexion</button> <button id="signout-button" disabled><i class="fas fa-sign-out-alt"></i> Déconnexion</button> </div>
             <span id="drive-status" aria-live="polite"></span>
            <div class="theme-toggle"> <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button> </div>
        </div>
    </div>
    <nav id="app-nav">
        <button class="nav-button active" data-section="evolution-tracker-area" disabled><i class="fas fa-chart-line"></i> Évolution</button>
        <button class="nav-button" data-section="program-config-area" disabled><i class="fas fa-cogs"></i> Équipement</button>
        <button class="nav-button" data-section="history-area" disabled><i class="fas fa-history"></i> Historique</button>
    </nav>
</header>

<div class="container">
    <main>
        <div id="connection-prompt">
            <p>Connectez-vous via Google pour suivre votre potentiel d'hypertrophie et configurer votre équipement.</p>
            <button id="signin-button-prompt" disabled><i class="fab fa-google"></i> Se connecter</button>
        </div>

        <!-- Section Évolution (HPS) -->
        <div id="evolution-tracker-area" class="app-section" style="display: none;">
            <div class="global-stats-card">
                 <div class="card-title">Score HPS Global</div>
                 <div id="overall-hps-display"> <span class="value">--</span> </div>
                 <div id="level-badge-container" title="Cliquez pour voir la description du niveau">
                     <div id="level-badge" class="level-unknown" data-level-key="L1_Bronze">
                        <i class="fas fa-shield-halved"></i>
                        <span>Bronze</span>
                        <!-- Le sous-niveau sera ajouté ici par JS -->
                     </div>
                     <!-- Icône Marvel ajoutée par JS si nécessaire -->
                 </div>
                 <div class="target-info-container">
                      <span id="target-hps-info">Objectif Niv. Suivant: <strong>-- HPS</strong></span>
                      <span id="marvel-target-info" style="display: none;"> | Benchmark <strong class="marvel-target">Marvel: -- HPS</strong></span>
                 </div>
            </div>
            <div id="muscle-groups-container" aria-live="polite">
                 <p class="loading-placeholder">Connectez-vous pour charger vos données...</p>
                 <!-- Cartes groupes musculaires ajoutées par JS -->
            </div>
        </div>

        <!-- Section Config Équipement -->
        <div id="program-config-area" class="app-section" style="display: none;">
             <h2><i class="fas fa-dumbbell"></i> Configuration Équipement Additionnel</h2>
             <div id="program-config-content">
                 <p class="loading-placeholder">Chargez vos programmes pour configurer...</p>
                 <!-- Contenu config ajouté par JS -->
             </div>
             <button id="save-config-button" disabled>
                 <span><i class="fas fa-save"></i> Sauvegarder Équipement</span>
                 <i class="fas fa-spinner fa-spin spinner"></i>
             </button>
        </div>

         <!-- Section Historique -->
         <div id="history-area" class="app-section" style="display: none;">
            <h2><i class="fas fa-history"></i> Historique HPS</h2>
            <div class="history-controls">
                <select id="history-muscle-group-select">
                    <option value="global">Global</option>
                    <!-- Options ajoutées par JS -->
                </select>
                <button data-period="week" class="history-period-btn active">7j</button>
                <button data-period="month" class="history-period-btn">30j</button>
                <button data-period="year" class="history-period-btn">1 an</button>
            </div>
            <div id="history-display">
                <p>Calcul de la tendance...</p>
                <!-- Tendance ajoutée par JS -->
            </div>
         </div>

    </main>
</div>

<footer>
     <p>© 2024 ArmorWorkout | <a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></p>
</footer>

<!-- Modal Détails Niveaux -->
<div id="level-info-modal" class="modal-overlay"> <div class="modal-content"> <div class="modal-header"> <h3 id="modal-title" class="modal-title"> <i id="modal-icon" class="fas fa-info-circle"></i> <span id="modal-level-name"></span> </h3> <button id="modal-close-btn" class="modal-close-btn">×</button> </div> <div id="modal-body" class="modal-body"> <!-- Contenu ajouté par JS --> </div> </div> </div>

<!-- Zone Message -->
<div id="message-area" class="message-area" role="status" aria-live="polite"></div>

<!-- Scripts -->
<script async defer src="https://accounts.google.com/gsi/client"></script>
<script>
    // --- CONFIGURATION & CONSTANTES GLOBALES ---
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const PROGRAM_FILENAMES = { Push: "armorworkout_push_program.json", Pull: "armorworkout_pull_program.json", Legs: "armorworkout_legs_program.json" };
    const EQUIPMENT_CONFIG_FILENAME = "armorworkout_exercise_config.json";
    const LOCALSTORAGE_HPS_VALUES_KEY = "armorHPS_lastValues_v7"; // Gardé pour compatibilité historique simple
    const LOCALSTORAGE_HPS_GLOBAL_KEY = "armorHPS_lastGlobal_v7"; // Gardé pour compatibilité historique simple
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const GIS_CHECK_INTERVAL = 100;
    const GIS_MAX_RETRIES = 50;

    // --- PARAMÈTRES HPS (v7.2 - Sync JSON) ---
    console.log("HPS Algorithm Version: v7.2 - JSON Sync");
    const HPS_BASE = 0;
    const HP_REFERENCE_GLOBAL = 2500;
    const K_LOG = 500;

    // Efficacité relative (v7.2 - Sync avec JSON fourni)
    const EXERCISE_EFFICACY = {
        'Push-ups (Variante la plus dure possible)': 1.15,
        'Band Floor Press (Élastique(s) sous le dos)': 0.70,
        'Band Kneeling Overhead Press (Ancrage bas sous les genoux)': 1.05,
        'Dumbbell Lateral Raises (Haltères 2x5kg)': 1.05,
        'Band Overhead Triceps Extension': 1.15,
        'Band Bent-Over Row (Élastique(s) sous les pieds)': 1.1,
        'Band Kneeling Lat Pulldown (Ancrage porte haut)': 1.10,
        'Band Face Pull (Ancrage porte milieu/haut)': 1.05,
        'Band Standing Hammer Curl (Élastique(s) sous les pieds)': 0.9,
        'Band Standing Biceps Curl (Élastique(s) sous les pieds)': 1.0,
        'Banded Goblet Squat': 1.20,
        'Banded Romanian Deadlift (RDL)': 1.15, // Ajouté pour le nouveau JSON
        'Alternating Reverse Lunges': 1.1,
        'Standing Calf Raises (Surélevé)': 0.9,
        'Hollow Body Hold / Rocks': 0.7,
        'Band Kneeling Crunch / Sit-up': 0.9,
        'Leg Raises (Relevé de jambes)': 0.85,
        'DEFAULT': 1.0 // Garder un défaut
    };

    // Charge effective (v7.2 - Sync avec JSON fourni + Composants)
    // Contient les valeurs pour les équipements de BASE (lus depuis JSON)
    // ET les valeurs pour les composants ADDITIONNELS (utilisés par la config)
    const EFFECTIVE_LOAD = {
        'Bodyweight': 50,
        'Bodyweight (ou + Bandes)': 50, // Pour Push-ups
        'Élastique 15kg': 30,
        'Élastique 25kg': 50,
        'Élastique 15+25kg': 65, // Hypothèse d'addition
        '2x5kg Haltères': 10,
        '1x5kg Haltère': 5, // Pour Goblet Squat base
        'Élastique 15kg + 1x5kg Haltère': 35, // Base pour Banded Goblet Squat (30+5)
        // Composants utilisables dans AVAILABLE_EQUIPMENT_CONFIG
        '1 haltère 5kg': 5, // Valeur si ajouté via config
        // Autres (potentiellement utiles pour progression non configurée)
        'Élastique 15kg doublé': 45,
        'Élastique 15+25kg + 1 haltère 5kg': 70,
        'Élastique 15+25kg + 2x5kg haltères': 75,
        'DEFAULT': 0 // Mise à 0 par défaut pour éviter HPS inattendu
    };

    // Équipement configurable (ce qui apparaît comme checkbox)
    const AVAILABLE_EQUIPMENT_CONFIG = [ 'Élastique 15kg', 'Élastique 25kg', '1 haltère 5kg' ];

    // Facteurs d'effort
    const EFFORT_FACTORS = { MID: 1.0, TARGET_MET: 1.2 };
    // Poids HPS global
    const WEIGHTS_GLOBAL_HPS = { Pectoraux: 0.15, Dos: 0.20, Épaules: 0.12, Biceps: 0.08, Triceps: 0.08, Abdos: 0.15, Legs: 0.22 };

    // --- NIVEAUX - SEUILS HPS ---
    const TARGET_LEVELS = { 'L1_Bronze':  { name: "Bronze",   minHPS: 1,   description: "Point de départ validé...", celebrity_example: "Débutant Consistant", colorVar: '--level-bronze-color',   bgVar: '--level-bronze-bg',   iconClass: 'fa-shield-halved' }, 'L2_Silver':  { name: "Argent",   minHPS: 150, description: "Physique athlétique naissant...", celebrity_example: "Sportif Régulier", colorVar: '--level-silver-color',   bgVar: '--level-silver-bg',   iconClass: 'fa-shield' }, 'L3_Gold':    { name: "Or",       minHPS: 300, description: "Force confirmée et solide...", celebrity_example: "Athlète Confirmé", colorVar: '--level-gold-color',     bgVar: '--level-gold-bg',     iconClass: 'fa-trophy' }, 'L_Marvel':   { name: "Marvel",   targetHPS: 550, description: "Benchmark : Esthétique équilibrée et athlétique remarquable (ex: acteurs super-héros).", celebrity_example: "Chris Evans (Captain America)", colorVar: '--level-marvel-color', bgVar: '--level-marvel-bg', iconClass: 'fa-bolt-lightning' }, 'L4_Crystal': { name: "Crystal",  minHPS: 450, description: "Niveau avancé, physique impressionnant.", celebrity_example: "Ryan Reynolds (Deadpool)", colorVar: '--level-crystal-color',  bgVar: '--level-crystal-bg',  iconClass: 'fa-gem' }, 'L5_Master':  { name: "Master",   minHPS: 600, description: "Maîtrise physique, très au-dessus de la moyenne.", celebrity_example: "Hugh Jackman (Wolverine)", colorVar: '--level-master-color',   bgVar: '--level-master-bg',   iconClass: 'fa-chess-king' }, 'L6_Champion':{ name: "Champion", minHPS: 750, description: "Physique d'élite, force et esthétique de haut niveau.", celebrity_example: "Henry Cavill (Superman)", colorVar: '--level-champion-color', bgVar: '--level-champion-bg', iconClass: 'fa-crown' }, 'L7_Titan':   { name: "Titan",    minHPS: 900, description: "Force et masse colossales, proche des limites naturelles.", celebrity_example: "Chris Hemsworth (Thor)", colorVar: '--level-titan-color',   bgVar: '--level-titan-bg',    iconClass: 'fa-mountain-sun' }, 'L8_Legende': { name: "Legende",  minHPS: 1100, description: "Statut quasi-mythique, potentiel génétique exceptionnel réalisé.", celebrity_example: "Dwayne 'The Rock' Johnson", colorVar: '--level-legende-color',  bgVar: '--level-legende-bg',  iconClass: 'fa-meteor' } };
    const LEVEL_ORDER = ['L1_Bronze', 'L2_Silver', 'L3_Gold', 'L4_Crystal', 'L5_Master', 'L6_Champion', 'L7_Titan', 'L8_Legende'];
    const MARVEL_BENCHMARK_KEY = 'L_Marvel';
    const NUM_SUB_LEVELS = 3;

    // --- Mapping Muscles V7.2 ---
    const MUSCLE_GROUPS_DISPLAY_CONFIG = { "Pectoraux": { subtitle: "Poitrine", icon: 'fa-dot-circle' }, "Dos": { subtitle: "Dorsaux/Trapèzes", icon: 'fa-bars-staggered' }, "Épaules":{ subtitle: "Deltoïdes", icon: 'fa-atom' }, "Biceps": { subtitle: "Bras (Flex.)", icon: 'fa-link' }, "Triceps": { subtitle: "Bras (Ext.)", icon: 'fa-diamond' }, "Abdos": { subtitle: "Abdominaux", icon: 'fa-grip-lines' }, "Legs": { subtitle: "Jambes/Mollets", icon: 'fa-shoe-prints'} };
    const LOGIC_TO_DISPLAY_MAP = { Pectoraux: "Pectoraux", Dos: "Dos", Épaules: "Épaules", Biceps: "Biceps", Triceps: "Triceps", Abdos: "Abdos", Legs: "Legs" };
    const ALL_MUSCLE_GROUPS_CALCULATED = Object.keys(LOGIC_TO_DISPLAY_MAP);
    const MUSCLE_GROUPS_FOR_GLOBAL_HPS = Object.keys(WEIGHTS_GLOBAL_HPS);

    // --- Éléments DOM ---
    let signInButton, signOutButton, driveStatusElement, themeToggleBtn, signInButtonPrompt, connectionPrompt, evolutionTrackerArea, overallHPSDisplayValue, levelBadgeContainer, levelBadge, levelBadgeIcon, levelBadgeText, targetHPSInfoStrong, marvelTargetInfoSpan, muscleGroupsContainer, messageArea, levelInfoModal, modalTitle, modalIcon, modalLevelName, modalBody, modalCloseBtn, appNav, navButtons, appSections, programConfigArea, programConfigContent, saveConfigButton, historyArea, historyMuscleGroupSelect, historyPeriodBtns, historyDisplay;

    // --- Variables d'État ---
    let googleAccessToken = null; let tokenClient = null; let programFileIds = { Push: null, Pull: null, Legs: null }; let equipmentConfigFileId = null; let loadedPrograms = { Push: [], Pull: [], Legs: [] }; let exerciseConfig = {}; let programsAnalysisStatus = 'pending'; let configLoadStatus = 'pending'; let currentHPSValues = {}; let previousHPSValues = {}; let overallAvgHPS = HPS_BASE; let currentGlobalLevelKey = LEVEL_ORDER[0]; let currentTheme = 'dark'; let messageTimeoutId = null; let gisCheckRetries = 0; let previousOverallAvgHPS = null; let currentHistoryMuscleGroup = 'global'; let currentHistoryPeriod = 'week'; let isSavingConfig = false;

    // --- Audio ---
    let audioContext = null; function initAudioContext() { if (!audioContext && typeof AudioContext !== 'undefined') { try { audioContext = new AudioContext(); } catch (e) { console.warn("AudioContext non supporté.", e); } } }
    function playSound(type = 'confirm', volume = 0.15) { if (!audioContext) return; try { const o = audioContext.createOscillator(), g = audioContext.createGain(); o.connect(g); g.connect(audioContext.destination); g.gain.setValueAtTime(0, audioContext.currentTime); g.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01); const t = audioContext.currentTime; let stopTime = t + 0.2; switch (type) { case 'confirm': o.type = 'sine'; o.frequency.setValueAtTime(523.25, t); o.frequency.linearRampToValueAtTime(783.99, t + 0.1); break; case 'error': o.type = 'square'; o.frequency.setValueAtTime(220, t); o.frequency.linearRampToValueAtTime(110, t + 0.15); break; case 'level_up': o.type = 'triangle'; g.gain.linearRampToValueAtTime(volume * 1.2, t + 0.01); o.frequency.setValueAtTime(440, t); o.frequency.linearRampToValueAtTime(554.37, t + 0.08); o.frequency.linearRampToValueAtTime(659.25, t + 0.16); o.frequency.linearRampToValueAtTime(880, t + 0.24); g.gain.exponentialRampToValueAtTime(0.0001, t + 0.4); stopTime = t + 0.4; o.start(t); o.stop(stopTime); return; default: o.type = 'triangle'; o.frequency.setValueAtTime(659.25, t); break; } o.start(t); o.stop(stopTime); } catch (e) { console.warn("Erreur lecture son:", e); } }

    // --- Google Identity Services & Drive API ---
    async function gisInitInternal() { try { tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CLIENT_ID, scope: GOOGLE_DRIVE_SCOPES, callback: tokenCallback, error_callback: handleTokenError, }); console.log("GIS Client init."); updateAuthUI(googleAccessToken !== null); } catch (error) { console.error("Erreur init GIS:", error); showMessage("Init Google impossible.", 5000, 'error'); if (signInButton) signInButton.disabled = true; if (signInButtonPrompt) signInButtonPrompt.disabled = true; } }
    function checkAndInitGis() { if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) { console.log("GIS prêt, init..."); gisInitInternal(); } else if (gisCheckRetries < GIS_MAX_RETRIES) { gisCheckRetries++; console.log(`GIS non prêt, retry ${gisCheckRetries}/${GIS_MAX_RETRIES}...`); setTimeout(checkAndInitGis, GIS_CHECK_INTERVAL); } else { console.error("Échec chargement GIS."); showMessage("Service Auth Google indispo.", 6000, 'error'); if (signInButton) signInButton.disabled = true; if (signInButtonPrompt) signInButtonPrompt.disabled = true;} }
    function handleTokenError(error) { console.error("Erreur Auth Google:", error); let msg = "Erreur connexion Google."; if (error?.type === 'popup_closed_by_user' || error?.error === 'user_cancel') msg = "Connexion annulée."; else if (error?.type === 'access_denied') msg = "Accès Drive refusé."; else if (error?.error === 'popup_blocked_by_browser') msg = "Popup connexion bloqué."; else if (error?.error === 'popup_failed_to_open') msg = "Échec ouverture Popup."; else if (error?.details) msg += ` Détails: ${error.details}`; showMessage(msg, 5000, 'error'); playSound('error'); googleAccessToken = null; updateAuthUI(false); resetProgressionDisplay(); resetConfigUI(); resetHistoryUI(); }
    async function tokenCallback(tokenResponse) { if (tokenResponse.error) { handleTokenError(tokenResponse); return; } if (tokenResponse && tokenResponse.access_token) { console.log("Access Token reçu."); googleAccessToken = tokenResponse.access_token; loadPreviousHPSFromLocalStorage(); console.log("Valeurs HPS précédentes chargées depuis localStorage:", previousHPSValues, previousOverallAvgHPS); playSound('confirm'); showMessage("Connecté ! Chargement données...", 2500, 'info'); if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; if (programConfigContent) programConfigContent.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; if (historyDisplay) historyDisplay.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; resetProgressionDisplay(); try { const [programsStatus, configStatus] = await Promise.all([ loadProgramsFromDrive(), loadExerciseConfigFromDrive() ]); programsAnalysisStatus = programsStatus; configLoadStatus = configStatus; console.log("Statut chargement progs:", programsAnalysisStatus); console.log("Statut chargement config:", configLoadStatus); if (programsAnalysisStatus === 'error' || configLoadStatus === 'error' ) { showMessage("Erreur chargement données (progs/config). Vérifiez fichiers sur Drive.", 6000, 'error'); playSound('error'); } else if (programsAnalysisStatus === 'partial' || configLoadStatus === 'partial' ) { showMessage("Données partielles chargées (certains fichiers manquaient?).", 5000, 'warning'); } else { showMessage("Données chargées. Calcul potentiel hypertrophie...", 3000, 'success'); } calculateAndDisplayProgression(); renderProgramConfigUI(); renderHistoryUI(); } catch (error) { console.error("Erreur CRITIQUE chargement/analyse:", error); showMessage("Erreur majeure chargement.", 6000, 'error'); playSound('error'); programsAnalysisStatus = 'error'; configLoadStatus = 'error'; if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; if (programConfigContent) programConfigContent.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; if (historyDisplay) historyDisplay.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; resetProgressionDisplay(); } finally { updateAuthUI(true); } } else { handleTokenError({ error: "invalid_response", details: "Réponse Google invalide." }); } }
    function handleAuthClick() { initAudioContext(); if (tokenClient) { console.log("Demande token Google..."); showMessage("Ouverture connexion Google...", 2000, 'info'); tokenClient.requestAccessToken({ prompt: '' }); } else { console.error("Auth sans tokenClient."); showMessage("Erreur : Service connexion non prêt.", 4000, 'error'); checkAndInitGis(); } }
    function handleSignoutClick(showMessages = true) { const token = googleAccessToken; if (!token) { console.log("Déjà déconnecté."); updateAuthUI(false); return; } initAudioContext(); if (showMessages) showMessage("Déconnexion...", 1500, 'info'); google.accounts.oauth2.revoke(token, () => { console.log('Token Google révoqué.'); googleAccessToken = null; programFileIds = { Push: null, Pull: null, Legs: null }; equipmentConfigFileId = null; programsAnalysisStatus = 'pending'; configLoadStatus = 'pending'; loadedPrograms = { Push: [], Pull: [], Legs: [] }; exerciseConfig = {}; currentHPSValues = {}; previousHPSValues = {}; overallAvgHPS = HPS_BASE; currentGlobalLevelKey = LEVEL_ORDER[0]; previousOverallAvgHPS = null; clearHPSLocalStorage(); if (showMessages) { showMessage("Déconnecté.", 3000, 'info'); playSound('confirm'); } resetProgressionDisplay(); resetConfigUI(); resetHistoryUI(); updateAuthUI(false); }); }
    async function findFileId(filename) { if (!googleAccessToken) return null; console.log(`Recherche ID pour: ${filename}`); try { const r = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+trashed=false&spaces=drive&fields=files(id,name)`, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!r.ok) { if (r.status === 401 || r.status === 403) { console.warn(`Auth expirée (find ${filename}). Déco.`); handleSignoutClick(false); return null; } else { console.error(`Erreur Drive (find ${filename}): ${r.status} ${r.statusText}`); throw new Error(`Erreur Drive ${r.status}`); } } const d = await r.json(); if (d.files && d.files.length > 0) { console.log(`ID trouvé pour ${filename}: ${d.files[0].id}`); return d.files[0].id; } console.log(`Fichier ${filename} non trouvé sur Drive.`); return null; } catch (e) { console.error(`Erreur recherche ${filename}:`, e); return null; } }
    async function readFileContent(fileId) { if (!googleAccessToken || !fileId) return null; console.log(`Lecture contenu ID: ${fileId}`); try { const r = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!r.ok) { if (r.status === 401 || r.status === 403) { console.warn(`Auth expirée (read ${fileId}). Déco.`); handleSignoutClick(false); return null; } else if (r.status === 404) { console.warn(`Fichier ${fileId} non trouvé (404) lors lecture.`); return null; } else { console.error(`Erreur Drive (read ${fileId}): ${r.status} ${r.statusText}`); throw new Error(`Erreur Drive ${r.status}`); } } return await r.text(); } catch (e) { console.error(`Erreur lecture ${fileId}:`, e); return null; } }
    async function loadProgramsFromDrive() { if (!googleAccessToken) return 'error'; console.log("Chargement programmes Drive..."); let allOk = true, anyOk = false; const tmp = { Push: [], Pull: [], Legs: [] }; for (const type of PROGRAM_TYPES) { programFileIds[type] = await findFileId(PROGRAM_FILENAMES[type]); let fileOk = false; if (programFileIds[type]) { const content = await readFileContent(programFileIds[type]); if (content !== null) { try { const p = JSON.parse(content || '[]'); if (Array.isArray(p)) { tmp[type] = p; fileOk = true; anyOk = true; if (p.length === 0) console.warn(`Prog ${type} vide.`); } else { console.error(`Contenu ${type} non-Array.`); showMessage(`Format invalide ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning'); allOk = false; } } catch (e) { console.error(`Erreur parsing JSON ${type}:`, e); showMessage(`Erreur format JSON ${PROGRAM_FILENAMES[type]}.`, 4000, 'error'); playSound('error'); allOk = false; } } else { console.warn(`Lecture ${type} échouée.`); showMessage(`Impossible lire ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning'); allOk = false; } } else { console.warn(`Fichier ${PROGRAM_FILENAMES[type]} introuvable. Créez-le via l'éditeur ou le timer.`); showMessage(`Fichier programme ${type} manquant.`, 4000, 'warning'); allOk = false; } } loadedPrograms = tmp; console.log(`Fin chargement progs. Global: ${allOk}, Partiel: ${anyOk}`); if (allOk) return 'success'; if (anyOk) return 'partial'; return 'error'; }
    async function loadExerciseConfigFromDrive() { if (!googleAccessToken) return 'error'; console.log("Chargement config équipement..."); equipmentConfigFileId = await findFileId(EQUIPMENT_CONFIG_FILENAME); if (equipmentConfigFileId) { const content = await readFileContent(equipmentConfigFileId); if (content !== null) { try { const parsedConfig = JSON.parse(content || '{}'); exerciseConfig = typeof parsedConfig === 'object' && parsedConfig !== null ? parsedConfig : {}; console.log("Config équipement chargée depuis Drive:", exerciseConfig); return 'success'; } catch (e) { console.error("Erreur parsing JSON config:", e); showMessage("Erreur format JSON config équipement.", 4000, 'error'); playSound('error'); exerciseConfig = {}; return 'error'; } } else { console.warn("Lecture config échouée (contenu null)."); showMessage("Impossible lire config équipement (contenu null).", 4000, 'warning'); exerciseConfig = {}; return 'error'; } } else { console.warn(`Fichier config "${EQUIPMENT_CONFIG_FILENAME}" introuvable. Utilisation config vide.`); exerciseConfig = {}; return 'partial'; } }
    async function saveExerciseConfigToDrive() { if (!googleAccessToken || !saveConfigButton || isSavingConfig) return; console.log("Sauvegarde config équipement..."); isSavingConfig = true; saveConfigButton.disabled = true; saveConfigButton.classList.add('saving'); const currentConfig = {}; const checkboxes = programConfigContent.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(cb => { const exerciseName = cb.dataset.exerciseName; const equipmentName = cb.value; if (!exerciseName || !equipmentName) return; if (!currentConfig[exerciseName]) { currentConfig[exerciseName] = { added_equipment: [] }; } if (cb.checked) { currentConfig[exerciseName].added_equipment.push(equipmentName); } }); for (const exo in currentConfig) { if (currentConfig[exo].added_equipment.length === 0) { delete currentConfig[exo]; } } console.log("Config à sauvegarder:", currentConfig); const configJson = JSON.stringify(currentConfig, null, 2); try { let method = 'PATCH'; let url = `https://www.googleapis.com/upload/drive/v3/files/${equipmentConfigFileId}?uploadType=media`; let body = configJson; let headers = { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json; charset=UTF-8' }; if (!equipmentConfigFileId) { console.log("Aucun ID config, tentative création..."); method = 'POST'; url = 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart'; const metadata = { name: EQUIPMENT_CONFIG_FILENAME, mimeType: 'application/json' }; const form = new FormData(); form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json; charset=UTF-8' })); form.append('file', new Blob([configJson], { type: 'application/json; charset=UTF-8' })); body = form; headers = { 'Authorization': `Bearer ${googleAccessToken}` }; } const response = await fetch(url, { method: method, headers: headers, body: body }); if (!response.ok) { if (response.status === 401 || response.status === 403) { handleSignoutClick(false); } const errorBody = await response.text(); console.error("Erreur sauvegarde fichier:", response.status, errorBody); throw new Error(`Erreur Drive ${response.status} (${method === 'POST' ? 'Création' : 'MàJ'})`); } const result = await response.json(); if (method === 'POST' && result.id) { equipmentConfigFileId = result.id; console.log("Fichier config créé avec ID:", equipmentConfigFileId); } console.log("Config équipement sauvegardée sur Drive."); exerciseConfig = currentConfig; showMessage("Configuration équipement sauvegardée !", 3000, 'success'); playSound('confirm'); calculateAndDisplayProgression(); } catch (error) { console.error("Erreur sauvegarde config:", error); showMessage(`Erreur sauvegarde config: ${error.message}`, 5000, 'error'); playSound('error'); } finally { saveConfigButton.disabled = false; saveConfigButton.classList.remove('saving'); isSavingConfig = false; } }

    // --- Logique de Calcul HPS (v7.2 - Sync JSON) ---
    function getExerciseEfficacy(exerciseName) {
        if (!exerciseName) return EXERCISE_EFFICACY['DEFAULT'] || 1.0;
        // Essayer le nom complet d'abord
        if (EXERCISE_EFFICACY[exerciseName]) return EXERCISE_EFFICACY[exerciseName];
        // Essayer sans les parenthèses (pour d'éventuelles variations futures)
        const cleanedName = exerciseName.replace(/\s*\([\s\S]*?\)\s*$/i, '').trim();
        if (EXERCISE_EFFICACY[cleanedName]) return EXERCISE_EFFICACY[cleanedName];
        // Utiliser le défaut si rien ne correspond
        console.warn(`Efficacité non trouvée pour "${exerciseName}", utilisation de DEFAULT.`);
        return EXERCISE_EFFICACY['DEFAULT'] || 1.0;
    }
    function getEffectiveLoad(baseEquipment, addedEquipmentList) {
        let normalizedBase = baseEquipment ? baseEquipment.trim() : 'DEFAULT';
        // Récupérer la charge de base depuis la constante EFFECTIVE_LOAD
        let baseLoad = EFFECTIVE_LOAD[normalizedBase] ?? EFFECTIVE_LOAD['DEFAULT'] ?? 0;
        if (EFFECTIVE_LOAD[normalizedBase] === undefined) {
            console.warn(`Charge de base non trouvée pour "${normalizedBase}", utilisation de DEFAULT (${EFFECTIVE_LOAD['DEFAULT'] ?? 0}).`);
        }

        let addedLoad = 0;
        if (addedEquipmentList && addedEquipmentList.length > 0) {
            addedEquipmentList.forEach(equipKey => {
                let normalizedAdd = equipKey ? equipKey.trim() : '';
                // Récupérer la charge ajoutée depuis la constante EFFECTIVE_LOAD (qui doit contenir les composants)
                let componentLoad = EFFECTIVE_LOAD[normalizedAdd] ?? 0;
                if (EFFECTIVE_LOAD[normalizedAdd] === undefined) {
                     console.warn(`Charge ajoutée non trouvée pour composant "${normalizedAdd}", ajout de 0.`);
                }
                addedLoad += componentLoad;
            });
        }
        return baseLoad + addedLoad;
    }
    function getEffortFactor(step) { const isDuration = step.duration && parseInt(step.duration, 10) > 0; const currentValStr = isDuration ? step.duration : step.reps; const targetMaxStr = isDuration ? step.duration_target_max : step.reps_target_max; const currentVal = parseInt(currentValStr, 10); const targetMax = parseInt(targetMaxStr, 10); if (!isNaN(currentVal) && !isNaN(targetMax) && targetMax > 0 && currentVal >= targetMax) { return EFFORT_FACTORS.TARGET_MET; } return EFFORT_FACTORS.MID; }
    function calculateHPPerSet(step) { if (!step || step.type !== 'exercise') return 0; const isDurationBased = step.duration && parseInt(step.duration, 10) > 0; const currentValueStr = isDurationBased ? step.duration : step.reps; const currentValue = parseInt(currentValueStr, 10); if (isNaN(currentValue) || currentValue <= 0) { return 0; } const exerciseName = step.name; const baseEquipment = step.equipment; // Nom complet de l'équipement depuis le JSON const configForThisExo = exerciseConfig[exerciseName]; const addedEquipment = configForThisExo?.added_equipment || []; // Noms des composants cochés const efficacy = getExerciseEfficacy(exerciseName); const effectiveLoad = getEffectiveLoad(baseEquipment, addedEquipment); const effortFactor = getEffortFactor(step); let volumeFactor = 0; if (isDurationBased) { volumeFactor = Math.sqrt(currentValue); } else { volumeFactor = currentValue; } if (efficacy <= 0 || effectiveLoad <= 0 || volumeFactor <= 0 || effortFactor <= 0) { /* console.warn(`calculateHPPerSet: Facteur invalide pour ${step.name}. Efficacy: ${efficacy}, Load: ${effectiveLoad}, Volume: ${volumeFactor}, Effort: ${effortFactor}`); */ return 0; } const hp = efficacy * effectiveLoad * volumeFactor * effortFactor; /* console.log(`HP Set: ${exerciseName} (Eq:${baseEquipment}, Add:${addedEquipment}) -> Eff:${efficacy.toFixed(2)}, Load:${effectiveLoad}, Vol:${volumeFactor}, Effort:${effortFactor} = HP ${hp.toFixed(1)}`); */ return hp; }
    function mapExerciseToMuscleGroup(name) {
        if (!name) return [];
        // Nettoyage moins agressif pour garder les détails importants
        const cleanedName = name.trim();
        const l = cleanedName.toLowerCase();

        // --- Mapping V7.2 (Priorité aux noms spécifiques) ---
        if (l.includes('push-ups') || l.includes('push up') || l.includes('floor press') || l.includes('chest press') || l.includes('écarté')) return [ { group: 'Pectoraux', weight: 0.60 }, { group: 'Triceps', weight: 0.25 }, { group: 'Épaules', weight: 0.15 } ];
        if (l.includes('overhead press') || l.includes('développé militaire') || l.includes('shoulder press')) return [ { group: 'Épaules', weight: 0.65 }, { group: 'Triceps', weight: 0.30 }, { group: 'Pectoraux', weight: 0.05 } ];
        if (l.includes('lateral raises') || l.includes('élévations latérales')) return [{ group: 'Épaules', weight: 1.0 }];
        if (l.includes('overhead triceps extension') || l.includes('triceps extension')) return [{ group: 'Triceps', weight: 1.0 }];
        if (l.includes('rowing') || l.includes('bent-over row') || l.includes('tirage horizontal')) return [ { group: 'Dos', weight: 0.65 }, { group: 'Biceps', weight: 0.20 }, { group: 'Épaules', weight: 0.15 } ];
        if (l.includes('lat pulldown') || l.includes('tirage vertical') || l.includes('tractions') || l.includes('pull up') || l.includes('chin up')) return [ { group: 'Dos', weight: 0.70 }, { group: 'Biceps', weight: 0.25 }, { group: 'Épaules', weight: 0.05 } ];
        if (l.includes('face pull')) return [ { group: 'Épaules', weight: 0.60 }, { group: 'Dos', weight: 0.40 } ];
        if (l.includes('hammer curl')) return [{ group: 'Biceps', weight: 1.0 }]; // Priorité Hammer
        if (l.includes('biceps curl')) return [{ group: 'Biceps', weight: 1.0 }]; // Priorité Biceps
        if (l.includes('goblet squat') || l.includes('front squat')) return [{ group: 'Legs', weight: 1.0 }]; // Focus Quad/Glutes
        if (l.includes('romanian deadlift') || l.includes('rdl')) return [{ group: 'Legs', weight: 1.0 }]; // Focus Hamstrings/Glutes
        if (l.includes('lunges') || l.includes('fentes')) return [{ group: 'Legs', weight: 1.0 }]; // Jambes globales
        if (l.includes('calf raises') || l.includes('mollets')) return [{ group: 'Legs', weight: 1.0 }]; // Mollets -> Legs
        if (l.includes('hollow body') || l.includes('gainage') || l.includes('planche')) return [{ group: 'Abdos', weight: 1.0 }];
        if (l.includes('crunch') || l.includes('sit-up') || l.includes('abdos')) return [{ group: 'Abdos', weight: 1.0 }];
        if (l.includes('leg raises') || l.includes('relevé de jambes')) return [{ group: 'Abdos', weight: 1.0 }];

        console.warn(`Mapping muscle PONDÉRÉ v7.2 non trouvé pour: "${name}" (nettoyé en "${cleanedName}"). Aucun HP attribué.`);
        return [];
    }
    function analyzeProgramsAndCalculateHPS() {
        console.log("Analyse programmes & calcul HPS (v7.2)...");
        const groupData = {};
        ALL_MUSCLE_GROUPS_CALCULATED.forEach(g => { groupData[g] = { totalHP: 0 }; });
        currentHPSValues = {};

        if (programsAnalysisStatus === 'error' || programsAnalysisStatus === 'pending' || configLoadStatus === 'error' || !loadedPrograms) {
            console.warn("Analyse HPS annulée - Données non prêtes.");
            ALL_MUSCLE_GROUPS_CALCULATED.forEach(g => { currentHPSValues[g] = HPS_BASE; });
            overallAvgHPS = HPS_BASE;
            saveCurrentHPSToLocalStorage();
            return;
        }

        console.log("Starting HP calculation loops...");

        PROGRAM_TYPES.forEach(type => {
            const program = loadedPrograms[type];
            if (!program || !Array.isArray(program) || program.length === 0) return;
            let currentBlock = { stepRef: null, setCount: 0 };

            function processCurrentBlock() {
                if (currentBlock.stepRef && currentBlock.setCount > 0) {
                    const hpPerSet = calculateHPPerSet(currentBlock.stepRef);
                    if (hpPerSet > 0) {
                        const muscleContributions = mapExerciseToMuscleGroup(currentBlock.stepRef.name);
                        if (muscleContributions.length > 0) {
                             muscleContributions.forEach(contribution => {
                                const groupName = contribution.group;
                                const weight = contribution.weight;
                                if (groupData[groupName] && weight > 0) {
                                    const weightedHpContribution = hpPerSet * weight;
                                    groupData[groupName].totalHP += weightedHpContribution * currentBlock.setCount;
                                }
                            });
                        }
                    }
                }
                currentBlock = { stepRef: null, setCount: 0 };
            }

            program.forEach((step, index) => {
                // Regroupement des séries consécutives du *même exercice*
                if (step.type === 'exercise' && step.name) {
                    if (currentBlock.stepRef && step.name === currentBlock.stepRef.name) {
                         currentBlock.setCount++;
                         currentBlock.stepRef = step; // Utiliser les détails de la dernière série pour le calcul
                    } else {
                         processCurrentBlock(); // Traiter le bloc précédent
                         currentBlock.stepRef = step;
                         currentBlock.setCount = 1; // Commencer un nouveau bloc
                    }
                } else {
                     processCurrentBlock(); // Traiter le bloc d'exercice avant un repos/autre
                }
                if(index === program.length - 1) {
                     processCurrentBlock(); // Traiter le dernier bloc
                }
            });
        });


        console.log("HP calculation loops finished. Finalizing scores...");
        let totalWeightedHPSOverall = 0; let totalWeightOverall = 0;
        console.log("Final groupData before HPS calculation:", JSON.parse(JSON.stringify(groupData)));

        ALL_MUSCLE_GROUPS_CALCULATED.forEach(g => {
            const totalHP = groupData[g]?.totalHP || 0;
            let hps = HPS_BASE;
            const referenceHP = HP_REFERENCE_GLOBAL; const kLogFactor = K_LOG;
            if (totalHP > 0 && referenceHP > 0 && kLogFactor > 0) {
                const ratioFactor = totalHP / referenceHP;
                hps = kLogFactor * Math.log10(1 + ratioFactor);
            }
            currentHPSValues[g] = Math.round(Math.max(0, hps));
            console.log(` -> HPS Calcul FINAL [${g}]: TotalHP=${totalHP.toFixed(1)}, HPS=${currentHPSValues[g]}`);

            if (MUSCLE_GROUPS_FOR_GLOBAL_HPS.includes(g)) {
                const weight = WEIGHTS_GLOBAL_HPS[g] || 0;
                if (weight > 0) {
                    totalWeightedHPSOverall += currentHPSValues[g] * weight;
                    totalWeightOverall += weight;
                }
            }
        });
        overallAvgHPS = totalWeightOverall > 0 ? Math.round(totalWeightedHPSOverall / totalWeightOverall) : HPS_BASE;
        overallAvgHPS = Math.max(0, overallAvgHPS);
        console.log(`HPS Global V7.2: ${overallAvgHPS} (Préc localStorage: ${previousOverallAvgHPS ?? 'N/A'})`);
        console.log("HPS Groupes V7.2 Actuels:", currentHPSValues);
        console.log("HPS Groupes Précédents (avant ce calcul):", previousHPSValues);
        saveCurrentHPSToLocalStorage(); // Sauvegarde après calcul
    }
    function getHPSLevelKey(hpsScore) { for (let i = LEVEL_ORDER.length - 1; i >= 0; i--) { const key = LEVEL_ORDER[i]; if (TARGET_LEVELS[key] && hpsScore >= TARGET_LEVELS[key].minHPS) { return key; } } return LEVEL_ORDER[0]; }
    function getHPSLevelAndSubLevel(hpsScore) { const levelKey = getHPSLevelKey(hpsScore); const level = TARGET_LEVELS[levelKey]; const levelIndex = LEVEL_ORDER.indexOf(levelKey); let subLevelNumeral = ''; if (levelIndex < LEVEL_ORDER.length - 1) { const nextLevelKey = LEVEL_ORDER[levelIndex + 1]; const nextLevel = TARGET_LEVELS[nextLevelKey]; const minHPSCurrent = level.minHPS; const minHPSNext = nextLevel.minHPS; const range = minHPSNext - minHPSCurrent; if (range > 0) { const subLevelStep = range / NUM_SUB_LEVELS; const thresholdII = minHPSCurrent + subLevelStep; const thresholdIII = minHPSCurrent + 2 * subLevelStep; if (hpsScore >= thresholdIII) { subLevelNumeral = 'III'; } else if (hpsScore >= thresholdII) { subLevelNumeral = 'II'; } else { subLevelNumeral = 'I'; } } else { subLevelNumeral = 'I'; } } else { subLevelNumeral = ''; } return { levelKey, level, subLevelNumeral }; }

    // --- Logique Affichage (v7.2) ---
    function calculateAndDisplayProgression() { console.log("Mise à jour affichage progression (HPS V7.2 - SubLevels)..."); if (!evolutionTrackerArea || !overallHPSDisplayValue || !levelBadge || !targetHPSInfoStrong || !muscleGroupsContainer || !levelBadgeContainer || !marvelTargetInfoSpan) { console.error("DOM manquant affichage HPS."); if(muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p class="error-placeholder">Erreur interne: DOM affichage manquant.</p>'; return; } if (programsAnalysisStatus !== 'pending' && configLoadStatus !== 'pending') { analyzeProgramsAndCalculateHPS(); } else { console.log("Affichage basé sur les données précédentes (si dispo) car chargement incomplet/en cours."); overallAvgHPS = previousOverallAvgHPS ?? HPS_BASE; currentHPSValues = previousHPSValues ?? {}; } const oldGlobalLevelKey = currentGlobalLevelKey; const { levelKey: newGlobalLevelKey, level: currentGlobalLevel, subLevelNumeral: globalSubLevelNumeral } = getHPSLevelAndSubLevel(overallAvgHPS); currentGlobalLevelKey = newGlobalLevelKey; const currentGlobalLevelIndex = LEVEL_ORDER.indexOf(currentGlobalLevelKey); const nextGlobalLevelKey = currentGlobalLevelIndex < LEVEL_ORDER.length - 1 ? LEVEL_ORDER[currentGlobalLevelIndex + 1] : null; const nextGlobalLevel = nextGlobalLevelKey ? TARGET_LEVELS[nextGlobalLevelKey] : null; const marvelBenchmark = TARGET_LEVELS[MARVEL_BENCHMARK_KEY]; const currentDisplayedHPS = parseFloat(overallHPSDisplayValue.textContent.replace(/[^0-9.]/g, '')) || HPS_BASE; animateValue(overallHPSDisplayValue, currentDisplayedHPS, overallAvgHPS, 700); levelBadgeIcon.className = `fas ${currentGlobalLevel.iconClass}`; levelBadgeText.innerHTML = `${currentGlobalLevel.name} <span class="sub-level">${globalSubLevelNumeral}</span>`; levelBadge.style.color = `var(${currentGlobalLevel.colorVar})`; levelBadge.style.backgroundColor = `var(${currentGlobalLevel.bgVar})`; levelBadge.style.borderColor = `var(${currentGlobalLevel.colorVar})`; levelBadge.setAttribute('data-level-key', currentGlobalLevelKey); targetHPSInfoStrong.textContent = nextGlobalLevel ? `${nextGlobalLevel.minHPS} HPS` : "MAX"; if (marvelBenchmark) { marvelTargetInfoSpan.innerHTML = ` | Benchmark <strong class="marvel-target">Marvel: ${marvelBenchmark.targetHPS} HPS</strong>`; marvelTargetInfoSpan.style.display = 'inline-block'; const isMarvelAchieved = overallAvgHPS >= marvelBenchmark.targetHPS; const existingMarvelIcon = document.getElementById('marvel-icon'); if (isMarvelAchieved) { if (!existingMarvelIcon) { const mI = document.createElement('i'); mI.id = 'marvel-icon'; mI.className = `fas ${marvelBenchmark.iconClass} marvel-achieved-icon`; mI.setAttribute('title', `Benchmark "${marvelBenchmark.name}" (${marvelBenchmark.targetHPS} HPS) atteint !`); levelBadgeContainer.appendChild(mI); } } else { if (existingMarvelIcon) existingMarvelIcon.remove(); } } else { marvelTargetInfoSpan.style.display = 'none'; } if (previousOverallAvgHPS !== null && currentGlobalLevelKey !== oldGlobalLevelKey) { const currentLevelThreshold = TARGET_LEVELS[currentGlobalLevelKey].minHPS; if (overallAvgHPS >= currentLevelThreshold && previousOverallAvgHPS < currentLevelThreshold) { console.log(`NIVEAU GLOBAL ATTEINT ! ${oldGlobalLevelKey} -> ${currentGlobalLevelKey}`); showMessage(`Félicitations ! Niveau Global ${currentGlobalLevel.name} atteint !`, 5000, 'success'); playSound('level_up', 0.2); const card = document.querySelector('.global-stats-card'); if (card) { card.style.animation = 'levelUpGlow 1.5s ease-out'; setTimeout(() => { card.style.animation = ''; }, 1500); } } } muscleGroupsContainer.innerHTML = ''; let hasData = false; const displayOrder = ["Pectoraux", "Dos", "Épaules", "Biceps", "Triceps", "Legs", "Abdos"]; displayOrder.forEach(displayGroup => { const logicGroup = ALL_MUSCLE_GROUPS_CALCULATED.find(key => LOGIC_TO_DISPLAY_MAP[key] === displayGroup); if (!logicGroup || currentHPSValues[logicGroup] === undefined || !MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup]) { return; } hasData = true; const config = MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup]; const currentHPS = currentHPSValues[logicGroup]; const { levelKey: muscleLevelKey, level: muscleLevel, subLevelNumeral: muscleSubLevelNumeral } = getHPSLevelAndSubLevel(currentHPS); const muscleLevelIndex = LEVEL_ORDER.indexOf(muscleLevelKey); const nextMuscleLevelKey = muscleLevelIndex < LEVEL_ORDER.length - 1 ? LEVEL_ORDER[muscleLevelIndex + 1] : null; const nextMuscleLevel = nextMuscleLevelKey ? TARGET_LEVELS[nextMuscleLevelKey] : null; const minHPSCurrent = muscleLevel.minHPS; const minHPSNext = nextMuscleLevel ? nextMuscleLevel.minHPS : minHPSCurrent; const range = minHPSNext - minHPSCurrent; let progress = 0; if (range > 0) { progress = ((currentHPS - minHPSCurrent) / range) * 100; } else if (currentHPS >= minHPSCurrent) { progress = 100; } const displayPercent = Math.max(0, Math.min(100, Math.round(progress))); const targetDisplay = nextMuscleLevel ? minHPSNext : "MAX"; const card = renderMuscleGroupCard( logicGroup, displayGroup, config.subtitle, config.icon, currentHPS, targetDisplay, displayPercent, muscleLevelKey, muscleLevel.name, muscleSubLevelNumeral, muscleLevel.colorVar, muscleLevel.bgVar ); muscleGroupsContainer.appendChild(card); }); if (!hasData && (programsAnalysisStatus !== 'pending' || configLoadStatus !== 'pending')) { const msg = (programsAnalysisStatus === 'error' || configLoadStatus === 'error') ? 'Erreur chargement données.' : 'Aucune donnée progression.'; muscleGroupsContainer.innerHTML = `<p class="${(programsAnalysisStatus === 'error' || configLoadStatus === 'error') ? 'error' : 'loading'}-placeholder">${msg}</p>`; } console.log("Affichage progression V7.2 mis à jour."); }
    function renderMuscleGroupCard(logicGroupKey, title, subtitle, iconClass, currentHPS, targetHPSNextMin, displayPercent, currentLevelKey, currentLevelName, currentSubLevelNumeral, currentLevelColorVar, currentLevelBgVar ) { const card = document.createElement('div'); card.className = 'muscle-group-card'; card.setAttribute('title', `${title} (${subtitle}) - Niveau: ${currentLevelName} ${currentSubLevelNumeral} - HPS: ${currentHPS} / ${targetHPSNextMin}. Progression: ${displayPercent}%.`); let levelProgressionHtml = '<div class="muscle-level-progression">'; let currentLevelFillWidth = '0%'; let currentLevelPosition = 0; LEVEL_ORDER.forEach((levelKey, index) => { const level = TARGET_LEVELS[levelKey]; if (!level) return; const basePosition = (index / (LEVEL_ORDER.length -1)) * 100; const adjustedPosition = 5 + (basePosition * 0.9); let indicatorClass = 'level-indicator'; let indicatorStyle = `left: ${adjustedPosition}%; border-color: var(${level.colorVar});`; let boxShadowStyle = `box-shadow: 0 0 10px var(${level.colorVar});`; if (levelKey === currentLevelKey) { indicatorClass += ' current'; indicatorStyle += boxShadowStyle; currentLevelPosition = adjustedPosition; const nextLevelIndex = index + 1; let endPos = 100; if (nextLevelIndex < LEVEL_ORDER.length) { const nextBasePos = (nextLevelIndex / (LEVEL_ORDER.length -1)) * 100; endPos = 5 + (nextBasePos * 0.9); } const segmentWidthPercent = endPos - currentLevelPosition; const fillWidthFromStart = currentLevelPosition + (segmentWidthPercent * (displayPercent / 100)); currentLevelFillWidth = `${fillWidthFromStart}%`; } levelProgressionHtml += `<div class="${indicatorClass}" style="${indicatorStyle}" data-level-key="${levelKey}" title="${level.name} (Min: ${level.minHPS} HPS)"><i class="fas ${level.iconClass}"></i></div>`; }); levelProgressionHtml = `<div class="current-level-fill" style="width: ${currentLevelFillWidth}; background-color: var(${currentLevelColorVar}); left: 0;"></div>` + levelProgressionHtml; levelProgressionHtml += '</div>'; const percentageBarHtml = ` <div class="percentage-progress-section"> <div class="percentage-bar-container" title="Progression vers ${targetHPSNextMin} HPS: ${displayPercent}%"> <div class="percentage-bar-fill" style="width: 0%;"></div> </div> <span class="percentage-value-text">${displayPercent}%</span> </div>`; card.innerHTML = ` <div class="card-header"> <div class="icon-container"><i class="fas ${iconClass}" aria-hidden="true"></i></div> <div class="title-container"> <div class="group-title">${title}</div> <div class="group-subtitle">${subtitle}</div> <div class="group-level-name" style="color: var(${currentLevelColorVar}); background-color: var(${currentLevelBgVar}); border-color: var(${currentLevelColorVar});"> ${currentLevelName} <span class="sub-level">${currentSubLevelNumeral}</span> </div> </div> <div class="hps-details" title="HPS Actuel / Seuil HPS Niveau Suivant"> <span class="current">${currentHPS}</span> / <span class="target">${targetHPSNextMin}</span> </div> </div> ${levelProgressionHtml} ${percentageBarHtml} `; requestAnimationFrame(() => { setTimeout(() => { const pbFill = card.querySelector('.percentage-bar-fill'); if (pbFill) { pbFill.style.width = `${displayPercent}%`; } }, 50); }); const indicators = card.querySelectorAll('.level-indicator'); indicators.forEach(indicator => { indicator.addEventListener('click', (e) => { e.stopPropagation(); const key = indicator.getAttribute('data-level-key'); if (key) openLevelInfoModal(key, title); }); }); return card; }
    function resetProgressionDisplay() { console.log("Réinitialisation affichage HPS..."); if (muscleGroupsContainer) { muscleGroupsContainer.innerHTML = `<p class="loading-placeholder">${googleAccessToken ? 'Analyse...' : 'Connectez-vous...'}</p>`; } if (overallHPSDisplayValue) overallHPSDisplayValue.textContent = '--'; const firstLevelKey = LEVEL_ORDER[0]; const baseLevel = TARGET_LEVELS[firstLevelKey]; if (levelBadge && baseLevel) { levelBadgeIcon.className = `fas ${baseLevel.iconClass}`; levelBadgeText.innerHTML = `${baseLevel.name}`; levelBadge.style.color = `var(${baseLevel.colorVar})`; levelBadge.style.backgroundColor = `var(${baseLevel.bgVar})`; levelBadge.style.borderColor = `var(${baseLevel.colorVar})`; levelBadge.setAttribute('data-level-key', firstLevelKey); } const secondLevelKey = LEVEL_ORDER.length > 1 ? LEVEL_ORDER[1] : null; const firstRealLevel = secondLevelKey ? TARGET_LEVELS[secondLevelKey] : null; if (targetHPSInfoStrong) targetHPSInfoStrong.textContent = firstRealLevel ? `${firstRealLevel.minHPS} HPS` : '-- HPS'; const marvelBenchmark = TARGET_LEVELS[MARVEL_BENCHMARK_KEY]; if (marvelTargetInfoSpan && marvelBenchmark) { marvelTargetInfoSpan.innerHTML = ` | Benchmark <strong class="marvel-target">Marvel: ${marvelBenchmark.targetHPS} HPS</strong>`; marvelTargetInfoSpan.style.display = 'inline-block'; } else if (marvelTargetInfoSpan) { marvelTargetInfoSpan.style.display = 'none'; } const existingMarvelIcon = document.getElementById('marvel-icon'); if (existingMarvelIcon) { existingMarvelIcon.remove(); } currentGlobalLevelKey = LEVEL_ORDER[0]; }

    // --- Rendu UI Config Équipement ---
    function renderProgramConfigUI() { if (!programConfigContent) return; if (programsAnalysisStatus === 'pending' || programsAnalysisStatus === 'error') { programConfigContent.innerHTML = '<p class="loading-placeholder">Chargez d\'abord vos programmes.</p>'; if(saveConfigButton) saveConfigButton.disabled = true; return; } let html = ''; const uniqueExercises = new Set(); PROGRAM_TYPES.forEach(type => { const program = loadedPrograms[type]; if (program && program.length > 0) { program.forEach(step => { if (step.type === 'exercise' && step.name) { uniqueExercises.add(step.name); } }); } }); if (uniqueExercises.size === 0) { programConfigContent.innerHTML = '<p class="loading-placeholder">Aucun exercice trouvé dans les programmes.</p>'; if(saveConfigButton) saveConfigButton.disabled = true; return; } html += `<div class="program-config-section"><h3>Équipement Additionnel par Exercice</h3>`; [...uniqueExercises].sort().forEach(exerciseName => { html += `<div class="config-exercise-item"><span class="exercise-name">${exerciseName}</span><div class="config-equipment-options">`; AVAILABLE_EQUIPMENT_CONFIG.forEach(equipKey => { const isChecked = exerciseConfig[exerciseName]?.added_equipment?.includes(equipKey) || false; html += `<label><input type="checkbox" value="${equipKey}" data-exercise-name="${exerciseName}" ${isChecked ? 'checked' : ''}> ${equipKey}</label>`; }); html += `</div></div>`; }); html += `</div>`; if(saveConfigButton) saveConfigButton.disabled = !googleAccessToken; programConfigContent.innerHTML = html; }
    function resetConfigUI() { if (programConfigContent) { programConfigContent.innerHTML = '<p class="loading-placeholder">Connectez-vous.</p>'; } if(saveConfigButton) saveConfigButton.disabled = true; exerciseConfig = {}; }

    // --- Logique Historique ---
    function renderHistoryUI() { if (!historyMuscleGroupSelect || !historyDisplay) return; historyMuscleGroupSelect.innerHTML = '<option value="global">Global</option>'; const displayOrder = ["Pectoraux", "Dos", "Épaules", "Biceps", "Triceps", "Legs", "Abdos"]; displayOrder.forEach(displayGroup => { const logicGroup = ALL_MUSCLE_GROUPS_CALCULATED.find(key => LOGIC_TO_DISPLAY_MAP[key] === displayGroup); if (logicGroup && MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup]) { const option = document.createElement('option'); option.value = logicGroup; option.textContent = MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup].subtitle || displayGroup; historyMuscleGroupSelect.appendChild(option); } }); historyMuscleGroupSelect.value = currentHistoryMuscleGroup; historyPeriodBtns.forEach(btn => { btn.classList.toggle('active', btn.dataset.period === currentHistoryPeriod); }); displayHistoryTrend(); }
    function displayHistoryTrend() { if (!historyDisplay) return; console.log(`Affichage historique V7.2 pour: ${currentHistoryMuscleGroup}, Période: ${currentHistoryPeriod}`); const muscleName = currentHistoryMuscleGroup === 'global' ? 'Global' : (MUSCLE_GROUPS_DISPLAY_CONFIG[currentHistoryMuscleGroup]?.subtitle || currentHistoryMuscleGroup); let periodText = 'depuis dernier calcul'; // Simplifié, car pas d'historique long terme
        const currentVal = currentHistoryMuscleGroup === 'global' ? overallAvgHPS : (currentHPSValues[currentHistoryMuscleGroup] ?? undefined); const previousVal = currentHistoryMuscleGroup === 'global' ? previousOverallAvgHPS : (previousHPSValues[currentHistoryMuscleGroup] ?? undefined);
        if (previousVal === undefined || previousVal === null || currentVal === undefined) { historyDisplay.innerHTML = `<p>Tendance HPS pour <strong>${muscleName}</strong> (${periodText}) :</p><p style="margin-top: 10px;"><span class="trend-value trend-neutral">N/A</span></p><p style="font-size: 0.8em; margin-top: 15px;">(Calcul initial ou pas de données précédentes)</p>`; return; } const diffAbs = currentVal - previousVal; const diffPerc = previousVal !== 0 ? (diffAbs / previousVal) * 100 : (currentVal > 0 ? Infinity : 0); const trendClass = diffAbs > 0.5 ? 'trend-positive' : (diffAbs < -0.5 ? 'trend-negative' : 'trend-neutral'); const sign = diffAbs > 0.5 ? '+' : ''; const formattedDiffPerc = diffPerc === Infinity ? '∞' : diffPerc.toFixed(1); historyDisplay.innerHTML = ` <p>Tendance HPS pour <strong>${muscleName}</strong> (${periodText}) :</p> <p style="margin-top: 10px;"> <span class="trend-value ${trendClass}">${sign}${diffAbs.toFixed(0)} HPS</span> ${previousVal !== 0 ? `(<span class="trend-value ${trendClass}">${sign}${formattedDiffPerc}%</span>)` : ''} </p> <p style="font-size: 0.8em; margin-top: 15px;">(${previousVal ?? 'N/A'} HPS -> ${currentVal} HPS)</p> `; }
    function handleHistorySelectionChange() { currentHistoryMuscleGroup = historyMuscleGroupSelect.value; displayHistoryTrend(); }
    function handleHistoryPeriodChange(event) { const targetButton = event.target.closest('.history-period-btn'); if (!targetButton) return; currentHistoryPeriod = targetButton.dataset.period; // Note: Cette période n'affecte pas le calcul actuel (simple diff)
        historyPeriodBtns.forEach(btn => btn.classList.remove('active')); targetButton.classList.add('active'); displayHistoryTrend(); }
    function resetHistoryUI() { if(historyDisplay) historyDisplay.innerHTML = '<p>Connectez-vous pour voir l\'historique.</p>'; if(historyMuscleGroupSelect) historyMuscleGroupSelect.innerHTML = '<option value="global">Global</option>'; currentHistoryMuscleGroup = 'global'; currentHistoryPeriod = 'week'; if(historyPeriodBtns) historyPeriodBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.period === currentHistoryPeriod)); }

    // --- Fonctions Modal ---
    function getMuscleSpecificContext(levelKey, muscleGroup) { const levelName = TARGET_LEVELS[levelKey]?.name || 'ce niveau'; switch (muscleGroup) { case 'Pectoraux': return `Pour les pectoraux, ${levelName} peut signifier une meilleure connexion et un début de galbe.`; case 'Dos': return `Pour le dos, ${levelName} suggère une amélioration de la posture et une sensation de largeur/épaisseur accrue.`; case 'Épaules': return `Pour les épaules, ${levelName} se traduit souvent par des épaules plus 'rondes' et une meilleure séparation avec les bras.`; case 'Biceps': return `Pour les biceps, ${levelName} implique un 'pic' plus prononcé et une meilleure sensation de contraction.`; case 'Triceps': return `Pour les triceps, ${levelName} signifie souvent une apparence plus dense du bras et une meilleure extension.`; case 'Legs': return `Pour les jambes, ${levelName} correspond à plus de force et d'endurance, avec un début de définition des quadriceps/ischios.`; case 'Abdos': return `Pour les abdominaux, ${levelName} indique un gainage plus solide lors des exercices directs et potentiellement une meilleure visibilité ou contrôle.`; default: return ''; } }
    function openLevelInfoModal(levelKey, muscleGroupName = null) { if (!levelInfoModal || !TARGET_LEVELS[levelKey]) return; const levelData = TARGET_LEVELS[levelKey]; modalIcon.className = `fas ${levelData.iconClass}`; modalLevelName.textContent = levelData.name; let bodyHtml = `<p>${levelData.description?.replace(/\n/g, '<br>') || '...'}</p>`; if (muscleGroupName) { const context = getMuscleSpecificContext(levelKey, muscleGroupName); if (context) { bodyHtml += `<p class="muscle-context">${context}</p>`; } } if(levelData.minHPS !== undefined) { bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Seuil HPS Minimum : <strong>${levelData.minHPS}</strong></p>`; } else if (levelData.targetHPS !== undefined) { bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Objectif HPS Benchmark : <strong>${levelData.targetHPS}</strong></p>`; } bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Exemple Physique: <i>${levelData.celebrity_example || 'N/A'}</i></p>`; modalBody.innerHTML = bodyHtml; modalTitle.style.color = `var(${levelData.colorVar})`; levelInfoModal.classList.add('visible'); }
    function closeLevelInfoModal() { if (levelInfoModal) levelInfoModal.classList.remove('visible'); }

    // --- Persistance Historique HPS (localStorage) ---
    function saveCurrentHPSToLocalStorage() { try { localStorage.setItem(LOCALSTORAGE_HPS_VALUES_KEY, JSON.stringify(currentHPSValues)); localStorage.setItem(LOCALSTORAGE_HPS_GLOBAL_KEY, overallAvgHPS.toString()); console.log("Scores HPS actuels sauvegardés dans localStorage."); } catch (e) { console.warn("Erreur sauvegarde HPS dans localStorage:", e); } }
    function loadPreviousHPSFromLocalStorage() { try { const savedValues = localStorage.getItem(LOCALSTORAGE_HPS_VALUES_KEY); const savedGlobal = localStorage.getItem(LOCALSTORAGE_HPS_GLOBAL_KEY); previousHPSValues = savedValues ? JSON.parse(savedValues) : {}; previousOverallAvgHPS = savedGlobal ? parseFloat(savedGlobal) : null; if(isNaN(previousOverallAvgHPS)) previousOverallAvgHPS = null; } catch (e) { console.error("Erreur lecture HPS depuis localStorage:", e); previousHPSValues = {}; previousOverallAvgHPS = null; } }
    function clearHPSLocalStorage() { try { localStorage.removeItem(LOCALSTORAGE_HPS_VALUES_KEY); localStorage.removeItem(LOCALSTORAGE_HPS_GLOBAL_KEY); console.log("Scores HPS supprimés de localStorage."); } catch (e) { console.warn("Erreur suppression HPS de localStorage:", e); } }

    // --- Animation & UI Update & Thème & Message ---
    function animateValue(el, start, end, duration) { if (!el) return; const fixedEnd = Math.round(end); const fixedStart = Math.round(start); if (fixedStart === fixedEnd) { el.textContent = fixedEnd; return; } const range = fixedEnd - fixedStart; if (range === 0) { el.textContent = fixedEnd; return; } let current = fixedStart; const increment = fixedEnd > fixedStart ? 1 : -1; const stepTime = Math.max(1, Math.min(50, Math.abs(Math.floor(duration / range)))); const timer = setInterval(() => { current += increment * Math.max(1, Math.round(Math.abs(fixedEnd - current) / 10)); if ((increment > 0 && current >= fixedEnd) || (increment < 0 && current <= fixedEnd)) { current = fixedEnd; clearInterval(timer); } el.textContent = current; }, stepTime); }
    function updateAuthUI(isLoggedIn) { console.log(`Update UI - Connecté: ${isLoggedIn}, GIS prêt: ${!!tokenClient}`); const b = document.body; b.classList.toggle('logged-in', isLoggedIn); b.classList.toggle('logged-out', !isLoggedIn); if(signInButton) signInButton.disabled = isLoggedIn || !tokenClient; if(signInButtonPrompt) signInButtonPrompt.disabled = isLoggedIn || !tokenClient; if(signOutButton) signOutButton.disabled = !isLoggedIn; if(themeToggleBtn) themeToggleBtn.disabled = false; if (connectionPrompt) connectionPrompt.style.display = isLoggedIn ? 'none' : 'block'; navButtons.forEach(btn => { btn.disabled = !isLoggedIn; if (isLoggedIn) { btn.style.display = 'inline-flex'; } else { btn.style.display = 'none'; }}); if (isLoggedIn) { switchTab(document.querySelector('.nav-button.active')?.dataset.section || 'evolution-tracker-area'); } else { appSections.forEach(sec => sec.style.display = 'none'); } if (!isLoggedIn) { programsAnalysisStatus = 'pending'; configLoadStatus = 'pending'; resetProgressionDisplay(); resetConfigUI(); resetHistoryUI(); } }
    function applyTheme(theme) { document.body.classList.remove('light-theme', 'dark-theme'); document.body.classList.add(theme + '-theme'); currentTheme = theme; localStorage.setItem('armorWorkoutTheme', theme); if (themeToggleBtn) { const i = themeToggleBtn.querySelector('i'); if (i) i.className = `fas fa-${theme === 'dark' ? 'sun' : 'moon'}`; themeToggleBtn.setAttribute('aria-label', `Passer au thème ${theme === 'dark' ? 'clair' : 'sombre'}`); } console.log(`Thème appliqué: ${theme}`); }
    function toggleTheme() { // Forcer le thème sombre pour l'instant
        applyTheme('dark');
        showMessage("Thème clair non disponible pour le moment.", 2000, 'info');
        // playSound('confirm'); // Optionnel
    }
    function loadSavedTheme() {
        // Toujours forcer le thème sombre au chargement
        applyTheme('dark');
        // const savedTheme = localStorage.getItem('armorWorkoutTheme') || 'dark';
        // applyTheme(savedTheme);
    }
    function showMessage(msg, duration = 3000, type = 'info') { if (!messageArea) return; messageArea.textContent = msg; messageArea.className = `message-area ${type} visible`; if (messageTimeoutId) clearTimeout(messageTimeoutId); messageTimeoutId = setTimeout(() => { messageArea.classList.remove('visible'); setTimeout(() => { if (!messageArea.classList.contains('visible')) { messageArea.className = 'message-area'; } }, 500); }, duration); }

    // --- Gestion Navigation ---
    function switchTab(targetSectionId) {
        if (!targetSectionId) return;
        console.log("Switch tab to:", targetSectionId);
        appSections.forEach(section => { section.style.display = 'none'; });
        const targetSection = document.getElementById(targetSectionId);
        if (targetSection) {
            targetSection.style.display = 'flex';
            targetSection.style.flexDirection = 'column';
        } else {
            console.error("Section cible non trouvée:", targetSectionId);
            // Fallback vers la première section si la cible n'existe pas
            const firstSection = document.querySelector('.app-section');
             if(firstSection) {
                firstSection.style.display = 'flex';
                firstSection.style.flexDirection = 'column';
                targetSectionId = firstSection.id;
             }
        }
        // Mettre à jour l'état actif des boutons de navigation
        navButtons.forEach(btn => { btn.classList.toggle('active', btn.dataset.section === targetSectionId); });

        // Actions spécifiques à l'onglet activé
        if (targetSectionId === 'program-config-area') {
            renderProgramConfigUI(); // Mettre à jour l'UI de config si elle est affichée
        } else if (targetSectionId === 'history-area') {
            renderHistoryUI(); // Mettre à jour l'UI de l'historique si elle est affichée
        }
    }

    // --- Initialisation ---
    function initializeDOMReferences() { console.log("Init DOM Refs..."); signInButton = document.getElementById('signin-button'); signOutButton = document.getElementById('signout-button'); driveStatusElement = document.getElementById('drive-status'); themeToggleBtn = document.getElementById('theme-toggle-btn'); signInButtonPrompt = document.getElementById('signin-button-prompt'); connectionPrompt = document.getElementById('connection-prompt'); evolutionTrackerArea = document.getElementById('evolution-tracker-area'); overallHPSDisplayValue = document.querySelector('#overall-hps-display .value'); levelBadgeContainer = document.getElementById('level-badge-container'); levelBadge = document.getElementById('level-badge'); if (levelBadge) { levelBadgeIcon = levelBadge.querySelector('i'); levelBadgeText = levelBadge.querySelector('span'); } targetHPSInfoStrong = document.querySelector('#target-hps-info strong'); marvelTargetInfoSpan = document.querySelector('#marvel-target-info'); muscleGroupsContainer = document.getElementById('muscle-groups-container'); programConfigArea = document.getElementById('program-config-area'); programConfigContent = document.getElementById('program-config-content'); saveConfigButton = document.getElementById('save-config-button'); historyArea = document.getElementById('history-area'); historyMuscleGroupSelect = document.getElementById('history-muscle-group-select'); historyPeriodBtns = document.querySelectorAll('.history-period-btn'); historyDisplay = document.getElementById('history-display'); messageArea = document.getElementById('message-area'); levelInfoModal = document.getElementById('level-info-modal'); modalTitle = document.getElementById('modal-title'); modalIcon = document.getElementById('modal-icon'); modalLevelName = document.getElementById('modal-level-name'); modalBody = document.getElementById('modal-body'); modalCloseBtn = document.getElementById('modal-close-btn'); appNav = document.getElementById('app-nav'); navButtons = document.querySelectorAll('.nav-button'); appSections = document.querySelectorAll('.app-section'); const critical = [signInButton, signOutButton, themeToggleBtn, signInButtonPrompt, connectionPrompt, evolutionTrackerArea, overallHPSDisplayValue, levelBadgeContainer, levelBadge, levelBadgeIcon, levelBadgeText, targetHPSInfoStrong, marvelTargetInfoSpan, muscleGroupsContainer, programConfigArea, programConfigContent, saveConfigButton, historyArea, historyMuscleGroupSelect, historyPeriodBtns, historyDisplay, messageArea, levelInfoModal, modalTitle, modalIcon, modalLevelName, modalBody, modalCloseBtn, appNav, navButtons, appSections]; if (critical.some(el => !el || (NodeList.prototype.isPrototypeOf(el) && el.length === 0))) { console.error("DOM CRITIQUES MANQUANTS!", critical.map((el, i) => el ? `OK_${i}` : `FAIL_${i}`)); showMessage("Erreur critique: UI incomplète.", 10000, 'error'); document.body.innerHTML = '<p style="color:red; padding: 20px;">Erreur critique interface. Vérifiez la console.</p>'; return false; } console.log("DOM Refs OK."); return true; }
    function addEventListeners() { if(signInButton) signInButton.addEventListener('click', handleAuthClick); if(signInButtonPrompt) signInButtonPrompt.addEventListener('click', handleAuthClick); if(signOutButton) signOutButton.addEventListener('click', () => handleSignoutClick(true)); if(themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme); document.body.addEventListener('click', initAudioContext, { once: true }); document.body.addEventListener('keydown', initAudioContext, { once: true }); if (levelBadge) levelBadge.addEventListener('click', () => { const key = levelBadge.getAttribute('data-level-key'); if(key) openLevelInfoModal(key); }); if (muscleGroupsContainer) { muscleGroupsContainer.addEventListener('click', (event) => { const indicator = event.target.closest('.level-indicator'); if (indicator) { const key = indicator.getAttribute('data-level-key'); const card = indicator.closest('.muscle-group-card'); const muscleName = card?.querySelector('.group-title')?.textContent; if (key) openLevelInfoModal(key, muscleName); } }); } if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeLevelInfoModal); if (levelInfoModal) levelInfoModal.addEventListener('click', (event) => { if (event.target === levelInfoModal) closeLevelInfoModal(); }); navButtons.forEach(button => { button.addEventListener('click', () => switchTab(button.dataset.section)); }); if (saveConfigButton) saveConfigButton.addEventListener('click', saveExerciseConfigToDrive); if(historyMuscleGroupSelect) historyMuscleGroupSelect.addEventListener('change', handleHistorySelectionChange); if(historyPeriodBtns) historyPeriodBtns.forEach(btn => btn.addEventListener('click', handleHistoryPeriodChange)); console.log("Écouteurs OK."); }

    // --- Point d'entrée ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Chargé. Init HPS System v7.2...");
        try {
            if (!initializeDOMReferences()) return;
            addEventListeners();
            loadSavedTheme(); // Appliquer thème sombre
            loadPreviousHPSFromLocalStorage(); // Charger avant la première UI update
            updateAuthUI(false); // Init état déconnecté
            resetProgressionDisplay(); // Afficher état initial HPS
            resetConfigUI(); // Afficher état initial Config
            resetHistoryUI(); // Afficher état initial Historique
            checkAndInitGis(); // Lancer init Google
            console.log("Init terminée. Attente API Google & utilisateur...");
        } catch (error) {
            console.error("Erreur Init DOMContentLoaded:", error);
            showMessage("Erreur critique chargement.", 10000, 'error');
            const b = document.querySelector('body');
            if(b) b.innerHTML = '<p style="color:red; padding: 20px;">Erreur critique chargement. Voir console.</p>';
        }
    });

</script>

</body>
</html>
