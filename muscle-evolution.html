<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Suivi Hypertrophie</title>
    <!-- Font Awesome & Google Fonts (inchangés) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        /* --- Variables CSS & Thèmes (inchangés - garder les couleurs niveaux) --- */
        :root {
            /* Thème Sombre */
            --bg-color-dark: #0a0f1e; --secondary-bg-color-dark: #141a30; --primary-text-color-dark: #e0e0ff; --secondary-text-color-dark: #8a94c1; --border-color-dark: #2a3150; --accent-border-color-dark: #4b558a; --input-bg-dark: #0a0f1e;
            /* Couleurs Néon/Gradient */
            --neon-blue: #6fa8ff; --neon-purple: #b18cff; --gradient-start: var(--neon-purple); --gradient-end: var(--neon-blue); --neon-green: #3fb950; --neon-red: #ff7b72; --neon-orange: #f9a825; --neon-yellow: #facc15;
            /* Couleurs Niveaux (RGBA pour bg) - GARDER CELLES-CI */
            --level-beginner-color: #8a94c1; --level-beginner-bg: rgba(138, 148, 193, 0.1);
            --level-bronze-color: #cd7f32;   --level-bronze-bg: rgba(205, 127, 50, 0.15);
            --level-silver-color: #c0c0c0;   --level-silver-bg: rgba(192, 192, 192, 0.15);
            --level-gold-color: #ffd700;     --level-gold-bg: rgba(255, 215, 0, 0.15);
            --level-crystal-color: #a7d8de;  --level-crystal-bg: rgba(167, 216, 222, 0.15);
            --level-master-color: #e384f1;   --level-master-bg: rgba(227, 132, 241, 0.15);
            --level-champion-color: #ff7b72; --level-champion-bg: rgba(255, 123, 114, 0.15);
            --level-titan-color: #aa99ff;    --level-titan-bg: rgba(170, 153, 255, 0.15);
            --level-legende-color: #fff7a3;  --level-legende-bg: rgba(255, 247, 163, 0.2);
            --level-marvel-color: #e62429;   --level-marvel-bg: rgba(230, 36, 41, 0.1);
            /* Glows */
            --glow-gradient: 0 0 20px rgba(177, 140, 255, 0.4), 0 0 30px rgba(111, 168, 255, 0.3); --glow-level-reached: 0 0 15px rgba(63, 185, 80, 0.7); --glow-connect: 0 0 10px rgba(63, 185, 80, 0.6); --glow-disconnect: 0 0 10px rgba(255, 123, 114, 0.6); --glow-marvel: 0 0 15px rgba(230, 36, 41, 0.6);
            /* Autres */
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; --border-radius-lg: 18px; --border-radius-md: 12px; --border-radius-sm: 8px; --transition-speed: 0.3s;
            /* RGBA */
            --bg-color-dark-rgb: 10, 15, 30; --secondary-bg-color-dark-rgb: 20, 26, 48; --primary-text-color-dark-rgb: 224, 224, 255; --secondary-text-color-dark-rgb: 138, 148, 193; --border-color-dark-rgb: 42, 49, 80; --neon-blue-rgb: 111, 168, 255; --neon-purple-rgb: 177, 140, 255; --neon-green-rgb: 63, 185, 80; --neon-red-rgb: 255, 123, 114; --neon-orange-rgb: 249, 168, 37;
            /* Thème Sombre */
            --bg-color: var(--bg-color-dark); --secondary-bg-color: var(--secondary-bg-color-dark); --primary-text-color: var(--primary-text-color-dark); --secondary-text-color: var(--secondary-text-color-dark); --border-color: var(--border-color-dark); --accent-border-color: var(--accent-border-color-dark); --input-bg: var(--input-bg-dark); --bg-color-rgb: var(--bg-color-dark-rgb); --secondary-bg-color-rgb: var(--secondary-bg-color-dark-rgb);
            /* Styles Spécifiques */
            --link-color: var(--neon-blue); --button-connect-color: var(--neon-green); --button-connect-glow: var(--glow-connect); --button-disconnect-color: var(--neon-red); --button-disconnect-glow: var(--glow-disconnect);
            /* Barres Progression */
            --progress-bar-bg: rgba(var(--primary-text-color-rgb), 0.1); --progress-bar-fill: linear-gradient(90deg, var(--gradient-start), var(--gradient-end));
        }

        /* --- Styles CSS (Identiques visuellement, ajustements mineurs si besoin) --- */
        /* Styles Généraux (body, container, header, nav, sections...) */
        * { box-sizing: border-box; margin: 0; padding: 0; } html { scroll-behavior: smooth; font-size: 16px; }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--primary-text-color); line-height: 1.6; transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; display: flex; flex-direction: column; min-height: 100vh; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; overflow-x: hidden; padding-top: 125px; /* Hauteur du header + nav */ }
        .container { max-width: 450px; margin: 0 auto; padding: 20px 15px; width: 100%; flex-grow: 1; display: flex; flex-direction: column; }
        #app-header { position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; background-color: rgba(var(--bg-color-rgb), 0.85); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-bottom: 1px solid var(--border-color); transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease; }
        .header-content { display: flex; flex-direction: column; align-items: center; max-width: 450px; margin: 0 auto; padding: 10px 15px 5px; gap: 8px; }
        header .title-container { display: flex; flex-direction: column; align-items: center; gap: 5px; }
        header .title-container i.header-icon { font-size: 1.8em; color: var(--primary-text-color); opacity: 0.8; }
        header h1 { font-size: 1.1em; color: var(--primary-text-color); margin: 0; font-weight: 500; letter-spacing: 0.1em; text-transform: uppercase; }
        .header-actions { display: flex; gap: 15px; align-items: center; justify-content: space-between; width: 100%; }
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button { background: none; border: 1px solid var(--border-color); color: var(--secondary-text-color); padding: 5px 12px; border-radius: var(--border-radius-md); font-size: 0.8em; font-weight: 500; cursor: pointer; transition: all var(--transition-speed) ease; display: inline-flex; align-items: center; gap: 5px; }
        .auth-controls button:disabled { opacity: 0.4; cursor: not-allowed; background: transparent !important; border-color: var(--border-color) !important; color: var(--secondary-text-color) !important; box-shadow: none !important; }
        .auth-controls button:not(:disabled):hover { border-color: var(--accent-border-color); color: var(--primary-text-color); background-color: rgba(var(--primary-text-color-rgb), 0.05); }
        #signin-button, #signin-button-prompt { border-color: var(--button-connect-color); color: var(--button-connect-color); }
        #signin-button:not(:disabled):hover, #signin-button-prompt:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--button-connect-glow); }
        #signout-button { border-color: var(--button-disconnect-color); color: var(--button-disconnect-color); }
        #signout-button:not(:disabled):hover { background-color: rgba(var(--neon-red-rgb), 0.1); box-shadow: var(--button-disconnect-glow); }
        #drive-status { display: none; }
        .theme-toggle button { background: none; border: none; color: var(--secondary-text-color); font-size: 1.1em; padding: 5px; cursor: pointer; transition: color var(--transition-speed) ease; }
        .theme-toggle button:hover { color: var(--neon-purple); }
        #app-nav { display: flex; justify-content: center; gap: 10px; padding: 8px 15px; border-top: 1px solid var(--border-color); background-color: rgba(var(--secondary-bg-color-rgb), 0.5); }
        .nav-button { background: none; border: none; color: var(--secondary-text-color); font-size: 0.85em; font-weight: 500; padding: 6px 12px; border-radius: var(--border-radius-md); cursor: pointer; transition: all 0.2s ease; border: 1px solid transparent; display: inline-flex; align-items: center; gap: 6px;}
        .nav-button i { font-size: 1.1em; width: 1.1em; text-align: center;}
        .nav-button:hover { color: var(--primary-text-color); background-color: rgba(var(--primary-text-color-rgb), 0.05); }
        .nav-button.active { color: var(--neon-blue); border-color: var(--neon-blue); background-color: rgba(var(--neon-blue-rgb), 0.1); font-weight: 700; }
        .nav-button:disabled { opacity: 0.5; cursor: not-allowed; color: var(--secondary-text-color) !important; background: none !important; border-color: transparent !important;}
        /* Affichage Conditionnel Sections & Auth */
        body.logged-out .nav-button { display: none; }
        body.logged-out #signin-button, body.logged-out #signin-button-prompt { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-in #signin-button, body.logged-in #signin-button-prompt { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-out #connection-prompt { display: block; }
        body.logged-in #connection-prompt { display: none; }
        body.logged-out .app-section { display: none; }
        body.logged-in .app-section { display: none; } /* Caché par défaut, JS gère l'affichage */
        /* Main & Prompt */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 20px; }
        #connection-prompt { text-align: center; padding: 30px 20px; background-color: var(--secondary-bg-color); border-radius: var(--border-radius-lg); border: 1px dashed var(--border-color); margin: 20px auto; max-width: 90%; }
        #connection-prompt p { margin-bottom: 15px; color: var(--secondary-text-color); font-size: 0.9em;}
        #connection-prompt button { padding: 8px 18px; font-size: 0.9em; }
        .app-section { width: 100%; }

        /* Section Évolution (HPS) */
        #evolution-tracker-area { display: flex; flex-direction: column; gap: 20px; }
        .global-stats-card { background-color: var(--secondary-bg-color); border-radius: var(--border-radius-lg); padding: 25px 20px; text-align: center; border: 1px solid var(--border-color); box-shadow: 0 10px 30px rgba(0,0,0, 0.2); position: relative; overflow: hidden; }
        .global-stats-card::before { content: ''; position: absolute; top: -30%; left: -30%; width: 160%; height: 160%; background: radial-gradient(circle, rgba(var(--neon-blue-rgb), 0.08) 0%, rgba(var(--neon-blue-rgb), 0) 60%); animation: rotateGlow 15s linear infinite; pointer-events: none; opacity: 0.7; }
        @keyframes rotateGlow { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .global-stats-card .card-title { font-size: 0.9em; color: var(--secondary-text-color); margin-bottom: 10px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05em; }
        #overall-hps-display .value { font-size: 4.5em; font-weight: 900; line-height: 1; margin-bottom: 15px; display: block; background: linear-gradient(90deg, var(--gradient-start), var(--gradient-end)); -webkit-background-clip: text; background-clip: text; color: transparent; text-shadow: var(--glow-gradient); animation: pulse-text 3s infinite ease-in-out; }
        @keyframes pulse-text { 0%, 100% { text-shadow: var(--glow-gradient); opacity: 1; } 50% { text-shadow: 0 0 15px rgba(177, 140, 255, 0.3), 0 0 25px rgba(111, 168, 255, 0.2); opacity: 0.95; } }
        #level-badge-container { display: inline-flex; align-items: center; gap: 10px; position: relative; cursor: default; }
        #level-badge { display: inline-flex; align-items: center; gap: 8px; padding: 6px 15px; border-radius: var(--border-radius-md); font-size: 0.9em; font-weight: 700; border: 1px solid transparent; transition: all var(--transition-speed) ease; cursor: pointer; }
        #level-badge i { font-size: 1.2em; width: 1.2em; text-align: center;}
        .marvel-achieved-icon { font-size: 1.1em; color: var(--level-marvel-color); vertical-align: middle; cursor: help; text-shadow: var(--glow-marvel); animation: marvelIconPulse 2s infinite ease-in-out; }
        @keyframes marvelIconPulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.8; } }
        .target-info-container { margin-top: 10px; font-size: 0.85em; color: var(--secondary-text-color); display: flex; flex-wrap: wrap; justify-content: center; gap: 5px 10px; }
        .target-info-container span { margin: 0; } .target-info-container strong { font-weight: 700; color: var(--primary-text-color); } .target-info-container .marvel-target { color: var(--level-marvel-color); font-weight: 700;}
        @keyframes levelUpGlow { 0% { box-shadow: 0 10px 30px rgba(0,0,0, 0.2), 0 0 0px rgba(var(--neon-green-rgb), 0); border-color: var(--border-color);} 50% { box-shadow: 0 10px 30px rgba(0,0,0, 0.1), 0 0 30px rgba(var(--neon-green-rgb), 0.7); border-color: var(--neon-green);} 100% { box-shadow: 0 10px 30px rgba(0,0,0, 0.2), 0 0 0px rgba(var(--neon-green-rgb), 0); border-color: var(--border-color);} }
        #muscle-groups-container { display: flex; flex-direction: column; gap: 15px; }
        .muscle-group-card { background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); border-radius: var(--border-radius-md); padding: 15px; display: flex; flex-direction: column; gap: 10px; transition: all var(--transition-speed) ease; position: relative; overflow: hidden; }
        .muscle-group-card:hover { border-color: var(--accent-border-color); transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0, 0.15); }
        .muscle-group-card .card-header { display: flex; align-items: center; gap: 12px; margin-bottom: 5px; }
        .muscle-group-card .icon-container { flex-shrink: 0; color: var(--secondary-text-color); font-size: 1.8em; width: 35px; text-align: center; opacity: 0.7; }
        .muscle-group-card .title-container { flex-grow: 1; } .muscle-group-card .group-title { font-size: 1.05em; font-weight: 700; color: var(--primary-text-color); line-height: 1.2; } .muscle-group-card .group-subtitle { font-size: 0.85em; color: var(--secondary-text-color); font-weight: 400; line-height: 1.2; margin-bottom: 2px; }
        .muscle-group-card .group-level-name { font-size: 0.8em; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em; line-height: 1; padding: 2px 6px; border-radius: var(--border-radius-sm); display: inline-block; margin-top: 4px; border: 1px solid; cursor: pointer; }
        .muscle-group-card .hps-details { font-size: 0.9em; font-weight: 500; color: var(--secondary-text-color); text-align: right; white-space: nowrap; } /* Renommé */
        .muscle-group-card .hps-details .current { color: var(--primary-text-color); font-weight: 700; }
        .muscle-group-card .hps-details .target { }
        .progress-section { display: flex; align-items: center; gap: 10px; margin-top: 5px; }
        .progress-bar-container { flex-grow: 1; height: 8px; background-color: var(--progress-bar-bg); border-radius: 4px; overflow: hidden; position: relative; }
        .progress-bar { height: 100%; width: 0%; background: var(--progress-bar-fill); border-radius: 4px; transition: width 0.8s cubic-bezier(0.25, 1, 0.5, 1); box-shadow: var(--glow-gradient); }
        .progress-percentage-value { font-size: 0.9em; font-weight: 700; color: var(--secondary-text-color); flex-shrink: 0; width: 40px; text-align: right; transition: color 0.3s ease; }
        .muscle-group-card.level-target-reached { border-color: var(--neon-green); box-shadow: 0 0 15px rgba(var(--neon-green-rgb), 0.3); }
        .muscle-group-card.level-target-reached .progress-percentage-value { color: var(--neon-green); }
        .muscle-group-card.level-target-reached::after { content: '\f00c'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; top: 10px; right: 10px; color: var(--neon-green); font-size: 0.9em; opacity: 0; animation: fadeInCheck 0.5s 0.5s ease forwards; }
        @keyframes fadeInCheck{ from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } }

        /* Section Config Équipement (inchangée visuellement) */
        #program-config-area { background-color: transparent; border-radius: 0; padding: 15px 5px; border: none; margin-top: 10px; display: flex; flex-direction: column; }
        #program-config-area h2 { font-size: 1.4em; color: var(--primary-text-color); border-bottom: 2px solid var(--neon-blue); padding-bottom: 10px; margin-bottom: 25px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 10px;}
        #program-config-content { flex-grow: 1; overflow-y: auto; max-height: 65vh; }
        .program-config-section { margin-bottom: 30px; background-color: var(--secondary-bg-color); border-radius: var(--border-radius-md); padding: 15px; border: 1px solid var(--border-color); }
        .program-config-section h3 { font-size: 1.2em; color: var(--neon-purple); margin-bottom: 15px; font-weight: 700; text-align: center; border-bottom: 1px dashed var(--border-color); padding-bottom: 8px;}
        .config-exercise-item { margin-bottom: 20px; padding: 15px; background-color: rgba(var(--bg-color-rgb), 0.5); border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); }
        .config-exercise-item .exercise-name { font-weight: 700; display: block; margin-bottom: 10px; color: var(--primary-text-color); font-size: 1.05em; border-bottom: 1px solid var(--accent-border-color); padding-bottom: 5px;}
        .config-equipment-options { display: grid; grid-template-columns: 1fr; gap: 10px; }
        @media (min-width: 400px) { .config-equipment-options { grid-template-columns: 1fr 1fr; } }
        .config-equipment-options label { display: flex; align-items: center; gap: 8px; font-size: 0.95em; cursor: pointer; padding: 8px 10px; border-radius: var(--border-radius-sm); transition: background-color 0.2s ease; border: 1px solid var(--border-color);}
        .config-equipment-options label:hover { background-color: rgba(var(--primary-text-color-rgb), 0.1); }
        .config-equipment-options input[type="checkbox"] { accent-color: var(--neon-blue); cursor: pointer; width: 16px; height: 16px; }
        #save-config-button { display: block; width: 100%; background-color: var(--neon-blue); color: #fff; border: none; padding: 12px 15px; border-radius: var(--border-radius-md); font-size: 1.1em; font-weight: 700; cursor: pointer; transition: background-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease; text-align: center; margin-top: 25px; flex-shrink: 0; }
        #save-config-button:hover { background-color: var(--gradient-end); box-shadow: 0 0 10px rgba(var(--neon-blue-rgb), 0.5); }
        #save-config-button:disabled { background-color: var(--secondary-text-color); cursor: not-allowed; box-shadow: none; opacity: 0.6; }
        #save-config-button .spinner { display: none; margin-left: 10px; } #save-config-button.saving .spinner { display: inline-block; } #save-config-button.saving span { display: none; }

        /* Section Détails Niveaux (inchangée visuellement, mais affichera minHPS) */
        #level-details-area { background-color: transparent; border: none; padding: 15px 5px; margin-top: 10px; display: flex; flex-direction: column; }
        #level-details-area h2 { font-size: 1.4em; color: var(--primary-text-color); border-bottom: 2px solid var(--neon-orange); padding-bottom: 10px; margin-bottom: 25px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 10px;}
        #level-details-content { display: flex; flex-direction: column; gap: 20px; /* Réduit l'écart */}
        .level-detail-item { background-color: var(--secondary-bg-color); border: 1px solid var(--border-color); border-left: 5px solid; border-radius: var(--border-radius-md); padding: 15px; /* Réduit padding */ box-shadow: 0 3px 10px rgba(0,0,0,0.1); }
        .level-detail-header { display: flex; align-items: center; gap: 10px; /* Réduit l'écart */ margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px dashed var(--border-color); }
        .level-detail-icon { font-size: 1.5em; /* Réduit taille */ width: 1.5em; text-align: center; }
        .level-detail-name { font-size: 1.1em; /* Réduit taille */ font-weight: 700; }
        .level-detail-hps { font-size: 0.85em; /* Renommé & Réduit taille */ color: var(--secondary-text-color); margin-left: auto; background-color: rgba(var(--bg-color-rgb), 0.5); padding: 2px 6px; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color); }
        .level-detail-description { font-size: 0.95em; /* Réduit taille */ color: var(--primary-text-color); margin-bottom: 10px; line-height: 1.6; }
        .level-detail-celebrity { font-size: 0.9em; /* Réduit taille */ color: var(--secondary-text-color); font-style: italic; background-color: rgba(var(--bg-color-rgb), 0.3); padding: 4px 8px; border-radius: var(--border-radius-sm); display: inline-block;}
        .level-detail-celebrity strong { color: var(--primary-text-color); font-style: normal; font-weight: 600; }

        /* Modal (inchangée) */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); display: flex; justify-content: center; align-items: center; z-index: 5000; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--secondary-bg-color); padding: 25px; border-radius: var(--border-radius-md); border: 1px solid var(--border-color); max-width: 90%; width: 400px; box-shadow: 0 5px 20px rgba(0,0,0,0.3); position: relative; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .modal-title { font-size: 1.2em; font-weight: 700; display: flex; align-items: center; gap: 10px; } .modal-title i { font-size: 1.1em; width: 1.2em; text-align: center;}
        .modal-close-btn { background: none; border: none; color: var(--secondary-text-color); font-size: 1.5em; cursor: pointer; padding: 5px; line-height: 1; transition: color 0.2s ease; }
        .modal-close-btn:hover { color: var(--primary-text-color); } .modal-body { font-size: 0.95em; line-height: 1.6; color: var(--primary-text-color); max-height: 60vh; overflow-y: auto; }
        .modal-body::-webkit-scrollbar { width: 6px; } .modal-body::-webkit-scrollbar-track { background: rgba(var(--primary-text-color-rgb), 0.05); border-radius: 3px;} .modal-body::-webkit-scrollbar-thumb { background-color: var(--accent-border-color); border-radius: 3px; } .modal-body::-webkit-scrollbar-thumb:hover { background-color: var(--neon-blue); }

        /* Footer, Messages, Placeholders (inchangés) */
        footer { color: var(--secondary-text-color); opacity: 0.6; border-top: 1px solid var(--border-color); margin-top: 40px; padding: 20px 15px; text-align: center; font-size: 0.8em; transition: border-color var(--transition-speed) ease, color var(--transition-speed) ease; }
        footer a { color: var(--link-color); text-decoration: none; } footer a:hover { color: var(--primary-text-color); }
        .message-area { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: rgba(var(--secondary-bg-color-rgb), 0.9); color: var(--primary-text-color); border: 1px solid var(--border-color); padding: 10px 20px; border-radius: var(--border-radius-md); z-index: 6000; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease; pointer-events: none; font-size: 0.9em; box-shadow: 0 4px 15px rgba(0,0,0,0.2); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); max-width: 90%; text-align: center; }
        .message-area.visible { opacity: 1; transform: translate(-50%, 0); bottom: 30px; pointer-events: auto; }
        .message-area.error { background-color: rgba(var(--neon-red-rgb), 0.9); color: #fff; border-color: var(--neon-red); } .message-area.success { background-color: rgba(var(--neon-green-rgb), 0.9); color: #fff; border-color: var(--neon-green); } .message-area.warning { background-color: rgba(var(--neon-orange-rgb), 0.9); color: #fff; border-color: var(--neon-orange); } .message-area.info { background-color: rgba(var(--neon-blue-rgb), 0.9); color: #fff; border-color: var(--neon-blue); }
        .loading-placeholder, .error-placeholder { background-color: var(--secondary-bg-color); border-radius: var(--border-radius-md); padding: 30px 20px; text-align: center; color: var(--secondary-text-color); font-style: italic; border: 1px dashed var(--border-color); margin: 10px 0; /* Ajusté margin */}
        .error-placeholder { color: var(--neon-red); border-color: var(--neon-red); }

        /* Responsive (inchangé) */
        @media (min-width: 768px) { .container { max-width: 600px; } .header-content { flex-direction: row; justify-content: space-between; max-width: 900px;} .header-actions { width: auto; } body { padding-top: 100px; } }

    </style>
</head>
<body class="logged-out dark-theme">

<header id="app-header">
    <div class="header-content">
         <div class="title-container"> <i class="fas fa-shield header-icon"></i> <h1>ArmorWorkout</h1> </div>
        <div class="header-actions">
            <div class="auth-controls"> <button id="signin-button" disabled><i class="fab fa-google"></i> Connexion</button> <button id="signout-button" disabled><i class="fas fa-sign-out-alt"></i> Déconnexion</button> </div>
             <span id="drive-status" aria-live="polite"></span>
            <div class="theme-toggle"> <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button> </div>
        </div>
    </div>
    <nav id="app-nav">
        <button class="nav-button active" data-section="evolution-tracker-area" disabled><i class="fas fa-chart-line"></i> Évolution</button>
        <button class="nav-button" data-section="program-config-area" disabled><i class="fas fa-cogs"></i> Équipement</button>
        <button class="nav-button" data-section="level-details-area" disabled><i class="fas fa-layer-group"></i> Niveaux</button>
    </nav>
</header>
<div class="container">
    <main>
        <div id="connection-prompt">
            <p>Connectez-vous via Google pour suivre votre potentiel d'hypertrophie et configurer votre équipement.</p>
            <button id="signin-button-prompt" disabled><i class="fab fa-google"></i> Se connecter</button>
        </div>

        <!-- Section Évolution (HPS) -->
        <div id="evolution-tracker-area" class="app-section" style="display: none;">
            <div class="global-stats-card">
                 <div class="card-title">Score HPS Haut du Corps</div> <!-- MODIFIÉ -->
                 <div id="overall-hps-display"> <span class="value">--</span> </div> <!-- MODIFIÉ ID -->
                 <div id="level-badge-container" title="Cliquez pour voir la description du niveau">
                     <div id="level-badge" class="level-unknown" data-level-key="L0_Base"> <i class="fas fa-seedling"></i> <span>Débutant</span> </div> <!-- MODIFIÉ icone/texte initial -->
                 </div>
                 <div class="target-info-container">
                      <span id="target-hps-info">Objectif Niv. Suivant: <strong>-- HPS</strong></span> <!-- MODIFIÉ -->
                      <span id="marvel-target-info" style="display: inline-block;"> | Benchmark <strong class="marvel-target">Marvel: -- HPS</strong></span> <!-- MODIFIÉ -->
                 </div>
            </div>
            <div id="muscle-groups-container" aria-live="polite">
                 <p class="loading-placeholder">Connectez-vous pour charger vos données...</p>
            </div>
        </div>

        <!-- Section Config Équipement (inchangée structurellement) -->
        <div id="program-config-area" class="app-section" style="display: none;">
             <h2><i class="fas fa-dumbbell"></i> Configuration Équipement Additionnel</h2>
             <div id="program-config-content">
                 <p class="loading-placeholder">Chargez vos programmes pour configurer...</p>
             </div>
             <button id="save-config-button" disabled>
                 <span><i class="fas fa-save"></i> Sauvegarder Équipement</span>
                 <i class="fas fa-spinner fa-spin spinner"></i>
             </button>
        </div>

        <!-- Section Détails Niveaux (inchangée structurellement) -->
         <div id="level-details-area" class="app-section" style="display: none;">
             <h2><i class="fas fa-layer-group"></i> Détails des Niveaux HPS</h2> <!-- MODIFIÉ -->
             <div id="level-details-content">
                  <p class="loading-placeholder">Connectez-vous pour voir les détails...</p>
             </div>
         </div>
    </main>
</div>

<footer>
     <p>© 2024 ArmorWorkout | <a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></p>
</footer>

<!-- Modal (inchangée structurellement) -->
<div id="level-info-modal" class="modal-overlay"> <div class="modal-content"> <div class="modal-header"> <h3 id="modal-title" class="modal-title"> <i id="modal-icon" class="fas fa-info-circle"></i> <span id="modal-level-name"></span> </h3> <button id="modal-close-btn" class="modal-close-btn">×</button> </div> <div id="modal-body" class="modal-body"></div> </div> </div>

<!-- Zone Message (inchangée) -->
<div id="message-area" class="message-area" role="status" aria-live="polite"></div>

<!-- Scripts -->
<script async defer src="https://accounts.google.com/gsi/client"></script>
<script>
    // --- CONFIGURATION & CONSTANTES GLOBALES ---
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const PROGRAM_FILENAMES = { Push: "armorworkout_push_program.json", Pull: "armorworkout_pull_program.json", Legs: "armorworkout_legs_program.json" };
    const EQUIPMENT_CONFIG_FILENAME = "armorworkout_exercise_config.json";
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const GIS_CHECK_INTERVAL = 100;
    const GIS_MAX_RETRIES = 50;

    // --- PARAMÈTRES HPS (Hypertrophy Potential Score) ---
    // CALIBRATION: Ces valeurs DOIVENT être ajustées par l'expert (vous !)
    const HPS_BASE = 0; // Score HPS pour le niveau de base (Débutant)
    const HP_REFERENCE_GLOBAL = 5000; // Total HP hebdomadaire estimé pour atteindre juste au-dessus du niveau Débutant
    const K_LOG = 500; // Facteur d'échelle logarithmique (plus K est grand, plus le score HPS monte vite)

    // CALIBRATION: Efficacité relative des exercices (1.0 = référence)
    const EXERCISE_EFFICACY = {
        // PUSH
        'Pompes (Push-ups)': 1.1,
        'Band Standing Chest Press': 0.9,
        'Band Floor Press': 0.85,
        'Overhead Press (Haltères)': 1.05, // Moins stable mais bon pour épaules
        'Dumbbell Lateral Raises': 1.0,
        'Overhead Triceps Extension (Band)': 1.1, // Bon étirement longue portion
        // PULL
        'Band Bent-over Row': 1.1, // Bon pour épaisseur dos
        'Band Kneeling Lat Pulldown': 1.0, // Focus largeur
        'Band Face Pull': 1.0, // Important pour santé épaules / haut du dos
        'Curl Marteau (Hammer Curl)': 0.95, // Brachial/Avant-bras
        'Concentration Curl (Band)': 1.0, // Isolation Biceps
        // LEGS / CORE
        'Front Squat Combo': 1.15, // Polyarticulaire demandant
        'Fentes Arrière (Alternées)': 1.1, // Unilatéral, stabilité
        'Calf Raises (sur livre/marche)': 0.9, // Isolation mollets
        'Hollow Body Hold': 0.8, // Isométrie gainage
        'Band Sit-up': 0.9, // Focus abdos (flexion)
        'Leg Raises (Relevé de jambes)': 0.9, // Focus bas abdos/fléchisseurs hanche
        // --- Default ---
        'DEFAULT': 1.0 // Pour exercices non listés
    };

    // CALIBRATION: Charge effective standardisée pour chaque équipement
    const EFFECTIVE_LOAD = {
        'Poids du corps': 50, // Référence
        '1 haltère 5kg': 5,   // Ajout faible
        '2 haltères 5kg': 10,  // Total faible pour OHP/Lateral etc.
        '1 élastique 15 kg': 25, // Tension moyenne estimée
        '1 élastique 15 kg doublé': 40, // Plus que simple, moins que 2x
        '1 élastique 25 kg': 40, // Tension moyenne estimée
        'Élastique 15+25kg': 65, // Combinaison
        'Élastique 15+25kg + 1 haltère 5kg': 70, // 65 + 5
        'Élastique 15+25kg + 2x5kg haltères': 75, // 65 + 10
         // --- Default ---
        'DEFAULT': 10 // Valeur faible pour équipement inconnu/non listé
    };

    // Équipement sélectionnable dans la config UI
    const AVAILABLE_EQUIPMENT_CONFIG = [
        '1 haltère 5kg',
        '2 haltères 5kg', // Garder même si non utilisé pour ajout ? Ou retirer ? Pour l'instant on le liste.
        '1 élastique 15 kg',
        '1 élastique 15 kg doublé',
        '1 élastique 25 kg',
    ];

    // CALIBRATION: Facteurs d'effort basés sur la position de reps/duration_start dans la fourchette cible
    const EFFORT_FACTORS = {
        LOW: 0.9,    // 0-33% de la fourchette [start, target_max]
        MID: 1.0,    // 34-66%
        HIGH: 1.1,   // 67-99%
        TARGET_MET: 1.2 // >= 100% (start >= target_max)
    };

    // CALIBRATION: Poids des groupes musculaires pour le HPS global (Haut du corps)
    const WEIGHTS_GLOBAL_HPS = {
        Pectoraux: 0.20,
        Dos: 0.25,
        Épaules: 0.15,
        Biceps: 0.10,
        Triceps: 0.10,
        Core: 0.20
        // Total doit faire 1.0
    };

    // --- NIVEAUX (Seuils minHPS à CALIBRER !) ---
    // CALIBRATION: Les valeurs 'minHPS' sont des exemples basés sur la nouvelle échelle (0 + 500*log...).
    // Il FAUT les ajuster pour qu'ils correspondent à votre vision des niveaux !
    const TARGET_LEVELS = {
        'L0_Base':    { name: "Débutant",      minHPS: 0,    description: "Point de départ. Focus technique et régularité.", celebrity_example: "N/A", colorVar: '--level-beginner-color', bgVar: '--level-beginner-bg', iconClass: 'fa-seedling' },
        'L1_Bronze':  { name: "Bronze",        minHPS: 100,  description: "Fondations posées. Force de base.", celebrity_example: "Début transformation", colorVar: '--level-bronze-color',   bgVar: '--level-bronze-bg',   iconClass: 'fa-shield-halved' },
        'L2_Silver':  { name: "Argent",        minHPS: 250,  description: "Physique athlétique naissant.", celebrity_example: "Sportif amateur régulier", colorVar: '--level-silver-color',   bgVar: '--level-silver-bg',   iconClass: 'fa-shield' },
        'L3_Gold':    { name: "Or",            minHPS: 400,  description: "Force confirmée. Définition visible.", celebrity_example: "Ryan Reynolds 'Deadpool'", colorVar: '--level-gold-color',     bgVar: '--level-gold-bg',     iconClass: 'fa-trophy' },
        'L_Marvel':   { name: "Marvel Physique", targetHPS: 550, description: "Benchmark : Esthétique 'super-héroïque' moderne...", celebrity_example: "Chris Hemsworth ('Thor')", colorVar: '--level-marvel-color', bgVar: '--level-marvel-bg', iconClass: 'fa-bolt-lightning' },
        'L4_Crystal': { name: "Crystal",       minHPS: 500,  description: "Niveau avancé. Volume notable, définition claire.", celebrity_example: "Michael B. Jordan 'Creed'", colorVar: '--level-crystal-color',  bgVar: '--level-crystal-bg',  iconClass: 'fa-gem' },
        'L5_Master':  { name: "Master",        minHPS: 600,  description: "Maîtrise physique. Muscles très développés.", celebrity_example: "Henry Cavill 'Superman'", colorVar: '--level-master-color',   bgVar: '--level-master-bg',   iconClass: 'fa-chess-king' },
        'L6_Champion':{ name: "Champion",      minHPS: 700,  description: "Physique d'élite. Volume et définition exceptionnels.", celebrity_example: "Dwayne 'The Rock' Johnson", colorVar: '--level-champion-color', bgVar: '--level-champion-bg', iconClass: 'fa-crown' },
        'L7_Titan':   { name: "Titan",         minHPS: 850,  description: "Force et masse colossales.", celebrity_example: "Hafþór Björnsson 'The Mountain'", colorVar: '--level-titan-color',    bgVar: '--level-titan-bg',    iconClass: 'fa-mountain-sun' },
        'L8_Legende': { name: "Legende",       minHPS: 1000, description: "Statut quasi-mythique.", celebrity_example: "Arnold Schwarzenegger (apogée)", colorVar: '--level-legende-color',  bgVar: '--level-legende-bg',  iconClass: 'fa-meteor' },
    };
    const LEVEL_ORDER = ['L0_Base', 'L1_Bronze', 'L2_Silver', 'L3_Gold', 'L4_Crystal', 'L5_Master', 'L6_Champion', 'L7_Titan', 'L8_Legende'];
    const MARVEL_BENCHMARK_KEY = 'L_Marvel';

    // --- Mapping Muscles ---
    const MUSCLE_GROUPS_DISPLAY_CONFIG = { "Pectoraux": { subtitle: "Poitrine", icon: 'fa-dot-circle' }, "Dos": { subtitle: "Dorsaux/Trapèzes", icon: 'fa-bars-staggered' }, "Épaules":{ subtitle: "Deltoïdes", icon: 'fa-atom' }, "Biceps": { subtitle: "Bras (Flex.)", icon: 'fa-link' }, "Triceps": { subtitle: "Bras (Ext.)", icon: 'fa-diamond' }, "Core": { subtitle: "Abdos/Lombaires", icon: 'fa-bullseye' } };
    const LOGIC_TO_DISPLAY_MAP = { Pectoraux: "Pectoraux", Dos: "Dos", Épaules: "Épaules", Biceps: "Biceps", Triceps: "Triceps", Core: "Core" };
    const ALL_MUSCLE_GROUPS_LOGIC = Object.keys(LOGIC_TO_DISPLAY_MAP); // Pour HPS global haut du corps

    // --- Éléments DOM ---
    let signInButton, signOutButton, driveStatusElement, themeToggleBtn, signInButtonPrompt, connectionPrompt, evolutionTrackerArea, overallHPSDisplayValue, levelBadgeContainer, levelBadge, levelBadgeIcon, levelBadgeText, targetHPSInfoStrong, marvelTargetInfoSpan, muscleGroupsContainer, messageArea, levelInfoModal, modalTitle, modalIcon, modalLevelName, modalBody, modalCloseBtn, appNav, navButtons, appSections, programConfigArea, programConfigContent, saveConfigButton, levelDetailsArea, levelDetailsContent;

    // --- Variables d'État ---
    let googleAccessToken = null; let tokenClient = null; let programFileIds = { Push: null, Pull: null, Legs: null }; let equipmentConfigFileId = null; let loadedPrograms = { Push: [], Pull: [], Legs: [] }; let exerciseConfig = {}; let programsAnalysisStatus = 'pending'; let configLoadStatus = 'pending'; let currentHPSValues = {}; let overallAvgHPS = HPS_BASE; let currentGlobalLevelKey = LEVEL_ORDER[0]; let currentTheme = 'dark'; let messageTimeoutId = null; let gisCheckRetries = 0; let previousOverallAvgHPS = null;

    // --- Audio (inchangé) ---
    let audioContext = null; function initAudioContext() { if (!audioContext && typeof AudioContext !== 'undefined') { try { audioContext = new AudioContext(); } catch (e) { console.warn("AudioContext non supporté.", e); } } } function playSound(type = 'confirm', volume = 0.15) { if (!audioContext) return; try { const o = audioContext.createOscillator(), g = audioContext.createGain(); o.connect(g); g.connect(audioContext.destination); g.gain.setValueAtTime(0, audioContext.currentTime); g.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01); const t = audioContext.currentTime; let stopTime = t + 0.2; switch (type) { case 'confirm': o.type = 'sine'; o.frequency.setValueAtTime(523.25, t); o.frequency.linearRampToValueAtTime(783.99, t + 0.1); break; case 'error': o.type = 'square'; o.frequency.setValueAtTime(220, t); o.frequency.linearRampToValueAtTime(110, t + 0.15); break; case 'level_up': o.type = 'triangle'; g.gain.linearRampToValueAtTime(volume * 1.2, t + 0.01); o.frequency.setValueAtTime(440, t); o.frequency.linearRampToValueAtTime(554.37, t + 0.08); o.frequency.linearRampToValueAtTime(659.25, t + 0.16); o.frequency.linearRampToValueAtTime(880, t + 0.24); g.gain.exponentialRampToValueAtTime(0.0001, t + 0.4); stopTime = t + 0.4; o.start(t); o.stop(stopTime); return; default: o.type = 'triangle'; o.frequency.setValueAtTime(659.25, t); break; } o.start(t); o.stop(stopTime); } catch (e) { console.warn("Erreur lecture son:", e); } }

    // --- Google Identity Services & Drive API (inchangé structurellement, mais appelle les nouvelles fonctions de chargement) ---
    async function gisInitInternal() { try { tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CLIENT_ID, scope: GOOGLE_DRIVE_SCOPES, callback: tokenCallback, error_callback: handleTokenError, }); console.log("GIS Client init."); updateAuthUI(googleAccessToken !== null); } catch (error) { console.error("Erreur init GIS:", error); showMessage("Init Google impossible.", 5000, 'error'); if (signInButton) signInButton.disabled = true; if (signInButtonPrompt) signInButtonPrompt.disabled = true; } }
    function checkAndInitGis() { if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) { console.log("GIS prêt, init..."); gisInitInternal(); } else if (gisCheckRetries < GIS_MAX_RETRIES) { gisCheckRetries++; console.log(`GIS non prêt, retry ${gisCheckRetries}/${GIS_MAX_RETRIES}...`); setTimeout(checkAndInitGis, GIS_CHECK_INTERVAL); } else { console.error("Échec chargement GIS."); showMessage("Service Auth Google indispo.", 6000, 'error'); if (signInButton) signInButton.disabled = true; if (signInButtonPrompt) signInButtonPrompt.disabled = true;} }
    function handleTokenError(error) { console.error("Erreur Auth Google:", error); let msg = "Erreur connexion Google."; if (error?.type === 'popup_closed_by_user') msg = "Connexion annulée."; else if (error?.type === 'access_denied') msg = "Accès Drive refusé."; else if (error?.error === 'popup_blocked_by_browser') msg = "Popup connexion bloqué."; else if (error?.details) msg += ` Détails: ${error.details}`; showMessage(msg, 5000, 'error'); playSound('error'); googleAccessToken = null; previousOverallAvgHPS = null; updateAuthUI(false); resetProgressionDisplay(); resetConfigUI(); resetLevelDetailsUI(); }
    async function tokenCallback(tokenResponse) { if (tokenResponse.error) { handleTokenError(tokenResponse); return; } if (tokenResponse && tokenResponse.access_token) { console.log("Access Token reçu."); googleAccessToken = tokenResponse.access_token; previousOverallAvgHPS = null; playSound('confirm'); showMessage("Connecté ! Chargement données...", 2500, 'info'); if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; if (programConfigContent) programConfigContent.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; if (levelDetailsContent) levelDetailsContent.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Chargement Données...</p>'; resetProgressionDisplay(); try { const [programsStatus, configStatus] = await Promise.all([ loadProgramsFromDrive(), loadExerciseConfigFromDrive() ]); programsAnalysisStatus = programsStatus; configLoadStatus = configStatus; console.log("Statut chargement progs:", programsAnalysisStatus); console.log("Statut chargement config:", configLoadStatus); if (programsAnalysisStatus === 'error' || configLoadStatus === 'error') { showMessage("Erreur chargement programmes ou config.", 6000, 'error'); playSound('error'); } else if (programsAnalysisStatus === 'partial' || configLoadStatus === 'partial') { showMessage("Données partielles (progs ou config manquante).", 5000, 'warning'); } else { showMessage("Données chargées. Calcul potentiel hypertrophie...", 3000, 'success'); } calculateAndDisplayProgression(); renderProgramConfigUI(); renderLevelDetailsUI(); } catch (error) { console.error("Erreur CRITIQUE chargement/analyse:", error); showMessage("Erreur majeure chargement.", 6000, 'error'); playSound('error'); programsAnalysisStatus = 'error'; configLoadStatus = 'error'; if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; if (programConfigContent) programConfigContent.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; if (levelDetailsContent) levelDetailsContent.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; resetProgressionDisplay(); } finally { updateAuthUI(true); } } else { handleTokenError({ error: "invalid_response", details: "Réponse Google invalide." }); } }
    function handleAuthClick() { initAudioContext(); if (tokenClient) { console.log("Demande token Google..."); showMessage("Ouverture connexion Google...", 2000, 'info'); tokenClient.requestAccessToken({ prompt: '' }); } else { console.error("Auth sans tokenClient."); showMessage("Erreur : Service connexion non prêt.", 4000, 'error'); checkAndInitGis(); } }
    function handleSignoutClick(showMessages = true) { const token = googleAccessToken; if (!token) { console.log("Déjà déconnecté."); updateAuthUI(false); return; } initAudioContext(); if (showMessages) showMessage("Déconnexion...", 1500, 'info'); google.accounts.oauth2.revoke(token, () => { console.log('Token Google révoqué.'); googleAccessToken = null; programFileIds = { Push: null, Pull: null, Legs: null }; equipmentConfigFileId = null; programsAnalysisStatus = 'pending'; configLoadStatus = 'pending'; loadedPrograms = { Push: [], Pull: [], Legs: [] }; exerciseConfig = {}; currentHPSValues = {}; overallAvgHPS = HPS_BASE; currentGlobalLevelKey = LEVEL_ORDER[0]; previousOverallAvgHPS = null; if (showMessages) { showMessage("Déconnecté.", 3000, 'info'); playSound('confirm'); } resetProgressionDisplay(); resetConfigUI(); resetLevelDetailsUI(); updateAuthUI(false); }); }
    // Fonctions findFileId, readFileContent (inchangées)
    async function findFileId(filename) { if (!googleAccessToken) return null; try { const r = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${filename}' and trashed=false&fields=files(id, name)`, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!r.ok) { if (r.status === 401 || r.status === 403) { console.warn(`Auth expirée (find ${filename}). Déco.`); handleSignoutClick(false); } else { console.error(`Erreur Drive (find ${filename}): ${r.status} ${r.statusText}`); } throw new Error(`Erreur Drive ${r.status}`); } const d = await r.json(); if (d.files && d.files.length > 0) return d.files[0].id; return null; } catch (e) { console.error(`Erreur recherche ${filename}:`, e); return null; } }
    async function readFileContent(fileId) { if (!googleAccessToken || !fileId) return null; try { const r = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!r.ok) { if (r.status === 401 || r.status === 403) { console.warn(`Auth expirée (read ${fileId}). Déco.`); handleSignoutClick(false); } else { console.error(`Erreur Drive (read ${fileId}): ${r.status} ${r.statusText}`); } throw new Error(`Erreur Drive ${r.status}`); } return await r.text(); } catch (e) { console.error(`Erreur lecture ${fileId}:`, e); return null; } }
    // Fonction loadProgramsFromDrive (inchangée)
    async function loadProgramsFromDrive() { if (!googleAccessToken) return 'error'; console.log("Chargement programmes Drive..."); let allOk = true, anyOk = false; const tmp = { Push: [], Pull: [], Legs: [] }; for (const type of PROGRAM_TYPES) { programFileIds[type] = await findFileId(PROGRAM_FILENAMES[type]); let fileOk = false; if (programFileIds[type]) { const content = await readFileContent(programFileIds[type]); if (content !== null) { try { const p = JSON.parse(content || '[]'); if (Array.isArray(p)) { tmp[type] = p; fileOk = true; anyOk = true; if (p.length === 0) console.warn(`Prog ${type} vide.`); } else { console.error(`Contenu ${type} non-Array.`); showMessage(`Format invalide ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning'); allOk = false; } } catch (e) { console.error(`Erreur parsing JSON ${type}:`, e); showMessage(`Erreur format JSON ${PROGRAM_FILENAMES[type]}.`, 4000, 'error'); playSound('error'); allOk = false; } } else { console.warn(`Lecture ${type} échouée.`); showMessage(`Impossible lire ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning'); allOk = false; } } else { console.warn(`Fichier ${PROGRAM_FILENAMES[type]} introuvable.`); allOk = false; } } loadedPrograms = tmp; console.log(`Fin chargement progs. Global: ${allOk}, Partiel: ${anyOk}`); if (allOk) return 'success'; if (anyOk) return 'partial'; return 'error'; }
    // Fonction loadExerciseConfigFromDrive (inchangée)
    async function loadExerciseConfigFromDrive() { if (!googleAccessToken) return 'error'; console.log("Chargement config équipement..."); equipmentConfigFileId = await findFileId(EQUIPMENT_CONFIG_FILENAME); if (equipmentConfigFileId) { const content = await readFileContent(equipmentConfigFileId); if (content !== null) { try { const parsedConfig = JSON.parse(content || '{}'); exerciseConfig = typeof parsedConfig === 'object' && parsedConfig !== null ? parsedConfig : {}; console.log("Config équipement chargée."); return 'success'; } catch (e) { console.error("Erreur parsing JSON config:", e); showMessage("Erreur format JSON config équipement.", 4000, 'error'); playSound('error'); exerciseConfig = {}; return 'error'; } } else { console.warn("Lecture config échouée."); showMessage("Impossible lire config équipement.", 4000, 'warning'); exerciseConfig = {}; return 'error'; } } else { console.warn(`Fichier config "${EQUIPMENT_CONFIG_FILENAME}" introuvable.`); exerciseConfig = {}; return 'partial'; } }
    // Fonction saveExerciseConfigToDrive (inchangée)
    async function saveExerciseConfigToDrive() { if (!googleAccessToken || !saveConfigButton) return; console.log("Sauvegarde config équipement..."); saveConfigButton.disabled = true; saveConfigButton.classList.add('saving'); const currentConfig = {}; const checkboxes = programConfigContent.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(cb => { const exerciseName = cb.dataset.exerciseName; const equipmentName = cb.value; if (!exerciseName || !equipmentName) return; if (!currentConfig[exerciseName]) { currentConfig[exerciseName] = { added_equipment: [] }; } if (cb.checked) { currentConfig[exerciseName].added_equipment.push(equipmentName); } }); for (const exo in currentConfig) { if (currentConfig[exo].added_equipment.length === 0) { delete currentConfig[exo]; } } const configJson = JSON.stringify(currentConfig, null, 2); try { let method = 'PATCH'; let url = `https://www.googleapis.com/upload/drive/v3/files/${equipmentConfigFileId}?uploadType=media`; let body = configJson; let headers = { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' }; if (!equipmentConfigFileId) { console.log("Aucun ID config, tentative création..."); method = 'POST'; url = 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart'; const metadata = { name: EQUIPMENT_CONFIG_FILENAME, mimeType: 'application/json' }; const form = new FormData(); form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' })); form.append('file', new Blob([configJson], { type: 'application/json' })); body = form; headers = { 'Authorization': `Bearer ${googleAccessToken}` }; } const response = await fetch(url, { method: method, headers: headers, body: body }); if (!response.ok) { if (response.status === 401 || response.status === 403) { handleSignoutClick(false); } const errorBody = await response.text(); console.error("Erreur sauvegarde fichier:", response.status, errorBody); throw new Error(`Erreur Drive ${response.status} (${method === 'POST' ? 'Création' : 'MàJ'})`); } const result = await response.json(); if (method === 'POST' && result.id) { equipmentConfigFileId = result.id; console.log("Fichier config créé avec ID:", equipmentConfigFileId); } console.log("Config équipement sauvegardée."); exerciseConfig = currentConfig; showMessage("Configuration équipement sauvegardée !", 3000, 'success'); playSound('confirm'); calculateAndDisplayProgression(); // Recalculer après sauvegarde } catch (error) { console.error("Erreur sauvegarde config:", error); showMessage(`Erreur sauvegarde config: ${error.message}`, 5000, 'error'); playSound('error'); } finally { saveConfigButton.disabled = false; saveConfigButton.classList.remove('saving'); } }

    // --- Logique de Calcul HPS ---

    /** Récupère le coefficient d'efficacité pour un exercice donné. */
    function getExerciseEfficacy(exerciseName) {
        // Tenter une correspondance exacte
        if (EXERCISE_EFFICACY[exerciseName]) {
            return EXERCISE_EFFICACY[exerciseName];
        }
        // Tenter une correspondance partielle (ex: ignorer "(Band)")
        const cleanedName = exerciseName.replace(/\s*\(Band\)\s*$/i, '').trim();
        if (EXERCISE_EFFICACY[cleanedName]) {
             return EXERCISE_EFFICACY[cleanedName];
        }
        console.warn(`Efficacité non trouvée pour "${exerciseName}", utilisation du défaut.`);
        return EXERCISE_EFFICACY['DEFAULT'] || 1.0;
    }

    /** Calcule la charge effective totale pour un exercice. */
    function getEffectiveLoad(baseEquipment, addedEquipmentList) {
        let totalLoad = EFFECTIVE_LOAD[baseEquipment] ?? EFFECTIVE_LOAD['DEFAULT'] ?? 0;
        if (addedEquipmentList && addedEquipmentList.length > 0) {
            addedEquipmentList.forEach(equipKey => {
                totalLoad += EFFECTIVE_LOAD[equipKey] ?? 0;
            });
        }
        return totalLoad;
    }

    /** Détermine le facteur d'effort basé sur la performance de départ vs la cible. */
    function getEffortFactor(details) {
        const isDuration = details.duration_start && details.duration_target_max;
        const start = isDuration ? parseInt(details.duration_start, 10) : parseInt(details.reps_start, 10);
        const targetMax = isDuration ? parseInt(details.duration_target_max, 10) : parseInt(details.reps_target_max, 10);

        if (isNaN(start) || isNaN(targetMax) || targetMax <= start) {
             // Si cible max est invalide ou déjà atteinte/dépassée par start
            return EFFORT_FACTORS.TARGET_MET;
        }

        const range = targetMax - start;
        if (range <= 0) return EFFORT_FACTORS.TARGET_MET; // Ou MID ? Disons TARGET_MET si start = max

        // Note: On compare la position de 'start' dans la fourchette [start, target_max].
        // Comme la performance actuelle EST 'start', elle est toujours à 0% de cette fourchette.
        // Modifions pour comparer 'start' à une fourchette de référence plus large, ou simplifions.
        // Simplification : Considérons que si on est dans `reps_start`, l'effort est "MID" pour le moment.
        // Ce facteur deviendra plus pertinent si on track les reps *réellement* faites.
        // Pour l'instant, appliquons MID par défaut si on est dans la fourchette.
        if (start < targetMax) {
            // Calculons le pourcentage de progression DANS la fourchette cible visée
            const minTarget = parseInt(details.reps_start || details.duration_start, 10); // La base de la fourchette
             if (isNaN(minTarget)) return EFFORT_FACTORS.MID; // Sécurité

            const totalRange = targetMax - minTarget;
            if (totalRange <= 0) return EFFORT_FACTORS.TARGET_MET; // Déjà au max

            // Position actuelle est 'start' (qui est égal à minTarget ici)
             const progressInTargetRange = 0; // Toujours 0% car on utilise start comme perf actuelle

            // Révisons la logique : où se situe reps_start par rapport à une échelle absolue ? Difficile.
            // Restons simple pour l'instant : Si on utilise reps_start, on applique MID.
             return EFFORT_FACTORS.MID;

            /* // Ancienne logique basée sur la position de start dans la fourchette [start, max]
            const progressPercentage = 0; // start est toujours au début de [start, max]

            if (progressPercentage < 0.34) return EFFORT_FACTORS.LOW;
            if (progressPercentage < 0.67) return EFFORT_FACTORS.MID;
            return EFFORT_FACTORS.HIGH;
            */

        } else {
             return EFFORT_FACTORS.TARGET_MET; // start >= target_max
        }
    }

    /** Calcule les points d'hypertrophie (HP) pour une seule série. */
    function calculateHPPerSet(step) {
        if (!step || step.type !== 'exercise' || !step.details) return 0;

        const details = step.details;
        const isDurationBased = details.duration_start && parseInt(details.duration_start, 10) > 0;
        const exerciseName = step.name;
        const baseEquipment = details.equipment;
        const configForThisExo = exerciseConfig[exerciseName];
        const addedEquipment = configForThisExo?.added_equipment || [];

        const efficacy = getExerciseEfficacy(exerciseName);
        const effectiveLoad = getEffectiveLoad(baseEquipment, addedEquipment);
        const effortFactor = getEffortFactor(details); // Utilise reps/duration_start vs target_max

        let volumeFactor = 0;
        if (isDurationBased) {
            const duration = parseInt(details.duration_start, 10);
            if (!isNaN(duration) && duration > 0) {
                volumeFactor = Math.sqrt(duration); // Volume basé sur racine de la durée
            }
        } else {
            const reps = parseInt(details.reps_start, 10);
            if (!isNaN(reps) && reps > 0) {
                volumeFactor = reps; // Volume basé sur les reps
            }
        }

        if (efficacy <= 0 || effectiveLoad <= 0 || volumeFactor <= 0 || effortFactor <= 0) {
            // console.log(`Skipping HP for ${exerciseName}: E=${efficacy}, L=${effectiveLoad}, V=${volumeFactor}, Ef=${effortFactor}`);
            return 0; // Pas de stimulus si un facteur est nul ou négatif
        }

        const hp = efficacy * effectiveLoad * volumeFactor * effortFactor;
        // console.log(`HP for ${exerciseName} (1 set): E(${efficacy.toFixed(2)}) * L(${effectiveLoad}) * V(${volumeFactor.toFixed(2)}) * Ef(${effortFactor}) = ${hp.toFixed(2)}`);
        return hp;
    }

    /** Analyse les programmes chargés et calcule les HPS pour chaque groupe musculaire et global. */
    function analyzeProgramsAndCalculateHPS() {
        console.log("Analyse programmes & calcul HPS...");
        const groupData = {};
        // Inclure 'Legs' pour le calcul, même s'il n'est pas dans le HPS global haut du corps
        [...ALL_MUSCLE_GROUPS_LOGIC, 'Legs'].forEach(g => {
            groupData[g] = { totalHP: 0 };
        });
        currentHPSValues = {}; // Réinitialiser les scores HPS

        if (programsAnalysisStatus === 'error' || programsAnalysisStatus === 'pending' || configLoadStatus === 'error') {
            console.warn("Analyse HPS annulée - Programmes ou config non prêts.");
            [...ALL_MUSCLE_GROUPS_LOGIC, 'Legs'].forEach(g => { currentHPSValues[g] = HPS_BASE; });
            overallAvgHPS = HPS_BASE;
            previousOverallAvgHPS = null;
            return;
        }

        // Accumuler les HP par groupe musculaire
        PROGRAM_TYPES.forEach(type => {
            const program = loadedPrograms[type];
            if (!program || program.length === 0) return;

            let currentExo = null;
            let sets = 0;
            let lastStepProcessed = -1; // Pour éviter de traiter le dernier bloc deux fois

            program.forEach((step, idx) => {
                 if (step.type === 'exercise') {
                    // Si c'est le même exo que le précédent, incrémenter sets
                    if (step.name === currentExo && idx > 0) {
                        sets++;
                    } else {
                        // Si on change d'exo (ou c'est le premier), traiter le bloc précédent s'il existe
                        if (currentExo !== null && sets > 0) {
                             const hpPerSet = calculateHPPerSet(program[idx-1]); // Utiliser les détails du dernier step du bloc
                             if (hpPerSet > 0) {
                                const groups = mapExerciseToMuscleGroup(currentExo);
                                groups.forEach(g => {
                                    if (groupData[g]) {
                                        groupData[g].totalHP += hpPerSet * sets;
                                    }
                                });
                             }
                             lastStepProcessed = idx - 1;
                        }
                        // Réinitialiser pour le nouvel exercice
                        currentExo = step.name;
                        sets = 1;
                    }

                    // Traiter le dernier exercice du programme
                    if (idx === program.length - 1 && sets > 0) {
                        const hpPerSet = calculateHPPerSet(step);
                        if (hpPerSet > 0) {
                            const groups = mapExerciseToMuscleGroup(currentExo);
                            groups.forEach(g => {
                                if (groupData[g]) {
                                    groupData[g].totalHP += hpPerSet * sets;
                                }
                            });
                        }
                         lastStepProcessed = idx;
                    }
                } else { // Si c'est un break ou autre, traiter le bloc d'exercice précédent
                    if (currentExo !== null && sets > 0 && lastStepProcessed < idx -1 ) {
                         const hpPerSet = calculateHPPerSet(program[idx-1]); // Détails du dernier exo avant le break
                         if (hpPerSet > 0) {
                            const groups = mapExerciseToMuscleGroup(currentExo);
                            groups.forEach(g => {
                                if (groupData[g]) {
                                    groupData[g].totalHP += hpPerSet * sets;
                                }
                            });
                         }
                    }
                    // Réinitialiser
                    currentExo = null;
                    sets = 0;
                }
            });
        });

        // Convertir Total HP en HPS pour chaque groupe
        let totalWeightedHPSOverall = 0;
        let totalWeightOverall = 0;

        [...ALL_MUSCLE_GROUPS_LOGIC, 'Legs'].forEach(g => {
            const totalHP = groupData[g]?.totalHP || 0;
            let hps = HPS_BASE; // Score par défaut
            if (totalHP > 0 && HP_REFERENCE_GLOBAL > 0) {
                 // Formule Log : HPS = Base + K * log10( Total / Ref )
                 // Assurer que l'argument du log est >= 1 pour éviter les log négatifs
                const ratio = Math.max(1, totalHP / HP_REFERENCE_GLOBAL);
                hps = HPS_BASE + K_LOG * Math.log10(ratio);
            }
            currentHPSValues[g] = Math.round(Math.max(0, hps)); // Arrondi et minimum 0

             console.log(`HPS Calcul [${g}]: TotalHP=${totalHP.toFixed(2)}, HPS=${currentHPSValues[g]}`);

            // Accumuler pour le HPS global (Haut du corps seulement)
            if (ALL_MUSCLE_GROUPS_LOGIC.includes(g)) { // Vérifier si c'est un groupe du haut du corps
                const weight = WEIGHTS_GLOBAL_HPS[g] || 0;
                if (weight > 0) {
                    totalWeightedHPSOverall += currentHPSValues[g] * weight;
                    totalWeightOverall += weight;
                }
            }
        });

        // Calculer HPS Global (Moyenne pondérée)
         // Gérer la division par zéro si somme des poids = 0
         if (previousOverallAvgHPS !== null) { // Garder la trace de l'ancien score si défini
             // previousOverallAvgHPS = overallAvgHPS; // Ne pas écraser si on est en train de recalculer
         } else if (overallAvgHPS > HPS_BASE) {
             previousOverallAvgHPS = overallAvgHPS; // Stocker seulement si l'ancien était significatif
         }


        overallAvgHPS = totalWeightOverall > 0 ? Math.round(totalWeightedHPSOverall / totalWeightOverall) : HPS_BASE;
        overallAvgHPS = Math.max(0, overallAvgHPS); // Assurer minimum 0

        console.log(`HPS Global (Haut du Corps): ${overallAvgHPS} (Préc: ${previousOverallAvgHPS})`);
        console.log("HPS Groupes Finaux:", currentHPSValues);
    }

    /** Trouve la clé de niveau correspondante pour un score HPS donné. */
    function getHPSLevelKey(hpsScore) {
        for (let i = LEVEL_ORDER.length - 1; i >= 0; i--) {
            const key = LEVEL_ORDER[i];
            // Utiliser minHPS ici
            if (TARGET_LEVELS[key] && hpsScore >= TARGET_LEVELS[key].minHPS) {
                return key;
            }
        }
        return LEVEL_ORDER[0]; // Retourner Débutant par défaut
    }

     /** Trouve les groupes musculaires ciblés par un exercice. (mapping simple par mots-clés) */
     function mapExerciseToMuscleGroup(name) {
         const cleanedName = name.replace(/\s*\(\w+\)\s*$/i, '').trim(); // Enlève (Band), (Haltères) etc.
         const l = cleanedName.toLowerCase();

         // Prioriser les correspondances plus spécifiques
         if (l.includes('overhead triceps extension')) return ['Triceps'];
         if (l.includes('concentration curl')) return ['Biceps'];
         if (l.includes('hammer curl') || l.includes('curl marteau')) return ['Biceps']; // Principalement Biceps dans ce contexte
         if (l.includes('lateral raises') || l.includes('élévations latérales')) return ['Épaules'];
         if (l.includes('face pull')) return ['Épaules', 'Dos']; // Haut du dos/Arrière épaule
         if (l.includes('overhead press') || l.includes('développé militaire')) return ['Épaules', 'Triceps'];
         if (l.includes('floor press')) return ['Pectoraux', 'Triceps']; // ROM limitée
         if (l.includes('chest press')) return ['Pectoraux', 'Triceps', 'Épaules'];
         if (l.includes('pompes') || l.includes('push up')) return ['Pectoraux', 'Triceps', 'Épaules'];
         if (l.includes('bent-over row') || l.includes('rowing')) return ['Dos', 'Biceps'];
         if (l.includes('lat pulldown') || l.includes('tirage vertical')) return ['Dos', 'Biceps'];
         if (l.includes('hollow body')) return ['Core'];
         if (l.includes('sit-up')) return ['Core'];
         if (l.includes('leg raises') || l.includes('relevé de jambes')) return ['Core']; // Et fléchisseurs hanche

         // Jambes (non utilisées pour HPS global mais calculées)
         if (l.includes('squat')) return ['Legs', 'Core'];
         if (l.includes('fentes')) return ['Legs', 'Core'];
         if (l.includes('calf raises') || l.includes('mollets')) return ['Legs'];

         // Générique
         if (l.includes('curl')) return ['Biceps'];
         if (l.includes('triceps')) return ['Triceps'];
         if (l.includes('press') || l.includes('développé')) return ['Pectoraux', 'Épaules', 'Triceps']; // Large
         if (l.includes('row') || l.includes('tirage')) return ['Dos', 'Biceps']; // Large

         console.warn(`Mapping muscle IMPRÉCIS pour: "${name}" (nettoyé en "${cleanedName}")`);
         // Retourner un groupe par défaut ou vide ? Vide est plus sûr.
         return [];
     }


    // --- Logique Affichage (Adaptée pour HPS) ---

    /** Met à jour l'UI avec les scores HPS calculés. */
    function calculateAndDisplayProgression() {
        console.log("Mise à jour affichage progression (HPS)...");
        if (!evolutionTrackerArea || !overallHPSDisplayValue || !levelBadge || !targetHPSInfoStrong || !muscleGroupsContainer || !levelBadgeContainer || !marvelTargetInfoSpan) {
            console.error("DOM manquant pour l'affichage HPS.");
            if(muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p class="error-placeholder">Erreur interne: DOM affichage manquant.</p>';
            return;
        }

        // 1. Calculer les HPS
        if (programsAnalysisStatus !== 'pending') {
            analyzeProgramsAndCalculateHPS();
        } else {
            // Si pas de données chargées, afficher les valeurs de base
            [...ALL_MUSCLE_GROUPS_LOGIC, 'Legs'].forEach(g => { currentHPSValues[g] = HPS_BASE; });
            overallAvgHPS = HPS_BASE;
            previousOverallAvgHPS = null;
        }

        // 2. Mettre à jour l'affichage global
        const previousGlobalLevelKey = currentGlobalLevelKey;
        currentGlobalLevelKey = getHPSLevelKey(overallAvgHPS);
        const currentGlobalLevel = TARGET_LEVELS[currentGlobalLevelKey];
        const currentGlobalLevelIndex = LEVEL_ORDER.indexOf(currentGlobalLevelKey);
        const nextGlobalLevelKey = currentGlobalLevelIndex < LEVEL_ORDER.length - 1 ? LEVEL_ORDER[currentGlobalLevelIndex + 1] : null;
        const nextGlobalLevel = nextGlobalLevelKey ? TARGET_LEVELS[nextGlobalLevelKey] : null;
        const marvelBenchmark = TARGET_LEVELS[MARVEL_BENCHMARK_KEY];

        // Animation et affichage score global
        const currentDisplayedHPS = parseFloat(overallHPSDisplayValue.textContent.replace(/[^0-9.]/g, '')) || HPS_BASE;
        animateValue(overallHPSDisplayValue, currentDisplayedHPS, overallAvgHPS, 700);

        // Badge de niveau global
        levelBadgeIcon.className = `fas ${currentGlobalLevel.iconClass}`;
        levelBadgeText.textContent = currentGlobalLevel.name;
        levelBadge.style.color = `var(${currentGlobalLevel.colorVar})`;
        levelBadge.style.backgroundColor = `var(${currentGlobalLevel.bgVar})`;
        levelBadge.style.borderColor = `var(${currentGlobalLevel.colorVar})`;
        levelBadge.setAttribute('data-level-key', currentGlobalLevelKey);

        // Info cible niveau suivant
        targetHPSInfoStrong.textContent = nextGlobalLevel ? `${nextGlobalLevel.minHPS} HPS` : "MAX";

        // Info cible Marvel
        if (marvelBenchmark) {
             marvelTargetInfoSpan.innerHTML = ` | Benchmark <strong class="marvel-target">Marvel: ${marvelBenchmark.targetHPS} HPS</strong>`; // Utiliser targetHPS
            marvelTargetInfoSpan.style.display = 'inline-block';

            const isMarvelAchieved = overallAvgHPS >= marvelBenchmark.targetHPS;
            const existingMarvelIcon = document.getElementById('marvel-icon');
            if (isMarvelAchieved) {
                if (!existingMarvelIcon) {
                    const marvelIcon = document.createElement('i');
                    marvelIcon.id = 'marvel-icon';
                    marvelIcon.className = `fas ${marvelBenchmark.iconClass} marvel-achieved-icon`;
                    marvelIcon.setAttribute('title', `Benchmark "${marvelBenchmark.name}" (${marvelBenchmark.targetHPS} HPS) atteint !`);
                    levelBadgeContainer.appendChild(marvelIcon);
                }
            } else {
                if (existingMarvelIcon) { existingMarvelIcon.remove(); }
            }
        } else {
             marvelTargetInfoSpan.style.display = 'none';
        }


        // Effet visuel si niveau global augmenté
        if (previousOverallAvgHPS !== null && currentGlobalLevelKey !== previousGlobalLevelKey && overallAvgHPS >= TARGET_LEVELS[previousGlobalLevelKey].minHPS ) {
             // Vérifier si le nouveau score dépasse bien l'ancien seuil
            console.log(`NIVEAU GLOBAL ATTEINT ! ${previousGlobalLevelKey} -> ${currentGlobalLevelKey}`);
            showMessage(`Félicitations ! Niveau Global ${currentGlobalLevel.name} atteint !`, 5000, 'success');
            playSound('level_up', 0.2);
            const card = document.querySelector('.global-stats-card');
            if (card) {
                card.style.animation = 'levelUpGlow 1.5s ease-out';
                setTimeout(() => { card.style.animation = ''; }, 1500);
            }
        }

        // 3. Mettre à jour l'affichage par groupe musculaire
        muscleGroupsContainer.innerHTML = ''; // Vider l'ancien contenu
        let hasData = false;
        for (const displayGroup in MUSCLE_GROUPS_DISPLAY_CONFIG) {
            const logicGroup = ALL_MUSCLE_GROUPS_LOGIC.find(key => LOGIC_TO_DISPLAY_MAP[key] === displayGroup);
            if (!logicGroup || currentHPSValues[logicGroup] === undefined) {
                console.warn(`Skipping render for ${displayGroup} - Logic group ${logicGroup} not found or HPS undefined`);
                continue;
            }
            hasData = true;

            const config = MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup];
            const currentHPS = currentHPSValues[logicGroup];
            const muscleLevelKey = getHPSLevelKey(currentHPS);
            const muscleLevel = TARGET_LEVELS[muscleLevelKey];
            const muscleLevelIndex = LEVEL_ORDER.indexOf(muscleLevelKey);
            const nextMuscleLevelKey = muscleLevelIndex < LEVEL_ORDER.length - 1 ? LEVEL_ORDER[muscleLevelIndex + 1] : null;
            const nextMuscleLevel = nextMuscleLevelKey ? TARGET_LEVELS[nextMuscleLevelKey] : null;

            const minHPSCurrent = muscleLevel.minHPS;
            const minHPSNext = nextMuscleLevel ? nextMuscleLevel.minHPS : minHPSCurrent; // Si dernier niveau, la cible est le seuil actuel
            const range = minHPSNext - minHPSCurrent;

            let progress = 0;
            if (range > 0) {
                progress = ((currentHPS - minHPSCurrent) / range) * 100;
            } else if (currentHPS >= minHPSCurrent) {
                // Si c'est le dernier niveau ou si les seuils sont mal définis (Next <= Current)
                progress = 100;
            }

            const displayPercent = Math.max(0, Math.min(100, Math.round(progress)));
            const isTargetReached = nextMuscleLevel ? currentHPS >= minHPSNext : true; // Considéré atteint si c'est le dernier niveau
            const targetDisplay = nextMuscleLevel ? minHPSNext : "MAX";

            const card = renderMuscleGroupCard(
                displayGroup, config.subtitle, config.icon, currentHPS, targetDisplay,
                displayPercent, muscleLevelKey, muscleLevel.name, muscleLevel.colorVar, muscleLevel.bgVar,
                isTargetReached
            );
            muscleGroupsContainer.appendChild(card);
        }

        if (!hasData && programsAnalysisStatus !== 'pending') {
            const msg = programsAnalysisStatus === 'error' ? 'Aucune donnée valide analysée.' : 'Aucune donnée de progression disponible.';
            muscleGroupsContainer.innerHTML = `<p class="${programsAnalysisStatus === 'error' ? 'error' : 'loading'}-placeholder">${msg}</p>`;
        }
        console.log("Affichage progression mis à jour.");
    }

    /** Génère le HTML pour une carte de groupe musculaire. */
    function renderMuscleGroupCard(title, subtitle, iconClass, currentHPS, targetHPSNextMin, displayPercent, currentLevelKey, currentLevelName, currentLevelColorVar, currentLevelBgVar, isTargetReached) {
        const card = document.createElement('div');
        card.className = 'muscle-group-card';
        if (isTargetReached && targetHPSNextMin !== "MAX") { // Ne pas mettre en vert si on est au niveau max
            card.classList.add('level-target-reached');
        }
        card.setAttribute('title', `${title} (${subtitle}) - Niveau: ${currentLevelName} - HPS: ${currentHPS} / ${targetHPSNextMin}. Progression: ${displayPercent}%.`);

        card.innerHTML = `
            <div class="card-header">
                <div class="icon-container"><i class="fas ${iconClass}" aria-hidden="true"></i></div>
                <div class="title-container">
                    <div class="group-title">${title}</div>
                    <div class="group-subtitle">${subtitle}</div>
                    <div class="group-level-name" style="color: var(${currentLevelColorVar}); background-color: var(${currentLevelBgVar}); border-color: var(${currentLevelColorVar});" data-level-key="${currentLevelKey}">
                        ${currentLevelName}
                    </div>
                </div>
                <div class="hps-details" title="HPS Actuel / Seuil HPS Niveau Suivant">
                    <span class="current">${currentHPS}</span> / <span class="target">${targetHPSNextMin}</span>
                </div>
            </div>
            <div class="progress-section">
                <div class="progress-bar-container" title="Progression vers niveau suivant: ${displayPercent}%">
                    <div class="progress-bar" style="width: 0%;" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                </div>
                <span class="progress-percentage-value">${displayPercent}%</span>
            </div>`;

        // Animation de la barre de progression
        requestAnimationFrame(() => {
            setTimeout(() => {
                const pb = card.querySelector('.progress-bar');
                if (pb) {
                    pb.style.width = `${displayPercent}%`;
                    pb.setAttribute('aria-valuenow', displayPercent);
                }
            }, 50); // Petit délai pour assurer le rendu initial
        });

        return card;
    }

    /** Réinitialise l'affichage de la progression HPS. */
    function resetProgressionDisplay() {
        console.log("Réinitialisation affichage HPS...");
        if (muscleGroupsContainer) {
            muscleGroupsContainer.innerHTML = `<p class="loading-placeholder">${googleAccessToken ? 'Analyse...' : 'Connectez-vous...'}</p>`;
        }
        if (overallHPSDisplayValue) overallHPSDisplayValue.textContent = '--';

        const baseLevel = TARGET_LEVELS[LEVEL_ORDER[0]];
        if (levelBadge && baseLevel) {
            levelBadgeIcon.className = `fas ${baseLevel.iconClass}`;
            levelBadgeText.textContent = baseLevel.name;
            levelBadge.style.color = `var(${baseLevel.colorVar})`;
            levelBadge.style.backgroundColor = `var(${baseLevel.bgVar})`;
            levelBadge.style.borderColor = `var(${baseLevel.colorVar})`;
            levelBadge.setAttribute('data-level-key', LEVEL_ORDER[0]);
        }

        const firstRealLevelKey = LEVEL_ORDER.length > 1 ? LEVEL_ORDER[1] : null;
        const firstRealLevel = firstRealLevelKey ? TARGET_LEVELS[firstRealLevelKey] : null;
        if (targetHPSInfoStrong) targetHPSInfoStrong.textContent = firstRealLevel ? `${firstRealLevel.minHPS} HPS` : '-- HPS';

        const marvelBenchmark = TARGET_LEVELS[MARVEL_BENCHMARK_KEY];
        if (marvelTargetInfoSpan && marvelBenchmark) {
             marvelTargetInfoSpan.innerHTML = ` | Benchmark <strong class="marvel-target">Marvel: ${marvelBenchmark.targetHPS} HPS</strong>`;
             marvelTargetInfoSpan.style.display = 'inline-block';
        } else if (marvelTargetInfoSpan) {
             marvelTargetInfoSpan.style.display = 'none';
        }


        const existingMarvelIcon = document.getElementById('marvel-icon');
        if (existingMarvelIcon) { existingMarvelIcon.remove(); }

        previousOverallAvgHPS = null;
        currentGlobalLevelKey = LEVEL_ORDER[0];
    }


    // --- Rendu UI Config Équipement (Adapté pour utiliser AVAILABLE_EQUIPMENT_CONFIG) ---
    function renderProgramConfigUI() {
        if (!programConfigContent || programsAnalysisStatus === 'pending' || programsAnalysisStatus === 'error') {
            programConfigContent.innerHTML = '<p class="loading-placeholder">Chargez d\'abord vos programmes.</p>';
            if(saveConfigButton) saveConfigButton.disabled = true;
            return;
        }

        let html = '';
        const uniqueExercises = new Set();
        PROGRAM_TYPES.forEach(type => {
            const program = loadedPrograms[type];
            if (program && program.length > 0) {
                program.forEach(step => {
                    if (step.type === 'exercise' && step.name) {
                        uniqueExercises.add(step.name);
                    }
                });
            }
        });

        if (uniqueExercises.size === 0) {
            programConfigContent.innerHTML = '<p class="loading-placeholder">Aucun exercice trouvé dans les programmes.</p>';
            if(saveConfigButton) saveConfigButton.disabled = true;
            return;
        }

        html += `<div class="program-config-section"><h3>Tous les exercices</h3>`;
        [...uniqueExercises].sort().forEach(exerciseName => {
            html += `<div class="config-exercise-item">
                        <span class="exercise-name">${exerciseName}</span>
                        <div class="config-equipment-options">`;
            AVAILABLE_EQUIPMENT_CONFIG.forEach(equipKey => { // Utiliser la liste définie
                const isChecked = exerciseConfig[exerciseName]?.added_equipment?.includes(equipKey) || false;
                html += `<label>
                            <input type="checkbox" value="${equipKey}" data-exercise-name="${exerciseName}" ${isChecked ? 'checked' : ''}>
                            ${equipKey}
                         </label>`;
            });
            html += `   </div>
                      </div>`;
        });
        html += `</div>`;

        if(saveConfigButton) saveConfigButton.disabled = false;
        programConfigContent.innerHTML = html;
    }

    /** Réinitialise l'UI de configuration. */
    function resetConfigUI() {
        if (programConfigContent) {
            programConfigContent.innerHTML = '<p class="loading-placeholder">Connectez-vous.</p>';
        }
        if(saveConfigButton) saveConfigButton.disabled = true;
        exerciseConfig = {};
    }

    // --- Rendu UI Détails Niveaux (Adapté pour HPS) ---
    function renderLevelDetailsUI() {
        if (!levelDetailsContent) return;
        let html = '';
        LEVEL_ORDER.forEach(levelKey => {
            const level = TARGET_LEVELS[levelKey];
            if (level) {
                html += `
                    <div class="level-detail-item" style="border-left-color: var(${level.colorVar});">
                        <div class="level-detail-header">
                            <i class="fas ${level.iconClass} level-detail-icon" style="color: var(${level.colorVar});"></i>
                            <span class="level-detail-name" style="color: var(${level.colorVar});">${level.name}</span>
                            <span class="level-detail-hps">HPS Min: ${level.minHPS}+</span>
                        </div>
                        <p class="level-detail-description">${level.description}</p>
                        <p class="level-detail-celebrity">Exemple Physique: <strong>${level.celebrity_example || 'N/A'}</strong></p>
                    </div>`;
            }
        });
        const marvelLevel = TARGET_LEVELS[MARVEL_BENCHMARK_KEY];
        if (marvelLevel) {
            html += `
                <div class="level-detail-item" style="border-left-color: var(${marvelLevel.colorVar}); margin-top: 20px;">
                    <div class="level-detail-header">
                        <i class="fas ${marvelLevel.iconClass} level-detail-icon" style="color: var(${marvelLevel.colorVar});"></i>
                        <span class="level-detail-name" style="color: var(${marvelLevel.colorVar});">${marvelLevel.name} (Benchmark)</span>
                        <span class="level-detail-hps">Objectif: ${marvelLevel.targetHPS} HPS</span>
                    </div>
                    <p class="level-detail-description">${marvelLevel.description}</p>
                    <p class="level-detail-celebrity">Exemple Physique: <strong>${marvelLevel.celebrity_example || 'N/A'}</strong></p>
                </div>`;
        }
        levelDetailsContent.innerHTML = html || '<p class="loading-placeholder">Impossible de charger les détails des niveaux.</p>';
    }

    /** Réinitialise l'UI des détails de niveaux. */
    function resetLevelDetailsUI() {
        if (levelDetailsContent) {
            levelDetailsContent.innerHTML = '<p class="loading-placeholder">Connectez-vous pour voir les détails...</p>';
        }
    }

    // --- Fonctions Modal (Adaptées pour HPS) ---
    function openLevelInfoModal(levelKey) {
        if (!levelInfoModal || !TARGET_LEVELS[levelKey]) return;
        const levelData = TARGET_LEVELS[levelKey];
        modalIcon.className = `fas ${levelData.iconClass}`;
        modalLevelName.textContent = levelData.name;
        let bodyHtml = `<p>${levelData.description.replace(/\n/g, '<br>')}</p>`;
        // Afficher le seuil HPS dans la modal
        if(levelData.minHPS !== undefined) {
             bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Seuil HPS Minimum : <strong>${levelData.minHPS}</strong></p>`;
        } else if (levelData.targetHPS !== undefined) {
             bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Objectif HPS Benchmark : <strong>${levelData.targetHPS}</strong></p>`;
        }
         bodyHtml += `<p style="margin-top: 10px; font-size: 0.9em; color: var(--secondary-text-color);">Exemple Physique: <i>${levelData.celebrity_example || 'N/A'}</i></p>`;

        modalBody.innerHTML = bodyHtml;
        modalTitle.style.color = `var(${levelData.colorVar})`;
        levelInfoModal.classList.add('visible');
    }
    function closeLevelInfoModal() { if (levelInfoModal) levelInfoModal.classList.remove('visible'); }

    // --- Animation & UI Update & Thème & Message (inchangés, mais updateAuthUI adapte les resets) ---
    function animateValue(el, start, end, duration) { if (!el) return; // ... (code animation inchangé)
        if (start === end) { el.textContent = Math.round(end); return; } const range = end - start; let current = start; const inc = end > start ? 1 : -1; const stepTime = Math.abs(Math.floor(duration / range)); const effStepTime = Math.max(1, Math.min(stepTime, 50)); const timer = setInterval(() => { current += inc * Math.max(1, Math.round(Math.abs(end - current) / 10)); if ((inc > 0 && current >= end) || (inc < 0 && current <= end)) { current = end; clearInterval(timer); } el.textContent = Math.round(current); }, effStepTime);
    }
    function updateAuthUI(isLoggedIn) { console.log(`Update UI - Connecté: ${isLoggedIn}, GIS prêt: ${!!tokenClient}`); const b = document.body; b.classList.toggle('logged-in', isLoggedIn); b.classList.toggle('logged-out', !isLoggedIn); if(signInButton) signInButton.disabled = isLoggedIn || !tokenClient; if(signInButtonPrompt) signInButtonPrompt.disabled = isLoggedIn || !tokenClient; if(signOutButton) signOutButton.disabled = !isLoggedIn; if(themeToggleBtn) themeToggleBtn.disabled = false; if (connectionPrompt) connectionPrompt.style.display = isLoggedIn ? 'none' : 'block'; navButtons.forEach(btn => btn.disabled = !isLoggedIn); if (isLoggedIn) { switchTab(document.querySelector('.nav-button.active')?.dataset.section || 'evolution-tracker-area'); } else { appSections.forEach(sec => sec.style.display = 'none'); } if (!isLoggedIn) { programsAnalysisStatus = 'pending'; configLoadStatus = 'pending'; resetProgressionDisplay(); resetConfigUI(); resetLevelDetailsUI(); } }
    function applyTheme(theme) { document.body.classList.remove('light-theme', 'dark-theme'); document.body.classList.add(theme + '-theme'); currentTheme = theme; localStorage.setItem('armorWorkoutTheme', theme); if (themeToggleBtn) { const i = themeToggleBtn.querySelector('i'); if (i) i.className = `fas fa-${theme === 'dark' ? 'sun' : 'moon'}`; themeToggleBtn.setAttribute('aria-label', `Passer au thème ${theme === 'dark' ? 'clair' : 'sombre'}`); } console.log(`Thème appliqué: ${theme}`); }
    function toggleTheme() { showMessage("Thème clair non disponible.", 2000, 'info'); playSound('confirm'); } function loadSavedTheme() { applyTheme('dark'); }
    function showMessage(msg, duration = 3000, type = 'info') { if (!messageArea) return; messageArea.textContent = msg; messageArea.className = `message-area ${type} visible`; if (messageTimeoutId) clearTimeout(messageTimeoutId); messageTimeoutId = setTimeout(() => { messageArea.classList.remove('visible'); setTimeout(() => { if (!messageArea.classList.contains('visible')) { messageArea.className = 'message-area'; } }, 500); }, duration); }

    // --- Gestion Navigation (inchangée) ---
    function switchTab(targetSectionId) { if (!targetSectionId) return; console.log("Switch tab to:", targetSectionId); appSections.forEach(section => { section.style.display = 'none'; }); const targetSection = document.getElementById(targetSectionId); if (targetSection) { targetSection.style.display = 'flex'; targetSection.style.flexDirection = 'column'; } else { console.error("Section cible non trouvée:", targetSectionId); } navButtons.forEach(btn => { btn.classList.toggle('active', btn.dataset.section === targetSectionId); }); if (targetSectionId === 'program-config-area') { renderProgramConfigUI(); } else if (targetSectionId === 'level-details-area') { renderLevelDetailsUI(); } }

    // --- Initialisation (avec les nouveaux IDs et variables) ---
    function initializeDOMReferences() {
        console.log("Init DOM Refs...");
        signInButton = document.getElementById('signin-button');
        signOutButton = document.getElementById('signout-button');
        driveStatusElement = document.getElementById('drive-status');
        themeToggleBtn = document.getElementById('theme-toggle-btn');
        signInButtonPrompt = document.getElementById('signin-button-prompt');
        connectionPrompt = document.getElementById('connection-prompt');
        evolutionTrackerArea = document.getElementById('evolution-tracker-area');
        overallHPSDisplayValue = document.querySelector('#overall-hps-display .value'); // MODIFIÉ
        levelBadgeContainer = document.getElementById('level-badge-container');
        levelBadge = document.getElementById('level-badge');
        if (levelBadge) {
            levelBadgeIcon = levelBadge.querySelector('i');
            levelBadgeText = levelBadge.querySelector('span');
        }
        targetHPSInfoStrong = document.querySelector('#target-hps-info strong'); // MODIFIÉ
        marvelTargetInfoSpan = document.querySelector('#marvel-target-info'); // MODIFIÉ (sélectionner le span)
        muscleGroupsContainer = document.getElementById('muscle-groups-container');
        programConfigArea = document.getElementById('program-config-area');
        programConfigContent = document.getElementById('program-config-content');
        saveConfigButton = document.getElementById('save-config-button');
        levelDetailsArea = document.getElementById('level-details-area');
        levelDetailsContent = document.getElementById('level-details-content');
        messageArea = document.getElementById('message-area');
        levelInfoModal = document.getElementById('level-info-modal');
        modalTitle = document.getElementById('modal-title');
        modalIcon = document.getElementById('modal-icon');
        modalLevelName = document.getElementById('modal-level-name');
        modalBody = document.getElementById('modal-body');
        modalCloseBtn = document.getElementById('modal-close-btn');
        appNav = document.getElementById('app-nav');
        navButtons = document.querySelectorAll('.nav-button');
        appSections = document.querySelectorAll('.app-section');

        // Vérification Critique
        const critical = [signInButton, signOutButton, themeToggleBtn, signInButtonPrompt, connectionPrompt, evolutionTrackerArea, overallHPSDisplayValue, levelBadgeContainer, levelBadge, levelBadgeIcon, levelBadgeText, targetHPSInfoStrong, marvelTargetInfoSpan, muscleGroupsContainer, programConfigArea, programConfigContent, saveConfigButton, levelDetailsArea, levelDetailsContent, messageArea, levelInfoModal, modalTitle, modalIcon, modalLevelName, modalBody, modalCloseBtn, appNav, navButtons, appSections];
        if (critical.some(el => !el || (NodeList.prototype.isPrototypeOf(el) && el.length === 0))) {
            console.error("DOM CRITIQUES MANQUANTS!", critical.map((el, i) => el ? `OK_${i}` : `FAIL_${i}`)); // Log détaillé
            showMessage("Erreur critique: UI incomplète.", 10000, 'error');
            document.body.innerHTML = '<p style="color:red; padding: 20px;">Erreur critique interface. Vérifiez la console pour les éléments manquants.</p>';
            return false;
        }
        console.log("DOM Refs OK.");
        return true;
    }

    // --- Add Event Listeners (Adapté pour HPS modal) ---
    function addEventListeners() {
        if(signInButton) signInButton.addEventListener('click', handleAuthClick);
        if(signInButtonPrompt) signInButtonPrompt.addEventListener('click', handleAuthClick);
        if(signOutButton) signOutButton.addEventListener('click', () => handleSignoutClick(true));
        if(themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme);
        document.body.addEventListener('click', initAudioContext, { once: true });
        document.body.addEventListener('keydown', initAudioContext, { once: true });

        // Ouvrir modal depuis badge global ou badge groupe
        if (levelBadge) levelBadge.addEventListener('click', () => { const key = levelBadge.getAttribute('data-level-key'); if(key) openLevelInfoModal(key); });
        if (muscleGroupsContainer) {
             muscleGroupsContainer.addEventListener('click', (event) => {
                const el = event.target.closest('.group-level-name');
                if (el) { const key = el.getAttribute('data-level-key'); if (key) openLevelInfoModal(key); }
            });
        }
        // Ouvrir modal depuis la liste des niveaux
        if (levelDetailsContent) {
            levelDetailsContent.addEventListener('click', (event) => {
                 // Trouver la clé de niveau associée à l'élément cliqué (si pertinent)
                 // Pour l'instant, clics non gérés ici, mais on pourrait rendre les items cliquables
            });
        }

        if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeLevelInfoModal);
        if (levelInfoModal) levelInfoModal.addEventListener('click', (event) => { if (event.target === levelInfoModal) closeLevelInfoModal(); });

        navButtons.forEach(button => {
            button.addEventListener('click', () => switchTab(button.dataset.section));
        });
        if (saveConfigButton) saveConfigButton.addEventListener('click', saveExerciseConfigToDrive);
        console.log("Écouteurs OK.");
    }

    // --- Point d'entrée ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Chargé. Init HPS System...");
        try {
            if (!initializeDOMReferences()) return;
            addEventListeners();
            loadSavedTheme();
            updateAuthUI(false); // Cache tout sauf prompt de connexion
            resetProgressionDisplay();
            resetConfigUI();
            resetLevelDetailsUI();
            checkAndInitGis();
            console.log("Init terminée. Attente API Google & utilisateur...");
        } catch (error) {
            console.error("Erreur Init DOMContentLoaded:", error);
            showMessage("Erreur critique chargement.", 10000, 'error');
            const b = document.querySelector('body');
            if(b) b.innerHTML = '<p style="color:red; padding: 20px;">Erreur critique chargement. Voir console.</p>';
        }
    });

</script>

</body>
</html>
