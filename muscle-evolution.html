<script>
    // --- CONFIGURATION & CONSTANTES ---
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const PROGRAM_FILENAMES = { Push: "armorworkout_push_program.json", Pull: "armorworkout_pull_program.json", Legs: "armorworkout_legs_program.json" };
    const HISTORY_FILENAME = "armorworkout_history.json"; // Pour la r√©gularit√©
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const GIS_CHECK_INTERVAL = 100;
    const GIS_MAX_RETRIES = 50;
    const REGULARITY_PERIOD_DAYS = 28; // Analyser r√©gularit√© sur 4 semaines
    const TARGET_SESSIONS_PER_WEEK = 3; // Cible PPL = 3 s√©ances/semaine

    // --- ELO PARAMETERS & TARGETS ---
    const ELO_BASE = 800;
    const INTENSITY_TECHNIQUE_BONUS_MULTIPLIER = 1.05; // +5% ELO bonus si intensity_technique: true
    const POLYARTICULAR_WEIGHT = 1.2; // Poids pour exos polyarticulaires
    const ISOLATION_WEIGHT = 1.0;     // Poids pour exos d'isolation
    const RESISTANCE_BONUS = {
        'Bodyweight': 75, 'Halt√®res 5kg': 50, '√âlastique 15kg': 50,
        '√âlastique 15kg doubl√©': 100, '√âlastique 25kg': 125, '√âlastique 15+25kg': 200,
        '√âlastique 15+25kg + 1 halt√®re 5kg': 225, '√âlastique 15+25kg + 2x5kg halt√®res': 250
    };
    const REPS_FACTORS = { 12: 1.0, 18: 1.2, 25: 1.3, Infinity: 1.4 };
    const DURATION_FACTORS = { 30: 0.9, 45: 1.0, 60: 1.1, 90: 1.2, Infinity: 1.3 };
    // Ajout d'un objectif RDJ comme exemple
    const TARGET_ELO_LEVELS = {
        'L1_MaxReps': { name: "Solide via Reps üí™", targetELO: 950, description: "Niveau solide atteignable en maximisant les r√©p√©titions avec l'√©quipement actuel. Physique athl√©tique visible, bonne endurance musculaire.", groups: { Pectoraux: 900, Dos: 920, √âpaules: 865, Biceps: 940, Triceps: 865, Core: 880 } },
        'L2_RDJ': { name: "Style Robert Downey Jr. ‚ú®", targetELO: 1050, description: "Physique d√©fini et athl√©tique, bonne masse musculaire mais pas excessive, bras notables. N√©cessite de commencer √† appliquer les techniques de progression.", groups: { Pectoraux: 1050, Dos: 1050, √âpaules: 1050, Biceps: 1080, Triceps: 1080, Core: 920 } },
        'L3_TomHolland': { name: "Athl√©tique Avanc√© / Tom Holland Style üï∑Ô∏è", targetELO: 1150, description: "Niveau avanc√© style 'acteur film d'action'. N√©cessite l'application avanc√©e des techniques de progression (combinaison d'√©lastiques, pompes lest√©es...). Muscles plus d√©velopp√©s, meilleure d√©finition (avec di√®te adapt√©e).", groups: { Pectoraux: 1150, Dos: 1150, √âpaules: 1150, Biceps: 1100, Triceps: 1100, Core: 950 } }
    };
    const FINAL_TARGET_ELO = TARGET_ELO_LEVELS.L3_TomHolland.targetELO || 1150;
    const MUSCLE_GROUPS_DISPLAY_ORDER = { "Torse": ["Pectoraux", "Dos"], "√âpaules": ["√âpaules"], "Bras": ["Biceps", "Triceps"], "Core": ["Core"] };
    const MUSCLE_GROUP_ICONS = { Pectoraux: 'fa-heart-pulse', Dos: 'fa-circle-nodes', √âpaules: 'fa-person-burst', Biceps: 'fa-dumbbell', Triceps: 'fa-hand-back-fist', Core: 'fa-fire' };

    // --- √âl√©ments DOM ---
    let signInButton, signOutButton, driveStatusElement, themeToggleBtn,
        signInButtonPrompt, connectionPrompt, evolutionTrackerArea,
        overallEloDisplay, overallEloValueElement, // S√©parer pour animation
        goalSelector, // Nouveau : S√©lecteur d'objectif
        goalInfo, goalDescriptionElement,
        muscleGroupsContainer, messageArea,
        globalProgressBar, globalProgressPercentage, globalProgressPercentageValueElement; // S√©parer pour animation

    // --- Variables d'√âtat ---
    let googleAccessToken = null; let tokenClient = null;
    let programFileIds = { Push: null, Pull: null, Legs: null }; let historyFileId = null; // Ajout ID historique
    let loadedPrograms = { Push: [], Pull: [], Legs: [] }; let workoutHistory = []; // Ajout historique
    let programsLoaded = false; let historyLoaded = false;
    let currentELOValues = {}; let overallAvgELO = 0;
    let selectedGoalKey = 'L1_MaxReps'; // Objectif choisi par l'utilisateur
    let currentTheme = 'dark'; let messageTimeoutId = null; let gisCheckRetries = 0;

    // --- Audio ---
    let audioContext = null;
    function initAudioContext() { if (!audioContext && typeof AudioContext !== 'undefined') { try { audioContext = new AudioContext(); } catch (e) { console.warn("AudioContext non support√© ou bloqu√©.", e); } } }

    // --- Google Identity Services & Drive API ---
    async function gisInitInternal() { console.log(">>> gisInitInternal appel√©e (Evolution)..."); const clientIdValid = GOOGLE_CLIENT_ID && !GOOGLE_CLIENT_ID.includes("YOUR_CLIENT_ID"); if (!clientIdValid) { console.error("CRITICAL: GOOGLE_CLIENT_ID non configur√© !"); showMessage("Erreur critique : ID Client Google manquant.", 10000, true); if(signInButton) signInButton.disabled = true; if(signInButtonPrompt) signInButtonPrompt.disabled = true; return; } if (!google || !google.accounts || !google.accounts.oauth2) { console.error("L'API Google Identity Services n'a pas √©t√© correctement charg√©e ou initialis√©e (Evolution)."); showMessage("Erreur chargement API Google.", 6000, true); if(signInButton) signInButton.disabled = true; if(signInButtonPrompt) signInButtonPrompt.disabled = true; return; } try { console.log("Tentative d'initialisation de initTokenClient (Evolution)..."); tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CLIENT_ID, scope: GOOGLE_DRIVE_SCOPES, callback: tokenCallback, error_callback: handleTokenError, prompt: '' }); console.log("Token Client Google initialis√© avec succ√®s (Evolution)."); if (signInButton) signInButton.disabled = false; if (signInButtonPrompt) signInButtonPrompt.disabled = false; } catch (error) { console.error("Erreur lors de l'appel √† google.accounts.oauth2.initTokenClient (Evolution):", error); showMessage("Erreur initialisation services Google.", 5000, true); updateAuthUI(false); if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Init Auth'; driveStatusElement.classList.remove('loading', 'success'); driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; } if(signInButton) signInButton.disabled = true; if(signInButtonPrompt) signInButtonPrompt.disabled = true; } console.log(">>> gisInitInternal (Evolution) - Fin d'ex√©cution"); }
    function checkAndInitGis() { console.log(`V√©rification GIS (Evolution - Essai ${gisCheckRetries + 1}/${GIS_MAX_RETRIES})...`); if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2 && typeof google.accounts.oauth2.initTokenClient === 'function') { console.log("API Google OAuth2 d√©tect√©e (Evolution)! Lancement de gisInitInternal."); gisInitInternal(); } else if (gisCheckRetries < GIS_MAX_RETRIES) { gisCheckRetries++; setTimeout(checkAndInitGis, GIS_CHECK_INTERVAL); } else { console.error(`√âchec de la d√©tection de l'API Google (Evolution) apr√®s ${GIS_MAX_RETRIES} essais.`); showMessage("Impossible de charger les services Google. V√©rifiez votre connexion ou bloqueur de script.", 10000, true); if(signInButton) signInButton.disabled = true; if(signInButtonPrompt) signInButtonPrompt.disabled = true; } }
    function handleTokenError(error) { console.error("Erreur Google Token Client (Evolution):", error); let userMessage = `Erreur Auth Google: ${error.type || error.error || 'Inconnue'}`; let statusText = 'Erreur Auth'; if (driveStatusElement) { driveStatusElement.classList.remove('loading', 'success'); driveStatusElement.classList.add('error'); driveStatusElement.style.display = 'inline-block'; } if (error.error === 'popup_closed_by_user' || error.error === 'user_cancel' || error.type === 'popup_closed') { userMessage = "Connexion Google annul√©e."; statusText = 'Annul√©'; } else if (error.error === 'popup_failed_to_open' || error.type === 'popup_failed_to_open') { userMessage = "Pop-up Google bloqu√©e."; statusText = 'Popup Bloqu√©'; } else if (error.error === 'access_denied' || error.type === 'access_denied') { userMessage = "Acc√®s Drive refus√©."; statusText = 'Acc√®s Refus√©'; } else if (error.error === 'token_network_error') { userMessage = "Erreur r√©seau lors de l'auth."; statusText = 'Erreur R√©seau'; } else if (error.error === 'invalid_grant') { userMessage = "Autorisation invalide."; statusText = 'Autorisation Invalide'; googleAccessToken = null; } showMessage(userMessage, 6000, true); if (driveStatusElement) driveStatusElement.textContent = statusText; updateAuthUI(false); }
    async function tokenCallback(tokenResponse) {
        console.log("DEBUG: tokenCallback start"); // DEBUG
        if (driveStatusElement) { driveStatusElement.classList.remove('loading', 'error', 'success'); driveStatusElement.style.display = 'inline-block'; }
        if (tokenResponse.error) { handleTokenError(tokenResponse); return; }
        if (tokenResponse && tokenResponse.access_token) {
            console.log("DEBUG: Access Token re√ßu (Evolution).");
            googleAccessToken = tokenResponse.access_token;
            showMessage("Connect√© ! Chargement donn√©es...", 2500);
            if (driveStatusElement) { driveStatusElement.textContent = 'Chargement...'; driveStatusElement.classList.add('loading'); }
            if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p style="text-align: center; color: var(--secondary-text-color); grid-column: 1 / -1;">Chargement des programmes et de l\'historique...</p>';

            try {
                console.log("DEBUG: tokenCallback - Avant Promise.all"); // DEBUG
                const [programsSuccess, historySuccess] = await Promise.all([
                    loadProgramsFromDrive(),
                    loadHistoryFromDrive()
                ]);
                console.log(`DEBUG: tokenCallback - Apr√®s Promise.all - programsSuccess: ${programsSuccess}, historySuccess: ${historySuccess}`); // DEBUG
                programsLoaded = programsSuccess;
                historyLoaded = historySuccess;

                if (programsLoaded && historyLoaded) {
                     showMessage("Donn√©es charg√©es. Calcul de l'√©volution...", 3000);
                     if (driveStatusElement) { driveStatusElement.textContent = 'Connect√©'; driveStatusElement.classList.remove('loading', 'error'); driveStatusElement.classList.add('success'); }
                     console.log("DEBUG: tokenCallback - Appelle calculateAndDisplayEvolution"); // DEBUG
                     calculateAndDisplayEvolution();
                     console.log("DEBUG: tokenCallback - FIN de calculateAndDisplayEvolution"); // DEBUG
                } else {
                     let errorMsg = [];
                     if (!programsLoaded) errorMsg.push("programmes");
                     if (!historyLoaded) errorMsg.push("historique");
                     showMessage(`Erreur chargement ${errorMsg.join(' et ')}. Analyse impossible.`, 5000, true);
                     if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Donn√©es'; driveStatusElement.classList.remove('loading'); driveStatusElement.classList.add('error'); }
                     if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = `<p style="text-align: center; color: var(--secondary-text-color); grid-column: 1 / -1;">Erreur chargement ${errorMsg.join(' et ')} depuis Drive.</p>`;
                }
            } catch (error) {
                console.error("Erreur CRITIQUE pendant le chargement parall√®le (Evolution):", error);
                showMessage("Erreur majeure chargement donn√©es Drive.", 6000, true);
                if (driveStatusElement) { driveStatusElement.textContent = 'Erreur Critique'; driveStatusElement.classList.remove('loading', 'success'); driveStatusElement.classList.add('error'); }
                programsLoaded = false; historyLoaded = false;
                if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p style="text-align: center; color: var(--secondary-text-color); grid-column: 1 / -1;">Erreur critique lors du chargement des donn√©es.</p>';
            } finally {
                console.log("DEBUG: tokenCallback - Finally block, appel updateAuthUI"); // DEBUG
                updateAuthUI(true);
                 console.log("DEBUG: tokenCallback - Fin Finally block"); // DEBUG
            }
        } else {
            handleTokenError({ error: "invalid_response", details: "R√©ponse inattendue du serveur Google (Evolution)." });
        }
         console.log("DEBUG: tokenCallback end"); // DEBUG
    }
    function handleAuthClick() { initAudioContext(); if (!tokenClient) { showMessage("Services Google non pr√™ts...", 3000); console.warn("Tentative de connexion avant init tokenClient (Evolution)."); if (!GOOGLE_CLIENT_ID || GOOGLE_CLIENT_ID.includes("YOUR_CLIENT_ID")) { showMessage("Erreur critique : ID Client Google manquant.", 8000, true); } return; } if (driveStatusElement) { driveStatusElement.textContent = 'Connexion...'; driveStatusElement.classList.add('loading'); driveStatusElement.classList.remove('error', 'success'); driveStatusElement.style.display = 'inline-block'; } tokenClient.requestAccessToken({ prompt: 'consent' }); }
    function handleSignoutClick(showMessages = true) { const token = googleAccessToken; if (!token) { console.log("D√©j√† d√©connect√© (Evolution)."); updateAuthUI(false); return; } if (showMessages && driveStatusElement) { driveStatusElement.textContent = 'D√©connexion...'; driveStatusElement.classList.add('loading'); driveStatusElement.style.display = 'inline-block'; } google.accounts.oauth2.revoke(token, () => { console.log('Token Google r√©voqu√© (Evolution).'); googleAccessToken = null; programFileIds = { Push: null, Pull: null, Legs: null }; historyFileId = null; programsLoaded = false; historyLoaded = false; loadedPrograms = { Push: [], Pull: [], Legs: [] }; workoutHistory = []; currentELOValues = {}; overallAvgELO = 0; selectedGoalKey = loadGoalPreference(); if (showMessages) { showMessage("D√©connect√© de Google Drive.", 3000); } if (driveStatusElement) { driveStatusElement.textContent = ''; driveStatusElement.style.display = 'none'; } if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = ''; if (overallEloValueElement) overallEloValueElement.textContent = '--'; if (goalInfo) goalInfo.innerHTML = 'Objectif Actuel : <span class="target-level">N/A</span> (ELO <span class="target-elo-value">--</span>)'; if(goalDescriptionElement) goalDescriptionElement.textContent = ''; if(globalProgressBar) globalProgressBar.style.width = '0%'; if(globalProgressPercentageValueElement) globalProgressPercentageValueElement.textContent = '0'; updateAuthUI(false); }); }
    async function findOrCreateFile(filename, defaultContent = "[]", mimeType = 'application/json') { /* ... */ console.log(`Drive (Evolution): Recherche/Cr√©ation de ${filename}`); if (!googleAccessToken) { console.warn("findOrCreateFile (Evolution): Pas de token Google."); return null; } const searchUrl = `https://www.googleapis.com/drive/v3/files?q=name='${encodeURIComponent(filename)}'+and+trashed=false&spaces=drive&fields=files(id,name)`; try { const searchRes = await fetch(searchUrl, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!searchRes.ok) { if (searchRes.status === 401 || searchRes.status === 403) { console.warn(`findOrCreateFile(${filename}): Erreur d'autorisation (${searchRes.status}) (Evolution). D√©connexion.`); handleSignoutClick(false); showMessage("Session Google expir√©e. Reconnectez-vous.", 5000, true); return null; } throw new Error(`Recherche √©chou√©e (${searchRes.status}) (Evolution): ${await searchRes.text()}`); } const searchData = await searchRes.json(); if (searchData.files && searchData.files.length > 0) { console.log(`Drive (Evolution): Fichier ${filename} trouv√© (ID: ${searchData.files[0].id}).`); return searchData.files[0].id; } console.log(`Drive (Evolution): Fichier ${filename} non trouv√©. Cr√©ation...`); const createUrl = `https://www.googleapis.com/drive/v3/files`; const metadata = { name: filename, mimeType: mimeType }; const createRes = await fetch(createUrl, { method: 'POST', headers: { 'Authorization': `Bearer ${googleAccessToken}`, 'Content-Type': 'application/json' }, body: JSON.stringify(metadata) }); if (!createRes.ok) { throw new Error(`Cr√©ation √©chou√©e (${createRes.status}) (Evolution): ${await createRes.text()}`); } const createData = await createRes.json(); const newFileId = createData.id; console.log(`Drive (Evolution): Fichier ${filename} cr√©√© (ID: ${newFileId}). Contenu par d√©faut PAS √©crit (page read-only).`); return newFileId; } catch (error) { console.error(`Erreur Drive (Evolution - findOrCreate ${filename}):`, error); showMessage(`Erreur Drive (${filename.substring(0, 15)}...): ${error.message}`, 6000, true); return null; } }
    async function readFileContent(fileId) { /* ... */ if (!googleAccessToken || !fileId) { console.warn("readFileContent (Evolution): Pas de token ou d'ID."); return null; } console.log(`Drive (Evolution): Lecture du fichier ${fileId}`); const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`; try { const response = await fetch(url, { headers: { 'Authorization': `Bearer ${googleAccessToken}` } }); if (!response.ok) { if (response.status === 404) { console.warn(`readFileContent(${fileId}) (Evolution): Fichier non trouv√© (404).`); return ""; } if (response.status === 401 || response.status === 403) { console.warn(`readFileContent(${fileId}): Erreur d'autorisation (${response.status}) (Evolution). D√©connexion.`); handleSignoutClick(false); showMessage("Session Google expir√©e. Reconnectez-vous.", 5000, true); return null; } throw new Error(`Lecture √©chou√©e (${response.status}) (Evolution): ${await response.text()}`); } const content = await response.text(); console.log(`Drive (Evolution): Contenu du fichier ${fileId} lu.`); return content; } catch (error) { console.error(`Erreur Drive (Evolution - readFile ${fileId}):`, error); showMessage(`Erreur Lecture Drive (${fileId}): ${error.message}`, 6000, true); return null; } }

    // --- Chargement Donn√©es ---
    async function loadProgramsFromDrive() { /* ... (Identique) ... */ if (!googleAccessToken) return false; console.log("Chargement des programmes depuis Drive (Evolution)..."); let allLoadedSuccessfully = true; const tempLoadedPrograms = {}; for (const type of PROGRAM_TYPES) { console.log(`Chargement programme: ${type}...`); const defaultJsonString = JSON.stringify([], null, 2); programFileIds[type] = await findOrCreateFile(PROGRAM_FILENAMES[type], defaultJsonString); if (programFileIds[type]) { const content = await readFileContent(programFileIds[type]); if (content !== null) { try { const parsedContent = JSON.parse(content || '[]'); tempLoadedPrograms[type] = Array.isArray(parsedContent) ? parsedContent : []; if (tempLoadedPrograms[type].length === 0) console.warn(`Programme ${type} charg√© mais vide ou invalide.`); else console.log(`Programme ${type} charg√©/pars√© (${tempLoadedPrograms[type].length} √©tapes).`); } catch (e) { console.error(`Erreur parsing JSON programme ${type}:`, e, "Contenu:", content); showMessage(`Erreur format programme ${type}. Analyse impossible.`, 4000, true); tempLoadedPrograms[type] = []; allLoadedSuccessfully = false; } } else { console.warn(`Lecture programme ${type} √©chou√©e. Utilisation d'un programme vide.`); tempLoadedPrograms[type] = []; allLoadedSuccessfully = false; } } else { console.error(`Impossible d'obtenir/cr√©er l'ID pour ${type}. Utilisation d'un programme vide.`); tempLoadedPrograms[type] = []; allLoadedSuccessfully = false; } } loadedPrograms = tempLoadedPrograms; console.log("Fin chargement programmes (Evolution). Global success:", allLoadedSuccessfully); return allLoadedSuccessfully; }
    async function loadHistoryFromDrive() { /* ... (Identique) ... */ if (!googleAccessToken) return false; console.log("Chargement de l'historique depuis Drive..."); historyFileId = await findOrCreateFile(HISTORY_FILENAME, JSON.stringify([])); if (historyFileId) { const content = await readFileContent(historyFileId); if (content !== null) { try { workoutHistory = JSON.parse(content || "[]"); if (!Array.isArray(workoutHistory)) workoutHistory = []; workoutHistory = workoutHistory.map(entry => ({ ...entry, date: new Date(entry.date) })).filter(entry => !isNaN(entry.date)); workoutHistory.sort((a, b) => b.date - a.date); console.log(`Historique charg√© depuis Drive (${workoutHistory.length} entr√©es).`); return true; } catch (e) { console.error("Erreur parsing JSON historique depuis Drive:", e); showMessage("Erreur: Format historique Drive invalide.", 5000, true); workoutHistory = []; return false; } } else { console.warn("Lecture du fichier historique Drive √©chou√©e."); workoutHistory = []; return false; } } else { console.error("Impossible d'obtenir l'ID du fichier historique."); showMessage("Erreur: Fichier historique Drive inaccessible.", 5000, true); workoutHistory = []; return false; } }

    // --- Logique de Calcul et Affichage ELO ---
    function getRepsFactor(reps) { /* ... */ if (reps === null || reps === undefined || reps < 8) return 0.8; const thresholds = Object.keys(REPS_FACTORS).map(Number).sort((a, b) => a - b); for (const threshold of thresholds) { if (reps <= threshold) { return REPS_FACTORS[threshold]; } } return 1.4; }
    function getDurationFactor(duration) { /* ... */ if (duration === null || duration === undefined || duration <= 0) return 0.8; const thresholds = Object.keys(DURATION_FACTORS).map(Number).sort((a, b) => a - b); for (const threshold of thresholds) { if (duration <= threshold) { return DURATION_FACTORS[threshold]; } } return 1.3; }
    function isPolyarticular(exerciseName) { /* ... */ const name = (exerciseName || '').toLowerCase(); const polyKeywords = ['press', 'pompe', 'row', 'pulldown', 'ohp', 'squat', 'fente']; return polyKeywords.some(keyword => name.includes(keyword)); }
    function calculateExerciseELO(step) { /* ... */ if (step.type !== 'exercise') return 0; const base = ELO_BASE; let bonusResistance = 0; let bonusScorePart = 0; const equipmentString = step.equipment || ''; let matchedKey = null; let maxBonus = 0; for (const key in RESISTANCE_BONUS) { if (equipmentString.includes(key) && RESISTANCE_BONUS[key] > maxBonus) { maxBonus = RESISTANCE_BONUS[key]; matchedKey = key; } } bonusResistance = maxBonus; if (bonusResistance === 0 && step.weight !== null && step.weight !== undefined) { /* ... Fallback ... */ if (step.weight === 0) bonusResistance = RESISTANCE_BONUS['Bodyweight'] || 75; else if (step.weight === 10) bonusResistance = RESISTANCE_BONUS['Halt√®res 5kg'] || 50; else if (step.weight === 15) bonusResistance = RESISTANCE_BONUS['√âlastique 15kg'] || 50; else if (step.weight === 25) bonusResistance = RESISTANCE_BONUS['√âlastique 25kg'] || 125; else if (step.weight === 40) bonusResistance = RESISTANCE_BONUS['√âlastique 15+25kg'] || 200; else if (step.weight === 45) bonusResistance = RESISTANCE_BONUS['√âlastique 15+25kg + 1 halt√®re 5kg'] || 225; else if (step.weight === 50) bonusResistance = RESISTANCE_BONUS['√âlastique 15+25kg + 2x5kg halt√®res'] || 250; else bonusResistance = step.weight * 2; } if (step.reps !== null && step.reps !== undefined) { const reps = step.reps; const repsFactor = getRepsFactor(reps); bonusScorePart = bonusResistance * Math.max(0, repsFactor - 1.0); } else if (step.duration !== null && step.duration !== undefined) { const duration = step.duration; const durationFactor = getDurationFactor(duration); bonusScorePart = bonusResistance * Math.max(0, durationFactor - 1.0); } let elo = base + bonusResistance + bonusScorePart; if (step.intensity_technique === true) { elo *= INTENSITY_TECHNIQUE_BONUS_MULTIPLIER; } return Math.round(elo); }
    function mapExerciseToMuscleGroup(exerciseName) { /* ... */ const name = (exerciseName || '').toLowerCase(); if (!name) return []; if (name.includes('press') || name.includes('pecs') || name.includes('pompe')) return ['Pectoraux']; if (name.includes('row') || name.includes('pulldown')) return ['Dos']; if (name.includes('face pull')) return ['Dos', '√âpaules']; if (name.includes('curl') || name.includes('bicep')) return ['Biceps']; if (name.includes('tricep') || name.includes('extension')) return ['Triceps']; if (name.includes('lateral raise')) return ['√âpaules']; if (name.includes('ohp') || name.includes('overhead press')) return ['√âpaules', 'Triceps']; if (name.includes('squat') || name.includes('fente') || name.includes('calf')) return ['Legs']; if (name.includes('sit-up') || name.includes('hollow') || name.includes('leg raise') || name.includes('planche') || name.includes('core') || name.includes('abdo')) return ['Core']; console.warn(`Groupe musculaire non mapp√© pour : "${exerciseName}"`); return []; }
    function calculateRegularityFactor(history, periodDays = 28, targetPerWeek = 3) { /* ... */ if (!history || history.length === 0) return 0.8; const now = new Date(); const startDate = new Date(now.getTime() - periodDays * 24 * 60 * 60 * 1000); const relevantHistory = history.filter(entry => entry.date >= startDate); const sessionsDone = relevantHistory.length; const weeksInPeriod = periodDays / 7; const targetTotalSessions = weeksInPeriod * targetPerWeek; if (targetTotalSessions <= 0) return 1.0; const regularityPercentage = Math.min(1.0, sessionsDone / targetTotalSessions); const factor = 0.8 + (0.2 * regularityPercentage); console.log(`Regularity: ${sessionsDone} sessions in last ${periodDays} days. Target: ${targetTotalSessions}. Factor: ${factor.toFixed(2)}`); return factor; }

    function analyzeProgramsAndCalculateELO() {
        console.log("DEBUG: analyzeProgramsAndCalculateELO start"); // DEBUG
        const groupData = {};
        Object.keys(MUSCLE_GROUPS_DISPLAY_ORDER).flatMap(cat => MUSCLE_GROUPS_DISPLAY_ORDER[cat]).forEach(group => {
            groupData[group] = { totalWeightedElo: 0, totalWeight: 0 };
        });
        currentELOValues = {}; overallAvgELO = ELO_BASE;
        if (!programsLoaded) { console.warn("Programmes non charg√©s, analyse annul√©e."); return; }

        PROGRAM_TYPES.forEach(type => {
            console.log(`DEBUG: Analyzing program type: ${type}`); // DEBUG
            if (!loadedPrograms[type] || loadedPrograms[type].length === 0) { console.log(`DEBUG: Programme ${type} vide, skip.`); return; }
            let currentExerciseName = null; let currentExerciseSets = 0; let lastExerciseStep = null;
            loadedPrograms[type].forEach((step, index) => {
                // console.log(`DEBUG: Analyzing step ${index}, type: ${step.type}, name: ${step.name}`); // DEBUG d√©taill√©
                if (step.type === 'exercise') {
                    if (step.name === currentExerciseName) { currentExerciseSets++; }
                    else { if (lastExerciseStep) { processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData); } currentExerciseName = step.name; currentExerciseSets = 1; }
                    lastExerciseStep = step;
                    if (index === loadedPrograms[type].length - 1) { processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData); }
                } else if (step.type === 'break') {
                    if (lastExerciseStep) { processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData); }
                    currentExerciseName = null; currentExerciseSets = 0; lastExerciseStep = null;
                }
            });
        });

        console.log("DEBUG: Donn√©es agr√©g√©es brutes:", JSON.parse(JSON.stringify(groupData))); // DEBUG avant r√©gularit√©

        const globalRegularityFactor = calculateRegularityFactor(workoutHistory, REGULARITY_PERIOD_DAYS, TARGET_SESSIONS_PER_WEEK);
        console.log(`DEBUG: Facteur R√©gularit√© Global: ${globalRegularityFactor}`); // DEBUG

        let totalOverallEloSum = 0; let totalOverallWeight = 0;
        Object.keys(groupData).forEach(group => {
            const data = groupData[group];
            let avgElo = ELO_BASE;
            if (data.totalWeight > 0) { avgElo = data.totalWeightedElo / data.totalWeight; }
            // Appliquer r√©gularit√© ICI pour l'affichage par groupe et la moyenne globale
            currentELOValues[group] = Math.round(avgElo * globalRegularityFactor);
             console.log(`DEBUG: Groupe ${group} - Raw Avg ELO: ${avgElo.toFixed(1)}, Final ELO (w/ Regu): ${currentELOValues[group]}, Total Weight: ${data.totalWeight}`); // DEBUG
            if (group !== 'Legs') {
                // Utiliser l'ELO *r√©gularis√©* et le poids total pour la moyenne pond√©r√©e globale
                totalOverallEloSum += currentELOValues[group] * data.totalWeight;
                totalOverallWeight += data.totalWeight;
            }
        });

        overallAvgELO = totalOverallWeight > 0 ? Math.round(totalOverallEloSum / totalOverallWeight) : Math.round(ELO_BASE * globalRegularityFactor);
        console.log("DEBUG: ELO Moyen Global Pond√©r√© & R√©gularis√© (Haut Corps):", overallAvgELO);
        console.log("DEBUG: ELO Moyen Final par Groupe:", currentELOValues);
         console.log("DEBUG: analyzeProgramsAndCalculateELO end"); // DEBUG
    }


    function processExerciseBlock(exerciseStep, numSets, groupData) { /* ... (Identique) ... */ const elo = calculateExerciseELO(exerciseStep); if (elo > 0) { const isPoly = isPolyarticular(exerciseStep.name); const weight = isPoly ? POLYARTICULAR_WEIGHT : ISOLATION_WEIGHT; const groups = mapExerciseToMuscleGroup(exerciseStep.name); groups.forEach(group => { if (groupData[group]) { groupData[group].totalWeightedElo += elo * numSets * weight; groupData[group].totalWeight += numSets * weight; } }); } }
    function determineCurrentGoalLevel() { /* ... (MAJ pour prendre la s√©lection utilisateur) ... */
         const userGoal = TARGET_ELO_LEVELS[selectedGoalKey];
         if (!userGoal) return 'L1_MaxReps'; // Fallback

         // On d√©termine le *prochain* objectif √† afficher dans la UI, pas l'actuel atteint
         const levelKeys = Object.keys(TARGET_ELO_LEVELS);
         let nextLevelKey = selectedGoalKey; // Par d√©faut, on vise le s√©lectionn√©

         // Si l'ELO actuel d√©passe l'objectif s√©lectionn√©, on vise le suivant (s'il existe)
         if (overallAvgELO >= (userGoal.targetELO || ELO_BASE) ) {
              const currentIndex = levelKeys.indexOf(selectedGoalKey);
              if (currentIndex < levelKeys.length - 1) {
                  nextLevelKey = levelKeys[currentIndex + 1];
              }
         }
         console.log(`DEBUG: determineCurrentGoalLevel - Selected: ${selectedGoalKey}, Overall ELO: ${overallAvgELO}, Target ELO: ${userGoal.targetELO}, Next Level Key: ${nextLevelKey}`);
         return nextLevelKey; // Retourne la cl√© du niveau √† viser
    }

    function calculateAndDisplayEvolution() {
        console.log("DEBUG: calculateAndDisplayEvolution start"); // DEBUG
        if (!evolutionTrackerArea || !overallEloDisplay || !goalInfo || !goalDescriptionElement || !muscleGroupsContainer || !globalProgressBar || !globalProgressPercentageValueElement || !overallEloValueElement) {
             console.error("DEBUG: El√©ments DOM manquants pour l'affichage."); return; // DEBUG
        }

        const previousOverallELO = parseFloat(overallEloValueElement.textContent) || ELO_BASE; // Pour animation
        analyzeProgramsAndCalculateELO(); // Recalculer ELOs

        const displayGoalKey = determineCurrentGoalLevel(); // Niveau √† afficher comme cible
        const displayGoal = TARGET_ELO_LEVELS[displayGoalKey];
        // Trouver le niveau pr√©c√©dent PAR RAPPORT AU NIVEAU AFFICH√â comme cible
        const levelKeys = Object.keys(TARGET_ELO_LEVELS);
        const displayGoalIndex = levelKeys.indexOf(displayGoalKey);
        const previousGoalLevelKey = displayGoalIndex > 0 ? levelKeys[displayGoalIndex - 1] : null;
        const previousGoal = previousGoalLevelKey ? TARGET_ELO_LEVELS[previousGoalLevelKey] : { targetELO: ELO_BASE, groups: {} };

        console.log(`DEBUG: Affichage - Niveau Cible Affich√©: ${displayGoalKey}, Niveau Pr√©c√©dent pour %: ${previousGoalLevelKey || 'BASE'}`); // DEBUG

        // Affichage Global
        animateValue(overallEloValueElement, previousOverallELO, overallAvgELO, 1000);
        goalInfo.innerHTML = `Objectif S√©lectionn√© : <span class="target-level">${TARGET_ELO_LEVELS[selectedGoalKey].name}</span> | Prochain Palier: <span class="target-level">${displayGoal.name}</span> (ELO Cible <span class="target-elo-value">${displayGoal.targetELO}</span>)`;
        goalDescriptionElement.textContent = displayGoal.description || "";
        overallEloDisplay.querySelector('.tooltip-icon').title = `ELO Moyen Pond√©r√© & R√©gularis√© (Haut du Corps): ${overallAvgELO}. Bas√© sur vos programmes, s√©ries, reps/dur√©es et r√©gularit√© (${(calculateRegularityFactor(workoutHistory) * 100).toFixed(0)}%).`;

        // Affichage par Groupe
        muscleGroupsContainer.innerHTML = '';
        for (const category in MUSCLE_GROUPS_DISPLAY_ORDER) {
             const categoryDiv = document.createElement('div'); categoryDiv.className = 'muscle-category';
             const categoryHeader = document.createElement('h3'); categoryHeader.className = 'muscle-category-header'; categoryHeader.textContent = category; categoryDiv.appendChild(categoryHeader);
             const groupGridDiv = document.createElement('div'); groupGridDiv.className = 'muscle-group-grid';
             MUSCLE_GROUPS_DISPLAY_ORDER[category].forEach(group => {
                 if (group === 'Legs') return;
                 const currentAvgELO = currentELOValues[group] || ELO_BASE;
                 const targetELO = displayGoal.groups[group] || displayGoal.targetELO; // Cible du niveau affich√©
                 const stageStartELO = previousGoal.groups[group] || previousGoal.targetELO || ELO_BASE; // D√©but de l'√©tape vers le niveau affich√©
                 let progressPercent = 0;
                 if (targetELO > stageStartELO) { progressPercent = ((currentAvgELO - stageStartELO) / (targetELO - stageStartELO)) * 100; }
                 else if (currentAvgELO >= targetELO) { progressPercent = 100; }
                 progressPercent = Math.max(0, Math.min(100, Math.round(progressPercent)));
                  console.log(`DEBUG: Groupe ${group} - Current: ${currentAvgELO}, Start: ${stageStartELO}, Target: ${targetELO}, Percent: ${progressPercent}`); // DEBUG
                 const card = renderMuscleGroupCard(group, currentAvgELO, targetELO, progressPercent);
                 groupGridDiv.appendChild(card);
             });
             categoryDiv.appendChild(groupGridDiv);
             muscleGroupsContainer.appendChild(categoryDiv);
        }

        // Affichage Barre Globale "Marvel" (vers objectif final L3)
        const previousGlobalPercent = parseFloat(globalProgressPercentageValueElement.textContent) || 0;
        let globalProgressPercent = 0;
        if (FINAL_TARGET_ELO > ELO_BASE) { globalProgressPercent = ((overallAvgELO - ELO_BASE) / (FINAL_TARGET_ELO - ELO_BASE)) * 100; }
        else if (overallAvgELO >= FINAL_TARGET_ELO) { globalProgressPercent = 100; }
        globalProgressPercent = Math.max(0, Math.min(100, Math.round(globalProgressPercent)));

        animateValue(globalProgressPercentageValueElement, previousGlobalPercent, globalProgressPercent, 1200, true);
        globalProgressBar.style.width = `0%`;
        globalProgressBar.setAttribute('aria-valuenow', overallAvgELO); globalProgressBar.setAttribute('aria-valuemin', ELO_BASE); globalProgressBar.setAttribute('aria-valuemax', FINAL_TARGET_ELO);
        globalProgressBar.parentElement.title = `${globalProgressPercent}% vers l'objectif final '${TARGET_ELO_LEVELS.L3_TomHolland.name}' (ELO ${FINAL_TARGET_ELO})`;
        requestAnimationFrame(() => { setTimeout(() => { globalProgressBar.style.width = `${globalProgressPercent}%`; }, 50); });
         console.log("DEBUG: calculateAndDisplayEvolution end"); // DEBUG
    }

    function renderMuscleGroupCard(groupName, currentElo, targetElo, progressPercent) {
        const card = document.createElement('div'); card.className = 'muscle-group-card';
        const iconClass = MUSCLE_GROUP_ICONS[groupName] || 'fa-question-circle';
        const previousElo = parseFloat(card.querySelector('.current-elo .elo-value')?.textContent) || ELO_BASE;
        const previousPercent = parseFloat(card.querySelector('.progress-percentage')?.textContent) || 0;

        card.innerHTML = `
            <div class="muscle-group-header">
                <i class="fas ${iconClass}" aria-hidden="true"></i>
                <h3 class="muscle-group-title">${groupName}</h3>
            </div>
            <div class="elo-info">
                <span class="current-elo">
                    <span class="elo-value" data-start-elo="${previousElo}" data-target-elo="${currentElo}">${Math.round(previousElo)}</span>
                     <i class="fas fa-circle-info tooltip-icon" title="ELO actuel (${currentElo}) pour ${groupName}, bas√© sur vos programmes et r√©gularit√©. Objectif du palier actuel: ${targetElo}."></i>
                </span>
                <span class="target-elo">Objectif Palier: <strong>${targetElo}</strong></span>
            </div>
            <div class="progress-bar-container" title="${progressPercent}% vers l'objectif ELO ${targetElo}">
                <div class="progress-bar" style="width: ${previousPercent}%;" role="progressbar" aria-valuenow="${previousPercent}" aria-valuemin="0" aria-valuemax="100">
                     <span class="progress-percentage" data-start-percent="${previousPercent}" data-target-percent="${progressPercent}">${Math.round(previousPercent)}%</span>
                </div>
            </div>
        `;
         requestAnimationFrame(() => {
            setTimeout(() => {
                const eloValueSpan = card.querySelector('.current-elo .elo-value');
                const progressBar = card.querySelector('.progress-bar');
                const percentageSpan = card.querySelector('.progress-percentage');
                // Utiliser l'ELO calcul√© 'currentElo' comme cible finale pour l'animation
                if (eloValueSpan) animateValue(eloValueSpan, parseFloat(eloValueSpan.textContent) || ELO_BASE, currentElo, 800);
                if (progressBar) {
                    progressBar.style.width = `${progressPercent}%`;
                    progressBar.setAttribute('aria-valuenow', progressPercent);
                }
                 if (percentageSpan) animateValue(percentageSpan, parseFloat(percentageSpan.textContent) || 0, progressPercent, 800, true);
            }, 50);
        });
        return card;
    }

    // --- Animation des Nombres ---
    function animateValue(element, start, end, duration, isPercent = false) { /* ... (Identique) ... */ if (!element) return; start = Math.round(start); end = Math.round(end); if (start === end) { element.textContent = end + (isPercent ? '%' : ''); return; } let startTimestamp = null; const step = (timestamp) => { if (!startTimestamp) startTimestamp = timestamp; const progress = Math.min((timestamp - startTimestamp) / duration, 1); const currentValue = Math.floor(progress * (end - start) + start); element.textContent = currentValue + (isPercent ? '%' : ''); if (progress < 1) { window.requestAnimationFrame(step); } else { element.textContent = end + (isPercent ? '%' : ''); } }; window.requestAnimationFrame(step); }

    // --- Gestion Pr√©f√©rence Objectif ---
    function populateGoalSelector() { /* ... */ if (!goalSelector) return; goalSelector.innerHTML = ''; for (const key in TARGET_ELO_LEVELS) { const option = document.createElement('option'); option.value = key; option.textContent = TARGET_ELO_LEVELS[key].name; goalSelector.appendChild(option); } selectedGoalKey = loadGoalPreference(); goalSelector.value = selectedGoalKey; }
    function handleGoalChange(event) { /* ... */ selectedGoalKey = event.target.value; saveGoalPreference(selectedGoalKey); calculateAndDisplayEvolution(); showMessage(`Objectif mis √† jour : ${TARGET_ELO_LEVELS[selectedGoalKey].name}`, 2500); }
    function saveGoalPreference(goalKey) { /* ... */ try { localStorage.setItem('armorWorkoutGoalKey', goalKey); } catch (e) { console.warn("Impossible de sauvegarder la pr√©f√©rence d'objectif:", e); } }
    function loadGoalPreference() { /* ... */ try { return localStorage.getItem('armorWorkoutGoalKey') || 'L1_MaxReps'; } catch (e) { console.warn("Impossible de lire la pr√©f√©rence d'objectif:", e); return 'L1_MaxReps'; } }

    // --- UI Update ---
    function updateAuthUI(isLoggedIn) { /* ... */ console.log(`Update UI (Evolution) - Connect√©: ${isLoggedIn}, Programmes Charg√©s: ${programsLoaded}, Historique Charg√©: ${historyLoaded}`); const body = document.body; body.classList.toggle('logged-in', isLoggedIn); body.classList.toggle('logged-out', !isLoggedIn); if (connectionPrompt) connectionPrompt.style.display = isLoggedIn ? 'none' : 'block'; const showEvolutionArea = isLoggedIn && programsLoaded && historyLoaded; if (evolutionTrackerArea) evolutionTrackerArea.style.display = showEvolutionArea ? 'flex' : 'none'; if(signInButton) signInButton.disabled = isLoggedIn || !tokenClient; if(signInButtonPrompt) signInButtonPrompt.disabled = isLoggedIn || !tokenClient; if(signOutButton) signOutButton.disabled = !isLoggedIn; if(themeToggleBtn) themeToggleBtn.disabled = false; if(goalSelector) goalSelector.disabled = !showEvolutionArea; if(driveStatusElement) { driveStatusElement.style.display = isLoggedIn ? 'inline-block' : 'none'; if (!isLoggedIn) driveStatusElement.textContent = ''; } if (!isLoggedIn) { if (muscleGroupsContainer) muscleGroupsContainer.innerHTML = ''; if (overallEloValueElement) overallEloValueElement.textContent = '--'; if (goalInfo) goalInfo.innerHTML = 'Objectif Actuel : <span class="target-level">N/A</span> (ELO <span class="target-elo-value">--</span>)'; if(goalDescriptionElement) goalDescriptionElement.textContent = ''; if(globalProgressBar) globalProgressBar.style.width = '0%'; if(globalProgressPercentageValueElement) globalProgressPercentageValueElement.textContent = '0'; } }

    // --- Gestion Th√®me ---
    function applyTheme(theme) { /* ... */ const body = document.body; currentTheme = theme; body.classList.remove('light-theme', 'dark-theme'); body.classList.add(theme + '-theme'); if (themeToggleBtn) { themeToggleBtn.innerHTML = theme === 'dark' ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>'; themeToggleBtn.setAttribute('aria-label', theme === 'dark' ? 'Passer au th√®me clair' : 'Passer au th√®me sombre'); } try { localStorage.setItem('theme', theme); console.log(`Th√®me appliqu√©/sauvegard√© (Evolution): ${theme}`); } catch (e) { console.warn("Impossible de sauvegarder le th√®me (Evolution):", e); } }
    function toggleTheme() { /* ... */ const newTheme = currentTheme === 'dark' ? 'light' : 'dark'; applyTheme(newTheme); }
    function loadSavedTheme() { /* ... */ let savedTheme = 'dark'; try { savedTheme = localStorage.getItem('theme') || 'dark'; } catch (e) { console.warn("Impossible de lire le th√®me depuis localStorage (Evolution):", e); } applyTheme(savedTheme); }

    // --- Message Area ---
    function showMessage(msg, duration = 3000, isError = false) { /* ... */ if (!messageArea) return; messageArea.textContent = msg; messageArea.style.backgroundColor = isError ? 'var(--neon-red)' : 'rgba(var(--secondary-bg-color-dark-rgb), 0.9)'; messageArea.style.color = isError ? '#fff' : 'var(--primary-text-color)'; messageArea.style.borderColor = isError ? 'var(--neon-red)' : 'var(--border-color)'; messageArea.classList.add('visible'); if (messageTimeoutId) clearTimeout(messageTimeoutId); messageTimeoutId = setTimeout(() => { messageArea.classList.remove('visible'); }, duration); }

    // --- Initialisation ---
    function initializeDOMReferences() {
        console.log("Init DOM Refs (Evolution)...");
        signInButton = document.getElementById('signin-button'); signOutButton = document.getElementById('signout-button'); driveStatusElement = document.getElementById('drive-status'); themeToggleBtn = document.getElementById('theme-toggle-btn');
        signInButtonPrompt = document.getElementById('signin-button-prompt'); connectionPrompt = document.getElementById('connection-prompt'); evolutionTrackerArea = document.getElementById('evolution-tracker-area');
        overallEloDisplay = document.getElementById('overall-elo-display'); overallEloValueElement = overallEloDisplay?.querySelector('.elo-value');
        goalSelector = document.getElementById('goal-selector');
        goalInfo = document.getElementById('goal-info'); goalDescriptionElement = document.getElementById('goal-description');
        muscleGroupsContainer = document.getElementById('muscle-groups-container'); messageArea = document.getElementById('message-area');
        globalProgressBar = document.getElementById('global-progress-bar'); globalProgressPercentage = document.getElementById('global-progress-percentage'); globalProgressPercentageValueElement = globalProgressPercentage; // Le span contient le % directement
        console.log("DOM Refs initialis√©es (Evolution).");
    }
    function addEventListeners() { /* ... (Identique, inclut goalSelector listener) ... */ console.log("Ajout Event Listeners (Evolution)..."); if(signInButton) signInButton.addEventListener('click', handleAuthClick); if(signInButtonPrompt) signInButtonPrompt.addEventListener('click', handleAuthClick); if(signOutButton) signOutButton.addEventListener('click', handleSignoutClick); if(themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme); if(goalSelector) goalSelector.addEventListener('change', handleGoalChange); console.log("Event Listeners ajout√©s (Evolution)."); }

    // --- Point d'entr√©e ---
    document.addEventListener('DOMContentLoaded', () => {
        console.log("DOM Charg√© (Evolution). Initialisation...");
        try {
            initializeDOMReferences();
            addEventListeners();
            populateGoalSelector();
            loadSavedTheme();
            updateAuthUI(false);
            checkAndInitGis();
            console.log("Initialisation Evolution termin√©e. Attente API Google...");
        } catch (error) {
            console.error("Erreur majeure lors de l'initialisation DOMContentLoaded (Evolution):", error);
             showMessage("Erreur critique au chargement du suivi d'√©volution.", 10000, true);
             const body = document.querySelector('body');
             if(body) {
                const errorDiv = document.createElement('div');
                errorDiv.textContent = "Erreur chargement suivi: " + error.message;
                errorDiv.style.color='red'; errorDiv.style.padding='10px';
                body.prepend(errorDiv);
             }
        }
    });

    /*
    =========================================
    LISTE DES AM√âLIORATIONS POSSIBLES (Mise √† jour)
    =========================================
    ‚úÖ = Impl√©ment√© ou Pr√©par√©

    **Donn√©es & Calcul ELO:**
    1.  ‚úÖ **Pond√©ration Poly/Iso:** Fait.
    2.  ‚úÖ **Impact Techniques Intensit√©:** Pr√©par√© (`intensity_technique: true`), n√©cessite MAJ Editeur.
    3.  ‚úÖ **Prise en Compte des S√©ries:** Fait.
    4.  ‚úÖ/‚ùì **Affiner Bonus R√©sistance:** Structure en place.
    5.  ‚úÖ **Prise en Compte du Temps:** Fait.
    6.  ‚úÖ **Historique (R√©gularit√©):** Fait.
    7.  **Historique ELO (Graphique):** ***Non impl√©ment√©.***
    8.  **Normalisation ELO?**

    **Interface Utilisateur (UI) & Exp√©rience (UX):**
    9.  ‚úÖ **Personnalisation Objectifs:** Fait (dropdown).
    10. ‚úÖ **Tooltips d'Information:** Fait (survol `title`).
    11. ‚úÖ **Animation des Chiffres:** Fait.
    12. **D√©tail par Exercice:** Cliquer sur une carte de groupe.
    13. **Conseils Personnalis√©s:** Sugg√©rer actions si groupe en retard.
    14. **Visualisation Muscle Map:** Colorer une silhouette.
    15. **Feedback Visuel Progr√®s:** Changer couleur barre/carte si objectif atteint.

    **Fonctionnalit√©s & Int√©gration:**
    16. ‚úÖ **Lien vers l'√âditeur:** Fait (header).
    17. **Lien vers l'Historique:** Afficher date dernier entra√Ænement / Graphique historique ELO (voir point 7).
    18. **Rappel Nutrition:** Note statique/conditionnelle.

    **Technique:**
    19. **Modularit√© du Code:** Peut √™tre am√©lior√©e.
    20. **Gestion Erreurs JSON:** Proposer r√©initialisation.
    21. **Tests Unitaires:** Pour valider logique ELO.
    22. ‚úÖ **Optimisation Chargement:** Chargement parall√®le fait.
    23. **Mapping Exercice->Groupe:** Pourrait √™tre affin√© ou rendu configurable.
    */

</script>

</body>
</html>
