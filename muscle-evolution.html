<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArmorWorkout - Suivi Évolution</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&display=swap" rel="stylesheet">

    <style>
        /* --- Variables Globales & Thèmes (Inspiré de l'image) --- */
        :root {
            /* Thème Sombre (Défaut) */
            --bg-color-dark: #0a0f1e; /* Bleu très sombre */
            --secondary-bg-color-dark: #141a30; /* Bleu sombre pour les cartes */
            --primary-text-color-dark: #e0e0ff; /* Blanc bleuté très clair */
            --secondary-text-color-dark: #8a94c1; /* Gris bleuté */
            --border-color-dark: #2a3150; /* Bordure subtile */
            --accent-border-color-dark: #4b558a; /* Bordure plus visible pour hover/focus */
            --input-bg-dark: #0a0f1e;

            /* Couleurs "Néon" / Gradient (Ajustées) */
            --neon-blue: #6fa8ff;
            --neon-purple: #b18cff;
            --gradient-start: var(--neon-purple);
            --gradient-end: var(--neon-blue);

            /* Couleurs Niveaux (Ajustées pour le badge) */
            --level-beginner-color: #8a94c1; --level-beginner-bg: rgba(138, 148, 193, 0.1);
            --level-bronze-color: #cd7f32;   --level-bronze-bg: rgba(205, 127, 50, 0.15);
            --level-silver-color: #c0c0c0;   --level-silver-bg: rgba(192, 192, 192, 0.15);
            --level-gold-color: #ffd700;     --level-gold-bg: rgba(255, 215, 0, 0.15);
            --level-crystal-color: #a7d8de;  --level-crystal-bg: rgba(167, 216, 222, 0.15);
            --level-master-color: #e384f1;   --level-master-bg: rgba(227, 132, 241, 0.15);
            --level-champion-color: #ff7b72; --level-champion-bg: rgba(255, 123, 114, 0.15);

            /* Glows (Principalement pour le score ELO et les barres) */
            --glow-gradient: 0 0 20px rgba(177, 140, 255, 0.4), 0 0 30px rgba(111, 168, 255, 0.3);
            --glow-level-reached: 0 0 15px rgba(63, 185, 80, 0.7); /* Vert pour objectif atteint */
            --neon-green: #3fb950; /* Vert pour indicateur succès/atteint */

            /* Autres */
            --font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius-lg: 18px; /* Plus arrondi */
            --border-radius-md: 12px;
            --border-radius-sm: 8px;
            --transition-speed: 0.3s;

            /* RGBA pour transparences */
            --bg-color-dark-rgb: 10, 15, 30;
            --secondary-bg-color-dark-rgb: 20, 26, 48;
            --primary-text-color-dark-rgb: 224, 224, 255;
            --secondary-text-color-dark-rgb: 138, 148, 193;
            --border-color-dark-rgb: 42, 49, 80;
            --neon-blue-rgb: 111, 168, 255;
            --neon-purple-rgb: 177, 140, 255;
            --neon-green-rgb: 63, 185, 80;

            /* Application Thème Sombre par défaut */
            --bg-color: var(--bg-color-dark);
            --secondary-bg-color: var(--secondary-bg-color-dark);
            --primary-text-color: var(--primary-text-color-dark);
            --secondary-text-color: var(--secondary-text-color-dark);
            --border-color: var(--border-color-dark);
            --accent-border-color: var(--accent-border-color-dark);
            --input-bg: var(--input-bg-dark);
            --bg-color-rgb: var(--bg-color-dark-rgb);
            --secondary-bg-color-rgb: var(--secondary-bg-color-dark-rgb);
            --primary-text-color-rgb: var(--primary-text-color-dark-rgb);
            --secondary-text-color-rgb: var(--secondary-text-color-dark-rgb);
            --border-color-rgb: var(--border-color-dark-rgb);

            /* Styles spécifiques */
            --link-color: var(--neon-blue);
            --button-connect-color: var(--neon-green);
            --button-connect-glow: 0 0 10px rgba(var(--neon-green-rgb), 0.6);
            --button-disconnect-color: #ff7b72; /* Rouge/Rose */
            --button-disconnect-glow: 0 0 10px rgba(255, 123, 114, 0.6);

            /* Barres de progression */
            --progress-bar-bg: rgba(var(--primary-text-color-rgb), 0.1);
            --progress-bar-fill: linear-gradient(90deg, var(--gradient-start), var(--gradient-end));
        }

        /* --- Styles de Base & Réinitialisation --- */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--primary-text-color);
            line-height: 1.6;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
            padding-top: 70px; /* Espace pour header fixe */
        }
        .container {
            max-width: 450px; /* Centré et plus étroit pour look mobile */
            margin: 0 auto;
            padding: 20px 15px; /* Moins de padding horizontal */
            width: 100%;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* --- En-tête Simplifié --- */
        header {
            position: fixed; /* Fixe en haut */
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px 0;
            z-index: 1000;
            background-color: rgba(var(--bg-color-rgb), 0.8); /* Fond semi-transparent */
            backdrop-filter: blur(10px); /* Effet verre dépoli */
            -webkit-backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
            transition: border-color var(--transition-speed) ease, background-color var(--transition-speed) ease;
        }
        .header-content {
            display: flex;
            flex-direction: column; /* Icône/Titre au-dessus des actions */
            align-items: center;
            max-width: 450px;
            margin: 0 auto;
            padding: 0 15px;
            gap: 10px; /* Espace entre titre et actions */
        }
        header .title-container {
             display: flex;
             flex-direction: column;
             align-items: center;
             gap: 5px;
             margin-bottom: 10px; /* Espace avant les boutons */
        }
        header .title-container i.header-icon {
             font-size: 1.8em;
             color: var(--primary-text-color);
             opacity: 0.8;
        }
        header h1 {
            font-size: 1.1em; /* Plus petit */
            color: var(--primary-text-color);
            margin: 0;
            font-weight: 500; /* Moins gras */
            letter-spacing: 0.1em; /* Espacement lettres */
            text-transform: uppercase;
        }
        .header-actions { display: flex; gap: 15px; align-items: center; justify-content: center; width: 100%; }
        .auth-controls { display: flex; gap: 10px; align-items: center; }
        .auth-controls button { /* Style des boutons d'auth */
            background: none;
            border: 1px solid var(--border-color); /* Bordure plus subtile */
            color: var(--secondary-text-color);
            padding: 5px 12px;
            border-radius: var(--border-radius-md);
            font-size: 0.8em;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
         .auth-controls button:disabled { opacity: 0.4; cursor: not-allowed; background: transparent !important; border-color: var(--border-color) !important; color: var(--secondary-text-color) !important; box-shadow: none !important; }
         .auth-controls button:not(:disabled):hover { border-color: var(--accent-border-color); color: var(--primary-text-color); background-color: rgba(var(--primary-text-color-rgb), 0.05); }
         #signin-button { border-color: var(--button-connect-color); color: var(--button-connect-color); }
         #signin-button:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--button-connect-glow); }
         #signout-button { border-color: var(--button-disconnect-color); color: var(--button-disconnect-color); }
         #signout-button:not(:disabled):hover { background-color: rgba(255, 123, 114, 0.1); box-shadow: var(--button-disconnect-glow); }

        #drive-status { display: none; } /* Caché pour ce design */
        .theme-toggle button { /* Icône thème à droite */
            background: none; border: none; color: var(--secondary-text-color); font-size: 1.1em; padding: 5px; cursor: pointer; transition: color var(--transition-speed) ease;
        }
        .theme-toggle button:hover { color: var(--neon-purple); }

        /* Affichage conditionnel */
        body.logged-out #signin-button { display: inline-flex; }
        body.logged-out #signout-button { display: none; }
        body.logged-in #signin-button { display: none; }
        body.logged-in #signout-button { display: inline-flex; }
        body.logged-out #connection-prompt { display: block; }
        body.logged-in #connection-prompt { display: none; }
        body.logged-out #evolution-tracker-area { display: none; }
        body.logged-in #evolution-tracker-area { display: flex; }

        /* --- Contenu Principal --- */
        main { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding-top: 20px; } /* Moins de padding top */

        /* Message si non connecté */
        #connection-prompt { text-align: center; padding: 30px 20px; background-color: var(--secondary-bg-color); border-radius: var(--border-radius-lg); border: 1px dashed var(--border-color); margin: 20px auto; max-width: 90%; }
        #connection-prompt p { margin-bottom: 15px; color: var(--secondary-text-color); font-size: 0.9em;}
        #connection-prompt button { padding: 8px 18px; font-size: 0.9em; border-color: var(--button-connect-color); color: var(--button-connect-color); }
        #connection-prompt button:not(:disabled):hover { background-color: rgba(var(--neon-green-rgb), 0.1); box-shadow: var(--button-connect-glow); }

        /* Zone principale d'affichage */
        #evolution-tracker-area {
            width: 100%;
            display: flex; /* Remplacé display: block */
            flex-direction: column;
            gap: 20px; /* Espace entre les cartes */
            margin-top: 0; /* Pas de marge sup */
            background: none; /* Pas de fond global ici */
            border: none; /* Pas de bordure globale */
            padding: 0; /* Pas de padding global */
            box-shadow: none;
        }

        /* Carte Principale ELO Score */
        .global-stats-card {
            background-color: var(--secondary-bg-color);
            border-radius: var(--border-radius-lg);
            padding: 25px 20px;
            text-align: center;
            border: 1px solid var(--border-color);
            box-shadow: 0 10px 30px rgba(0,0,0, 0.2);
            position: relative;
            overflow: hidden;
        }
         /* Lueur subtile interne */
        .global-stats-card::before {
             content: ''; position: absolute; top: -30%; left: -30%; width: 160%; height: 160%;
             background: radial-gradient(circle, rgba(var(--neon-blue-rgb), 0.1) 0%, rgba(var(--neon-blue-rgb), 0) 60%);
             animation: rotateGlow 15s linear infinite;
             pointer-events: none;
             opacity: 0.7;
         }
         @keyframes rotateGlow { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .global-stats-card .card-title {
            font-size: 0.9em;
            color: var(--secondary-text-color);
            margin-bottom: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        #overall-elo-display .value {
            font-size: 4.5em; /* Très grand */
            font-weight: 900;
            line-height: 1;
            margin-bottom: 15px;
            display: block;
            /* Effet gradient + lueur texte */
            background: linear-gradient(90deg, var(--gradient-start), var(--gradient-end));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: var(--glow-gradient);
            animation: pulse-text 3s infinite ease-in-out;
        }
         @keyframes pulse-text {
             0%, 100% { text-shadow: var(--glow-gradient); opacity: 1; }
             50% { text-shadow: 0 0 15px rgba(177, 140, 255, 0.3), 0 0 25px rgba(111, 168, 255, 0.2); opacity: 0.95; }
         }

        #level-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 15px;
            border-radius: var(--border-radius-md);
            font-size: 0.9em;
            font-weight: 700;
            margin-bottom: 8px;
            border: 1px solid transparent; /* Pour la transition */
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease, border-color var(--transition-speed) ease;
            cursor: default;
        }
        #level-badge i {
            font-size: 1.2em;
        }
        /* Styles spécifiques au niveau (appliqués par JS) */
        /* #level-badge.level-bronze { background-color: var(--level-bronze-bg); color: var(--level-bronze-color); border-color: rgba(var(--level-bronze-color-rgb), 0.5); } ... etc */

        #target-elo-info {
            font-size: 0.85em;
            color: var(--secondary-text-color);
        }
        #target-elo-info strong {
            font-weight: 700;
            color: var(--primary-text-color);
        }

        /* Conteneur des groupes musculaires */
        #muscle-groups-container { display: flex; flex-direction: column; gap: 15px; } /* Espacement entre cartes muscle */

        /* Carte pour un groupe musculaire (Style de l'image) */
        .muscle-group-card {
            background-color: var(--secondary-bg-color);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-md);
            padding: 15px;
            display: flex;
            flex-direction: column; /* Empile les éléments verticalement */
            gap: 12px;
            transition: all var(--transition-speed) ease;
            position: relative; /* Pour pseudo-éléments */
            overflow: hidden;
        }
        .muscle-group-card:hover {
             border-color: var(--accent-border-color);
             transform: translateY(-2px);
             box-shadow: 0 5px 15px rgba(0,0,0, 0.15);
         }

        .muscle-group-card .card-header {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .muscle-group-card .icon-container {
            flex-shrink: 0;
            color: var(--secondary-text-color);
            font-size: 1.8em; /* Icône plus grande */
            width: 35px; /* Taille fixe */
            text-align: center;
            opacity: 0.7;
        }
        .muscle-group-card .title-container {
            flex-grow: 1;
        }
        .muscle-group-card .group-title {
            font-size: 1.05em;
            font-weight: 700;
            color: var(--primary-text-color);
            line-height: 1.2;
        }
        .muscle-group-card .group-subtitle {
            font-size: 0.85em;
            color: var(--secondary-text-color);
            font-weight: 400;
            line-height: 1.2;
        }
        .muscle-group-card .elo-details {
            font-size: 0.9em;
            font-weight: 500;
            color: var(--secondary-text-color);
            text-align: right; /* Aligné à droite */
            white-space: nowrap;
        }
        .muscle-group-card .elo-details .current {
             color: var(--primary-text-color);
             font-weight: 700;
        }
         .muscle-group-card .elo-details .target {} /* Pas de style spécifique, juste / */


        /* Barre de progression stylée */
        .progress-bar-container {
            width: 100%;
            height: 8px; /* Plus fine */
            background-color: var(--progress-bar-bg);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 5px;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            width: 0%; /* Modifié par JS */
            background: var(--progress-bar-fill);
            border-radius: 4px;
            transition: width 0.8s cubic-bezier(0.25, 1, 0.5, 1);
            box-shadow: var(--glow-gradient); /* Applique la lueur */
        }
        .progress-percentage { /* Pourrait être affiché ailleurs ou caché */
             display: none; /* Caché par défaut dans ce design */
        }

        /* Style pour objectif atteint sur une carte */
        .muscle-group-card.level-target-reached {
             border-color: var(--neon-green);
             box-shadow: 0 0 15px rgba(var(--neon-green-rgb), 0.3);
        }
         .muscle-group-card.level-target-reached::after { /* Indicateur visuel subtil */
             content: '\f00c'; /* Checkmark FontAwesome */
             font-family: 'Font Awesome 6 Free';
             font-weight: 900;
             position: absolute;
             top: 10px;
             right: 10px;
             color: var(--neon-green);
             font-size: 0.9em;
             opacity: 0;
             animation: fadeInCheck 0.5s 0.5s ease forwards;
         }
         @keyframes fadeInCheck{ from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } }


        /* Pied de page simplifié */
        footer {
             color: var(--secondary-text-color);
             opacity: 0.6;
             border-top: 1px solid var(--border-color);
             margin-top: 40px;
             padding: 20px 15px;
             text-align: center;
             font-size: 0.8em;
             transition: border-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }
        footer a { color: var(--link-color); text-decoration: none; }
        footer a:hover { color: var(--primary-text-color); }

        /* --- Zone de Messages Flottante (Stylisée) --- */
        .message-area {
             position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
             background-color: rgba(var(--secondary-bg-color-rgb), 0.9); /* Utilise le fond secondaire */
             color: var(--primary-text-color);
             border: 1px solid var(--border-color);
             padding: 10px 20px; /* Plus petit */
             border-radius: var(--border-radius-md);
             z-index: 3000; opacity: 0;
             transition: opacity 0.5s ease, transform 0.5s ease, bottom 0.5s ease;
             pointer-events: none; font-size: 0.9em;
             box-shadow: 0 4px 15px rgba(0,0,0,0.2);
             backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
             max-width: 90%; text-align: center;
         }
        .message-area.visible { opacity: 1; transform: translate(-50%, 0); bottom: 30px; pointer-events: auto; }
        .message-area.error { background-color: rgba(255, 123, 114, 0.9); color: #fff; border-color: #ff7b72; }
        .message-area.success { background-color: rgba(var(--neon-green-rgb), 0.9); color: #fff; border-color: var(--neon-green); }
        .message-area.warning { background-color: rgba(249, 168, 37, 0.9); color: #fff; border-color: #f9a825; } /* Orange pour warning */
        .message-area.info { background-color: rgba(var(--neon-blue-rgb), 0.9); color: #fff; border-color: var(--neon-blue); }

        /* Placeholder/Error styling */
        #muscle-groups-container .loading-placeholder,
        #muscle-groups-container .error-placeholder {
            background-color: var(--secondary-bg-color);
            border-radius: var(--border-radius-md);
            padding: 30px 20px;
            text-align: center;
            color: var(--secondary-text-color);
            font-style: italic;
            border: 1px dashed var(--border-color);
            margin-top: 10px; /* Espace par rapport à la carte ELO */
        }
        #muscle-groups-container .error-placeholder {
            color: #ff7b72; /* Rouge/Rose */
            border-color: #ff7b72;
        }

        /* --- Responsive (Peu nécessaire car mobile-first, mais pour contexte) --- */
        @media (min-width: 768px) {
             /* Si on voulait un layout plus large sur tablette/desktop */
             .container { max-width: 600px; }
             header .title-container { margin-bottom: 0; }
             .header-content { flex-direction: row; justify-content: space-between; max-width: 900px;}
             .header-actions { width: auto; } /* Ne prend plus toute la largeur */
             body { padding-top: 80px; } /* Ajuster pour header potentiellement plus haut */
        }

    </style>
</head>
<body class="logged-out dark-theme"> <!-- Toujours commencer en sombre et déconnecté -->

<header>
    <div class="header-content">
         <div class="title-container">
             <i class="fas fa-shield header-icon"></i> <!-- Icône bouclier simple -->
             <h1>ArmorWorkout</h1>
         </div>
        <div class="header-actions">
            <div class="auth-controls">
                <button id="signin-button" disabled><i class="fab fa-google"></i> Connexion</button> <!-- Texte simplifié -->
                <button id="signout-button" disabled><i class="fas fa-sign-out-alt"></i> Déconnexion</button>
            </div>
             <span id="drive-status" aria-live="polite"></span> <!-- Caché par CSS mais gardé pour la logique -->
            <div class="theme-toggle">
                <button id="theme-toggle-btn" aria-label="Basculer le thème"><i class="fas fa-sun"></i></button>
            </div>
        </div>
    </div>
</header>

<div class="container">
    <main>
        <!-- Le titre H2 n'est plus nécessaire, l'info est dans les cartes -->

        <div id="connection-prompt">
            <p>Connectez-vous via Google pour suivre votre évolution.</p>
            <button id="signin-button-prompt" disabled><i class="fab fa-google"></i> Se connecter</button>
        </div>

        <div id="evolution-tracker-area">
            <!-- Carte Stats Globales (Nouveau format) -->
            <div class="global-stats-card">
                 <div class="card-title">Upper Body ELO Score</div>
                 <div id="overall-elo-display">
                     <span class="value">--</span>
                     <!-- Label déplacé dans .card-title -->
                 </div>
                 <div id="level-badge" class="level-unknown" title="Niveau global basé sur l'ELO moyen">
                      <i class="fas fa-question-circle"></i> <!-- Icône par défaut -->
                      <span>Indéterminé</span>
                 </div>
                 <div id="target-elo-info">
                      Objectif: <strong>-- ELO</strong>
                 </div>
            </div>

            <!-- Section Groupes Musculaires (les cartes sont générées ici) -->
            <div id="muscle-groups-container" aria-live="polite">
                 <p class="loading-placeholder">Connectez-vous pour charger vos données...</p>
            </div>

             <!-- Section Barre de Progression Globale (supprimée pour ce design) -->
             <!-- <div class="global-goal-progress" id="global-goal-progress-section"> ... </div> -->

        </div>

    </main>
</div>

<footer>
     <p>© 2024 ArmorWorkout | <a href="https://github.com/ironworkout/armorworkout" target="_blank" rel="noopener noreferrer"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a></p>
     <!-- Liens Timer/Editeur enlevés du footer pour simplifier -->
</footer>

<!-- Zone de Message Flottante -->
<div id="message-area" class="message-area" role="status" aria-live="polite"></div>

<!-- Google Identity Services Script -->
<script async defer src="https://accounts.google.com/gsi/client"></script>

<script>
    // --- CONFIGURATION & CONSTANTES ---
    const GOOGLE_CLIENT_ID = "731283926358-viam3ulpgna14flfdeb9m92l8s620hoi.apps.googleusercontent.com";
    const GOOGLE_DRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file';
    const PROGRAM_FILENAMES = { Push: "armorworkout_push_program.json", Pull: "armorworkout_pull_program.json", Legs: "armorworkout_legs_program.json" };
    const PROGRAM_TYPES = ['Push', 'Pull', 'Legs'];
    const GIS_CHECK_INTERVAL = 100;
    const GIS_MAX_RETRIES = 50;

    // --- PARAMÈTRES ELO & NIVEAUX ---
    const ELO_BASE = 800;
    const INTENSITY_TECHNIQUE_BONUS_MULTIPLIER = 1.05;
    const POLYARTICULAR_WEIGHT = 1.2;
    const ISOLATION_WEIGHT = 1.0;
    const RESISTANCE_BONUS = { 'Bodyweight': 75, 'Haltères 5kg': 50, 'Élastique 15kg': 50, 'Élastique 15kg doublé': 100, 'Élastique 25kg': 125, 'Élastique 15+25kg': 200, 'Élastique 15+25kg + 1 haltère 5kg': 225, 'Élastique 15+25kg + 2x5kg haltères': 250 };
    const REPS_FACTORS = { 8: 0.9, 12: 1.0, 18: 1.2, 25: 1.3, Infinity: 1.4 };

    // Niveaux d'objectifs (Structure conservée, utilisée pour badge/cible)
     const TARGET_ELO_LEVELS = {
        'L0_Base':    { name: "Débutant",      targetELO: ELO_BASE, description: "Le commencement du voyage.", colorVar: '--level-beginner-color', bgVar: '--level-beginner-bg', iconClass: 'fa-seedling',           groups: {} },
        'L1_Bronze':  { name: "Bronze Phys", targetELO: 950,  description: "Fondations solides établies.", colorVar: '--level-bronze-color',   bgVar: '--level-bronze-bg',   iconClass: 'fa-shield-halved',  groups: { Pectoraux: 900,  Dos: 920,  Épaules: 880,  Biceps: 900,  Triceps: 880,  Core: 850 } },
        'L2_Silver':  { name: "Argent Force",   targetELO: 1050, description: "Force accrue, muscles définis.", colorVar: '--level-silver-color',   bgVar: '--level-silver-bg',   iconClass: 'fa-shield',           groups: { Pectoraux: 1025, Dos: 1025, Épaules: 1000, Biceps: 1000, Triceps: 1000, Core: 900 } },
        'L3_Gold':    { name: "Or Puissance",   targetELO: 1150, description: "Niveau avancé !", colorVar: '--level-gold-color',     bgVar: '--level-gold-bg',     iconClass: 'fa-trophy',           groups: { Pectoraux: 1150, Dos: 1150, Épaules: 1120, Biceps: 1100, Triceps: 1100, Core: 950 } }, // Icône Trophée pour Or
        'L4_Crystal': { name: "Crystal Guerrier",targetELO: 1250, description: "Performance d'élite.", colorVar: '--level-crystal-color',  bgVar: '--level-crystal-bg',  iconClass: 'fa-gem',              groups: { Pectoraux: 1250, Dos: 1250, Épaules: 1250, Biceps: 1200, Triceps: 1200, Core: 1000 } },
        'L5_Master':  { name: "Master Combattant",targetELO: 1350, description: "Maîtrise quasi totale.", colorVar: '--level-master-color',   bgVar: '--level-master-bg',   iconClass: 'fa-crown',            groups: { Pectoraux: 1350, Dos: 1350, Épaules: 1350, Biceps: 1300, Triceps: 1300, Core: 1050 } },
        'L6_Champion':{ name: "Champion Ultime", targetELO: 1400, description: "Le summum.", colorVar: '--level-champion-color', bgVar: '--level-champion-bg', iconClass: 'fa-skull-crossbones', groups: { Pectoraux: 1400, Dos: 1400, Épaules: 1400, Biceps: 1350, Triceps: 1350, Core: 1100 } }
    };
    const LEVEL_ORDER = ['L0_Base', 'L1_Bronze', 'L2_Silver', 'L3_Gold', 'L4_Crystal', 'L5_Master', 'L6_Champion'];
    const FINAL_TARGET_ELO = TARGET_ELO_LEVELS[LEVEL_ORDER[LEVEL_ORDER.length - 1]].targetELO;

    // Groupes affichés et icônes (Noms ajustés FR/EN)
    const MUSCLE_GROUPS_DISPLAY_CONFIG = {
        // Clé: Nom affiché principal, Value: { subtitle: Nom secondaire, icon: classe FA }
        "Chest":    { subtitle: "Pectoraux", icon: 'fa-heart-pulse' }, // fa-person-breastfeeding est peut-être trop spécifique
        "Back":     { subtitle: "Dos",       icon: 'fa-circle-nodes' }, // Bonne icône pour dos/réseau
        "Shoulders":{ subtitle: "Épaules",   icon: 'fa-person-burst' }, // Bonne icône dynamique
        "Biceps":   { subtitle: "Biceps",    icon: 'fa-dumbbell' },
        "Triceps":  { subtitle: "Triceps",   icon: 'fa-hand-back-fist' },
        "Core":     { subtitle: "Core",      icon: 'fa-fire' }
        // "Legs": { subtitle: "Jambes", icon: 'fa-shoe-prints' } // Commenté car focus sur Upper Body
    };
     // Mapper les noms de config aux noms utilisés dans la logique ELO (si différents)
    const LOGIC_TO_DISPLAY_MAP = {
         Pectoraux: "Chest", Dos: "Back", Épaules: "Shoulders", Biceps: "Biceps", Triceps: "Triceps", Core: "Core" // Legs: "Legs"
     };
    const ALL_MUSCLE_GROUPS_LOGIC = Object.keys(LOGIC_TO_DISPLAY_MAP); // Noms utilisés dans le calcul ELO

    // --- Éléments DOM ---
    let signInButton, signOutButton, driveStatusElement, themeToggleBtn,
        signInButtonPrompt, connectionPrompt, evolutionTrackerArea,
        overallEloDisplayValue, // Changé pour cibler directement la valeur
        levelBadge, levelBadgeIcon, levelBadgeText, // Éléments spécifiques du badge
        targetEloInfoStrong, // Pour la valeur cible ELO
        muscleGroupsContainer, messageArea;

    // --- Variables d'État ---
    let googleAccessToken = null; let tokenClient = null; let programFileIds = { Push: null, Pull: null, Legs: null };
    let loadedPrograms = { Push: [], Pull: [], Legs: [] }; let programsAnalysisStatus = 'pending'; // 'pending', 'success', 'partial', 'error'
    let currentELOValues = {}; let overallAvgELO = ELO_BASE;
    let currentGoalLevelKey = LEVEL_ORDER[1]; // Commence à viser Bronze
    let currentTheme = 'dark'; let messageTimeoutId = null; let gisCheckRetries = 0;
    let previousOverallAvgELO = null; // Pour détecter passage de niveau

    // --- Audio ---
    // initAudioContext et playSound restent identiques au code précédent

    // --- Google Identity Services & Drive API ---
    // gisInitInternal, checkAndInitGis, handleTokenError, tokenCallback,
    // handleAuthClick, handleSignoutClick, findFileId, readFileContent
    // restent majoritairement identiques au code précédent.
    // *Ajustement mineur dans tokenCallback* : Mettre à jour `previousOverallAvgELO = null` lors de la connexion.
    // *Ajustement dans handleSignoutClick* : Mettre à jour `previousOverallAvgELO = null` lors de la déconnexion.

     // --- Audio ---
     let audioContext = null;
     function initAudioContext() { if (!audioContext && typeof AudioContext !== 'undefined') { try { audioContext = new AudioContext(); } catch (e) { console.warn("AudioContext non supporté ou bloqué.", e); } } }
     function playSound(type = 'confirm', volume = 0.15) {
         if (!audioContext) return;
         try {
             const oscillator = audioContext.createOscillator();
             const gainNode = audioContext.createGain();
             oscillator.connect(gainNode);
             gainNode.connect(audioContext.destination);

             gainNode.gain.setValueAtTime(0, audioContext.currentTime);
             gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01); // Fade in

             switch (type) {
                 case 'confirm':
                     oscillator.type = 'sine';
                     oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                     oscillator.frequency.linearRampToValueAtTime(783.99, audioContext.currentTime + 0.1); // G5
                     break;
                 case 'error':
                     oscillator.type = 'square';
                     oscillator.frequency.setValueAtTime(220, audioContext.currentTime); // A3
                     oscillator.frequency.linearRampToValueAtTime(110, audioContext.currentTime + 0.15); // A2
                     break;
                 case 'level_up': // Son spécifique pour passage de niveau
                     oscillator.type = 'triangle';
                      // Séquence de notes ascendantes rapides
                      gainNode.gain.linearRampToValueAtTime(volume * 1.2, audioContext.currentTime + 0.01); // Un peu plus fort
                      const t = audioContext.currentTime;
                      oscillator.frequency.setValueAtTime(440, t); // A4
                      oscillator.frequency.linearRampToValueAtTime(554.37, t + 0.08); // C#5
                      oscillator.frequency.linearRampToValueAtTime(659.25, t + 0.16); // E5
                      oscillator.frequency.linearRampToValueAtTime(880, t + 0.24); // A5
                      gainNode.gain.exponentialRampToValueAtTime(0.0001, t + 0.4); // Fade out plus long
                      oscillator.stop(t + 0.4);
                      break;
                 default: // 'info' or other
                     oscillator.type = 'triangle';
                     oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime); // E5
                     break;
             }

             // Stop standard pour confirm, error, info
             if (type !== 'level_up') {
                 oscillator.start(audioContext.currentTime);
                 gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + 0.2);
                 oscillator.stop(audioContext.currentTime + 0.2);
             } else {
                  oscillator.start(audioContext.currentTime); // Déjà géré dans le case 'level_up'
             }
         } catch (e) { console.warn("Erreur lors de la lecture du son:", e); }
     }


     // --- Google Identity Services & Drive API ---
     async function gisInitInternal() {
         try {
             tokenClient = google.accounts.oauth2.initTokenClient({
                 client_id: GOOGLE_CLIENT_ID,
                 scope: GOOGLE_DRIVE_SCOPES,
                 callback: tokenCallback,
                 error_callback: handleTokenError,
             });
             console.log("GIS Token Client initialisé (Evolution).");
             updateAuthUI(googleAccessToken !== null);
         } catch (error) {
             console.error("Erreur majeure lors de l'initialisation de GIS (Evolution):", error);
             showMessage("Impossible d'initialiser la connexion Google.", 5000, 'error');
             if (signInButton) signInButton.disabled = true;
             if (signInButtonPrompt) signInButtonPrompt.disabled = true;
         }
     }
     function checkAndInitGis() {
         if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) {
             console.log("GIS prêt, initialisation... (Evolution)");
             gisInitInternal();
         } else if (gisCheckRetries < GIS_MAX_RETRIES) {
             gisCheckRetries++;
             console.log(`GIS non prêt, tentative ${gisCheckRetries}/${GIS_MAX_RETRIES}... (Evolution)`);
             setTimeout(checkAndInitGis, GIS_CHECK_INTERVAL);
         } else {
             console.error("Échec du chargement de Google Identity Services après plusieurs tentatives (Evolution).");
             showMessage("Le service d'authentification Google n'a pas pu charger.", 6000, 'error');
             if (signInButton) signInButton.disabled = true;
             if (signInButtonPrompt) signInButtonPrompt.disabled = true;
         }
     }
     function handleTokenError(error) {
         console.error("Erreur d'authentification Google (Evolution):", error);
         let message = "Erreur de connexion Google.";
         if (error?.type === 'popup_closed_by_user') message = "Connexion annulée.";
         else if (error?.type === 'access_denied') message = "Accès refusé. Autorisation Drive nécessaire.";
         else if (error?.error === 'popup_blocked_by_browser') message = "Popup de connexion bloqué.";
         else if (error?.details) message += ` Détails: ${error.details}`;

         showMessage(message, 5000, 'error');
         playSound('error');
         googleAccessToken = null;
         previousOverallAvgELO = null; // Reset historique ELO
         updateAuthUI(false);
         resetEvolutionDisplay();
     }
      async function tokenCallback(tokenResponse) {
          // Ne pas masquer/afficher driveStatusElement car il est caché par CSS
          if (tokenResponse.error) { handleTokenError(tokenResponse); return; }

          if (tokenResponse && tokenResponse.access_token) {
              console.log("Access Token reçu (Evolution).");
              googleAccessToken = tokenResponse.access_token;
              previousOverallAvgELO = null; // Reset historique ELO à la connexion
              playSound('confirm');
              showMessage("Connecté ! Analyse des programmes...", 2500, 'info');
              if (muscleGroupsContainer) { muscleGroupsContainer.innerHTML = '<p class="loading-placeholder"><i class="fas fa-spinner fa-spin"></i> Analyse des programmes Google Drive...</p>'; }
              resetEvolutionDisplay(); // Prépare l'affichage

              try {
                  programsAnalysisStatus = await loadProgramsFromDrive();
                  console.log("Statut analyse programmes:", programsAnalysisStatus);

                  if (programsAnalysisStatus === 'success') {
                      showMessage("Programmes analysés. Calcul de l'évolution...", 3000, 'success');
                  } else if (programsAnalysisStatus === 'partial') {
                      showMessage("Certains programmes manquants/invalides. Évolution partielle.", 5000, 'warning');
                  } else {
                      showMessage("Erreur chargement/analyse des programmes.", 6000, 'error');
                      playSound('error');
                  }
                  calculateAndDisplayEvolution(); // Calculer même si partiel/erreur

              } catch (error) {
                  console.error("Erreur CRITIQUE pendant chargement/analyse (Evolution):", error);
                  showMessage("Erreur majeure lors de l'analyse.", 6000, 'error');
                  playSound('error');
                  programsAnalysisStatus = 'error';
                  if (muscleGroupsContainer) { muscleGroupsContainer.innerHTML = `<p class="error-placeholder">Erreur critique : ${error.message}</p>`; }
                  resetEvolutionDisplay();
              } finally {
                  updateAuthUI(true);
              }
          } else {
              handleTokenError({ error: "invalid_response", details: "Réponse Google invalide (Evolution)." });
          }
      }
     function handleAuthClick() {
         initAudioContext();
         if (tokenClient) {
             console.log("Demande de token Google... (Evolution)");
             showMessage("Ouverture connexion Google...", 2000, 'info');
             tokenClient.requestAccessToken({ prompt: '' });
             // Afficher un état de chargement sur le bouton ? Non, la redirection suffit.
         } else {
             console.error("Tentative auth mais tokenClient non initialisé (Evolution).");
             showMessage("Erreur : Service connexion non prêt.", 4000, 'error');
             checkAndInitGis();
         }
     }
     function handleSignoutClick(showMessages = true) {
         const token = googleAccessToken;
         if (!token) { console.log("Déjà déconnecté (Evolution)."); updateAuthUI(false); return; }
         initAudioContext();
         if (showMessages) showMessage("Déconnexion...", 1500, 'info');

         google.accounts.oauth2.revoke(token, () => {
             console.log('Token Google révoqué (Evolution).');
             googleAccessToken = null;
             programFileIds = { Push: null, Pull: null, Legs: null };
             programsAnalysisStatus = 'pending';
             loadedPrograms = { Push: [], Pull: [], Legs: [] };
             currentELOValues = {};
             overallAvgELO = ELO_BASE;
             currentGoalLevelKey = LEVEL_ORDER[1];
             previousOverallAvgELO = null; // Reset historique ELO

             if (showMessages) { showMessage("Déconnecté de Google Drive.", 3000, 'info'); playSound('confirm'); }
             resetEvolutionDisplay();
             updateAuthUI(false);
         });
     }
     async function findFileId(filename) {
         // Identique au code précédent
          if (!googleAccessToken) return null;
          //console.log(`Recherche du fichier : ${filename}`);
          try {
              const response = await fetch(`https://www.googleapis.com/drive/v3/files?q=name='${filename}' and trashed=false&fields=files(id, name)`, {
                  headers: { 'Authorization': `Bearer ${googleAccessToken}` }
              });
              if (!response.ok) {
                  if (response.status === 401 || response.status === 403) {
                      console.warn(`Autorisation expirée ou invalide pour chercher ${filename}. Tentative de déconnexion.`);
                      handleSignoutClick(false);
                  } else { console.error(`Erreur API Drive (findFileId ${filename}): ${response.status} ${response.statusText}`); }
                  throw new Error(`Erreur API Drive ${response.status}`);
              }
              const data = await response.json();
              if (data.files && data.files.length > 0) {
                  //console.log(`Fichier trouvé : ${filename} (ID: ${data.files[0].id})`);
                  return data.files[0].id;
              } else {
                  //console.log(`Fichier non trouvé : ${filename}`);
                  return null;
              }
          } catch (error) { console.error(`Erreur lors de la recherche du fichier ${filename}:`, error); return null; }
     }
     async function readFileContent(fileId) {
         // Identique au code précédent
         if (!googleAccessToken || !fileId) return null;
         //console.log(`Lecture du contenu du fichier ID: ${fileId}`);
         try {
             const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
                 headers: { 'Authorization': `Bearer ${googleAccessToken}` }
             });
             if (!response.ok) {
                 if (response.status === 401 || response.status === 403) {
                      console.warn(`Autorisation expirée ou invalide pour lire ${fileId}. Tentative de déconnexion.`);
                      handleSignoutClick(false);
                  } else { console.error(`Erreur API Drive (readFileContent ${fileId}): ${response.status} ${response.statusText}`); }
                 throw new Error(`Erreur API Drive ${response.status}`);
             }
             const content = await response.text();
             //console.log(`Contenu fichier ID ${fileId} lu.`);
             return content;
         } catch (error) { console.error(`Erreur lors de la lecture du fichier ${fileId}:`, error); return null; }
     }

    // --- Chargement des Programmes ---
    async function loadProgramsFromDrive() {
        // Identique au code précédent
         if (!googleAccessToken) return 'error';
         console.log("Chargement des programmes depuis Drive (Evolution)...");
         let allSuccess = true; let anySuccess = false;
         const tempLoadedPrograms = { Push: [], Pull: [], Legs: [] };

         for (const type of PROGRAM_TYPES) {
             //console.log(`--- Traitement programme: ${type} ---`);
             programFileIds[type] = await findFileId(PROGRAM_FILENAMES[type]);
             let fileSuccess = false;
             if (programFileIds[type]) {
                 const content = await readFileContent(programFileIds[type]);
                 if (content !== null) {
                     try {
                         const parsedContent = JSON.parse(content || '[]');
                         if (Array.isArray(parsedContent)) {
                             tempLoadedPrograms[type] = parsedContent;
                             fileSuccess = true; anySuccess = true;
                              if (tempLoadedPrograms[type].length === 0) console.warn(`Programme ${type} chargé mais vide.`);
                              //else console.log(`Programme ${type} chargé (${tempLoadedPrograms[type].length} étapes).`);
                         } else { console.error(`Contenu ${type} n'est pas un tableau JSON.`); showMessage(`Format invalide pour ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning'); allSuccess = false; }
                     } catch (e) { console.error(`Erreur parsing JSON ${type}:`, e); showMessage(`Erreur format JSON ${PROGRAM_FILENAMES[type]}.`, 4000, 'error'); playSound('error'); allSuccess = false; }
                 } else { console.warn(`Lecture ${type} échouée.`); showMessage(`Impossible de lire ${PROGRAM_FILENAMES[type]}.`, 4000, 'warning'); allSuccess = false; }
             } else { console.error(`Fichier ${PROGRAM_FILENAMES[type]} introuvable.`); showMessage(`Fichier ${PROGRAM_FILENAMES[type]} introuvable.`, 4000, 'warning'); allSuccess = false; }
              //console.log(`--- Fin traitement ${type}. Succès fichier: ${fileSuccess} ---`);
         }
         loadedPrograms = tempLoadedPrograms;
         console.log(`Fin chargement programmes. Succès global: ${allSuccess}, Au moins un succès: ${anySuccess}`);
         if (allSuccess) return 'success'; if (anySuccess) return 'partial'; return 'error';
    }


    // --- Logique de Calcul et Affichage ELO ---
    // getRepsFactor, isPolyarticular, calculateExerciseELO, mapExerciseToMuscleGroup,
    // analyzeProgramsAndCalculateELO, processExerciseBlock, determineCurrentGoalLevelKey, getPreviousLevelKey
    // restent identiques au code précédent.

     function getRepsFactor(reps) {
         const numericReps = parseInt(reps, 10);
         if (isNaN(numericReps) || reps === 'AMRAP' || reps === 'MAX') return REPS_FACTORS[Infinity];
         if (numericReps <= 8) return REPS_FACTORS[8]; if (numericReps <= 12) return REPS_FACTORS[12];
         if (numericReps <= 18) return REPS_FACTORS[18]; if (numericReps <= 25) return REPS_FACTORS[25];
         return REPS_FACTORS[Infinity];
     }
     function isPolyarticular(exerciseName) {
         const nameLower = exerciseName.toLowerCase();
         const polyKeywords = ['pompes', 'push up', 'dips', 'tractions', 'pull up', 'chin up', 'rowing', 'tirage', 'squat', 'fentes', 'soulevé', 'deadlift', 'développé', 'press', 'overhead press'];
         return polyKeywords.some(keyword => nameLower.includes(keyword));
     }
      function calculateExerciseELO(step) {
          if (!step || step.type !== 'exercise' || !step.details) return 0;
          const details = step.details;
          const baseResistance = RESISTANCE_BONUS[details.resistance] || 0;
          const repsFactor = getRepsFactor(details.reps);
          const techniqueBonus = (details.intensityTechnique && details.intensityTechnique !== 'Aucune') ? INTENSITY_TECHNIQUE_BONUS_MULTIPLIER : 1.0;
          const calculatedELO = ELO_BASE / 10 + (baseResistance * repsFactor * techniqueBonus);
          return calculatedELO;
      }
      function mapExerciseToMuscleGroup(exerciseName) {
          const nameLower = exerciseName.toLowerCase();
          if (nameLower.includes('pompes') || nameLower.includes('push up') || nameLower.includes('dips') || nameLower.includes('développé couché') || nameLower.includes('chest press')) return ['Pectoraux', 'Triceps', 'Épaules'];
          if (nameLower.includes('tractions') || nameLower.includes('pull up') || nameLower.includes('chin up') || nameLower.includes('rowing') || nameLower.includes('tirage')) return ['Dos', 'Biceps'];
          if (nameLower.includes('développé militaire') || nameLower.includes('overhead press') || nameLower.includes('élévations latérales') || nameLower.includes('shoulder press')) return ['Épaules', 'Triceps'];
          if (nameLower.includes('curl') || nameLower.includes('biceps')) return ['Biceps'];
          if (nameLower.includes('extension triceps') || nameLower.includes('triceps pushdown') || nameLower.includes('skullcrusher')) return ['Triceps'];
          if (nameLower.includes('gainage') || nameLower.includes('planche') || nameLower.includes('crunch') || nameLower.includes('abdos') || nameLower.includes('core')) return ['Core'];
          if (nameLower.includes('squat') || nameLower.includes('fentes') || nameLower.includes('leg press') || nameLower.includes('leg extension') || nameLower.includes('leg curl') || nameLower.includes('mollets')) return ['Legs'];
          console.warn(`Mapping musculaire non défini pour : ${exerciseName}`);
          return [];
      }
      function analyzeProgramsAndCalculateELO() {
           console.log("Analyse des programmes et calcul ELO...");
           const groupData = {};
           // Utilise ALL_MUSCLE_GROUPS_LOGIC (inclut Legs si présent dans map)
           [...ALL_MUSCLE_GROUPS_LOGIC, 'Legs'].forEach(group => { // Assure que 'Legs' est initialisé
               groupData[group] = { totalWeightedElo: 0, totalWeight: 0 };
           });
           currentELOValues = {};

           if (programsAnalysisStatus === 'error' || programsAnalysisStatus === 'pending') {
               console.warn("Analyse ELO annulée car programmes non chargés.");
               ALL_MUSCLE_GROUPS_LOGIC.forEach(group => { currentELOValues[group] = ELO_BASE; });
               overallAvgELO = ELO_BASE;
               return;
           }

           PROGRAM_TYPES.forEach(type => {
               const program = loadedPrograms[type];
               if (!program || program.length === 0) return;
               let currentExerciseName = null, currentExerciseSets = 0, lastExerciseStep = null;
               program.forEach((step, index) => {
                   if (step.type === 'exercise') {
                       if (step.name === currentExerciseName && lastExerciseStep) { currentExerciseSets++; }
                       else { if (lastExerciseStep) processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData); currentExerciseName = step.name; currentExerciseSets = 1; }
                       lastExerciseStep = step;
                       if (index === program.length - 1) processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData);
                   } else if (step.type === 'break' || step.type === 'info') {
                       if (lastExerciseStep) processExerciseBlock(lastExerciseStep, currentExerciseSets, groupData);
                       currentExerciseName = null; currentExerciseSets = 0; lastExerciseStep = null;
                   }
               });
           });

           let totalOverallEloSum = 0, totalOverallWeight = 0;
           ALL_MUSCLE_GROUPS_LOGIC.forEach(group => { // Ne calcule que pour les groupes logiques mappés
               const data = groupData[group];
               currentELOValues[group] = data.totalWeight > 0 ? ELO_BASE + Math.round(data.totalWeightedElo / data.totalWeight) : ELO_BASE;
               // Exclut 'Legs' (si présent) de la moyenne globale affichée
               if (group !== 'Legs' && data.totalWeight > 0) {
                   totalOverallEloSum += (currentELOValues[group] - ELO_BASE) * data.totalWeight;
                   totalOverallWeight += data.totalWeight;
               }
           });

           // Stocke l'ELO précédent AVANT de calculer le nouveau
           if (overallAvgELO !== ELO_BASE) { // Ne stocke pas la valeur initiale
               previousOverallAvgELO = overallAvgELO;
           }
           overallAvgELO = totalOverallWeight > 0 ? ELO_BASE + Math.round(totalOverallEloSum / totalOverallWeight) : ELO_BASE;

           console.log("--- Résultats Analyse ELO ---");
           console.log("ELO Moyen Global Pondéré (Haut Corps):", overallAvgELO, `(Précédent: ${previousOverallAvgELO})`);
           console.log("ELO Moyen Pondéré par Groupe (Logique):", currentELOValues);
       }
      function processExerciseBlock(exerciseStep, numSets, groupData) {
           const eloPerSet = calculateExerciseELO(exerciseStep);
           if (eloPerSet > 0 && numSets > 0) {
               const isPoly = isPolyarticular(exerciseStep.name);
               const weightFactor = isPoly ? POLYARTICULAR_WEIGHT : ISOLATION_WEIGHT;
               const targetGroups = mapExerciseToMuscleGroup(exerciseStep.name);
               targetGroups.forEach(group => {
                   if (groupData[group]) {
                       groupData[group].totalWeightedElo += eloPerSet * numSets * weightFactor;
                       groupData[group].totalWeight += numSets * weightFactor;
                   } else { console.warn(`Groupe musculaire logique inconnu : ${group} pour ${exerciseStep.name}`); }
               });
           }
       }
      function determineCurrentGoalLevelKey() {
         for (let i = 1; i < LEVEL_ORDER.length; i++) {
             const levelKey = LEVEL_ORDER[i];
             if (overallAvgELO < TARGET_ELO_LEVELS[levelKey].targetELO) return levelKey;
         }
         return LEVEL_ORDER[LEVEL_ORDER.length - 1];
     }
      function getPreviousLevelKey(currentLevelKey) {
          const currentIndex = LEVEL_ORDER.indexOf(currentLevelKey);
          return currentIndex > 0 ? LEVEL_ORDER[currentIndex - 1] : LEVEL_ORDER[0];
     }

    // Fonction principale pour calculer et mettre à jour l'affichage
    function calculateAndDisplayEvolution() {
        console.log("Mise à jour de l'affichage de l'évolution (Nouveau Design)...");
        if (!evolutionTrackerArea || !overallEloDisplayValue || !levelBadge || !targetEloInfoStrong || !muscleGroupsContainer) {
            console.error("Éléments DOM manquants pour afficher l'évolution (Nouveau Design).");
             if(muscleGroupsContainer) muscleGroupsContainer.innerHTML = '<p class="error-placeholder">Erreur interne: DOM manquant.</p>';
            return;
        }

        // 1. Analyse et calcule les ELO
        if (programsAnalysisStatus !== 'pending') {
            analyzeProgramsAndCalculateELO(); // Met à jour overallAvgELO et currentELOValues
        } else {
            // État initial ou erreur de chargement
            ALL_MUSCLE_GROUPS_LOGIC.forEach(group => { currentELOValues[group] = ELO_BASE; });
            overallAvgELO = ELO_BASE;
            previousOverallAvgELO = null; // Pas d'historique
        }

        // 2. Détermine niveau objectif actuel et précédent
        const previousGoalLevelKey = currentGoalLevelKey; // Sauvegarde l'ancien niveau avant recalcul
        currentGoalLevelKey = determineCurrentGoalLevelKey();
        const currentGoal = TARGET_ELO_LEVELS[currentGoalLevelKey];
        const previousGoal = TARGET_ELO_LEVELS[getPreviousLevelKey(currentGoalLevelKey)]; // Recalculé car current peut avoir changé

        // 2.1 Détecter passage de niveau ELO global
        if (previousOverallAvgELO !== null && currentGoalLevelKey !== previousGoalLevelKey && currentGoal.targetELO > previousGoal.targetELO) {
             // Vérifie si l'ELO actuel dépasse la cible du niveau *précédent*
             // (plus robuste que de juste comparer les clés)
             if (overallAvgELO >= TARGET_ELO_LEVELS[previousGoalLevelKey].targetELO) {
                 console.log(`NIVEAU SUPÉRIEUR ATTEINT ! ${previousGoalLevelKey} -> ${currentGoalLevelKey}`);
                 showMessage(`Félicitations ! Niveau ${currentGoal.name} atteint !`, 5000, 'success');
                 playSound('level_up', 0.2); // Joue le son de niveau supérieur (volume ajusté)
                  // Animation spéciale ? (ex: faire briller la carte ELO)
                  const eloCard = document.querySelector('.global-stats-card');
                  if (eloCard) {
                      eloCard.style.animation = 'levelUpGlow 1.5s ease-out';
                      setTimeout(() => { eloCard.style.animation = ''; }, 1500);
                  }
             }
        }
         // CSS pour l'animation de la carte ELO
         const styleSheet = document.styleSheets[0];
         styleSheet.insertRule(`
             @keyframes levelUpGlow {
                 0% { box-shadow: 0 10px 30px rgba(0,0,0, 0.2), 0 0 0px rgba(var(--neon-green-rgb), 0); }
                 50% { box-shadow: 0 10px 30px rgba(0,0,0, 0.1), 0 0 30px rgba(var(--neon-green-rgb), 0.7); }
                 100% { box-shadow: 0 10px 30px rgba(0,0,0, 0.2), 0 0 0px rgba(var(--neon-green-rgb), 0); }
             }`, styleSheet.cssRules.length);


        // 3. Met à jour la carte ELO globale
        animateValue(overallEloDisplayValue, parseFloat(overallEloDisplayValue.textContent.replace(/[^0-9.]/g, '')) || ELO_BASE, overallAvgELO, 700);

        // Met à jour le badge de niveau
        levelBadgeIcon.className = `fas ${currentGoal.iconClass}`;
        levelBadgeText.textContent = currentGoal.name;
        levelBadge.style.color = `var(${currentGoal.colorVar})`;
        levelBadge.style.backgroundColor = `var(${currentGoal.bgVar})`;
        levelBadge.style.borderColor = `var(${currentGoal.colorVar})`; // Bordure assortie
        levelBadge.setAttribute('title', currentGoal.description);

        // Met à jour l'objectif ELO affiché
        targetEloInfoStrong.textContent = `${currentGoal.targetELO} ELO`;

        // 4. Génère les cartes des groupes musculaires (Affichage basé sur MUSCLE_GROUPS_DISPLAY_CONFIG)
        muscleGroupsContainer.innerHTML = ''; // Vide le conteneur
        let hasDataToShow = false;

        for (const displayGroup in MUSCLE_GROUPS_DISPLAY_CONFIG) {
             // Trouve le nom logique correspondant au nom d'affichage
             const logicGroup = Object.keys(LOGIC_TO_DISPLAY_MAP).find(key => LOGIC_TO_DISPLAY_MAP[key] === displayGroup);

             if (!logicGroup || currentELOValues[logicGroup] === undefined) {
                 console.warn(`Groupe logique non trouvé ou ELO manquant pour l'affichage: ${displayGroup}`);
                 continue; // Passe au groupe suivant si pas de correspondance ou pas de données
             }

             hasDataToShow = true;
             const config = MUSCLE_GROUPS_DISPLAY_CONFIG[displayGroup];
             const currentAvgELO = currentELOValues[logicGroup];
             const targetELO = currentGoal.groups[logicGroup] ?? currentGoal.targetELO;
             const stageStartELO = previousGoal.groups[logicGroup] ?? previousGoal.targetELO;

             let progressPercent = 0;
             const range = targetELO - stageStartELO;
             if (range > 0) { progressPercent = ((currentAvgELO - stageStartELO) / range) * 100; }
             else if (currentAvgELO >= targetELO) { progressPercent = 100; }
             progressPercent = Math.max(0, Math.min(100, Math.round(progressPercent)));

             //console.log(`Carte ${displayGroup} (${logicGroup}): ELO=${currentAvgELO}, Start=${stageStartELO}, Target=${targetELO}, Prog%=${progressPercent}`);

             const card = renderMuscleGroupCard(displayGroup, config.subtitle, config.icon, currentAvgELO, targetELO, progressPercent);
             muscleGroupsContainer.appendChild(card);
        }

        if (!hasDataToShow && programsAnalysisStatus !== 'pending') {
             const message = programsAnalysisStatus === 'error'
                ? 'Aucune donnée valide analysée pour calculer l\'évolution.'
                : 'Aucune donnée d\'évolution à afficher.';
             muscleGroupsContainer.innerHTML = `<p class="${programsAnalysisStatus === 'error' ? 'error' : 'loading'}-placeholder">${message}</p>`;
         }

        console.log("Affichage de l'évolution mis à jour (Nouveau Design).");
    }

    // Crée le HTML pour une carte de groupe musculaire (Nouveau Design)
    function renderMuscleGroupCard(title, subtitle, iconClass, currentElo, targetElo, progressPercent) {
         const card = document.createElement('div');
         card.className = 'muscle-group-card';
         const isTargetReached = progressPercent === 100;

         // Ajoute la classe si l'objectif est atteint
         if (isTargetReached) {
             card.classList.add('level-target-reached');
         }

         card.setAttribute('title', `${title} (${subtitle}) - ELO: ${currentElo} / ${targetElo}. Progression: ${progressPercent}%.`);

         card.innerHTML = `
             <div class="card-header">
                 <div class="icon-container">
                     <i class="fas ${iconClass}" aria-hidden="true"></i>
                 </div>
                 <div class="title-container">
                     <div class="group-title">${title}</div>
                     <div class="group-subtitle">${subtitle}</div>
                 </div>
                 <div class="elo-details" title="ELO Actuel / ELO Cible">
                     <span class="current">${currentElo}</span> / <span class="target">${targetElo}</span>
                 </div>
             </div>
             <div class="progress-bar-container" title="Progression: ${progressPercent}%">
                 <div class="progress-bar" style="width: 0%;" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                     <!-- Percentage text removed from bar -->
                 </div>
             </div>
         `;

         // Animation de la barre de progression
         requestAnimationFrame(() => {
             setTimeout(() => {
                 const progressBar = card.querySelector('.progress-bar');
                 if (progressBar) {
                     progressBar.style.width = `${progressPercent}%`;
                     progressBar.setAttribute('aria-valuenow', progressPercent);
                 }
             }, 50); // Délai pour l'animation
         });

         return card;
     }

    // Réinitialise l'affichage ELO (Nouveau Design)
    function resetEvolutionDisplay() {
        console.log("Réinitialisation de l'affichage (Nouveau Design)...");
        if (muscleGroupsContainer) {
             muscleGroupsContainer.innerHTML = `<p class="loading-placeholder">${googleAccessToken ? 'Analyse...' : 'Connectez-vous...'}</p>`;
        }
        if (overallEloDisplayValue) overallEloDisplayValue.textContent = '--';
        if (levelBadge) {
             levelBadgeIcon.className = 'fas fa-question-circle';
             levelBadgeText.textContent = 'Indéterminé';
             levelBadge.style.color = 'var(--secondary-text-color)';
             levelBadge.style.backgroundColor = 'rgba(var(--secondary-text-color-rgb), 0.1)';
             levelBadge.style.borderColor = 'var(--border-color)';
             levelBadge.setAttribute('title', 'Niveau non déterminé');
        }
        if (targetEloInfoStrong) targetEloInfoStrong.textContent = '-- ELO';
        previousOverallAvgELO = null; // Reset historique
    }


    // --- Animation de Chiffre Simple ---
    // Reste identique au code précédent
    function animateValue(element, start, end, duration) {
         if (!element) return;
         if (start === end) { element.textContent = Math.round(end); return; }
         const range = end - start; let current = start; const increment = end > start ? 1 : -1;
         const stepTime = Math.abs(Math.floor(duration / range));
         const effectiveStepTime = Math.max(1, Math.min(stepTime, 50));
         const timer = setInterval(() => {
             current += increment * Math.max(1, Math.round(Math.abs(end - current) / 10));
             if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                 current = end; clearInterval(timer);
             }
             element.textContent = Math.round(current);
         }, effectiveStepTime);
     }

    // --- UI Update ---
    function updateAuthUI(isLoggedIn) {
         // Identique au code précédent, juste log et toggle des classes/disabled
         console.log(`Update UI (Nouveau Design) - Connecté: ${isLoggedIn}, GIS prêt: ${!!tokenClient}`);
          const body = document.body;
          body.classList.toggle('logged-in', isLoggedIn);
          body.classList.toggle('logged-out', !isLoggedIn);
          if(signInButton) signInButton.disabled = isLoggedIn || !tokenClient;
          if(signInButtonPrompt) signInButtonPrompt.disabled = isLoggedIn || !tokenClient;
          if(signOutButton) signOutButton.disabled = !isLoggedIn;
          if(themeToggleBtn) themeToggleBtn.disabled = false;
          // driveStatusElement n'est plus affiché
          if (connectionPrompt) connectionPrompt.style.display = isLoggedIn ? 'none' : 'block';
          if (evolutionTrackerArea) evolutionTrackerArea.style.display = isLoggedIn ? 'flex' : 'none';
          if (!isLoggedIn) {
              programsAnalysisStatus = 'pending';
              resetEvolutionDisplay();
          }
     }

    // --- Gestion Thème ---
    // applyTheme, toggleTheme, loadSavedTheme restent identiques

     function applyTheme(theme) {
         document.body.classList.remove('light-theme', 'dark-theme');
         document.body.classList.add(theme + '-theme');
         currentTheme = theme;
         localStorage.setItem('armorWorkoutTheme', theme);
         if (themeToggleBtn) {
             const icon = themeToggleBtn.querySelector('i');
             if (icon) icon.className = `fas fa-${theme === 'dark' ? 'sun' : 'moon'}`;
             themeToggleBtn.setAttribute('aria-label', `Passer au thème ${theme === 'dark' ? 'clair' : 'sombre'}`);
         }
         console.log(`Thème appliqué: ${theme}`);
          // Ici, on pourrait adapter les variables root si le thème clair était implémenté
          // Exemple: document.documentElement.style.setProperty('--bg-color', theme === 'dark' ? 'var(--bg-color-dark)' : 'var(--bg-color-light)');
          // Mais comme on n'a que le sombre pour l'instant, on ne fait rien de plus.
     }
     function toggleTheme() {
         // Pour l'instant, on ne bascule pas car seul le thème sombre est défini visuellement
         showMessage("Le thème clair n'est pas encore disponible.", 2000, 'info');
         // const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
         // applyTheme(newTheme);
         playSound('confirm');
     }
      function loadSavedTheme() {
          // Toujours charger le thème sombre car c'est le seul stylé
          applyTheme('dark');
          // const savedTheme = localStorage.getItem('armorWorkoutTheme') || 'dark';
          // applyTheme(savedTheme);
      }

    // --- Message Area ---
    // showMessage reste identique

    function showMessage(msg, duration = 3000, type = 'info') {
         if (!messageArea) return;
         messageArea.textContent = msg;
         messageArea.className = `message-area ${type} visible`;
         if (messageTimeoutId) clearTimeout(messageTimeoutId);
         messageTimeoutId = setTimeout(() => {
             messageArea.classList.remove('visible');
             setTimeout(() => { if (!messageArea.classList.contains('visible')) { messageArea.className = 'message-area'; } }, 500);
         }, duration);
     }

    // --- Initialisation ---
    function initializeDOMReferences() {
         console.log("Init DOM Refs (Nouveau Design)...");
         signInButton = document.getElementById('signin-button');
         signOutButton = document.getElementById('signout-button');
         driveStatusElement = document.getElementById('drive-status'); // Gardé pour la logique même si caché
         themeToggleBtn = document.getElementById('theme-toggle-btn');
         signInButtonPrompt = document.getElementById('signin-button-prompt');
         connectionPrompt = document.getElementById('connection-prompt');
         evolutionTrackerArea = document.getElementById('evolution-tracker-area');
         // Éléments de la carte ELO principale
         overallEloDisplayValue = document.querySelector('#overall-elo-display .value');
         levelBadge = document.getElementById('level-badge');
         if (levelBadge) {
             levelBadgeIcon = levelBadge.querySelector('i');
             levelBadgeText = levelBadge.querySelector('span');
         }
         targetEloInfoStrong = document.querySelector('#target-elo-info strong');
         // Conteneur des cartes muscles
         muscleGroupsContainer = document.getElementById('muscle-groups-container');
         messageArea = document.getElementById('message-area');

         // Vérification critique (adaptée aux nouveaux éléments)
         const criticalElements = [signInButton, signOutButton, themeToggleBtn, signInButtonPrompt, connectionPrompt, evolutionTrackerArea, overallEloDisplayValue, levelBadge, levelBadgeIcon, levelBadgeText, targetEloInfoStrong, muscleGroupsContainer, messageArea];
         if (criticalElements.some(el => !el)) {
              console.error("Éléments DOM CRITIQUES manquants (Nouveau Design)! Vérifiez les IDs/Classes HTML.", criticalElements);
              showMessage("Erreur critique: UI incomplète.", 10000, 'error');
              document.body.innerHTML = '<p style="color:red; padding: 20px; text-align: center; font-family: sans-serif;">Erreur critique: L\'interface ne peut pas démarrer.</p>';
              return false;
         }
         console.log("DOM Refs initialisées (Nouveau Design).");
         return true;
     }
    function addEventListeners() {
        // Identique au code précédent
         if(signInButton) signInButton.addEventListener('click', handleAuthClick);
         if(signInButtonPrompt) signInButtonPrompt.addEventListener('click', handleAuthClick);
         if(signOutButton) signOutButton.addEventListener('click', () => handleSignoutClick(true));
         if(themeToggleBtn) themeToggleBtn.addEventListener('click', toggleTheme);
         document.body.addEventListener('click', initAudioContext, { once: true });
         document.body.addEventListener('keydown', initAudioContext, { once: true });
         console.log("Écouteurs d'événements ajoutés (Evolution).");
    }

    // --- Point d'entrée ---
    document.addEventListener('DOMContentLoaded', () => {
        // Identique au code précédent
         console.log("DOM Chargé (Evolution). Initialisation...");
         try {
             if (!initializeDOMReferences()) return;
             addEventListeners();
             loadSavedTheme(); // Charge toujours sombre pour l'instant
             updateAuthUI(false);
             resetEvolutionDisplay();
             checkAndInitGis();
             console.log("Initialisation Evolution terminée. Attente API Google et action utilisateur...");
         } catch (error) {
             console.error("Erreur majeure lors de l'initialisation DOMContentLoaded (Evolution):", error);
              showMessage("Erreur critique au chargement.", 10000, 'error');
              const body = document.querySelector('body');
              if(body) body.innerHTML = '<p style="color:red; padding: 20px; text-align: center; font-family: sans-serif;">Erreur critique au chargement. Vérifiez la console.</p>';
         }
    });

</script>

</body>
</html>
